<!DOCTYPE html>
<html lang="zh-CN">
    <head>
  <!-- 元数据 -->
  <meta charset="utf-8">
  
  
  <title>心咖</title>
  
  <meta name="author" content="dreamin" />
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="format-detection" content="telphone=no, email=no" />
  
    <meta name="keywords" content="" />
  
  <meta name="description" content="生于尘埃，溺于人海，死于理想的高台">
<meta property="og:type" content="website">
<meta property="og:title" content="心咖">
<meta property="og:url" content="https://xinka.vercel.app/index.html">
<meta property="og:site_name" content="心咖">
<meta property="og:description" content="生于尘埃，溺于人海，死于理想的高台">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="dreamin">
<meta name="twitter:card" content="summary">
  
  <!-- 站点验证相关 -->
  
    
    
    
  
  <!-- 样式表文件 -->
  <link rel="stylesheet" id="kratos-css" href="/css/kratosr.min.css" media="all"></script>
  
    <link rel="stylesheet" id="darkmode-css" href="/css/kr-color-dark.min.css" media="(prefers-color-scheme: dark)"></script>
    <script src="/js/kr-dark.min.js"></script>
  
  
    <link rel="stylesheet" id="highlight-css" href="/css/highlight/night-eighties.min.css" media="all"></script>
  
  <link rel="stylesheet" id="fontawe-css" href="/vendors/font-awesome@4.7.0/css/font-awesome.min.css" media="all"></script>
  <link rel="stylesheet" id="nprogress-css" href="/vendors/nprogress@0.2.0/nprogress.css" media="all"></script>
  
  
    <link rel="stylesheet" href="/vendors/aplayer@1.10.1/dist/APlayer.min.css"></script>
  
  
    <link rel="stylesheet" href="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"></script>
  
  <!-- 不得不预先加载的一些JS文件 -->
  <script src="/vendors/jquery@3.6.0/dist/jquery.min.js"></script>
  
    <script src="/vendors/qrcode_js@1.0.0/qrcode.min.js"></script>
  
  
  <style>
    
    
  </style>
  
<meta name="generator" content="Hexo 7.2.0"></head>


    <body class="custom-background">
        <div id="kratos-wrapper">
    <div id="kratos-page">
        <div id="kratos-header">
            <header id="kratos-desktop-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="nav-header">
                        <nav id="kratos-menu-wrap">
                            <ul id="kratos-primary-menu" class="sf-menu">
                                
                                    
                                    
                                
                            </ul>
                        </nav>
                    </div>
                </div>
            </header>
            <header id="kratos-mobile-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="color-logo"><a href="/">心咖</a></div>
                    <div class="nav-toggle">
                        <a class="kratos-nav-toggle js-kratos-nav-toggle">
                            <i></i>
                        </a>
                    </div>
                </div>
            </header>
        </div>
        <div class="kratos-start kratos-hero-2">
            <!-- <div class="kratos-overlay"></div> -->
            <div class="kratos-cover kratos-cover-2 text-center">
                <div class="desc desc2 animate-box">
                    <a href="/">
                        <h2>心咖</h2> <br />
                        <span>人生如此，方趁我心</span>
                    </a>
                </div>
            </div>
        </div>

        <div id="kratos-blog-post">
            <div class="container">
                <div id="main" class="row">
                    

        

            <section class="col-md-8">

        

            <!-- Breadcrumb for tag & category page -->




    
    
        <article class="kratos-hentry clearfix" itemscope itemtype="https://schema.org/Article">
            <div class="kratos-entry-border-new clearfix">
                
                <div class="kratos-entry-thumb-new">
                    <a href="/2024/04/23/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D/">
                        
                            <img class="kratos-entry-thumb-new-img" alt="">
                        
                    </a>
                </div>
                <div class="kratos-post-inner-new">
                    <header class="kratos-entry-header-new">
                            
                        <h2 class="kratos-entry-title-new"><a href="/2024/04/23/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D/" itemprop="mainEntityOfPage"><span itemprop="name headline">Englislearning</span></a>
                    </header>
                    <div class="kratos-entry-content-new">
                        <p itemProp="description">
                            
                                


单词
词性
翻译
关联




concatenate
v. | adj.
连接
n. concatenation



leet
n
民事法庭




laborious
adj.
费力的；艰难的




novel
n.ad...
                            
                        </p>
                    </div>
                </div>
                <footer class="kratos-post-meta-new">
                    <span class="pull-left">
                        <time datetime="2024-04-23T03:06:21.784Z" itemprop="datePublished">
                            <a><i class="fa fa-calendar"></i> 2024-04-23</a>
                        </time>
                        <a>
                            
                        </a>
                        
                            <!-- 当前仅支持valine/waline自带的统计功能 -->
                            
                        
                        
                            <!-- 当前仅支持waline自带的统计功能 -->
                            
                        
                    </span>
                    <span class="pull-right">
                        <a class="read-more" href="/2024/04/23/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D/" title="阅读全文">阅读全文<i class="fa fa-chevron-circle-right"></i></a>
                    </span>
                </footer>
            </div>
        </article>
    

    
    
        <article class="kratos-hentry clearfix" itemscope itemtype="https://schema.org/Article">
            <div class="kratos-entry-border-new clearfix">
                
                <div class="kratos-entry-thumb-new">
                    <a href="/2024/04/23/hello-world/">
                        
                            <img class="kratos-entry-thumb-new-img" alt="">
                        
                    </a>
                </div>
                <div class="kratos-post-inner-new">
                    <header class="kratos-entry-header-new">
                            
                        <h2 class="kratos-entry-title-new"><a href="/2024/04/23/hello-world/" itemprop="mainEntityOfPage"><span itemprop="name headline">Hello Worldaaaaaaa</span></a>
                    </header>
                    <div class="kratos-entry-content-new">
                        <p itemProp="description">
                            
                                Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using ...
                            
                        </p>
                    </div>
                </div>
                <footer class="kratos-post-meta-new">
                    <span class="pull-left">
                        <time datetime="2024-04-23T03:05:46.433Z" itemprop="datePublished">
                            <a><i class="fa fa-calendar"></i> 2024-04-23</a>
                        </time>
                        <a>
                            
                        </a>
                        
                            <!-- 当前仅支持valine/waline自带的统计功能 -->
                            
                        
                        
                            <!-- 当前仅支持waline自带的统计功能 -->
                            
                        
                    </span>
                    <span class="pull-right">
                        <a class="read-more" href="/2024/04/23/hello-world/" title="阅读全文">阅读全文<i class="fa fa-chevron-circle-right"></i></a>
                    </span>
                </footer>
            </div>
        </article>
    

    
    
        <article class="kratos-hentry kratos-entry-border-new clearfix" itemscope itemtype="https://schema.org/Article">
            <div class="kratos-status">
                
                    <i class="fa fa-refresh"></i>
                
                <div class="kratos-status-inner">
                    <div class="kratos-status-content" itemprop="articleBody">
                        
                            <h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a target="_blank" rel="noopener" href="https://github.com/Smith-Cruise/TinyKV-White-Paper">Smith-Cruise&#x2F;TinyKV-White-Paper: Tutorial for TinyKV project in Talent Plan. (github.com)</a><br><a target="_blank" rel="noopener" href="https://cn.pingcap.com/blog/the-design-and-implementation-of-multi-raft/#raftstore">源码解析</a></p>
<h1 id="Project2-RaftKV"><a href="#Project2-RaftKV" class="headerlink" title="Project2 RaftKV"></a>Project2 RaftKV</h1><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h3><p>[[Raft 协议]]</p>
<h3 id="Raft-GC"><a href="#Raft-GC" class="headerlink" title="Raft GC"></a>Raft GC</h3><p>Raft GC 是指在 Raft 一致性算法中用于清理日志条目的过程。在 Raft 中，每个节点都会维护一个日志，用于记录系统状态的变化。当日志变得庞大时，执行一致性操作的成本也会增加。为了限制日志的大小并提高性能，Raft 使用 Raft GC 机制来清理已经提交（committed）的日志条目。</p>
<p>Raft GC 的基本原则是，一旦某个日志条目已经被提交并应用到状态机，就可以安全地删除该条目之前的所有条目。删除旧的日志条目可以释放存储空间，并减少后续一致性操作的开销。Raft GC 通常通过一些策略（例如基于索引或时间）来判断哪些日志条目可以安全删除。</p>
<h3 id="Snapshot（快照）"><a href="#Snapshot（快照）" class="headerlink" title="Snapshot（快照）"></a>Snapshot（快照）</h3><p>Raft 中的快照是一种机制，用于在节点的状态机状态较新的情况下压缩和清理日志。当日志变得很大时，将整个日志传输给新加入的节点可能会很耗时和耗带宽。为了解决这个问题，Raft 使用快照机制来捕获节点的状态，并将其保存为一个快照文件。</p>
<p>快照包含了节点在某个特定时间点的状态机状态。当新节点加入集群时，它可以通过获取最新的快照来快速将自己带到当前状态，并只追加日志中从快照之后的新条目。这样可以大大减少传输和恢复的开销。</p>
<p>快照通常是通过在节点的状态机达到某个预定阈值时触发，或者通过节点之间的协商来创建。创建快照后，旧的日志条目可以被截断和删除，只保留最新的日志条目和快照文件。</p>
<h2 id="任务目标"><a href="#任务目标" class="headerlink" title="任务目标"></a>任务目标</h2><ol>
<li>实现基本的 raft 算法。</li>
<li>在 Raft 上构建容错 KV 服务器。</li>
<li>添加 Raft GC 和 snapshot 的支持。</li>
</ol>
<h3 id="Part-A"><a href="#Part-A" class="headerlink" title="Part A"></a>Part A</h3><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ol>
<li>代码位于 raft&#x2F;</li>
<li>使用逻辑时钟实现，选举和超时时间</li>
<li>粗略阅读一下 eraftpb.proto ， 消息接收和发送的定义</li>
<li>注意，这里与标准 Raft 协议不同，将 HeartBeat 和 AppendEntries 分成不同的消息。</li>
<li>大致步骤：<ol>
<li>Leader election</li>
<li>Log replication</li>
<li>Raw node interface</li>
</ol>
</li>
</ol>
<h4 id="实现-Raft-算法"><a href="#实现-Raft-算法" class="headerlink" title="实现 Raft 算法"></a>实现 Raft 算法</h4><ol>
<li><code>Raft/Raft.go</code> 提供了 Raft 算法的核心，包括消息处理、驱动逻辑时钟等。</li>
</ol>
<h5 id="Leader-选举"><a href="#Leader-选举" class="headerlink" title="Leader 选举"></a>Leader 选举</h5><ol>
<li><code>raft.Raft.tick()</code> 可以将内部时钟前移一个</li>
<li>发送消息时仅将消息推入<code>raft.Raft.msgs</code>，因为测试代码会从这个里面的消息然后使用 <code>raft.Raft.Step()</code> 处理回应消息</li>
<li>make project2aa 测试。</li>
</ol>
<h5 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h5><ol>
<li>先在发送方和接收方实现处理 “MsgAppend” 和 “MsgAppendResponse” 。</li>
<li><code>raft/log.go</code> 中的 <code>raft.RaftLog</code> 是关键结构。</li>
<li>需要通过<code>raft/Storage.go</code>中定义的<code>Storage </code>接口与上层应用程序交互，以获取日志条目和快照等持久化数据。</li>
<li>make project2ab 进行测试。</li>
</ol>
<h4 id="实现-Rawnode-接口"><a href="#实现-Rawnode-接口" class="headerlink" title="实现 Rawnode 接口"></a>实现 Rawnode 接口</h4><p> <code>raft/rawnode.go</code> 中的 <code>raft.RawNode</code> 是与上层应用交互的接口。</p>
<ol>
<li><p>包含 <code>raft.Raft</code> ，封装了时钟相关： <code>RawNode.Tick()</code>and <code>RawNode.Step()</code>，日志 ：<code>RawNode.Propose()</code></p>
</li>
<li><p>包含一个新的 结构 <code>Ready</code>，处理消息或推进逻辑时钟时，<code>raft.Raft</code> 可能需要与上层应用程序交互，例如：</p>
<ul>
<li>向其他对等方发送消息</li>
<li>将日志项保存到稳定的存储中</li>
<li>保存硬状态（如术语），提交索引，并投票到稳定存储</li>
<li>将提交的日志条目应用于状态机</li>
<li>等<br>交互不会立即发生，相反，它们被封装在 “Ready” 中，并由 “RawNode” 返回。<code>Ready（）</code>到上层应用程序。这取决于上层应用程序何时调用 <code>Ready（）</code>并进行处理。在处理完返回的 Ready 之后，上层应用程序还需要调用一些函数，如 <code>RawNode.Advance（）</code> 更新 <code>raft.Raft</code> 的内部状态，如应用索引、稳定日志索引等。</li>
</ul>
</li>
<li><p>“makeproject2ac” 来测试实现</p>
</li>
</ol>
<p>也可以运行 “make project2a” 来测试整个A部分。</p>
<blockquote>
<p>提示。</p>
<ul>
<li>需要时添加任何状态到 <code>raft.Raft</code>, <code>raft.RaftLog</code>, <code>raft.RawNode</code> 和消息，在<code>eraftpb.proto</code> 中</li>
<li>测试中假设初始的 term 0</li>
<li>测试中假设新选举的 Leader 应该在任期内添加一个 noop 条目。 </li>
<li>测试中假设一旦领导者推进其提交索引，它将通过 “MessageType_MsgAppend” 消息广播提交索引。</li>
<li>测试中不会为本地 Message，<code>MessageType_MsgHup</code>, <code>MessageType_MsgBeat</code> 和 <code>MessageType_MsgPropose</code> 添加 term 号, </li>
<li>领导者和非领导者的日志条目附加有很大不同，有不同的来源，检查和处理，请小心。</li>
<li>不要忘记，peers 之间的选举超时时间应该不同。</li>
<li>rawnode.go 中的一些包装函数可以通过 raft.Step(local message) 来实现</li>
<li>当启动一个新的 raft 时，从<code>Storage</code>中获取最后的稳定状态来初始化<code>raft.Raft</code>和<code>raft.Raft Log</code></li>
</ul>
</blockquote>
<h3 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h3><p>使用 part A 中 实现的 Raft 模块构建一个容错键值存储服务。</p>
<ol>
<li>键&#x2F;值服务将是一个复制状态机，由多个使用 Raft 进行复制的键&#x2F;值服务器组成。</li>
<li>只要大多数服务器处于活动状态并且可以通信，尽管存在其他故障或网络分区，您的键&#x2F;值服务就应该继续处理客户端请求。<blockquote>
<p>三个术语：“Store”、“Peer” 和 “Region”（定义在 “proto&#x2F;proto&#x2F;metapb.proto” 中）</p>
<ul>
<li>Store 代表tinykv-server 的一个实例</li>
<li>Peer 代表在 Store 上运行的 Raft 节点</li>
<li>Region是 Peers 的集合，也称为 Raft group (现在不需要考虑Region的范围。 项目3中将进一步引入多个区域。)</li>
</ul>
</blockquote>
</li>
</ol>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>查看 <code>kv/storage/raft_storage/raft_server.go</code> 中的 <code>RaftStorage</code> ：实现了 <code>Storage</code> 接口（与 Project1 中的单机存储不同），首先将每个写入和读取请求发送到 Raft，然后在 Raft 提交请求后才对底层引擎进行实际的写入和读取。<br><code>RaftStorage</code> 创建一个 <code>Raftstore</code> 来驱动 Raft。 当调用 <code>Reader</code> 或 <code>Write</code> 函数时，它实际上通过通道（ 通道是“raftWorker”的“raftCh”），并在 Raft 提交并应用命令后返回响应。 Reader 和 Write 函数的 kvrpc.Context 参数现在很有用，它从客户端的角度携带 Region 信息，并作为 RaftCmdRequest 的 header 传递。 这些信息可能不正确或过时，因此 raftstore 需要检查它们并决定是否提出请求。<br>接下来，就到了TinyKV的核心——raftstore。 结构有点复杂，阅读 TiKV 参考资料可以更好地理解设计：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://pingcap.com/blog-cn/the-design-and-implementation-of-multi-raft/#raftstore">https://pingcap.com/blog-cn/the-design-and-implementation-of-multi-raft/#raftstore</a>（中文版）</li>
<li><a target="_blank" rel="noopener" href="https://pingcap.com/blog/design-and-implementation-of-multi-raft/#raftstore">https://pingcap.com/blog/design-and-implementation-of-multi-raft/#raftstore</a>（英文版）</li>
</ul>
<p>raftstore 的入口是 <code>Raftstore</code>，参见<code>kv/raftstore/raftstore.go</code>。 它启动一些工作线程异步处理特定任务，其中大多数现在不使用，因此您可以忽略它们。 你需要关注的是<code>raftWorker</code>。(kv&#x2F;raftstore&#x2F;raft_worker.go)</p>
<p>整个过程分为两部分：raftworker 轮询 “raftCh” 以获取消息，包括驱动 Raft 模块的基本 tick 和建议作为 Raft 条目的 Raft 命令； 它从 Raft 模块获取并处理就绪，包括发送 raft 消息、持久化状态、将提交的条目应用到状态机。 申请后，将响应返回给客户。</p>
<h4 id="实现对等存储-peer-storage"><a href="#实现对等存储-peer-storage" class="headerlink" title="实现对等存储 peer storage"></a>实现对等存储 peer storage</h4><p>对等存储是您通过 A 部分中的 “Storage”  接口进行交互的内容，但除了 raft 日志之外，对等存储还管理其他持久化元数据，这对于重启后恢复一致状态机非常重要</p>
<blockquote>
<p><code>proto/proto/raft_serverpb.proto</code> 中定义了三个重要的状态：</p>
</blockquote>
<ul>
<li>RaftLocalState：用于存储当前 Raft 的 HardState 和最后一个 Log Index。</li>
<li>RaftApplyState：用于存储 Raft 最后应用的 Log 索引以及一些被截断的 Log 信息。</li>
<li>RegionLocalState：用于存储 Region 信息以及该 Store 上对应的 Peer 状态。 Normal 表示该 Peer 正常，Tombstone 表示该 Peer 已从 Region 中移除，无法加入 Raft Group。<br>这些状态存储在两个 badger 实例中：raftdb 和 kvdb：</li>
<li>raftdb 存储 raft 日志和 <code>RaftLocalState</code></li>
<li>kvdb 将键值数据存储在不同的列族 “RegionLocalState” 和 “RaftApplyState” 中。 可以把kvdb看成Raft论文中提到的状态机<blockquote>
<p>why?<br>实际上，可以只使用一个 badger 来存储 raft 日志和状态机数据。 分成两个实例只是为了与 TiKV 设计保持一致。</p>
</blockquote>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">Key</th>
<th align="left">KeyFormat</th>
<th align="left">Value</th>
<th align="left">DB</th>
</tr>
</thead>
<tbody><tr>
<td align="left">raft_log_key</td>
<td align="left">0x01 0x02 region_id 0x01 log_idx</td>
<td align="left">Entry</td>
<td align="left">raft</td>
</tr>
<tr>
<td align="left">raft_state_key</td>
<td align="left">0x01 0x02 region_id 0x02</td>
<td align="left">RaftLocalState</td>
<td align="left">raft</td>
</tr>
<tr>
<td align="left">apply_state_key</td>
<td align="left">0x01 0x02 region_id 0x03</td>
<td align="left">RaftApplyState</td>
<td align="left">kv</td>
</tr>
<tr>
<td align="left">region_state_key</td>
<td align="left">0x01 0x03 region_id 0x01</td>
<td align="left">RegionLocalState</td>
<td align="left">kv</td>
</tr>
<tr>
<td align="left">这些元数据应该在 “PeerStorage” 中创建和更新。 创建 PeerStorage 时，请参阅 “kv&#x2F;raftstore&#x2F;peer_storage.go”。 它会初始化该 Peer 的RaftLocalState、RaftApplyState，或者重启时从底层引擎获取之前的值。 注意，RAFT_INIT_LOG_TERM 和 RAFT_INIT_LOG_INDEX 的值都是 5（只要大于 1），而不是 0。之所以不设置为 0，是为了与 conf 更改后被动创建 Peer 的情况区别。 你现在可能还不太明白，所以请记住这一点，当你实现 conf 更改时，详细信息将在project3b 中描述。</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>这部分需要实现的代码只有一个函数：<code>PeerStorage.SaveReadyState</code>，该函数的作用是将 <code>raft.Ready</code> 中的数据保存到 badger 中，包括追加日志条目和保存 Raft 硬状态。</p>
<blockquote>
<p>硬状态：更新 <code>RaftLocalState.HardState</code> 并保存。</p>
</blockquote>
<p>要追加日志条目，只需将 “raft.Ready.Entries” 中的所有日志条目保存到 raftdb 并删除任何以前追加的永远不会提交的日志条目。 另外，更新对等存储的 “RaftLocalState”并将其保存到 raftdb。</p>
<blockquote>
<p>提示：</p>
<ul>
<li>使用 <code>WriteBatch</code> 立即保存这些状态。</li>
<li>有关如何读取和写入这些状态的信息，请参阅 <code>peer_storage.go</code> 中的其他函数。</li>
<li>设置环境变量 LOG_LEVEL&#x3D;debug 这可以帮助您进行调试，另请参阅所有可用的<a href="../log/log.go">日志级别</a>。</li>
</ul>
</blockquote>
<h3 id="实施-Raft-Ready-流程"><a href="#实施-Raft-Ready-流程" class="headerlink" title="实施 Raft Ready 流程"></a>实施 Raft Ready 流程</h3><p>在 Part A 部分，构建了一个基于 tick 的 Raft 模块。 现在您需要编写外部进程来驱动它。 大部分代码已经在 <code>kv/raftstore/peer_msg_handler.go</code> 和 <code>kv/raftstore/peer.go</code> 下实现。 所以你需要学习代码并完成 <code>proposeRaftCommand</code> 和 <code>HandleRaftReady</code> 的逻辑。 以下是对该框架的一些解释。</p>
<p>Raft “RawNode” 已使用 “PeerStorage” 创建并存储在 “peer” 中。 在 Raft Worker 中，您可以看到它采用 “peer” 并通过 “peerMsgHandler” 包装它。  <code>peerMsgHandler</code> 主要有两个功能：一是 <code>HandleMsg</code> ，另一个是 <code>HandleRaftReady</code>。</p>
<p><code>HandleMsg</code> 处理从 raftCh 接收到的所有消息，包括 <code>MsgTypeTick</code> 调用 <code>RawNode.Tick()</code> 来驱动 Raft，<code>MsgTypeRaftCmd</code> 包装来自客户端的请求，以及 <code>MsgTypeRaftMessage</code> 是 Raft 对等点之间传输的消息 。 所有消息类型都在 <code>kv/raftstore/message/msg.go</code> 中定义。 具体大家可以查看一下，其中一些会在后面的部分用到。</p>
<p>消息处理完毕后，Raft 节点应该有一些状态更新。 因此 <code>HandleRaftReady</code> 应该从 Raft 模块中做好准备并执行相应的操作，例如持久化日志条目、应用提交的条目<br>并通过网络向其他对等点发送 raft 消息。</p>
<p>在伪代码中，raftstore 使用 Raft，如下所示：</p>
<pre><code class="go">for &#123;
  select &#123;
  case &lt;-s.Ticker:
    Node.Tick()
  default:
    if Node.HasReady() &#123;
      rd := Node.Ready()
      saveToStorage(rd.State, rd.Entries, rd.Snapshot)
      send(rd.Messages)
      for _, entry := range rd.CommittedEntries &#123;
        process(entry)
      &#125;
      s.Node.Advance(rd)
    &#125;
&#125;
</code></pre>
<p>之后读取或写入的整个过程将是这样的：</p>
<ul>
<li>客户端调用RPC RawGet&#x2F;RawPut&#x2F;RawDelete&#x2F;RawScan</li>
<li>RPC处理程序调用<code>RaftStorage</code>相关方法</li>
<li><code>RaftStorage</code> 向 raftstore 发送 Raft 命令请求，并等待响应</li>
<li><code>RaftStore</code> 将 Raft 命令请求作为 Raft 日志提出</li>
<li>Raft模块追加日志，并通过<code>PeerStorage</code>持久化</li>
<li>Raft模块提交日志</li>
<li>Raft Worker在Raft准备就绪时执行Raft命令，并通过回调返回响应</li>
<li><code>RaftStorage</code> 接收回调的响应并返回到 RPC 处理程序</li>
<li>RPC 处理程序执行一些操作并将 RPC 响应返回给客户端。</li>
</ul>
<p>您应该运行“make project2b”来通过所有测试。 整个测试运行一个模拟集群，包括多个带有模拟网络的 TinyKV 实例。 它执行一些读写操作并检查返回值是否符合预期。</p>
<p>需要注意的是，错误处理是通过测试的重要组成部分。 您可能已经注意到“proto&#x2F;proto&#x2F;errorpb.proto”中定义了一些错误，并且错误是 gRPC 响应的一个字段。 另外，实现了 error 接口的相应错误定义在 kv&#x2F;raftstore&#x2F;util&#x2F;error.go 中，因此您可以将它们用作函数的返回值。</p>
<p>这些错误主要与Region有关。 所以它也是<code>RaftCmdResponse</code>的<code>RaftResponseHeader</code>的成员。 当提出请求或应用命令时，可能会出现一些错误。 如果是这样，您应该返回带有错误的 raft 命令响应，然后错误将进一步传递给 gRPC 响应。 当返回带有错误的响应时，您可以使用 kv&#x2F;raftstore&#x2F;cmd_resp.go 中提供的 BindRespError 将这些错误转换为 errorpb.proto 中定义的错误。</p>
<p>在这个阶段，你可能会考虑这些错误，其他的将在 project3 中处理：</p>
<ul>
<li>ErrNotLeader：在跟随者上提议 raft 命令。 所以用它来让客户端尝试其他对等点。</li>
<li>ErrStaleCommand：可能由于领导者更改，某些日志未提交并被新领导者的日志覆盖。 但客户并不知道这一点，仍在等待回复。 因此，您应该返回此信息以让客户端知道并再次重试该命令。</li>
</ul>
<h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><blockquote>
<p>why<br>RAFT_INIT_LOG_TERM 和 RAFT_INIT_LOG_INDEX 的值都是 5（只要大于 1）</p>
</blockquote>
<blockquote>
<p>Config.Applied uint64 干嘛用的</p>
</blockquote>

                        
                    </div>
                </div>
            </div>
            
                <footer class="kratos-post-meta-new">
                    <span class="pull-left">
                        <time datetime="2024-04-23T03:05:06.671Z" itemprop="datePublished">
                            <a><i class="fa fa-calendar"></i> 2024-04-23</a>
                        </time>
                        
                        
                            <!-- 当前仅支持valine/waline自带的统计功能 -->
                            
                        
                        
                            <!-- 当前仅支持waline自带的统计功能 -->
                            
                        
                    </span>
                    
                    
                        <span class="pull-right">
                            <a class="read-more" href="/2024/04/23/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/TinyKV/TinyKV%20%E9%A1%B9%E7%9B%AE%E8%A6%81%E6%B1%82/" title="留言">留言<i class="fa fa-chevron-circle-right"></i></a>
                        </span>
                    

                </footer>
            
        </article>
    

    
    
        <article class="kratos-hentry kratos-entry-border-new clearfix" itemscope itemtype="https://schema.org/Article">
            <div class="kratos-status">
                
                    <i class="fa fa-refresh"></i>
                
                <div class="kratos-status-inner">
                    <div class="kratos-status-content" itemprop="articleBody">
                        
                            <h1 id="Raft-协议"><a href="#Raft-协议" class="headerlink" title="Raft 协议"></a>Raft 协议</h1><p>参考：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1nu4y167WM?p=5&spm_id_from=pageDriver&vd_source=59461060c1867e9bf731e467ae6f00b5">Raft-4：Raft 协议的基础工作流程_哔哩哔哩_bilibili</a><br>知识点：Paxos<br>核心原理：在多个副本之间进行投票和决策，以确保数据的一致性。<br>两个阶段：</p>
<ol>
<li>prepare: 提案者提出一个提议，发送给其他所有参与者，每个参与者都参与投票。如果大多数参与者同意这个协议，则进入 accept 阶段。</li>
<li>accept：提案者再次向所有参与者发送一个包含提议编号和提议内容的消息，如果大多数参与者再次同意这个提议，则该提议被视为有效并被接受。<br>关键特性：<br> 去中心化设计：没有单一的领导者节点负责做出最终决策，相反，任何节点都可以成为提案者或者接收者。<br>Raft：<br>基本流程：</li>
<li>多个 server 共同选举产生一个 Leader，负责响应客户端的请求。</li>
<li>Leader 通过一致性协议，将客户端的指令发送到所有节点上。</li>
<li>每个节点将客户端的指令以 Entry的形式保存到自己的 Log 中，此时 Entry 状态为 uncommited 。</li>
<li>当有多数节点共同保存了 Entry 后，就可以执行 Entry 中的客户端指令，提交到 State 状态机中，此时 Entry 更新为 commited 状态。<br>![[Pasted image 20240320211915.png]]<br>理解  Raft 中的 Term：</li>
<li>Raft 将时间线分割为多个 term （任期）；</li>
<li>一个任期有一个 id ，分两个阶段：<ol>
<li>选举 election：选举出一个 leader。如果选举失败，此 term（任期）快速结束。</li>
<li>操作：进行执行任务。<br>![[Pasted image 20240320211822.png]]</li>
</ol>
</li>
</ol>
<p>理解 Raft 中的 状态机制<br>Raft 协议会为每一个服务器记录一个状态，状态有三种：<br>    1. Follower：负责同步 Leader 的操作日志。<br>    2. Candidate<br>    3. Leader：</p>
<ol>
<li>所有节点都是从 Follower 开始，Follower 负责同步 Leader 的操作日志。</li>
<li>Leader 会给 Follower 发送心跳。</li>
<li>Follower 收到心跳超时（随机值），转入 Candidate 状态，发起选举，如果成功，则变成 Leader；</li>
<li>新的 Leader 会向所有其他节点发送心跳。</li>
<li>此时其他节点无论是什么状态，都会变成 Follower<br>![[Pasted image 20240320211748.png]]</li>
</ol>
<p>Raft 协议会为每一个服务器记录两个超时：</p>
<ol>
<li>选举超时。</li>
<li></li>
</ol>
<p>Raft 和 Paxos 类似，但是更容易理解，也更容易实现。<br>Raft 主要是用来竞选主节点。<br>单个 Candidate 的竞选<br>有三种节点：Follower、Candidate 和 Leader。Leader 会周期性的发送心跳包给 Follower。每个 Follower 都设置了一个随机的竞选超时时间，一般为 150ms~300ms，如果在这个时间内没有收到 Leader 的心跳包，就会变成 Candidate，进入竞选阶段。</p>
<ul>
<li><p>下图表示一个分布式系统的最初阶段，此时只有 Follower，没有 Leader。Follower A 等待一个随机的竞选超时时间之后，没收到 Leader 发来的心跳包，因此进入竞选阶段。</p>
</li>
<li><p>此时 A 发送投票请求给其它所有节点。</p>
</li>
<li><p>其它节点会对请求进行回复，如果超过一半的节点回复了，那么该 Candidate 就会变成 Leader。</p>
</li>
<li><p>之后 Leader 会周期性地发送心跳包给 Follower，Follower 接收到心跳包，会重新开始计时。</p>
</li>
</ul>
<h2 id="多个-Candidate-竞选"><a href="#多个-Candidate-竞选" class="headerlink" title="多个 Candidate 竞选"></a>多个 Candidate 竞选</h2><ul>
<li><p>如果有多个 Follower 成为 Candidate，并且所获得票数相同，那么就需要重新开始投票，例如下图中 Candidate B 和 Candidate D 都获得两票，因此需要重新开始投票。</p>
</li>
<li><p>当重新开始投票时，由于每个节点设置的随机竞选超时时间不同，因此能下一次再次出现多个 Candidate 并获得同样票数的概率很低。</p>
</li>
</ul>
<h2 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h2><ul>
<li><p>来自客户端的修改都会被传入 Leader。注意该修改还未被提交，只是写入日志中。</p>
</li>
<li><p>Leader 会把修改复制到所有 Follower。</p>
</li>
<li><p>Leader 会等待大多数的 Follower 也进行了修改，然后才将修改提交。</p>
</li>
<li><p>此时 Leader 会通知的所有 Follower 让它们也提交修改，此时所有节点的值达成一致</p>
</li>
</ul>

                        
                    </div>
                </div>
            </div>
            
                <footer class="kratos-post-meta-new">
                    <span class="pull-left">
                        <time datetime="2024-04-23T03:05:06.670Z" itemprop="datePublished">
                            <a><i class="fa fa-calendar"></i> 2024-04-23</a>
                        </time>
                        
                        
                            <!-- 当前仅支持valine/waline自带的统计功能 -->
                            
                        
                        
                            <!-- 当前仅支持waline自带的统计功能 -->
                            
                        
                    </span>
                    
                    
                        <span class="pull-right">
                            <a class="read-more" href="/2024/04/23/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/TinyKV/Raft%20%E5%8D%8F%E8%AE%AE/" title="留言">留言<i class="fa fa-chevron-circle-right"></i></a>
                        </span>
                    

                </footer>
            
        </article>
    

    
    
        <article class="kratos-hentry kratos-entry-border-new clearfix" itemscope itemtype="https://schema.org/Article">
            <div class="kratos-status">
                
                    <i class="fa fa-refresh"></i>
                
                <div class="kratos-status-inner">
                    <div class="kratos-status-content" itemprop="articleBody">
                        
                            <h1 id="Project-1"><a href="#Project-1" class="headerlink" title="Project 1"></a>Project 1</h1><h1 id="Project-2"><a href="#Project-2" class="headerlink" title="Project 2"></a>Project 2</h1><h2 id="Project-2-整体架构"><a href="#Project-2-整体架构" class="headerlink" title="Project 2 整体架构"></a>Project 2 整体架构</h2><h2 id="Project-2A"><a href="#Project-2A" class="headerlink" title="Project 2A"></a>Project 2A</h2><h3 id="Project-2A-整体架构"><a href="#Project-2A-整体架构" class="headerlink" title="Project 2A 整体架构"></a>Project 2A 整体架构</h3><p>本部分实现基础的 Raft 算法，且不需要考虑快照操作。我们共需要实现三个模块，分别为 RawNode、Raft 和 RaftLog，分别对应文件 <code>rawnode.go</code>、<code>raft.go</code> 和 <code>log.go</code> ，这三个模块，共同构成一层，我将其称为 <code>raft 层</code>。结构图如下<br>![[image2.png]]</p>
<ul>
<li><strong>RawNode</strong>：该模块用来接收上层传来的信息，将信息下传给 Raft 模块。比如，上层传递一个 Msg 给 RawNode，这个 Msg 可能是 心跳请求、日志提交请求、日志追加请求等等。然后 RawNode 收到这个 Msg 之后，将其交给 Raft 模块去处理。比如，上层交给 RawNode 一个日志提交请求，然后 RawNode 将其交给 Raft ，如果该节点是领导人，那么其就会追加这条日志，然后发送给其他节点进行同步。另外，RawNode 不仅用来接受请求然后传递给 Raft，还要用来收到 Raft 的同步结果然后传递给上层。RawNode 要负责检查 Raft 模块是否已有同步好的日志需要应用、是否有 Msg 需要发送、是否有日志需要持久化等等，然后把这些信息（Ready）交给上层，上层会据此进行处理。总的来说，RawNode 是 raft 层暴露给上层的一个模块，用来进行信息的传递。</li>
<li><strong>Raft</strong>：整个 raft 层最关键的就是它，它就是实现 Raft 算法的核心模块。其中，领导人选举、日志追加、角色转换等等均是在这里实现。Raft 模块会接受 RawNode 发来的信息，然后在进群中进行相关的同步操作，同步结果不需要主动返回给 RawNode，因为 RawNode 自己会进行检查。</li>
<li><strong>RaftLog</strong>：该模块用来暂存节点的日志条目，同时还要维护一些日志指针，如 committed、applied 等等。</li>
</ul>
<p>总结一下，RawNode 是 raft 层中暴露在外面的模块，用于该层与上层的信息交互，Raft 模块是 raft 层中的核心模块，算法的核心逻辑均在该模块实现，RaftLog 用来暂存日志信息，并维护相关指针。</p>
<h3 id="Project-2-AA｜Project-2-AB"><a href="#Project-2-AA｜Project-2-AB" class="headerlink" title="Project 2 AA｜Project 2 AB"></a>Project 2 AA｜Project 2 AB</h3><h4 id="消息类型以及基本逻辑"><a href="#消息类型以及基本逻辑" class="headerlink" title="消息类型以及基本逻辑"></a>消息类型以及基本逻辑</h4><ol>
<li><p>case pb.MessageType_MsgHup:</p>
<ol>
<li>选举的本地消息，由 Tick() 触发。</li>
<li>如果发生选举超时，节点应将“MessageType_MsgHup”传递给其 Step 方法并开始新的选举，向其他所有节点发送 MsgRequestVote；</li>
<li>一旦收到了这个消息，说明就是要重新开始一次选举。</li>
</ol>
</li>
<li><p>case pb.MessageType_MsgBeat:</p>
<ol>
<li>本地心跳信息。表示当前节点的时钟前进，判断心跳超时和选举超时并进行相应的处理。</li>
<li>注意只有 Leader 需要处理这个消息。</li>
</ol>
</li>
<li><p>case pb.MessageType_MsgPropose:</p>
<ol>
<li>注意只有 Leader 会处理这个消息。 </li>
<li>Leader 收到此消息需要将日志广播给其他节点。<ol>
<li>发送时，如果要发送的 Index 已经被压缩了，转为发送快照。</li>
<li>否则发送 MsgAppend。</li>
<li>如果 MsgAppend 被接收者拒绝，Leader 会调整 next，重新进行前置判断，如果无需发快照，则按照新的 next 重新发送 MsgAppend。</li>
</ol>
</li>
<li>发送方：由 Raft 层的上层构造此 msg 表示一次追加日志。此外，becomeLeader 时也会发送一个空 Entry 的 propose（也会被 广播）。</li>
</ol>
</li>
<li><p>case pb.MessageType_MsgAppend:</p>
<ol>
<li>发送方：如上，一般 propose 之后触发，由 Leader 发送给其他节点来同步日志条目。</li>
<li>接收方：<ol>
<li>判断 Msg 的 Term 是否大于等于自己的 Term，是则更新，否则拒绝；</li>
<li>拒绝，如果 prevLogIndex &gt; r.RaftLog.LastIndex() 说明中间有日志缺失。否则往下；</li>
<li>拒绝，如果接收者日志中没有包含这样一个条目：即该条目的 Term 在 prevLogIndex 上不能和 prevLogTerm 匹配上。否则往下；</li>
<li>追加新条目，同时删除冲突条目，冲突条目的判别方式和论文中的一致；</li>
<li>当前节点更新 committedIndex 时，要比较 Leader 已知已经提交的最高的日志条目的索引 m.Commit 或者是上一个新条目的索引，然后取两者的最小值。为</li>
<li>接受；</li>
</ol>
</li>
</ol>
</li>
<li><p>case pb.MessageType_MsgAppendResponse:</p>
<ol>
<li>只有 Leader 会处理该 Msg，其余角色直接忽略；</li>
<li>如果被 reject 了，那么重置 next。重置规则为将旧的 next –，然后比较 m.Index + 1，最后取小的那个赋值给 next，然后重新进行日志 &#x2F; 快照追加；</li>
<li>如果没有 reject，则更新 match 和 next。next 赋值为 m.Index + 1，match 赋值为 next - 1 ；</li>
<li>按照论文的思路更新 commit。假设存在 N 满足N &gt; commitIndex，使得大多数的 matchIndex[i] ≥ N以及log[N].term &#x3D;&#x3D; currentTerm 成立，则令 commitIndex &#x3D; N。为了快速更新，这里先将节点按照 match 进行了递增排序，这样就可以快速确定 N 的位置。</li>
</ol>
</li>
<li><p>case pb.MessageType_MsgRequestVote:</p>
<ol>
<li>判断 Msg 的 Term 是否大于等于自己的 Term，是则更新，否则拒绝；</li>
<li>如果 votedFor 不为空或者不等于 candidateID，则说明该节点以及投过票了，直接拒绝。否则往下；</li>
<li>Candidate 的日志至少和自己一样新，那么就给其投票，否者拒绝。新旧判断逻辑如下：<ul>
<li>如果两份日志最后的条目的任期号不同，那么任期号大的日志更加新</li>
<li>如果两份日志最后的条目任期号相同，那么日志比较长的那个就更加新；<br> Candidate 会通过 r.votes 记录下都有哪些节点同意哪些节点拒绝，当同意的票数过半时，即可成为 Leader，当拒绝的票数过半时，则转变为 Follower。</li>
</ul>
</li>
</ol>
</li>
<li><p>case pb.MessageType_MsgRequestVoteResponse:</p>
<ol>
<li>只有 Candidate 会处理该 Msg，其余节点收到后直接忽略；</li>
<li>根据 m.Reject 更新 r.votes[m.From]，即记录投票结果；</li>
<li>算出同意的票数 agrNum 和拒绝的票数 denNum；</li>
<li>如果同意的票数过半，那么直接成为 Leader；</li>
<li>如果拒绝的票数过半，那么直接成为 Follower</li>
</ol>
</li>
<li><p>case pb.MessageType_MsgSnapshot:</p>
<ol>
<li>Project2C 中才会实现，所以该 Msg 在 Project2C 处</li>
</ol>
</li>
<li><p>case pb.MessageType_MsgHeartbeat:</p>
<ol>
<li>发送：<ol>
<li>每当 Leader 的 heartbeatTimeout 达到时，就会给其余所有节点发送 MsgHeartbeat；</li>
</ol>
</li>
<li>接收与处理：<ol>
<li>判断 Msg 的 Term 是否大于等于自己的 Term，是则更新，否则拒绝；</li>
<li>重置选举计时 r.electionElapsed</li>
<li>发送 MsgHeartbeatResponse</li>
<li>Commit:  min(r.RaftLog.committed, r.Prs[to].Match), 确保了心跳消息中的 Commit 字段不会超过已经在目标节点上提交的日志索引，使得心跳消息不需要推进 Commit。</li>
</ol>
</li>
</ol>
</li>
<li><p>case pb.MessageType_MsgHeartbeatResponse:</p>
<ol>
<li>发送：<ol>
<li>当节点收到 MsgHeartbeat 时，会相应的回复 MsgHeartbeatResponse；</li>
</ol>
</li>
<li>接收与处理：<ol>
<li>只有 Leader 会处理 MsgHeartbeatResponse，其余角色直接忽略；</li>
<li>通过 m.Commit 判断节点是否落后了，如果是，则进行日志追加；</li>
</ol>
</li>
</ol>
</li>
<li><p>case pb.MessageType_MsgTransferLeader:</p>
<ol>
<li>用于上层请求转移 Leader，Project3 使用。</li>
</ol>
</li>
<li><p>case pb.MessageType_MsgTimeoutNow:</p>
<ol>
<li>节点收到后清空 r.electionElapsed，并即刻发起选举</li>
</ol>
</li>
</ol>
<h4 id="消息使用的字段"><a href="#消息使用的字段" class="headerlink" title="消息使用的字段"></a>消息使用的字段</h4><table>
<thead>
<tr>
<th>MessageType\msg_nr</th>
<th>MsgType</th>
<th>To</th>
<th>From</th>
<th>Term</th>
<th>LogTerm</th>
<th>Index</th>
<th>Entries</th>
<th>Commit</th>
<th>Snapshot</th>
<th>Reject</th>
</tr>
</thead>
<tbody><tr>
<td>Hup</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Beat</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Propose</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>RequestVote</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>requestVoteResponse</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>。</td>
<td>。</td>
<td></td>
<td></td>
<td></td>
<td>√</td>
</tr>
<tr>
<td>Heartbeat</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>HeartbeatResponse</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Append</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>AppendResponse</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td>√</td>
</tr>
<tr>
<td>Snapshot</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>TransferLeader</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>TimeoutNow</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>注意点：</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ol>
<li>Hup 和 Beat 一定是本地消息，而 Propose 不一定是本地消息，可能是外部构造的不再 Raft 内部调用 Step 处理，所以：From 不使用但是 To 需要使用。</li>
<li>TimeoutNow 也是 本地消息，即刻发起选举。</li>
<li>对于 MessageType_MsgAppend：<ol>
<li>LogTerm 为要发送的条目的前一个条目的 Term，即论文中的 prevLogTerm</li>
<li>Index 为要发送的条目的前一个条目的 Index，即论文中的 prevLogIndex</li>
<li>当前节点 (Leader) 的 committedIndex</li>
</ol>
</li>
<li>对于 MessageType_MsgAppendResponse：<ol>
<li>Index：r.RaftLog.LastIndex()；该字段用于 Leader 更快地去更新 next</li>
</ol>
</li>
<li>Reject 两个功能，一个 投票一个 在 append<br> 不同的是，propose 的 entry 无论是不是一个空的，都会被当成一个新的 entry 进行添加，而 Appen 的 entry，则可能被拒绝或者截取部分。</li>
</ol>
<h4 id="推进器-Step"><a href="#推进器-Step" class="headerlink" title="推进器 Step()"></a>推进器 Step()</h4><p>Step() 作为驱动器，用来接收上层发来的 Msg，然后根据不同的角色和不同的 MsgType 进行不同的处理。</p>
<h4 id="计时器-tick"><a href="#计时器-tick" class="headerlink" title="计时器 tick()"></a>计时器 tick()</h4><p>该函数起到计时器的作用，即逻辑时钟。每调用一次，就要增加节点的心跳计时（ r.electionElapsed），如果是 Leader，就要增加自己的选举计时（ r.heartbeatElapsed），然后，应按照角色进行对应的操作。</p>
<h4 id="log-go"><a href="#log-go" class="headerlink" title="log.go"></a>log.go</h4><h4 id="关键点｜易错点"><a href="#关键点｜易错点" class="headerlink" title="关键点｜易错点"></a>关键点｜易错点</h4><ol>
<li>raft 的 id 是从 0 开始的，但是 0 是无效 id ：const RaftInvalidIndex uint64 &#x3D; 0</li>
<li>entry 的 index 指的是 在 storage 中的 索引，而不是在数组中的下标。<br> 下标计算： index - entries[0].Index</li>
<li>注意每一个 entry 都有一个自己的 <strong>term</strong></li>
<li>Leader 不会自己发起一个新的选举。</li>
<li>注意变成 Candidate 后发现，只有一个节点，再直接变成 Leader。</li>
<li>注意某一个消息处理时如果遍历 Prs 且跳过了当前节点的 id ，需要额外考虑一下集群只有一个节点的情况。</li>
<li>becomeCandidate 和 发送 请求 投票要分开进行</li>
<li>allEntries() 描述中需要排除 排除虚拟条目，但是实际上，<br> &#x2F;&#x2F; if ent.Data !&#x3D; nil { &#x2F;&#x2F; 如果 这里的 ent 的 Data 是空的,说明 entry 无效<br> &#x2F;&#x2F; }<br> 不需要排除，这个是在 测试中确定的。</li>
<li>handleRequestVoteResponse  除了统计同意的个数，还需要统计 拒绝的个数。</li>
</ol>
<h4 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h4><p><strong>随机选举时间问题</strong></p>
<ul>
<li>如果 et 太小，会过早开始选举，导致 term 比测试预期大。如果太大，会很晚发生选举，导致 term 比测试预期小。而且如果按照etcd那样一直递增，最后时间会非常长，直接卡住。我最后把它限制在 10~20 之间，通过测试。</li>
</ul>
<p><strong>leader 更新 committed 之后要告知 follower</strong></p>
<ul>
<li>eader 收到 appendResp 后，会相应的更新自己的 committed，但是更新之后一定要把更新结果告知<code>全部</code> follower，即另外发送一个 appendResp 。如果不这样的话，最后一轮完成后，集群的 committed 会不同步。并且为了防止死循环，leader 只能在 committed 发生变化的时候去通知 follower。</li>
</ul>
<p><strong>测试要求 msg 是nil，而不是空切片</strong></p>
<ul>
<li>TestRawNodeRestartFromSnapshot2C 中，want 里的 msg 为 nil，即测试点预期 newRaft 处的 msg 应该为 nil，而不是 make 一个空切片。</li>
</ul>
<h3 id="Project-2-AB"><a href="#Project-2-AB" class="headerlink" title="Project 2 AB"></a>Project 2 AB</h3><p>空空如也</p>
<h3 id="Project-2-AC"><a href="#Project-2-AC" class="headerlink" title="Project 2 AC"></a>Project 2 AC</h3><h4 id="RawNode-部分整体工作流程"><a href="#RawNode-部分整体工作流程" class="headerlink" title="RawNode 部分整体工作流程"></a>RawNode 部分整体工作流程</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> &lt;-s.Ticker:</span><br><span class="line">    Node.Tick()</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">if</span> Node.HasReady() &#123;</span><br><span class="line">      rd := Node.Ready()</span><br><span class="line">      saveToStorage(rd.State, rd.Entries, rd.Snapshot)</span><br><span class="line">      send(rd.Messages)</span><br><span class="line">      <span class="keyword">for</span> _, entry := <span class="keyword">range</span> rd.CommittedEntries &#123;</span><br><span class="line">        process(entry)</span><br><span class="line">      &#125;</span><br><span class="line">      s.Node.Advance(rd)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码解释：</p>
<ol>
<li>RawNode 是 Raft 的包装器，上层 ( peer 层) 会不停的调用 RawNode 的 tick() 函数，进一步触发 Raft 的 tick() 函数。 </li>
<li>上层会定时从 RawNode 获取 Ready，首先上层通过 HasReady() 进行判断，如果有新的 Ready，上层会调用RawNode 的Ready()方法进行获取，RawNode 从 Raft 中 获取信息生成相应的 Ready 返回给上层应用，Raft 的信息则是存储在 RaftLog 之中。上层应用处理完 Ready 后，会调用 RawNode 的Advance() 方法进行推进，告诉 RawNode 之前的 Ready 已经被处理完成，然后你可以执行一些操作，比如修改 applied，stabled 等信息。 </li>
<li>上层应用可以直接调用 RawNode 提供的 Propose(data []byte) ，Step(m pb.Message) 等方法，RawNode 会将这些请求统一包装成 Message，通过 Raft 提供的 Step(m pb.Message) 输入信息。</li>
</ol>
<h4 id="HasReady"><a href="#HasReady" class="headerlink" title="HasReady()"></a>HasReady()</h4><p>RawNode 通过 HasReady() 来判断 Raft 模块是否已经有同步完成并且需要上层处理的信息，包括：</p>
<ul>
<li>是否有需要持久化的状态；</li>
<li>是否有需要持久化的条目；</li>
<li>是否有需要应用的快照；</li>
<li>是否有需要应用的条目；</li>
<li>是否有需要发送的 Msg</li>
</ul>
<p>其中，最后一点的 Msg，就是 Raft 模块中节点间相互发送的 Msg。也就是说，节点间发送的 Msg 是通过 RawNode 先发送给上层，然后上层在将其发送给对应节点的。</p>
<p>如果 HasReady() 返回 true，那么上层就会调用 Ready() 来获取具体要做的事情，和上述 HasReady() 的判断一一对应。该方法直接调用 rn.newReady() 生成一个 Ready() 结构体然后返回即可。</p>
<h4 id="Advance"><a href="#Advance" class="headerlink" title="Advance()"></a>Advance()</h4><p>当上层处理完 Ready 后，调用 Advance() 来推进整个状态机。Advance() 的实现就按照 Ready 结构体一点点更改 RawNode 的状态即可，包括：</p>
<ul>
<li>prevHardSt 变更；</li>
<li>stabled 指针变更；</li>
<li>applied 指针变更；</li>
<li>清空 rn.Raft.msgs；</li>
<li>丢弃被压缩的暂存日志；</li>
<li>清空 pendingSnapshot；</li>
</ul>
<h4 id="思考-总结"><a href="#思考-总结" class="headerlink" title="思考&amp;总结"></a>思考&amp;总结</h4><ol>
<li>RawNode 是 Raft 的封装，保存 Raft 的一部分状态</li>
</ol>
<h3 id="Project-2A-总结-思考"><a href="#Project-2A-总结-思考" class="headerlink" title="Project 2A  总结&amp;思考"></a>Project 2A  总结&amp;思考</h3><h4 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h4><blockquote>
<p>对于某个 Raft 变为 Candidate 提出选举，是当场给自己投一票 还是 同样构造一个 msg 发给自己处理？从 term 的角度思考。<br>    1. 假设发消息。可能导致当前 Raft 先收到其他 Raft 的投票请求，从而自己没有给自己投票。<br>    2. 因此当场给自己投一票。这样也减少了自己和自己的发消息多余操作。</p>
</blockquote>
<blockquote>
<p>如果当前的 Raft 就是自己本身，开始一个新的选举之后  term 要增加吗？<br>    增加。</p>
</blockquote>
<blockquote>
<p>如果超时，是先增加  term 还是先发送 MsgHup 消息？<br>    先增加 term。如果先发送消息，那么在消息队列中，这个消息前面的消息会认为这个 Raft 还是没有超时（实际上已经超时了）</p>
</blockquote>
<blockquote>
<p>先发心跳包等到响应再增加 Elapsed 还是 先增加？<br>    先增加。万一响应收不到了，Elapsed 还是要增加的。</p>
</blockquote>
<blockquote>
<p>Message 中 Commit 字段的作用？<br>    表示提交索引（commit index）。在 Raft 一致性算法中，每个节点都会维护一个提交索引。提交索引表示在该索引之前的所有日志条目都已经被安全地复制到了大多数节点，并且可以被应用到状态机中。换句话说，提交索引是已经达成共识并可以执行的日志条目的最高索引。</p>
</blockquote>
<blockquote>
<p>RaftLog 中 committed | applied | stabled 三个字段？<br>    committed：已知在多数节点上的稳定存储中的最高日志位置。<br>    applied：已经应用到状态机的最大 log 位置<br>    stabled： 已经被持久化存储的最大 log 位置。</p>
</blockquote>
<blockquote>
<p>持久化存储中到底要存储什么？<br>    1. “Save log entries to stable storage”（将日志条目保存到稳定存储）：在 Raft 中，每个节点会维护一个日志（log），其中包含按顺序记录的操作或状态变化。当节点接收到来自客户端的命令或其他节点的日志复制请求时，它将这些日志条目追加到自己的日志中。为了确保数据的持久性和可靠性，节点需要将这些日志条目保存到稳定存储介质（如磁盘）上，以便在节点重启或发生故障时能够恢复日志的状态。<br>    2. “Save hard state like the term, commit index, and vote to stable storage”（将任期、提交索引和投票信息等硬状态保存到稳定存储）：除了日志条目之外，Raft 还维护了一些重要的状态信息，称为硬状态。这些硬状态包括当前任期（term）、已提交的索引（commit index）和投票信息（如上一次投票的候选人ID等）。这些硬状态的变化需要被持久化保存，以确保在节点重启或发生故障时能够恢复到正确的状态。</p>
</blockquote>
<blockquote>
<p>MemoryStorage  中 ents[i] has raft log position i+snapshot.Metadata.Index 的含义？<br>    <code>ents[i]</code> 表示 Raft 日志中的第 <code>i</code> 个条目。该条目的 Raft 日志位置是通过 <code>i + snapshot.Metadata.Index</code> 来确定的。<br>    在 Raft 算法中，为了支持快照（snapshot）功能，可以将当前节点的状态和日志压缩成一个快照。快照包含了快照的元数据信息以及存储在快照中的状态和日志条目。<br>    在代码中的 <code>ents</code> 切片中，存储了一系列的日志条目。为了与快照中的日志条目对应起来，<code>ents[i]</code> 的 Raft 日志位置是通过 <code>i + snapshot.Metadata.Index</code> 计算得出的。<br>    具体来说，<code>snapshot.Metadata.Index</code> 表示快照元数据中的索引值，它指示了快照中第一个条目的索引。然后，对于 <code>ents</code> 切片中的第 <code>i</code> 个条目，其在 Raft 日志中的位置就是 <code>i + snapshot.Metadata.Index</code>。<br>    这样的计算方式可以确保在应用快照之后，<code>ents</code> 切片中的日志条目仍然与 Raft 日志中的对应位置保持一致。<br>    需要注意的是，<code>snapshot.Metadata.Index</code> 是快照元数据中的一个字段，用于表示快照中第一个条目的索引。在给出的代码中，<code>snapshot</code> 是一个 <code>Metadata</code> 类型的字段，可能是一个结构体或变量，用于存储快照的元数据信息。<br>    也就是说  0 号位置的 Index 就是 <code>snapshot.Metadata.Index</code></p>
</blockquote>
<blockquote>
<p>RaftLog 中的 entries  和 Storage 中的 ents 有什么区别？<br>    1. entries 是 从下标 1 开始作为有效记录；ents 是从下表 0 开始作为有效记录。<br>    2. .ents[0].Index 始终是有效的，用来作为基础索引</p>
</blockquote>
<blockquote>
<p>RaftLog.storage.Snapshot() 和 RaftLog.pendingSnapshot 中的区别<br>    一个永久快照，一个临时快照。</p>
</blockquote>
<blockquote>
<p>心跳 heatbeat 时间和选举 election 时间的关系<br>    1. heatbeat 只有 Leader 发送；election 时间是非 leader  需要维护的信息，以便即使开始一个选举。</p>
</blockquote>
<blockquote>
<p>收到陌生 Raft 的信息，该怎么处理？<br>    1. 可能是一个新的节点，需要添加到已有结构中。<br>    2. 什么情况下添加？<br>        1. 首先只有这个新的 Raft 发送消息时才能被旧 Raft 知道，但是陌生 Raft 的工作消息直接处理可能会出问题，所以应该使用 heatbeat 作为新 Raft 的识别消息（谁收到了这个消息谁添加节点）。那么：<br>        2. 选举过程：<br>            1. Candidate 收到 heatbeat：多一个投票人，不会导致选举失败 。<br>            2. 其他角色 收到 heatbeat：更不会影响选举。<br>        3. 工作过程：<br>            1. Leader 收到 heatbeat：多一个工作者，不会导致工作错误 。<br>            2. 其他角色 收到 heatbeat：更不会影响工作（因为不会给 这个 Raft 发送工作消息）。<br>    3. 总结：任何情况下，收到 新 Raft 的 heatbeat 时，可将其添加到当前 Raft 的记录中（最好同时向这个新 Raft 同步一下当前系统的情况）。</p>
</blockquote>
<p>sendAppendResponse 不需要 回复 —-嘛嘛嘛？？？？？？？</p>
<h4 id="总结一下-commmit-applied-stable-的修改时机"><a href="#总结一下-commmit-applied-stable-的修改时机" class="headerlink" title="总结一下 commmit|applied|stable 的修改时机"></a>总结一下 commmit|applied|stable 的修改时机</h4><p>&#x2F;&#x2F;	snapshot&#x2F;first…..applied….committed….stabled…..last<br>&#x2F;&#x2F;	——–|————————————————|<br>&#x2F;&#x2F;	                          log entries</p>
<h4 id="RaftLog-committed-修改时机总结"><a href="#RaftLog-committed-修改时机总结" class="headerlink" title="RaftLog.committed 修改时机总结"></a>RaftLog.committed 修改时机总结</h4><ol>
<li>在  newRaft() 中调用 newLog() 时被初始化为 storage 中 hardState 的 Commit</li>
<li>Leader 在 发送 MessageType_MsgAppend 时发送当前 commited</li>
<li>Raft 在收到 MessageType_MsgAppend 并更新 RaftLog.entries 之后，将 commited 置为以下两者的最小值<ol>
<li>Leader 的 committed： m.Commit</li>
<li>Leader 以为的 此 Raft 的 Committed：m.Index+uint64(len(m.Entries))</li>
</ol>
</li>
<li>Leader 在收到 AppendEntriesResponse 之后 将自己的 commited 置为 当前 Term 的Entry 被大多数 Peers 中 都 Match 的最小 Index。</li>
<li>Leader 在 发送 MessageType_MsgHeartbeat 时发送 min(r.RaftLog.committed, r.Prs[to].Match) （确保心跳消息中的 Commit 字段不会超过已经和目标j节点同步的日志索引，从而使得心跳消息不会推进 committed ）</li>
<li>Raft 收到 Lead 的  MessageType_MsgHeartbeat 之后，如果发现 m.Commit（Leader 认为的提交） &gt;&#x3D; r.RaftLog.committed （Raft 自认为的提交），说明当前 Raft 的 RaftLog.entries 中有一部分 Leader 认为还未提交（需要被覆盖）。修改 committed 值为<br> min(m.Commit, r.RaftLog.LastIndex())</li>
</ol>
<h4 id="RaftLog-applied-修改时机总结"><a href="#RaftLog-applied-修改时机总结" class="headerlink" title="RaftLog.applied 修改时机总结"></a>RaftLog.applied 修改时机总结</h4><ol>
<li>在  newRaft() 中调用 newLog() 时被初始化为 storage 中 的 ent[0].Index 或者 初始化为 0，表示初始没有被 applied 的 entry。</li>
<li>在 Advance() 中第一次修改。</li>
</ol>
<h4 id="RaftLog-stabled-修改时机总结"><a href="#RaftLog-stabled-修改时机总结" class="headerlink" title="RaftLog.stabled 修改时机总结"></a>RaftLog.stabled 修改时机总结</h4><ol>
<li>在  newRaft() 中调用 newLog() 时被初始化为 storage 中 ent 最后一个 entry 的 Index。</li>
<li>r.RaftLog.stabled &#x3D; m.Index</li>
<li>rn.Raft.RaftLog.stabled &#x3D; rd.Entries[len(rd.Entries)-1].Index</li>
</ol>
<h4 id="r-Prs-的-Match-Next"><a href="#r-Prs-的-Match-Next" class="headerlink" title="r.Prs 的 Match &amp; Next"></a>r.Prs 的 Match &amp; Next</h4><ol>
<li>收到 Propose 时 if lastIndex &#x3D;&#x3D; 0 Propose</li>
</ol>
<h2 id="Project-2B"><a href="#Project-2B" class="headerlink" title="Project 2B"></a>Project 2B</h2><h3 id="Project-2B-整体流程"><a href="#Project-2B-整体流程" class="headerlink" title="Project 2B 整体流程"></a>Project 2B 整体流程</h3><p>Project2B 实现了 rawNode 之上的上层应用，即真正开始多线程集群操作，引入了 peer 和 region 的概念。同时，除了实现上层的调用，Project2B 还需要通过调用 RaftStorage 中的接口真正实现写落盘。 store、peer、region 三者的关系如下：<br>![[Pasted image 20240420190155.png]]</p>
<ol>
<li>Store：每一个节点叫做一个 store，也就是一个节点上面只有一个 Store。代码里面叫 RaftStore，后面统一使用 RaftStore 代称。 </li>
<li>Peer：一个 RaftStore 里面会包含多个 peer，一个 RaftStore 里面的所有 peer 公用同一个底层存储，也就是多个 peer 公用同一个 badger 实例。 </li>
<li>Region：一个 Region 叫做一个 Raft group，即同属一个 raft 集群，一个 region 包含多个 peer，这些 peer 散落在不同的 RaftStore 上。</li>
</ol>
<p>这里将 Rawnode-Raft-RaftLog 统称为 raft 层，把要实现的部分称为 peer 层。peer 层首先接收来自 client 的 RaftCmdRequest，其中包含着不同的<code>命令请求</code>，接着它会把这些请求逐一以 entry 的形式传递给 raft 层，当然，这个 peer 应该是 Leader，不然 client 会找下一个 peer 继续试。raft 层收到条目后，会在集群内部进行同步，这就是 project2a 的内容。同步的过程中，peer 层会不时询问 raft 层有哪些已经同步好的 entry 可以拿来应用（执行）？哪些 entry 需要持久化？有没有快照需要应用？等等。三层的交互如下图所示：<br>![[Pasted image 20240421125735.png]]<br>此模块要完善两个文件，分别为 <code>peer_msg_handler.go</code> 和 <code>peer_storage.go</code></p>
<p><a target="_blank" rel="noopener" href="https://github.com/sakura-ysy/TinyKV-2022-doc/blob/main/doc/project2.md?spm=a2c6h.13046898.publish-article.80.37936ffauECnFr&file=project2.md">https://github.com/sakura-ysy/TinyKV-2022-doc/blob/main/doc/project2.md?spm=a2c6h.13046898.publish-article.80.37936ffauECnFr&amp;file=project2.md</a></p>
<h3 id="TODO-1"><a href="#TODO-1" class="headerlink" title="TODO"></a>TODO</h3><p>type peer struct 中为什么&#x2F;&#x2F; Instance of the Raft module<br>    是 RaftGroup *raft.RawNode<br>一个 region 包含多个 peer 怎么理解</p>
<h2 id="Project-2C"><a href="#Project-2C" class="headerlink" title="Project 2C"></a>Project 2C</h2><p>Project 2C 整体流程</p>
<h3 id="RawNode-中-hardState-和"><a href="#RawNode-中-hardState-和" class="headerlink" title="RawNode 中 hardState  和"></a>RawNode 中 hardState  和</h3><h1 id="Project-3"><a href="#Project-3" class="headerlink" title="Project 3"></a>Project 3</h1><p><a target="_blank" rel="noopener" href="https://www.inlighting.org/archives/tinykv-project3">https://www.inlighting.org/archives/tinykv-project3</a></p>
<h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><h2 id="日志输出"><a href="#日志输出" class="headerlink" title="日志输出"></a>日志输出</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">log.Infof(<span class="string">&quot;Raft init with config=&#123;len(peers)=%d&#125;, &quot;</span>+</span><br><span class="line">        <span class="string">&quot;peerid=%d, log commitid=%d, applied=%d, stabled=%d&quot;</span>,</span><br><span class="line">        <span class="built_in">len</span>(c.peers),</span><br><span class="line">        rsp.id, rsp.RaftLog.committed, rsp.RaftLog.applied, rsp.RaftLog.stabled)</span><br><span class="line">        </span><br><span class="line">log.Fatal(err)</span><br><span class="line"></span><br><span class="line">log.Infof(<span class="string">&quot;peerid = %d becomes leader&quot;</span>, r.id)</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="TODO-2"><a href="#TODO-2" class="headerlink" title="TODO"></a>TODO</h2><p>&#x2F;&#x2F; TODO 这里的 stabled 在 newlog 的时候赋值过一次，应该不会是 0 ，为什么会判断一次stabled<br>    if l.stabled &#x3D;&#x3D; 0 {<br>        return l.entries<br>        &#x2F;&#x2F; log.Infof(“stabled &#x3D; %d”, l.stabled)<br>    }<br> <br>&#x2F;&#x2F; TODO 什么时候 修改 committed </p>
<blockquote>
<p>sendAppend 时没有修改<br>handle AppendEntriesRespinse 时修改了。<br><a target="_blank" rel="noopener" href="https://github.com/LX-676655103/Tinykv-2021/blob/course/raft/log.go">https://github.com/LX-676655103/Tinykv-2021/blob/course/raft/log.go</a></p>
</blockquote>
<p>&#x2F;&#x2F; TODO 怎么处理 新 leader 中未 commit 的部分<br>？从当前的逻辑来看，只有 当前 term 也产生 log 时 才会顺便更新前面的log</p>
<p>&#x2F;&#x2F; TODO 第一次收到 Lead 的消息时，需要进怎么样的处理</p>
<p>&#x2F;&#x2F; TODO noop Entry 会发送吗，</p>
<p>&#x2F;&#x2F; TODO r.Prs[r.id].Match 是  handlePropose 时修改。</p>
<p>TODO  搞清楚  Next 和 Match 之间的关系。<br>TODO 快照的同步逻辑</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://github.com/LX-676655103/Tinykv-2021/blob/course/raft/raft.go#L967">https://github.com/LX-676655103/Tinykv-2021/blob/course/raft/raft.go#L967</a><br><a target="_blank" rel="noopener" href="https://github.com/sakura-ysy/TinyKV-2022-doc/">https://github.com/sakura-ysy/TinyKV-2022-doc/</a></p>
<p><a target="_blank" rel="noopener" href="https://chenyunong.com/2021/08/04/TinyKV-Project2/">https://chenyunong.com/2021/08/04/TinyKV-Project2/</a><br><a target="_blank" rel="noopener" href="https://www.inlighting.org/archives/tinykv-project2">https://www.inlighting.org/archives/tinykv-project2</a></p>

                        
                    </div>
                </div>
            </div>
            
                <footer class="kratos-post-meta-new">
                    <span class="pull-left">
                        <time datetime="2024-04-23T03:05:06.670Z" itemprop="datePublished">
                            <a><i class="fa fa-calendar"></i> 2024-04-23</a>
                        </time>
                        
                        
                            <!-- 当前仅支持valine/waline自带的统计功能 -->
                            
                        
                        
                            <!-- 当前仅支持waline自带的统计功能 -->
                            
                        
                    </span>
                    
                    
                        <span class="pull-right">
                            <a class="read-more" href="/2024/04/23/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/TinyKV/TinyKV%20%E9%A1%B9%E7%9B%AE%E6%97%A5%E5%BF%97/" title="留言">留言<i class="fa fa-chevron-circle-right"></i></a>
                        </span>
                    

                </footer>
            
        </article>
    

    
    
        <article class="kratos-hentry kratos-entry-border-new clearfix" itemscope itemtype="https://schema.org/Article">
            <div class="kratos-status">
                
                    <i class="fa fa-refresh"></i>
                
                <div class="kratos-status-inner">
                    <div class="kratos-status-content" itemprop="articleBody">
                        
                            <p>不行：<br>nohup docker compose up &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;<br>行：<br>docker compose up -d<br>121.48.161.86</p>
<p>插如新的字典信息：<br>INSERT INTO <code>File</code> (<code>filename</code>, <code>size</code>, <code>isSecret</code>, <code>fileType</code>, <code>accessGroupId</code>, <code>lineCount</code>) VALUES<br> (‘base01_<del>FFXXFF</del>.txt’, 25705231224, 0 , 0 , 1, 1000000000),<br> (‘base02_<del>FFXXFF</del>.txt’, 25705106232, 0 , 0 , 1, 1000000000),<br> (‘base03_<del>FFXXFF</del>.txt’, 25705041692, 0 , 0 , 1, 1000000000),<br> (‘base04_<del>FFXXFF</del>.txt’, 25704512508, 0 , 0 , 1, 1000000000),<br> (‘base05_<del>FFXXFF</del>.txt’, 25704626392, 0 , 0 , 1, 1000000000),<br> (‘base06_<del>FFXXFF</del>.txt’, 9911144907,   0 , 0 , 1, 385579419);</p>
<ol>
<li>关于剩余时间的添加：</li>
<li>已运行时间&#x2F;百分比，</li>
</ol>

                        
                    </div>
                </div>
            </div>
            
                <footer class="kratos-post-meta-new">
                    <span class="pull-left">
                        <time datetime="2024-04-23T03:05:06.668Z" itemprop="datePublished">
                            <a><i class="fa fa-calendar"></i> 2024-04-23</a>
                        </time>
                        
                        
                            <!-- 当前仅支持valine/waline自带的统计功能 -->
                            
                        
                        
                            <!-- 当前仅支持waline自带的统计功能 -->
                            
                        
                    </span>
                    
                    
                        <span class="pull-right">
                            <a class="read-more" href="/2024/04/23/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/MimaPJ/MMPJ%20%E6%97%A5%E5%BF%97/" title="留言">留言<i class="fa fa-chevron-circle-right"></i></a>
                        </span>
                    

                </footer>
            
        </article>
    

    
    
        <article class="kratos-hentry kratos-entry-border-new clearfix" itemscope itemtype="https://schema.org/Article">
            <div class="kratos-status">
                
                    <i class="fa fa-refresh"></i>
                
                <div class="kratos-status-inner">
                    <div class="kratos-status-content" itemprop="articleBody">
                        
                            <p>这里主要展示自己所参与过或者开发的项目，一些包含一些思考和总结。</p>
<h1 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h1><p>[[TinyKV 项目要求]]</p>

                        
                    </div>
                </div>
            </div>
            
                <footer class="kratos-post-meta-new">
                    <span class="pull-left">
                        <time datetime="2024-04-23T03:05:06.666Z" itemprop="datePublished">
                            <a><i class="fa fa-calendar"></i> 2024-04-23</a>
                        </time>
                        
                        
                            <!-- 当前仅支持valine/waline自带的统计功能 -->
                            
                        
                        
                            <!-- 当前仅支持waline自带的统计功能 -->
                            
                        
                    </span>
                    
                    
                        <span class="pull-right">
                            <a class="read-more" href="/2024/04/23/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/" title="留言">留言<i class="fa fa-chevron-circle-right"></i></a>
                        </span>
                    

                </footer>
            
        </article>
    

    
    
        <article class="kratos-hentry kratos-entry-border-new clearfix" itemscope itemtype="https://schema.org/Article">
            <div class="kratos-status">
                
                    <i class="fa fa-refresh"></i>
                
                <div class="kratos-status-inner">
                    <div class="kratos-status-content" itemprop="articleBody">
                        
                            <p>院校报名时间：2023年10月7日-一—2023年12月15日</p>
<p>省赛：2024年4月13日9:00-13:00（软件类）&#x2F;9:00-14:00（电子类)</p>
<p>国赛：2024年6月中旬第十五届蓝桥杯大赛软件赛知识点大纲</p>

                        
                    </div>
                </div>
            </div>
            
                <footer class="kratos-post-meta-new">
                    <span class="pull-left">
                        <time datetime="2024-04-23T03:05:06.659Z" itemprop="datePublished">
                            <a><i class="fa fa-calendar"></i> 2024-04-23</a>
                        </time>
                        
                        
                            <!-- 当前仅支持valine/waline自带的统计功能 -->
                            
                        
                        
                            <!-- 当前仅支持waline自带的统计功能 -->
                            
                        
                    </span>
                    
                    
                        <span class="pull-right">
                            <a class="read-more" href="/2024/04/23/%E8%B5%9B%E4%BA%8B%E6%B4%BB%E5%8A%A8/%E8%93%9D%E6%A1%A5%E6%9D%AF/" title="留言">留言<i class="fa fa-chevron-circle-right"></i></a>
                        </span>
                    

                </footer>
            
        </article>
    

    
    
        <article class="kratos-hentry kratos-entry-border-new clearfix" itemscope itemtype="https://schema.org/Article">
            <div class="kratos-status">
                
                    <i class="fa fa-refresh"></i>
                
                <div class="kratos-status-inner">
                    <div class="kratos-status-content" itemprop="articleBody">
                        
                            <p>6月开始，到12月</p>

                        
                    </div>
                </div>
            </div>
            
                <footer class="kratos-post-meta-new">
                    <span class="pull-left">
                        <time datetime="2024-04-23T03:05:06.658Z" itemprop="datePublished">
                            <a><i class="fa fa-calendar"></i> 2024-04-23</a>
                        </time>
                        
                        
                            <!-- 当前仅支持valine/waline自带的统计功能 -->
                            
                        
                        
                            <!-- 当前仅支持waline自带的统计功能 -->
                            
                        
                    </span>
                    
                    
                        <span class="pull-right">
                            <a class="read-more" href="/2024/04/23/%E8%B5%9B%E4%BA%8B%E6%B4%BB%E5%8A%A8/%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B/" title="留言">留言<i class="fa fa-chevron-circle-right"></i></a>
                        </span>
                    

                </footer>
            
        </article>
    

    
    
        <article class="kratos-hentry kratos-entry-border-new clearfix" itemscope itemtype="https://schema.org/Article">
            <div class="kratos-status">
                
                    <i class="fa fa-refresh"></i>
                
                <div class="kratos-status-inner">
                    <div class="kratos-status-content" itemprop="articleBody">
                        
                            <p>[[华为软件精英挑战赛]]<br>每年 三月份</p>
<p>[[Google Code Jam]]<br>已停办</p>
<p>[[ICPC 国际大学生程序设计竞赛]]<br>可以尝试，且大概五月多才开始，可以提前准备。到那时<br>本科入学五年内。但是，主要还是大学生</p>
<p>[[CCPC 中国大学生网络预选赛]]<br>研究生不能参加最终决赛。算了，但是可以参考题目。</p>
<p>[[蓝桥杯]]<br>可以 大概 4月份。报名 截至三月份</p>
<p>[[中兴捧月]]<br>4月初 报名</p>

                        
                    </div>
                </div>
            </div>
            
                <footer class="kratos-post-meta-new">
                    <span class="pull-left">
                        <time datetime="2024-04-23T03:05:06.658Z" itemprop="datePublished">
                            <a><i class="fa fa-calendar"></i> 2024-04-23</a>
                        </time>
                        
                        
                            <!-- 当前仅支持valine/waline自带的统计功能 -->
                            
                        
                        
                            <!-- 当前仅支持waline自带的统计功能 -->
                            
                        
                    </span>
                    
                    
                        <span class="pull-right">
                            <a class="read-more" href="/2024/04/23/%E8%B5%9B%E4%BA%8B%E6%B4%BB%E5%8A%A8/%E5%95%8A%20%E6%AF%94%E8%B5%9B%E6%B1%87%E6%80%BB/" title="留言">留言<i class="fa fa-chevron-circle-right"></i></a>
                        </span>
                    

                </footer>
            
        </article>
    



    <div class='text-center pagination'>
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
    </div>



    <div class="hidden">
        <!-- 加载文章阅读对应的统计功能，评论自带的那种 -->
        
    </div>



        

            </section>

        

                
            

<section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm">
    <!-- 文章和页面根据splitter来分割，没有的话就从头开始设置为sticky -->
    
        <div class="sticky-area">
    
    
                <aside id="krw-about" class="widget widget-kratos-about clearfix">
    <div class="photo-background"></div>
    <div class="photo-wrapper clearfix">
        <div class="photo-wrapper-tip text-center">
            <img class="about-photo" src="/images/avatar.webp" loading="lazy" decoding="auto" />
        </div>
    </div>
    <div class="textwidget">
        <p class="text-center">生于尘埃，溺于人海，死于理想的高台</p>
    </div>
    <div class="site-meta">
        <a class="meta-item" href="/archives/">
            <span class="title">
                文章
            </span>
            <span class="count">
                98
            </span>
        </a>
        <a class="meta-item" href="/categories/">
            <span class="title">
                分类
            </span>
            <span class="count">
                0
            </span>
        </a>
        <a class="meta-item" href="/tags/">
            <span class="title">
                标签
            </span>
            <span class="count">
                1
            </span>
        </a>
    </div>
</aside>
            
                

            
                
  <aside id="krw-tags" class="widget widget-kratos-tags clearfix">
    <h4 class="widget-title"><i class="fa fa-tags"></i>标签聚合</h4>
      <div class="tag-clouds">
        <a href="/tags/excalidraw/" style="font-size: 0.6em;">excalidraw</a>
      </div>
  </aside>

            
                
  <aside id="krw-posts" class="widget widget-kratos-posts">
  <h4 class="widget-title"><i class="fa fa-file"></i>最新文章</h4>
  <div class="tab-content">
      <ul class="list-group">
        
        
          
          
            <a class="list-group-item" href="/2024/04/23/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D/"><i class="fa  fa-book"></i> Englislearning</a>
            
          
        
          
          
            <a class="list-group-item" href="/2024/04/23/hello-world/"><i class="fa  fa-book"></i> Hello Worldaaaaaaa</a>
            
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
      </ul>
  </div>
  </aside>

            
    </div>
</section>
        
        </div>
    </div>
</div>
<footer>
    <div id="footer"  class="ap-lrc"  >
        <div class="container">
            <div class="row">
                <div class="col-md-6 col-md-offset-3 footer-list text-center">
                    <ul class="kratos-social-icons">
                        <!-- Keep for compatibility -->
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        <!-- New links -->
                        
                    </ul>
                    <ul class="kratos-copyright">
                        <div>
                            <li>&copy; 2024 心咖 版权所有.</li>
                            <li>本站已运行<span id="span_dt">Loading...</span></li>
                        </div>
                        <div>
                            <li>Theme <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a></li>
                            <li>Site built with&nbsp;<i class="fa fa-heart throb" style="color:#d43f57"></i>&nbsp;by dreamin.</li>
                        </div>
                        <div>
                            <li>Powered by <a href="https://hexo.io" target="_blank" rel="nofollow">Hexo</a></li>
                            <li>Hosted on <a href="https://github.io" target="_blank">Github Pages</a></li>
                        </div>
                        <div>
                            
                            
                        </div>
                    </ul>
                </div>
            </div>
        </div>
        <div class="kr-tool text-center">
            <div class="tool">
                
                    <div class="box search-box">
                        <a href="/search/">
                            <span class="fa fa-search"></span>
                        </a>
                    </div>
                
                
                    <div class="box theme-box" id="darkmode-switch">
                        <span class="fa fa-adjust"></span>
                    </div>
                
                
                
            </div>
            <div class="box gotop-box">
                <span class="fa fa-chevron-up"></span>
            </div>
        </div>
    </div>
</footer>
</div>
</div>

        <script defer src="/vendors/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>
<script defer src="/vendors/nprogress@0.2.0/nprogress.js"></script>
<script>
    if (!window.kr) {
        window.kr = {};
    }
    window.kr.notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));
    window.kr.siteRoot = "/";
</script>


    <script async src="/js/candy.min.js"></script>



    <script defer src="/vendors/aplayer@1.10.1/dist/APlayer.min.js"></script>
    
    <script defer src="/vendors/meting@2.0.1/dist/Meting.min.js"></script>
    <meting-js
        server="netease"
        type="playlist"
        id="3204190542"
        order="random"
        fixed="true"
    >
    </meting-js>



    <script defer src="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script defer src="/js/kratosr.min.js"></script>
<script defer src="/js/pjax.min.js"></script>



<!-- Extra support for third-party plguins  -->


    </body>
</html>