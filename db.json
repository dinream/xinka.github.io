{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"themes\\kratos-rebirth\\source\\css\\kr-color-dark.min.css","path":"css/kr-color-dark.min.css","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\css\\kratosr.min.css","path":"css/kratosr.min.css","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\css\\prismjs.min.css","path":"css/prismjs.min.css","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\images\\404.webp","path":"images/404.webp","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\images\\about.webp","path":"images/about.webp","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\images\\alipay.webp","path":"images/alipay.webp","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\images\\avatar.webp","path":"images/avatar.webp","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\images\\banner.webp","path":"images/banner.webp","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\images\\banner_dark.webp","path":"images/banner_dark.webp","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\images\\bg.webp","path":"images/bg.webp","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\images\\bg_dark.webp","path":"images/bg_dark.webp","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\images\\comment.webp","path":"images/comment.webp","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\images\\comment_dark.webp","path":"images/comment_dark.webp","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\images\\failure.ico","path":"images/failure.ico","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\images\\psr.webp","path":"images/psr.webp","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\images\\wechat.webp","path":"images/wechat.webp","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\js\\candy.min.js","path":"js/candy.min.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\js\\kr-dark.min.js","path":"js/kr-dark.min.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\js\\kratosr.min.js","path":"js/kratosr.min.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\js\\local-search.min.js","path":"js/local-search.min.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\js\\pjax.min.js","path":"js/pjax.min.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\js\\snow.min.js","path":"js/snow.min.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\maps\\candy.min.js.map","path":"maps/candy.min.js.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\maps\\kr-color-dark.min.css.map","path":"maps/kr-color-dark.min.css.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\maps\\kr-dark.min.js.map","path":"maps/kr-dark.min.js.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\maps\\kratosr.min.css.map","path":"maps/kratosr.min.css.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\maps\\kratosr.min.js.map","path":"maps/kratosr.min.js.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\maps\\light.min.css.map","path":"maps/light.min.css.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\maps\\local-search.min.js.map","path":"maps/local-search.min.js.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\maps\\night-blue.min.css.map","path":"maps/night-blue.min.css.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\maps\\night-bright.min.css.map","path":"maps/night-bright.min.css.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\maps\\night-eighties.min.css.map","path":"maps/night-eighties.min.css.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\maps\\night.min.css.map","path":"maps/night.min.css.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\maps\\pjax.min.js.map","path":"maps/pjax.min.js.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\maps\\prismjs.min.css.map","path":"maps/prismjs.min.css.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\maps\\snow.min.js.map","path":"maps/snow.min.js.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\css\\highlight\\light.min.css","path":"css/highlight/light.min.css","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\css\\highlight\\night-blue.min.css","path":"css/highlight/night-blue.min.css","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\css\\highlight\\night-bright.min.css","path":"css/highlight/night-bright.min.css","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\css\\highlight\\night-eighties.min.css","path":"css/highlight/night-eighties.min.css","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\css\\highlight\\night.min.css","path":"css/highlight/night.min.css","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\images\\thumb\\thumb_1.webp","path":"images/thumb/thumb_1.webp","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\images\\thumb\\thumb_10.webp","path":"images/thumb/thumb_10.webp","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\images\\thumb\\thumb_11.webp","path":"images/thumb/thumb_11.webp","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\images\\thumb\\thumb_12.webp","path":"images/thumb/thumb_12.webp","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\images\\thumb\\thumb_13.webp","path":"images/thumb/thumb_13.webp","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\images\\thumb\\thumb_14.webp","path":"images/thumb/thumb_14.webp","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\images\\thumb\\thumb_15.webp","path":"images/thumb/thumb_15.webp","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\images\\thumb\\thumb_16.webp","path":"images/thumb/thumb_16.webp","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\images\\thumb\\thumb_17.webp","path":"images/thumb/thumb_17.webp","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\images\\thumb\\thumb_18.webp","path":"images/thumb/thumb_18.webp","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\images\\thumb\\thumb_19.webp","path":"images/thumb/thumb_19.webp","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\images\\thumb\\thumb_20.webp","path":"images/thumb/thumb_20.webp","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\images\\thumb\\thumb_2.webp","path":"images/thumb/thumb_2.webp","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\images\\thumb\\thumb_3.webp","path":"images/thumb/thumb_3.webp","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\images\\thumb\\thumb_4.webp","path":"images/thumb/thumb_4.webp","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\images\\thumb\\thumb_5.webp","path":"images/thumb/thumb_5.webp","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\images\\thumb\\thumb_6.webp","path":"images/thumb/thumb_6.webp","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\images\\thumb\\thumb_7.webp","path":"images/thumb/thumb_7.webp","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\images\\thumb\\thumb_8.webp","path":"images/thumb/thumb_8.webp","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\images\\thumb\\thumb_9.webp","path":"images/thumb/thumb_9.webp","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\qrcode_js@1.0.0\\LICENSE","path":"vendors/qrcode_js@1.0.0/LICENSE","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\qrcode_js@1.0.0\\README.md","path":"vendors/qrcode_js@1.0.0/README.md","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\qrcode_js@1.0.0\\bower.json","path":"vendors/qrcode_js@1.0.0/bower.json","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\qrcode_js@1.0.0\\index-svg.html","path":"vendors/qrcode_js@1.0.0/index-svg.html","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\qrcode_js@1.0.0\\index.html","path":"vendors/qrcode_js@1.0.0/index.html","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\qrcode_js@1.0.0\\index.svg","path":"vendors/qrcode_js@1.0.0/index.svg","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\qrcode_js@1.0.0\\jquery.min.js","path":"vendors/qrcode_js@1.0.0/jquery.min.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\qrcode_js@1.0.0\\package.json","path":"vendors/qrcode_js@1.0.0/package.json","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\qrcode_js@1.0.0\\qrcode.js","path":"vendors/qrcode_js@1.0.0/qrcode.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\qrcode_js@1.0.0\\qrcode.min.js","path":"vendors/qrcode_js@1.0.0/qrcode.min.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\nprogress@0.2.0\\History.md","path":"vendors/nprogress@0.2.0/History.md","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\nprogress@0.2.0\\License.md","path":"vendors/nprogress@0.2.0/License.md","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\nprogress@0.2.0\\Notes.md","path":"vendors/nprogress@0.2.0/Notes.md","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\nprogress@0.2.0\\Readme.md","path":"vendors/nprogress@0.2.0/Readme.md","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\nprogress@0.2.0\\bower.json","path":"vendors/nprogress@0.2.0/bower.json","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\nprogress@0.2.0\\component.json","path":"vendors/nprogress@0.2.0/component.json","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\nprogress@0.2.0\\nprogress.css","path":"vendors/nprogress@0.2.0/nprogress.css","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\nprogress@0.2.0\\nprogress.js","path":"vendors/nprogress@0.2.0/nprogress.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\nprogress@0.2.0\\package.json","path":"vendors/nprogress@0.2.0/package.json","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\aplayer@1.10.1\\dist\\APlayer.min.css","path":"vendors/aplayer@1.10.1/dist/APlayer.min.css","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\aplayer@1.10.1\\dist\\APlayer.min.js","path":"vendors/aplayer@1.10.1/dist/APlayer.min.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\aplayer@1.10.1\\dist\\APlayer.min.css.map","path":"vendors/aplayer@1.10.1/dist/APlayer.min.css.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\aplayer@1.10.1\\dist\\APlayer.min.js.map","path":"vendors/aplayer@1.10.1/dist/APlayer.min.js.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\disqusjs@1.3.0\\dist\\disqus.js","path":"vendors/disqusjs@1.3.0/dist/disqus.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\disqusjs@1.3.0\\dist\\disqusjs.css","path":"vendors/disqusjs@1.3.0/dist/disqusjs.css","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\font-awesome@4.7.0\\css\\font-awesome.css","path":"vendors/font-awesome@4.7.0/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\font-awesome@4.7.0\\css\\font-awesome.css.map","path":"vendors/font-awesome@4.7.0/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\font-awesome@4.7.0\\css\\font-awesome.min.css","path":"vendors/font-awesome@4.7.0/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\font-awesome@4.7.0\\fonts\\FontAwesome.otf","path":"vendors/font-awesome@4.7.0/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\font-awesome@4.7.0\\fonts\\fontawesome-webfont.eot","path":"vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\font-awesome@4.7.0\\fonts\\fontawesome-webfont.svg","path":"vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\font-awesome@4.7.0\\fonts\\fontawesome-webfont.ttf","path":"vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\font-awesome@4.7.0\\fonts\\fontawesome-webfont.woff","path":"vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\font-awesome@4.7.0\\fonts\\fontawesome-webfont.woff2","path":"vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\gitalk@1.7.2\\dist\\gitalk-component.js","path":"vendors/gitalk@1.7.2/dist/gitalk-component.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\gitalk@1.7.2\\dist\\gitalk-component.js.map","path":"vendors/gitalk@1.7.2/dist/gitalk-component.js.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\gitalk@1.7.2\\dist\\gitalk.css","path":"vendors/gitalk@1.7.2/dist/gitalk.css","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\gitalk@1.7.2\\dist\\gitalk.css.map","path":"vendors/gitalk@1.7.2/dist/gitalk.css.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\gitalk@1.7.2\\dist\\gitalk.js","path":"vendors/gitalk@1.7.2/dist/gitalk.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\gitalk@1.7.2\\dist\\gitalk.js.map","path":"vendors/gitalk@1.7.2/dist/gitalk.js.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\gitalk@1.7.2\\dist\\gitalk.min.js","path":"vendors/gitalk@1.7.2/dist/gitalk.min.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\gitalk@1.7.2\\dist\\gitalk.min.js.map","path":"vendors/gitalk@1.7.2/dist/gitalk.min.js.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\gitment@0.0.3\\dist\\constants.js","path":"vendors/gitment@0.0.3/dist/constants.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\gitment@0.0.3\\dist\\constants.js.map","path":"vendors/gitment@0.0.3/dist/constants.js.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\gitment@0.0.3\\dist\\gitment.browser.js.map","path":"vendors/gitment@0.0.3/dist/gitment.browser.js.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\gitment@0.0.3\\dist\\gitment.browser.js","path":"vendors/gitment@0.0.3/dist/gitment.browser.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\gitment@0.0.3\\dist\\gitment.js.map","path":"vendors/gitment@0.0.3/dist/gitment.js.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\gitment@0.0.3\\dist\\gitment.js","path":"vendors/gitment@0.0.3/dist/gitment.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\gitment@0.0.3\\dist\\icons.js.map","path":"vendors/gitment@0.0.3/dist/icons.js.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\gitment@0.0.3\\dist\\utils.js","path":"vendors/gitment@0.0.3/dist/utils.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\gitment@0.0.3\\dist\\icons.js","path":"vendors/gitment@0.0.3/dist/icons.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\gitment@0.0.3\\dist\\utils.js.map","path":"vendors/gitment@0.0.3/dist/utils.js.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\layui.js","path":"vendors/layui-src@2.5.5/dist/layui.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\jquery@3.6.0\\dist\\jquery.js","path":"vendors/jquery@3.6.0/dist/jquery.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\layui.all.js","path":"vendors/layui-src@2.5.5/dist/layui.all.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\jquery@3.6.0\\dist\\jquery.min.js","path":"vendors/jquery@3.6.0/dist/jquery.min.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\jquery@3.6.0\\dist\\jquery.min.map","path":"vendors/jquery@3.6.0/dist/jquery.min.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\jquery@3.6.0\\dist\\jquery.slim.js","path":"vendors/jquery@3.6.0/dist/jquery.slim.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\jquery@3.6.0\\dist\\jquery.slim.min.js","path":"vendors/jquery@3.6.0/dist/jquery.slim.min.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\jquery@3.6.0\\dist\\jquery.slim.min.map","path":"vendors/jquery@3.6.0/dist/jquery.slim.min.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\mermaid@9.1.1\\dist\\mermaid.esm.min.mjs","path":"vendors/mermaid@9.1.1/dist/mermaid.esm.min.mjs","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\mermaid@9.1.1\\dist\\mermaid.esm.min.mjs.LICENSE.txt","path":"vendors/mermaid@9.1.1/dist/mermaid.esm.min.mjs.LICENSE.txt","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\mermaid@9.1.1\\dist\\mermaid.core.js","path":"vendors/mermaid@9.1.1/dist/mermaid.core.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\mermaid@9.1.1\\dist\\mermaid.core.js.map","path":"vendors/mermaid@9.1.1/dist/mermaid.core.js.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\mermaid@9.1.1\\dist\\mermaid.esm.min.mjs.map","path":"vendors/mermaid@9.1.1/dist/mermaid.esm.min.mjs.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\mermaid@9.1.1\\dist\\mermaid.js","path":"vendors/mermaid@9.1.1/dist/mermaid.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\mermaid@9.1.1\\dist\\mermaid.min.js","path":"vendors/mermaid@9.1.1/dist/mermaid.min.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\mermaid@9.1.1\\dist\\mermaid.js.map","path":"vendors/mermaid@9.1.1/dist/mermaid.js.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\mermaid@9.1.1\\dist\\mermaid.min.js.LICENSE.txt","path":"vendors/mermaid@9.1.1/dist/mermaid.min.js.LICENSE.txt","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\mermaid@9.1.1\\dist\\mermaid.min.js.map","path":"vendors/mermaid@9.1.1/dist/mermaid.min.js.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\nprogress@0.2.0\\test\\component.html","path":"vendors/nprogress@0.2.0/test/component.html","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\meting@2.0.1\\dist\\Meting.min.js","path":"vendors/meting@2.0.1/dist/Meting.min.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\nprogress@0.2.0\\test\\test.js","path":"vendors/nprogress@0.2.0/test/test.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\twikoo@1.5.11\\dist\\twikoo.all.min.js","path":"vendors/twikoo@1.5.11/dist/twikoo.all.min.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\twikoo@1.5.11\\dist\\twikoo.all.min.js.LICENSE.txt","path":"vendors/twikoo@1.5.11/dist/twikoo.all.min.js.LICENSE.txt","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\twikoo@1.5.11\\dist\\twikoo.min.js","path":"vendors/twikoo@1.5.11/dist/twikoo.min.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\valine@1.4.18\\dist\\Valine.Pure.min.js","path":"vendors/valine@1.4.18/dist/Valine.Pure.min.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\valine@1.4.18\\dist\\Valine.Pure.min.js.map","path":"vendors/valine@1.4.18/dist/Valine.Pure.min.js.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\valine@1.4.18\\dist\\Valine.min.js","path":"vendors/valine@1.4.18/dist/Valine.min.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\twikoo@1.5.11\\dist\\twikoo.min.js.LICENSE.txt","path":"vendors/twikoo@1.5.11/dist/twikoo.min.js.LICENSE.txt","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\valine@1.4.18\\dist\\Valine.min.js.map","path":"vendors/valine@1.4.18/dist/Valine.min.js.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\valine@1.4.18\\dist\\Valine.min.umd.js","path":"vendors/valine@1.4.18/dist/Valine.min.umd.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\valine@1.4.18\\dist\\Valine.min.umd.js.map","path":"vendors/valine@1.4.18/dist/Valine.min.umd.js.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\valine@1.4.18\\dist\\escape.min.js","path":"vendors/valine@1.4.18/dist/escape.min.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\valine@1.4.18\\dist\\detect.min.js","path":"vendors/valine@1.4.18/dist/detect.min.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@fancyapps\\fancybox@3.5.7\\dist\\jquery.fancybox.css","path":"vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@fancyapps\\fancybox@3.5.7\\dist\\jquery.fancybox.js","path":"vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@fancyapps\\fancybox@3.5.7\\dist\\jquery.fancybox.min.js","path":"vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\bootstrap@3.3.4\\dist\\fonts\\glyphicons-halflings-regular.eot","path":"vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.eot","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\bootstrap@3.3.4\\dist\\fonts\\glyphicons-halflings-regular.svg","path":"vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.svg","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@fancyapps\\fancybox@3.5.7\\dist\\jquery.fancybox.min.css","path":"vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\bootstrap@3.3.4\\dist\\fonts\\glyphicons-halflings-regular.ttf","path":"vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.ttf","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\bootstrap@3.3.4\\dist\\fonts\\glyphicons-halflings-regular.woff2","path":"vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.woff2","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\bootstrap@3.3.4\\dist\\fonts\\glyphicons-halflings-regular.woff","path":"vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.woff","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\api.cjs","path":"vendors/@waline/client@2.14.1/dist/api.cjs","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\api.d.cts","path":"vendors/@waline/client@2.14.1/dist/api.d.cts","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\api.d.mts","path":"vendors/@waline/client@2.14.1/dist/api.d.mts","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\api.cjs.map","path":"vendors/@waline/client@2.14.1/dist/api.cjs.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\api.d.ts","path":"vendors/@waline/client@2.14.1/dist/api.d.ts","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\api.mjs","path":"vendors/@waline/client@2.14.1/dist/api.mjs","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\api.mjs.map","path":"vendors/@waline/client@2.14.1/dist/api.mjs.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\comment.cjs.map","path":"vendors/@waline/client@2.14.1/dist/comment.cjs.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\comment.cjs","path":"vendors/@waline/client@2.14.1/dist/comment.cjs","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\comment.d.cts","path":"vendors/@waline/client@2.14.1/dist/comment.d.cts","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\comment.d.ts","path":"vendors/@waline/client@2.14.1/dist/comment.d.ts","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\comment.d.mts","path":"vendors/@waline/client@2.14.1/dist/comment.d.mts","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\comment.js","path":"vendors/@waline/client@2.14.1/dist/comment.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\comment.mjs","path":"vendors/@waline/client@2.14.1/dist/comment.mjs","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\comment.js.map","path":"vendors/@waline/client@2.14.1/dist/comment.js.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\comment.mjs.map","path":"vendors/@waline/client@2.14.1/dist/comment.mjs.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\component.mjs.map","path":"vendors/@waline/client@2.14.1/dist/component.mjs.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\component.mjs","path":"vendors/@waline/client@2.14.1/dist/component.mjs","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\legacy.umd.d.ts","path":"vendors/@waline/client@2.14.1/dist/legacy.umd.d.ts","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\legacy.umd.js.map","path":"vendors/@waline/client@2.14.1/dist/legacy.umd.js.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\legacy.umd.js","path":"vendors/@waline/client@2.14.1/dist/legacy.umd.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\pageview.cjs","path":"vendors/@waline/client@2.14.1/dist/pageview.cjs","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\pageview.d.cts","path":"vendors/@waline/client@2.14.1/dist/pageview.d.cts","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\pageview.cjs.map","path":"vendors/@waline/client@2.14.1/dist/pageview.cjs.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\pageview.d.ts","path":"vendors/@waline/client@2.14.1/dist/pageview.d.ts","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\pageview.js.map","path":"vendors/@waline/client@2.14.1/dist/pageview.js.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\pageview.d.mts","path":"vendors/@waline/client@2.14.1/dist/pageview.d.mts","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\pageview.js","path":"vendors/@waline/client@2.14.1/dist/pageview.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\pageview.mjs","path":"vendors/@waline/client@2.14.1/dist/pageview.mjs","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\pageview.mjs.map","path":"vendors/@waline/client@2.14.1/dist/pageview.mjs.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\shim.cjs.map","path":"vendors/@waline/client@2.14.1/dist/shim.cjs.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\shim.cjs","path":"vendors/@waline/client@2.14.1/dist/shim.cjs","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\shim.d.cts","path":"vendors/@waline/client@2.14.1/dist/shim.d.cts","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\shim.d.mts","path":"vendors/@waline/client@2.14.1/dist/shim.d.mts","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\shim.mjs.map","path":"vendors/@waline/client@2.14.1/dist/shim.mjs.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\shim.mjs","path":"vendors/@waline/client@2.14.1/dist/shim.mjs","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\waline-meta.css","path":"vendors/@waline/client@2.14.1/dist/waline-meta.css","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\waline-meta.css.map","path":"vendors/@waline/client@2.14.1/dist/waline-meta.css.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\waline.cjs.map","path":"vendors/@waline/client@2.14.1/dist/waline.cjs.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\waline.css","path":"vendors/@waline/client@2.14.1/dist/waline.css","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\waline.cjs","path":"vendors/@waline/client@2.14.1/dist/waline.cjs","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\waline.css.map","path":"vendors/@waline/client@2.14.1/dist/waline.css.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\waline.d.cts","path":"vendors/@waline/client@2.14.1/dist/waline.d.cts","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\waline.d.ts","path":"vendors/@waline/client@2.14.1/dist/waline.d.ts","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\waline.d.mts","path":"vendors/@waline/client@2.14.1/dist/waline.d.mts","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\waline.js","path":"vendors/@waline/client@2.14.1/dist/waline.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\waline.js.map","path":"vendors/@waline/client@2.14.1/dist/waline.js.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\waline.mjs.map","path":"vendors/@waline/client@2.14.1/dist/waline.mjs.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\bootstrap@3.3.4\\dist\\js\\bootstrap.js","path":"vendors/bootstrap@3.3.4/dist/js/bootstrap.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\waline.mjs","path":"vendors/@waline/client@2.14.1/dist/waline.mjs","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\bootstrap@3.3.4\\dist\\js\\bootstrap.min.js","path":"vendors/bootstrap@3.3.4/dist/js/bootstrap.min.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\bootstrap@3.3.4\\dist\\js\\npm.js","path":"vendors/bootstrap@3.3.4/dist/js/npm.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\bootstrap@3.3.4\\dist\\css\\bootstrap-theme.css.map","path":"vendors/bootstrap@3.3.4/dist/css/bootstrap-theme.css.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\bootstrap@3.3.4\\dist\\css\\bootstrap-theme.min.css","path":"vendors/bootstrap@3.3.4/dist/css/bootstrap-theme.min.css","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\bootstrap@3.3.4\\dist\\css\\bootstrap-theme.css","path":"vendors/bootstrap@3.3.4/dist/css/bootstrap-theme.css","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\bootstrap@3.3.4\\dist\\css\\bootstrap.css","path":"vendors/bootstrap@3.3.4/dist/css/bootstrap.css","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\bootstrap@3.3.4\\dist\\css\\bootstrap.css.map","path":"vendors/bootstrap@3.3.4/dist/css/bootstrap.css.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\gitment@0.0.3\\dist\\theme\\default.js","path":"vendors/gitment@0.0.3/dist/theme/default.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\gitment@0.0.3\\dist\\theme\\default.js.map","path":"vendors/gitment@0.0.3/dist/theme/default.js.map","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\bootstrap@3.3.4\\dist\\css\\bootstrap.min.css","path":"vendors/bootstrap@3.3.4/dist/css/bootstrap.min.css","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\layui.css","path":"vendors/layui-src@2.5.5/dist/css/layui.css","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\layui.mobile.css","path":"vendors/layui-src@2.5.5/dist/css/layui.mobile.css","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\font\\iconfont.svg","path":"vendors/layui-src@2.5.5/dist/font/iconfont.svg","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\font\\iconfont.eot","path":"vendors/layui-src@2.5.5/dist/font/iconfont.eot","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\font\\iconfont.woff","path":"vendors/layui-src@2.5.5/dist/font/iconfont.woff","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\font\\iconfont.woff2","path":"vendors/layui-src@2.5.5/dist/font/iconfont.woff2","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\font\\iconfont.ttf","path":"vendors/layui-src@2.5.5/dist/font/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\modules\\code.css","path":"vendors/layui-src@2.5.5/dist/css/modules/code.css","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\0.gif","path":"vendors/layui-src@2.5.5/dist/images/face/0.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\10.gif","path":"vendors/layui-src@2.5.5/dist/images/face/10.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\11.gif","path":"vendors/layui-src@2.5.5/dist/images/face/11.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\12.gif","path":"vendors/layui-src@2.5.5/dist/images/face/12.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\1.gif","path":"vendors/layui-src@2.5.5/dist/images/face/1.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\13.gif","path":"vendors/layui-src@2.5.5/dist/images/face/13.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\15.gif","path":"vendors/layui-src@2.5.5/dist/images/face/15.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\14.gif","path":"vendors/layui-src@2.5.5/dist/images/face/14.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\16.gif","path":"vendors/layui-src@2.5.5/dist/images/face/16.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\18.gif","path":"vendors/layui-src@2.5.5/dist/images/face/18.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\19.gif","path":"vendors/layui-src@2.5.5/dist/images/face/19.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\17.gif","path":"vendors/layui-src@2.5.5/dist/images/face/17.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\2.gif","path":"vendors/layui-src@2.5.5/dist/images/face/2.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\21.gif","path":"vendors/layui-src@2.5.5/dist/images/face/21.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\20.gif","path":"vendors/layui-src@2.5.5/dist/images/face/20.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\22.gif","path":"vendors/layui-src@2.5.5/dist/images/face/22.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\24.gif","path":"vendors/layui-src@2.5.5/dist/images/face/24.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\23.gif","path":"vendors/layui-src@2.5.5/dist/images/face/23.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\25.gif","path":"vendors/layui-src@2.5.5/dist/images/face/25.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\27.gif","path":"vendors/layui-src@2.5.5/dist/images/face/27.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\26.gif","path":"vendors/layui-src@2.5.5/dist/images/face/26.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\28.gif","path":"vendors/layui-src@2.5.5/dist/images/face/28.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\3.gif","path":"vendors/layui-src@2.5.5/dist/images/face/3.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\29.gif","path":"vendors/layui-src@2.5.5/dist/images/face/29.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\30.gif","path":"vendors/layui-src@2.5.5/dist/images/face/30.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\32.gif","path":"vendors/layui-src@2.5.5/dist/images/face/32.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\31.gif","path":"vendors/layui-src@2.5.5/dist/images/face/31.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\33.gif","path":"vendors/layui-src@2.5.5/dist/images/face/33.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\34.gif","path":"vendors/layui-src@2.5.5/dist/images/face/34.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\35.gif","path":"vendors/layui-src@2.5.5/dist/images/face/35.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\36.gif","path":"vendors/layui-src@2.5.5/dist/images/face/36.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\37.gif","path":"vendors/layui-src@2.5.5/dist/images/face/37.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\39.gif","path":"vendors/layui-src@2.5.5/dist/images/face/39.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\4.gif","path":"vendors/layui-src@2.5.5/dist/images/face/4.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\38.gif","path":"vendors/layui-src@2.5.5/dist/images/face/38.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\40.gif","path":"vendors/layui-src@2.5.5/dist/images/face/40.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\42.gif","path":"vendors/layui-src@2.5.5/dist/images/face/42.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\41.gif","path":"vendors/layui-src@2.5.5/dist/images/face/41.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\43.gif","path":"vendors/layui-src@2.5.5/dist/images/face/43.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\46.gif","path":"vendors/layui-src@2.5.5/dist/images/face/46.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\44.gif","path":"vendors/layui-src@2.5.5/dist/images/face/44.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\47.gif","path":"vendors/layui-src@2.5.5/dist/images/face/47.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\49.gif","path":"vendors/layui-src@2.5.5/dist/images/face/49.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\48.gif","path":"vendors/layui-src@2.5.5/dist/images/face/48.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\5.gif","path":"vendors/layui-src@2.5.5/dist/images/face/5.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\51.gif","path":"vendors/layui-src@2.5.5/dist/images/face/51.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\50.gif","path":"vendors/layui-src@2.5.5/dist/images/face/50.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\52.gif","path":"vendors/layui-src@2.5.5/dist/images/face/52.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\54.gif","path":"vendors/layui-src@2.5.5/dist/images/face/54.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\53.gif","path":"vendors/layui-src@2.5.5/dist/images/face/53.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\55.gif","path":"vendors/layui-src@2.5.5/dist/images/face/55.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\57.gif","path":"vendors/layui-src@2.5.5/dist/images/face/57.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\56.gif","path":"vendors/layui-src@2.5.5/dist/images/face/56.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\58.gif","path":"vendors/layui-src@2.5.5/dist/images/face/58.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\6.gif","path":"vendors/layui-src@2.5.5/dist/images/face/6.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\59.gif","path":"vendors/layui-src@2.5.5/dist/images/face/59.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\60.gif","path":"vendors/layui-src@2.5.5/dist/images/face/60.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\62.gif","path":"vendors/layui-src@2.5.5/dist/images/face/62.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\61.gif","path":"vendors/layui-src@2.5.5/dist/images/face/61.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\63.gif","path":"vendors/layui-src@2.5.5/dist/images/face/63.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\65.gif","path":"vendors/layui-src@2.5.5/dist/images/face/65.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\64.gif","path":"vendors/layui-src@2.5.5/dist/images/face/64.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\66.gif","path":"vendors/layui-src@2.5.5/dist/images/face/66.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\68.gif","path":"vendors/layui-src@2.5.5/dist/images/face/68.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\67.gif","path":"vendors/layui-src@2.5.5/dist/images/face/67.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\69.gif","path":"vendors/layui-src@2.5.5/dist/images/face/69.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\70.gif","path":"vendors/layui-src@2.5.5/dist/images/face/70.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\7.gif","path":"vendors/layui-src@2.5.5/dist/images/face/7.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\71.gif","path":"vendors/layui-src@2.5.5/dist/images/face/71.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\9.gif","path":"vendors/layui-src@2.5.5/dist/images/face/9.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\8.gif","path":"vendors/layui-src@2.5.5/dist/images/face/8.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\45.gif","path":"vendors/layui-src@2.5.5/dist/images/face/45.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\lay\\modules\\carousel.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/carousel.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\lay\\modules\\code.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/code.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\lay\\modules\\colorpicker.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/colorpicker.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\lay\\modules\\element.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/element.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\lay\\modules\\flow.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/flow.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\lay\\modules\\form.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/form.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\lay\\modules\\jquery.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/jquery.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\lay\\modules\\laydate.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/laydate.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\lay\\modules\\layedit.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/layedit.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\lay\\modules\\layer.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/layer.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\lay\\modules\\layim.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/layim.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\lay\\modules\\laypage.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/laypage.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\lay\\modules\\laytpl.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/laytpl.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\lay\\modules\\mobile.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/mobile.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\lay\\modules\\rate.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/rate.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\lay\\modules\\slider.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/slider.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\lay\\modules\\table.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/table.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\lay\\modules\\transfer.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/transfer.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\lay\\modules\\tree.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/tree.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\lay\\modules\\upload.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/upload.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\lay\\modules\\util.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/util.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\valine@1.4.18\\dist\\plugins\\emojis\\index.js","path":"vendors/valine@1.4.18/dist/plugins/emojis/index.js","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\valine@1.4.18\\dist\\plugins\\emojis\\light.json","path":"vendors/valine@1.4.18/dist/plugins/emojis/light.json","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\modules\\layim\\layim.css","path":"vendors/layui-src@2.5.5/dist/css/modules/layim/layim.css","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\modules\\layim\\html\\chatlog.html","path":"vendors/layui-src@2.5.5/dist/css/modules/layim/html/chatlog.html","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\modules\\layim\\html\\find.html","path":"vendors/layui-src@2.5.5/dist/css/modules/layim/html/find.html","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\modules\\layim\\html\\msgbox.html","path":"vendors/layui-src@2.5.5/dist/css/modules/layim/html/msgbox.html","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\modules\\layim\\html\\getmsg.json","path":"vendors/layui-src@2.5.5/dist/css/modules/layim/html/getmsg.json","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\modules\\layim\\mobile\\layim.css","path":"vendors/layui-src@2.5.5/dist/css/modules/layim/mobile/layim.css","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\modules\\layim\\skin\\1.jpg","path":"vendors/layui-src@2.5.5/dist/css/modules/layim/skin/1.jpg","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\modules\\layim\\skin\\2.jpg","path":"vendors/layui-src@2.5.5/dist/css/modules/layim/skin/2.jpg","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\modules\\layim\\skin\\3.jpg","path":"vendors/layui-src@2.5.5/dist/css/modules/layim/skin/3.jpg","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\modules\\layim\\skin\\4.jpg","path":"vendors/layui-src@2.5.5/dist/css/modules/layim/skin/4.jpg","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\modules\\layim\\skin\\5.jpg","path":"vendors/layui-src@2.5.5/dist/css/modules/layim/skin/5.jpg","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\modules\\layim\\skin\\logo.jpg","path":"vendors/layui-src@2.5.5/dist/css/modules/layim/skin/logo.jpg","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\modules\\laydate\\default\\laydate.css","path":"vendors/layui-src@2.5.5/dist/css/modules/laydate/default/laydate.css","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\modules\\layim\\voice\\default.mp3","path":"vendors/layui-src@2.5.5/dist/css/modules/layim/voice/default.mp3","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\modules\\layer\\default\\icon-ext.png","path":"vendors/layui-src@2.5.5/dist/css/modules/layer/default/icon-ext.png","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\modules\\layer\\default\\icon.png","path":"vendors/layui-src@2.5.5/dist/css/modules/layer/default/icon.png","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\modules\\layer\\default\\layer.css","path":"vendors/layui-src@2.5.5/dist/css/modules/layer/default/layer.css","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\modules\\layer\\default\\loading-0.gif","path":"vendors/layui-src@2.5.5/dist/css/modules/layer/default/loading-0.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\modules\\layer\\default\\loading-1.gif","path":"vendors/layui-src@2.5.5/dist/css/modules/layer/default/loading-1.gif","modified":1,"renderable":1},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\modules\\layer\\default\\loading-2.gif","path":"vendors/layui-src@2.5.5/dist/css/modules/layer/default/loading-2.gif","modified":1,"renderable":1}],"Cache":[{"_id":"source\\_posts\\TEMP：组会铺垫.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1710988590966},{"_id":"source\\_posts\\论文笔记\\基于深度学习的口令安全关键技术研究.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1709710011445},{"_id":"source\\_posts\\论文笔记\\未命名.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1713426871052},{"_id":"source\\_posts\\赛事活动\\Google Code Jam.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1713422253883},{"_id":"source\\_posts\\赛事活动\\TEMP.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1713423213271},{"_id":"source\\_posts\\TEMP：中铁.md","hash":"889af78640e257e0ae11979fb052ae63499b2ed2","modified":1713793408745},{"_id":"source\\_posts\\XinKa.md","hash":"aa96a2afb84725cd2ceed8a557be6bec645f8f28","modified":1711791051582},{"_id":"source\\_posts\\TEMP：论文思路.md","hash":"11d0f06d229da04cc4cebce877021cc3283ec249","modified":1713360828681},{"_id":"source\\_posts\\hello-world.md","hash":"a0e4165e0319a11b57a8b4af26c26c0fa981b11e","modified":1713791173945},{"_id":"source\\_posts\\test.md","hash":"38083351a2eb46ee73603595be124a255cec8f05","modified":1713790089761},{"_id":"source\\_posts\\随手记.md","hash":"02b31dd25987c6bd4cb0cd7a76ebb9bbcaf660b7","modified":1713683452824},{"_id":"source\\_posts\\人工智能\\AI 学习.md","hash":"95f49f3e68a520ddbd80ae9ad98123a344cb10cc","modified":1713359333012},{"_id":"source\\_posts\\人工智能\\数据集.md","hash":"619a930e77c811b6831d83f39ff1000a3621cbcb","modified":1710996079702},{"_id":"source\\_posts\\人工智能\\AI 最新进展.md","hash":"c5b7599b44dbed72b895150a80070ed5cd0e464c","modified":1713359502609},{"_id":"source\\_posts\\人工智能\\机器学习基本概念.md","hash":"0aecf2bc64645a2523a7156690829e73af8b622e","modified":1713406309845},{"_id":"source\\_posts\\人工智能\\深度学习基本概念.md","hash":"2a684a341d9998f134580e362e923bf8eab0ecf5","modified":1713269632773},{"_id":"source\\_posts\\工具教程\\工具教程.md","hash":"c8640190fc8d9e4e6beba6203fb76bd26859aea8","modified":1713443132967},{"_id":"source\\_posts\\工具教程\\教程：GPU 相关.md","hash":"2548a0ad0e462be065b8173ac9c42f6c0a9d7834","modified":1711071866089},{"_id":"source\\_posts\\工具教程\\教程：Hexo.md","hash":"6f2cf87b55f04e846171df8e3b82d86e4c0f38b6","modified":1713789619332},{"_id":"source\\_posts\\工具教程\\教程：Linux 指令.md","hash":"28b6b1c3aa0759b4051dd0551cfb1d7b0b85e2d7","modified":1713754969554},{"_id":"source\\_posts\\工具教程\\教程：MD 数学公式语法.md","hash":"bc05df868ef58e1ea850ae283e3ab6aae5673beb","modified":1712915387435},{"_id":"source\\_posts\\工具教程\\教程：Obsidian.md","hash":"6225c646fd92d80a0bec6283b70c5af0316922c5","modified":1708569304892},{"_id":"source\\_posts\\工具教程\\教程：Rime 输入法.md","hash":"fa790883c6112a97431d817948f851597b8c2957","modified":1709628436620},{"_id":"source\\_posts\\工具教程\\教程：Wandb.md","hash":"8f7f27d65b53eaf3a21ef71380292d531d727e49","modified":1711008053196},{"_id":"source\\_posts\\工具教程\\教程：git.md","hash":"c046fc995b389180fc298709cc38440c0bed9c08","modified":1713788180563},{"_id":"source\\_posts\\工具教程\\配置：VMWare.md","hash":"8d31604a14e6016e53bb6087a9baf2d339e73ab2","modified":1711773813895},{"_id":"source\\_posts\\工具教程\\配置：Linux 系统.md","hash":"bc3180bbb3dd0b19e5631ff2ee24a22bcc862f69","modified":1713766973210},{"_id":"source\\_posts\\工具教程\\配置：Windows.md","hash":"e3587dfb682212e5f3d71d01b80899c6ca8514d9","modified":1713362316026},{"_id":"source\\_posts\\工具教程\\配置：python 安装文档.md","hash":"0243b12b78a0e314966583630c32c43b34b5bd49","modified":1713773766717},{"_id":"source\\_posts\\日程安排\\IDL.md","hash":"3a6c516fcb2f8f337d1e2013b5a58b6debc9a6ac","modified":1709714665084},{"_id":"source\\_posts\\日程安排\\TEMP.md","hash":"2f08390d682b77ce57692fb6c33f0ddb283296ce","modified":1712627603586},{"_id":"source\\_posts\\日程安排\\今日计划.md","hash":"b73cf21eeef1417637055d57b100d89b936b11e3","modified":1711536250292},{"_id":"source\\_posts\\日程安排\\工作日志.md","hash":"1de19e6b27816b515ceadef3add0a8bccfdcf972","modified":1713272497004},{"_id":"source\\_posts\\日程安排\\草稿.md","hash":"c139bc600faf1a14698bd188cf8337ed00967eb9","modified":1710835327253},{"_id":"source\\_posts\\日程安排\\近期计划.md","hash":"8229e4cf22cbfc50ddad1951fb6d7945e73fadc1","modified":1708570194802},{"_id":"source\\_posts\\研究方向\\PASS_RF.md","hash":"efccc5000ed2df4c76ae9e7befba1a1bc1bfb360","modified":1713274941199},{"_id":"source\\_posts\\研究方向\\会议调研.md","hash":"aa06173b46f36509728c5b41afce3479f3cb7044","modified":1712285410354},{"_id":"source\\_posts\\研究方向\\方向调研.md","hash":"8f87053332d7bc763f3c6cda5547e83bf0aa3d2c","modified":1713404677390},{"_id":"source\\_posts\\研究方向\\方向：密码生成.md","hash":"a881b68078612e988f6c279bbd96935c8b183a9b","modified":1713441719583},{"_id":"source\\_posts\\研究方向\\检索工具.md","hash":"b9d9732b5443d54c54e0db136c76c7282e40c47a","modified":1709818789254},{"_id":"source\\_posts\\研究方向\\研究.md","hash":"349307fc053e17a54bba0c764ab6c9a02bbf9ac8","modified":1711000099530},{"_id":"source\\_posts\\毕业设计\\TEMP.md","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1713426954250},{"_id":"source\\_posts\\算法题目\\STL.md","hash":"bf896b25200e90605aba4d7dc15e914524312461","modified":1708933232653},{"_id":"source\\_posts\\算法题目\\问题分析.md","hash":"a91b34466893549bcad09ac5265921440af6e548","modified":1708930009166},{"_id":"source\\_posts\\英语学习\\英语单词.md","hash":"dddf64ab5648e37c383b13f942b86e4e2df8d330","modified":1713793513976},{"_id":"source\\_posts\\英语学习\\英语学习.md","hash":"ec8c6fcaa1eb50a7a6b8da0a4e26e99530516068","modified":1708508169329},{"_id":"source\\_posts\\英语学习\\英语短语.md","hash":"da5476cdb6233ecd1921abedb15ebedb815f0e1e","modified":1708514992023},{"_id":"source\\_posts\\课程作业\\6G技术发展报告.md","hash":"b4171b3529d8a7d56521d252cc31c1e1bbb080cc","modified":1710140402171},{"_id":"source\\_posts\\论文笔记\\AReview.md","hash":"4308960b48a3d5a5bd3b555f1593b4bfd4bcd7b8","modified":1709828042919},{"_id":"source\\_posts\\论文笔记\\GuessFuse.md","hash":"2001477e41ec78cd4597074b8a1c2df9ea652c93","modified":1713517727126},{"_id":"source\\_posts\\论文笔记\\Pass improved Transformer.md","hash":"ced53a10a0f04c6b9bcfab6c8e0657e9bb2999cd","modified":1712248931043},{"_id":"source\\_posts\\论文笔记\\PassBERT.md","hash":"491ebf91ae6eabbe7af3bf9fde5f27024c0c1d39","modified":1710480713017},{"_id":"source\\_posts\\论文笔记\\PassDiff.md","hash":"2600dd1ab07285e9132f3b627ee96297c97ac85d","modified":1712985916127},{"_id":"source\\_posts\\论文笔记\\PassGAN.md","hash":"22b99842b2a0e292c9e6a9b8025759a557bab0fc","modified":1710816694723},{"_id":"source\\_posts\\论文笔记\\PassGPT.md","hash":"8032cd1f483942ca60cb136440b4bc42b42203c2","modified":1711521108278},{"_id":"source\\_posts\\论文笔记\\Pass_RNN.md","hash":"1f9b4028e7c839794c2a1bb409bd2c5d3ab4a836","modified":1712737051231},{"_id":"source\\_posts\\论文笔记\\REDPACK.md","hash":"8b7ee52739136dba43f1269a11d9ed0d53a2df72","modified":1713273145835},{"_id":"source\\_posts\\论文笔记\\TEMP.md","hash":"3ba36131c110cc43a7c14f794f5dab0fc2ef75cb","modified":1713438332132},{"_id":"source\\_posts\\论文笔记\\明文口令生成模型.md","hash":"406d75fe6b61c48b043013033e228a7c0ef97bbe","modified":1709716457373},{"_id":"source\\_posts\\论文笔记\\语义密码模型和密码语言模式分析.md","hash":"8c7e6105da05a855c0926e1aba497f8558cd16a4","modified":1712825581317},{"_id":"source\\_posts\\论文笔记\\语法密码分析.md","hash":"aafb09a9311bcdfa864835350599070bc53e0795","modified":1709824827065},{"_id":"source\\_posts\\赛事活动\\CCPC 中国大学生网络预选赛.md","hash":"8e25e3ec7806fabda04a5b611a8bd0c171ca3071","modified":1713423473255},{"_id":"source\\_posts\\赛事活动\\ICPC 国际大学生程序设计竞赛.md","hash":"8f13053865ae244c7b457b981f43081bd1657a47","modified":1713423173369},{"_id":"source\\_posts\\赛事活动\\中兴捧月.md","hash":"fa554dd5a218558bb9b10f93e2904dd16c89e2f8","modified":1713426264577},{"_id":"source\\_posts\\赛事活动\\华为软件精英挑战赛.md","hash":"5669508d0d3597a91d9b05c976ddd078b8fc1f64","modified":1710643249347},{"_id":"source\\_posts\\赛事活动\\华为软件精英挑战赛——配置.md","hash":"0968ded745994c000ff0d405aeae317ae7ac5ec0","modified":1709802556284},{"_id":"source\\_posts\\赛事活动\\啊 比赛汇总.md","hash":"4e978a15b62298a97818fc83d9220f3fa7deb971","modified":1713426343471},{"_id":"source\\_posts\\赛事活动\\百度之星程序设计大赛.md","hash":"dfad6ef2851d47087d3572d47a70158ff01fb9bf","modified":1713425048639},{"_id":"source\\_posts\\赛事活动\\蓝桥杯.md","hash":"a15597b6d1cd61e624d822e974174c8e7d532207","modified":1713423984770},{"_id":"source\\_posts\\项目经历\\项目经历.md","hash":"303cf60ccf7ac523bd853408726b0aa37d1401e6","modified":1711792396484},{"_id":"source\\_posts\\人工智能\\大语言模型\\Finetuning.md","hash":"efc96d7c675dfea7d4c59ce3dad3eab8afa9bad2","modified":1710138325648},{"_id":"source\\_posts\\人工智能\\大语言模型\\GAI 的工作原理.md","hash":"49651fb953f4c06de9a61478309ad28551cd1eb3","modified":1709361047969},{"_id":"source\\_posts\\人工智能\\大语言模型\\GAI 的应用.md","hash":"ee50c60c168f03585f0127ddbbcbd4da53734fb0","modified":1713791327211},{"_id":"source\\_posts\\人工智能\\大语言模型\\Prompt.md","hash":"d412ec5dad0a76c07a23d9f826dbfd4ec6bc05ee","modified":1710247076080},{"_id":"source\\_posts\\人工智能\\大语言模型\\MoEs.md","hash":"b1f5cdabeea3b6d91283427afdf852039546221e","modified":1713360469235},{"_id":"source\\_posts\\人工智能\\大语言模型\\RAG 检索增强.md","hash":"1e4f6f3cd6170708e20dda20d387605e6c22e92c","modified":1710816250260},{"_id":"source\\_posts\\人工智能\\大语言模型\\RAG 项目.md","hash":"0e107c0e3e7f04237c3000ceafa68d273e27bd30","modified":1709519846601},{"_id":"source\\_posts\\人工智能\\大语言模型\\微信项目.md","hash":"ec15b1118e246536d3806e55fa065bcdccdd74d7","modified":1710856849793},{"_id":"source\\_posts\\人工智能\\大语言模型\\大模型入门.md","hash":"40f7183ef3934f752858119be430861c989fff60","modified":1710816353307},{"_id":"source\\_posts\\人工智能\\常见模型\\GAN.md","hash":"970bef6fc995a38b3b939dc78d16c34ce3d5912b","modified":1713268994386},{"_id":"source\\_posts\\人工智能\\常见模型\\Transformer.md","hash":"eae12a109980a83d8c98a9d98f283a199d46ffe2","modified":1709361081631},{"_id":"source\\_posts\\人工智能\\常见模型\\变分编码器.md","hash":"64bf6bb89cf5deaf634a19287a553f8a8be278ed","modified":1708839039653},{"_id":"source\\_posts\\人工智能\\常见模型\\扩散模型.md","hash":"64797b3808db28e9d4443e5d391181f0c33fade1","modified":1712985642477},{"_id":"source\\_posts\\人工智能\\常见模型\\生成模型.md","hash":"a43e3077fab9f8818e2ab2ffef0a1491387493e9","modified":1712913611234},{"_id":"source\\_posts\\工具教程\\attachments\\Pasted image 20240227143021.png","hash":"183d991298faba94f3b1db1a06fdbec570706b38","modified":1709015421370},{"_id":"source\\_posts\\工具教程\\attachments\\Pasted image 20240329091944.png","hash":"af9883639b56060336487e474d49281f9d535492","modified":1711675184751},{"_id":"source\\_posts\\工具教程\\attachments\\Pasted image 20240329092608.png","hash":"3aab11b079caa89d843869d4edbb34ca36bb90a5","modified":1711675568334},{"_id":"source\\_posts\\工具教程\\attachments\\Pasted image 20240329102239.png","hash":"6efe14d8bd4da88683692be60a0cc8a5ea71d10b","modified":1711678959097},{"_id":"source\\_posts\\工具教程\\attachments\\Pasted image 20240329141340.png","hash":"7533da5a6cc490df14bd962db2553937a136e26f","modified":1711692820133},{"_id":"source\\_posts\\工具教程\\attachments\\Pasted image 20240329141220.png","hash":"8181735175a56ea51549cc9257187f0ff9253fc8","modified":1711692740333},{"_id":"source\\_posts\\工具教程\\attachments\\Pasted image 20240329142241.png","hash":"1a7f202d24cbade379e11b2601d89b00a8b60515","modified":1711693361138},{"_id":"source\\_posts\\工具教程\\attachments\\Pasted image 20240329142244.png","hash":"1a7f202d24cbade379e11b2601d89b00a8b60515","modified":1711693364309},{"_id":"source\\_posts\\工具教程\\attachments\\Pasted image 20240329142326.png","hash":"c193b614f380aced3bd5c47cfcd7659bb8ff0ffb","modified":1711693406029},{"_id":"source\\_posts\\工具教程\\attachments\\Pasted image 20240329151945.png","hash":"4b4a4eda3564c35c2a61587c4cd84537314a12eb","modified":1711696785478},{"_id":"source\\_posts\\工具教程\\attachments\\Pasted image 20240329152009.png","hash":"99630af9ca3647ead1907b8cf2231cc8ba578136","modified":1711696809139},{"_id":"source\\_posts\\工具教程\\attachments\\Pasted image 20240406101500.png","hash":"935562aab7d6d89a4237846224d85018d4155659","modified":1712369700608},{"_id":"source\\_posts\\工具教程\\attachments\\Pasted image 20240406101639.png","hash":"935562aab7d6d89a4237846224d85018d4155659","modified":1712369799501},{"_id":"source\\_posts\\工具教程\\attachments\\v2-371af7e580072999e774d6d3182efb48_720w.webp","hash":"dffb818a279dc4aff4699091901e1c3c7d7a6a31","modified":1711675169547},{"_id":"source\\_posts\\编程语言\\GO_lang\\go语言学习记录.md","hash":"8948f682b6f22cd1a900d4186966d091cc16bf57","modified":1710663312437},{"_id":"source\\_posts\\编程语言\\GO_lang\\go 高级.md","hash":"bb5aed5fcc82fe8598c509e83303e236950fb0ae","modified":1713760793107},{"_id":"source\\_posts\\编程语言\\GO_lang\\go 基础.md","hash":"39bcecd0f18b32799093a45415cd14869843b1b1","modified":1712565919752},{"_id":"source\\_posts\\编程语言\\Python\\python 高级.md","hash":"98c6dcac2b2093fc1e2efef2253a702b477a63ea","modified":1711071963041},{"_id":"source\\_posts\\论文笔记\\attachments\\Pasted image 20240222172953.png","hash":"042190cd8d089ce233c9fe13fb19ca6434406634","modified":1708594193967},{"_id":"source\\_posts\\论文笔记\\attachments\\Pasted image 20240229164854.png","hash":"3de1801f406d04480bbd1c9a024c2388e1f0b4d3","modified":1709196534854},{"_id":"source\\_posts\\论文笔记\\attachments\\Pasted image 20240314160458.png","hash":"876d3e356b8b5d20bc5de93220460e00b66c9e70","modified":1710403498778},{"_id":"source\\_posts\\论文笔记\\attachments\\Pasted image 20240314161946.png","hash":"8011f10f9c52e0e8296d38284cf261d21d3e049b","modified":1710404386226},{"_id":"source\\_posts\\论文笔记\\attachments\\Pasted image 20240314203049.png","hash":"4be93aaf14b4bcd1da72229bbdba1b2be9eb9785","modified":1710419449109},{"_id":"source\\_posts\\论文笔记\\attachments\\Pasted image 20240409191656.png","hash":"8e6bf28a76bc2316a5a2bceff5f84bfccaf33be0","modified":1712661416046},{"_id":"source\\_posts\\论文笔记\\attachments\\Pasted image 20240416105310.png","hash":"68025af7194851898d46d13129b779b3da02eecb","modified":1713235990325},{"_id":"source\\_posts\\论文笔记\\attachments\\Pasted image 20240416105456.png","hash":"0620914bd5edca9212dc447dd753fb2d727ed9d3","modified":1713236096638},{"_id":"source\\_posts\\论文笔记\\复现\\复现：PassGPT.md","hash":"595a5b8f65faef54b61c6a9683a0d8b3e6755cdd","modified":1712058075622},{"_id":"source\\_posts\\赛事活动\\attachments\\Pasted image 20240307091119.png","hash":"63b55324ad07773af1132133a1b02738d80f1574","modified":1709773879542},{"_id":"source\\_posts\\赛事活动\\attachments\\Pasted image 20240308135154.png","hash":"0cf1923001594c5ba3ac3931557ed919425ee6a1","modified":1709877114387},{"_id":"source\\_posts\\项目经历\\TinyKV\\TinyKV 项目日志.md","hash":"12b67f467eb66c3d142d5cf0b069495abd9e0224","modified":1713753585960},{"_id":"source\\_posts\\项目经历\\TinyKV\\Raft 协议.md","hash":"68d8c0b63e300489b9de5d432f180b33505b19ce","modified":1710942698345},{"_id":"source\\_posts\\项目经历\\TinyKV\\TinyKV 项目要求.md","hash":"ee94491ddb25e970880579668516793a74bbd6b5","modified":1713688537176},{"_id":"source\\_posts\\项目经历\\MimaPJ\\MMPJ 日志.md","hash":"729a80a0ae8911d416426fc8927111be158eb0e7","modified":1712624881385},{"_id":"source\\_posts\\人工智能\\大语言模型\\attachments\\Pasted image 20240303155734.png","hash":"1cfca6cd502f98118b94fc3a7f581be5c1d2b889","modified":1709452654719},{"_id":"source\\_posts\\人工智能\\大语言模型\\attachments\\Pasted image 20240311104630.png","hash":"c55c6975e5d3e817bc9d7925f0c9da114b980b0f","modified":1710125190927},{"_id":"source\\_posts\\编程语言\\GO_lang\\grpc\\grpc_1.md","hash":"ad31d8136597c6902faf3a62a6160019238746d2","modified":1707281252910},{"_id":"source\\_posts\\人工智能\\常见模型\\attachments\\Pasted image 20240415162616.png","hash":"0d8765f0e0ebbde28e021168b38e4ccf138a2ce2","modified":1713169576218},{"_id":"source\\_posts\\人工智能\\常见模型\\attachments\\Pasted image 20240412152711.png","hash":"12787752a867db1f31489b7e6633c424332f082e","modified":1712906831404},{"_id":"source\\_posts\\论文笔记\\复现\\attachments\\Pasted image 20240322091910.png","hash":"f487655e84c36156b16eb30d366e18eb4f559f36","modified":1711070350707},{"_id":"source\\_posts\\论文笔记\\复现\\attachments\\Pasted image 20240322093300.png","hash":"42b203161beebd6c415297a25d92ad2421bb11e0","modified":1711071180561},{"_id":"source\\_posts\\论文笔记\\复现\\attachments\\Pasted image 20240322093250.png","hash":"e6e7c3229190cf2e1caa37ebf4e749211b0b0e48","modified":1711071170693},{"_id":"source\\_posts\\论文笔记\\复现\\attachments\\Pasted image 20240322093550.png","hash":"2ba74478b7163b05a5a47f4ec1156ff0877e3d16","modified":1711071350203},{"_id":"source\\_posts\\项目经历\\TinyKV\\attachments\\Pasted image 20240330205906.jpg","hash":"60cdfc66b03e5037ac8b064c8ff8523e493d0fc6","modified":1711803546542},{"_id":"source\\_posts\\项目经历\\TinyKV\\attachments\\Pasted image 20240420190155.png","hash":"7640784da51185b1d4ef6999ea4465e528fde400","modified":1713610915858},{"_id":"source\\_posts\\项目经历\\TinyKV\\attachments\\Pasted image 20240420200025.png","hash":"367a02df17954a038222b854054a08ea7b0aeeb4","modified":1713614425051},{"_id":"source\\_posts\\项目经历\\TinyKV\\attachments\\Pasted image 20240421125735.png","hash":"05f91c704ea608071ab898a31c0c2e82790afbfd","modified":1713675455193},{"_id":"source\\_posts\\认知社会\\caremyself.md","hash":"3e8a8ecc55358db4705c5c404e001aebe9425f32","modified":1713676677177},{"_id":"source\\_posts\\认知社会\\careall.md","hash":"dfdfbddf24e60b95206d6350c37745a43bc58462","modified":1712907290240},{"_id":"source\\_posts\\日程安排\\attachments\\Pasted image 20240319155428.png","hash":"cf3b36d99c75f865f9790bb92f7073f2370293f4","modified":1710834868621},{"_id":"source\\_posts\\论文笔记\\attachments\\Pasted image 20240319110425.png","hash":"e7b7340edb31ef207dbefdfaa8e5507c381aa8f6","modified":1710817465016},{"_id":"source\\_posts\\论文笔记\\attachments\\Pasted image 20240222173025.png","hash":"7a9daeef96acc187e56d813208bd8323931891cd","modified":1708594225576},{"_id":"source\\_posts\\论文笔记\\attachments\\Pasted image 20240319150308.png","hash":"f74e3c9459bc79661cd5bbefd34225629874897d","modified":1710831788478},{"_id":"source\\_posts\\论文笔记\\attachments\\Pasted image 20240327142047.png","hash":"6e695b7417caee02f7c7525a6763d6c1a616bcc1","modified":1711520447174},{"_id":"source\\_posts\\论文笔记\\attachments\\Pasted image 20240327111524.png","hash":"c7da8a2d6a178139be17f3a4d23f80841b6d5865","modified":1711509324615},{"_id":"source\\_posts\\论文笔记\\attachments\\Pasted image 20240327152521.png","hash":"014e13d4e3f5e81b9379de8445e64445b2e9ae92","modified":1711524321278},{"_id":"source\\_posts\\论文笔记\\attachments\\Pasted image 20240327105738.png","hash":"a29cdb95e990da966b2dfdc890ff95535fb0e524","modified":1711508258629},{"_id":"source\\_posts\\论文笔记\\attachments\\Pasted image 20240416111123.png","hash":"6b7b24591b434d88cde41fc59ee1c68f0bbf8e2c","modified":1713237083435},{"_id":"source\\_posts\\论文笔记\\attachments\\Pasted image 20240416171606.png","hash":"6fcac5d5aff3ac5ce5a5e76b791256fe9870d8e1","modified":1713258966498},{"_id":"source\\_posts\\论文笔记\\attachments\\Pasted image 20240416201514.png","hash":"3294cbf5dc1d2872b0cc71eae657b45cff33ae7a","modified":1713269714061},{"_id":"source\\_posts\\论文笔记\\attachments\\Pasted image 20240416202513.png","hash":"cd661a626b6ec5b01415fc76456e579cb33863fa","modified":1713270313749},{"_id":"source\\_posts\\论文笔记\\attachments\\Pasted image 20240416202512.png","hash":"cd661a626b6ec5b01415fc76456e579cb33863fa","modified":1713270312545},{"_id":"source\\_posts\\论文笔记\\attachments\\Pasted image 20240419155303.png","hash":"3d98eb3dc1eaa36f3e326709dd22398bbc4b736f","modified":1713513183813},{"_id":"source\\_posts\\生活琐事\\祝词.md","hash":"20fe94a62820f8f7f5c3696170c941e79c99f187","modified":1711448040676},{"_id":"source\\_posts\\项目经历\\TinyKV\\attachments\\Pasted image 20240320211742.png","hash":"093f2fa073562a128a1fb0af8fa47aa68848c698","modified":1710940662331},{"_id":"source\\_posts\\论文笔记\\复现\\attachments\\Pasted image 20240322102651.png","hash":"af5ac3ea9765c1aa8022dac26ab08eddbadcf6ba","modified":1711074411993},{"_id":"source\\_posts\\项目经历\\TinyKV\\attachments\\Pasted image 20240320211822.png","hash":"f76b80d2842dd15070e1e52caa2f42bd4be7baba","modified":1710940702120},{"_id":"source\\_posts\\项目经历\\TinyKV\\attachments\\Pasted image 20240320211748.png","hash":"093f2fa073562a128a1fb0af8fa47aa68848c698","modified":1710940668115},{"_id":"source\\_posts\\项目经历\\TinyKV\\attachments\\Pasted image 20240320211915.png","hash":"cace6b766ed0442b7a88a8997a5b688943d37ecb","modified":1710940755402},{"_id":"source\\_posts\\项目经历\\TinyKV\\attachments\\image2.png","hash":"0d4d58f67727f22ef364ebc5ef1a8a9d496244aa","modified":1711875941151},{"_id":"source\\_posts\\项目经历\\TinyKV\\attachments\\Pasted image 20240420205753.png","hash":"4de2e6e3908cccf189991aec5781b69bfbfdf691","modified":1713617873543},{"_id":"source\\_posts\\论文笔记\\attachments\\Pasted image 20240416143214.png","hash":"a94860b3fb9eaf760a43c808b65e2e45e178f48d","modified":1713249134319},{"_id":"source\\_posts\\论文笔记\\attachments\\Pasted image 20240416155902.png","hash":"9a1cc7eedf3510ec6f422a1b72e142dba9d1d8f1","modified":1713254342630},{"_id":"source\\_posts\\论文笔记\\attachments\\Pasted image 20240416194910.png","hash":"1462a94b8512367ae53057165ed268c98242ff42","modified":1713268150033},{"_id":"source\\_posts\\论文笔记\\attachments\\Pasted image 20240416202030.png","hash":"a13f2d68690f8438fbf9378352331fa88e179abe","modified":1713270030193},{"_id":"source\\_posts\\论文笔记\\attachments\\Pasted image 20240416202041.png","hash":"a13f2d68690f8438fbf9378352331fa88e179abe","modified":1713270041754},{"_id":"source\\_posts\\论文笔记\\attachments\\Pasted image 20240418173804.png","hash":"92774e0d7aad424d4a2fa3d0b35205317e98b3fc","modified":1713433084102},{"_id":"source\\_posts\\论文笔记\\attachments\\Pasted image 20240418211929.png","hash":"3beeb4cbb96c010dd421b7c20fbcb2370ca9a633","modified":1713446369694},{"_id":"source\\_posts\\论文笔记\\attachments\\Pasted image 20240418173807.png","hash":"92774e0d7aad424d4a2fa3d0b35205317e98b3fc","modified":1713433087927},{"_id":"source\\_posts\\论文笔记\\attachments\\Pasted image 20240419170602.png","hash":"12079c24081810880f44095e7334b7b529025917","modified":1713517562405},{"_id":"source\\_posts\\论文笔记\\attachments\\Pasted image 20240419170332.png","hash":"6ee97babcf65a3f8638f10e994c3bcb305496417","modified":1713517412319},{"_id":"source\\_posts\\赛事活动\\attachments\\Pasted image 20240418154011.png","hash":"28985f530b0bb3b72937581bc4e641b41d46fc0d","modified":1713426012000},{"_id":"source\\_posts\\赛事活动\\attachments\\Y[Y%]@RY36}%AGFAHROTPCN.png","hash":"7426c77649ac129f3e8308956263c8c17897c2e2","modified":1709807433237},{"_id":"source\\_posts\\赛事活动\\attachments\\Pasted image 20240309134153.png","hash":"957dd80fc219c7e828390a0c79ac59d4b01bb5b5","modified":1709962913683},{"_id":"source\\_posts\\人工智能\\大语言模型\\attachments\\Pasted image 20240303130455.png","hash":"28296be0a553da31cb9ee6c04491cdd3c52a2504","modified":1709442295353},{"_id":"source\\_posts\\人工智能\\大语言模型\\attachments\\Pasted image 20240302135631.png","hash":"f983dd34ace5dcec76aebcded76fef3e73280e17","modified":1709358991699},{"_id":"source\\_posts\\人工智能\\大语言模型\\attachments\\Pasted image 20240303183026.png","hash":"2e28663f9d7b4b86addcd9a6c640db2e72ded797","modified":1709461826380},{"_id":"source\\_posts\\人工智能\\大语言模型\\attachments\\Pasted image 20240310201128.png","hash":"1001c49b65fb9d08b81d07ddb53f9ce13b136372","modified":1710072688709},{"_id":"source\\_posts\\论文笔记\\attachments\\Pasted image 20240305201324.png","hash":"31ff618dc55e09f9a0b0ec8400cc315f3945505b","modified":1709640804494},{"_id":"source\\_posts\\论文笔记\\attachments\\Pasted image 20240418204958.png","hash":"a5a5ab16a4c342ae836295c655b3b2b0beb620cd","modified":1713444598142},{"_id":"source\\_posts\\论文笔记\\复现\\attachments\\Pasted image 20240322011742.png","hash":"9979798217f102bee231c919694db01d442c83dc","modified":1711041462715},{"_id":"source\\_posts\\研究方向\\attachments\\Pasted image 20240307212248.png","hash":"5e379d599b0a1b3355e3ad88755c1423fed961f5","modified":1709817768238},{"_id":"source\\_posts\\论文笔记\\attachments\\Pasted image 20240419165944.png","hash":"1cdc2d63996887b7b8e56cbfab9de7c81a7b9baf","modified":1713517184647},{"_id":"source\\_posts\\人工智能\\大语言模型\\attachments\\Pasted image 20240303174734.png","hash":"82ed5a0d42ac02132551984422ffb2c6c050d9ff","modified":1709459254470},{"_id":"source\\_posts\\论文笔记\\attachments\\Pasted image 20240305093437.png","hash":"1a142892f8ca70834c6570806f1642e67bbcf086","modified":1709602477779},{"_id":"source\\_posts\\论文笔记\\attachments\\Pasted image 20240419151949.png","hash":"a38cae2a16e666dbd0517500a068466165e67291","modified":1713511189100},{"_id":"themes\\kratos-rebirth\\.gitignore","hash":"42d134511aca5e3712b57229770e1005a8b68a31","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\.npmignore","hash":"c33752bc1711668ead4e649355c51d6410dff608","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\Kratos-Rebirth-Manual.md","hash":"e400244898a10821e1421d948fbd6e386a2b537b","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\LICENSE","hash":"31a3d460bb3c7d98845187c716a30db81c44b615","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\_config.yml","hash":"00bafc45bff6ee461f6652dc1e0c0ce79d69011c","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\package.json","hash":"5fd0535d4cf0b2b9f6d1dc2e0b29fbc78ba8b1b1","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\ReadMe.md","hash":"226fe826a596132a9a288f19f7df5f6d093de1ac","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\.github\\dependabot.yml","hash":"89c16d0b45677ff20b86b655e3bfc7f1e675b2d4","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\gulpfile.js","hash":"ee5ebfd16459eda0bf9f82f5760b49cdf8cbb41c","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\.demo\\_config.kratos-rebirth.yml","hash":"42d1339dc7553285793834d5f098c2014375a8a9","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\scripts\\additional-pages.js","hash":"b99cdd8fa23d0519403abefc595f031ebaace59a","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\languages\\zh-CN.yml","hash":"f253d94bc5171ef6e00d0511c3f4db26d3441781","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\scripts\\canonical.js","hash":"80ac473fa2794ddb95bca4f921d7ee34872933ed","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\scripts\\cdn-optimize-helpers.js","hash":"b0865dc553d3b757757b5a0471d5bcef6fd5be41","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\scripts\\search.js","hash":"fb892991e53a272db74ec5f3d3ab26e728c8ee06","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\scripts\\comments.js","hash":"b6deff86498b80c97e15b0a47eb66220455817a3","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\scripts\\check-update.js","hash":"fcadb1499a85d427d5b80fc6c64eab61ca999925","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\scripts\\friends.js","hash":"4c7dfca9d47c508934d7d27a56f8037a761da7ff","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\scripts\\genconfig.js","hash":"41e8da155a1cc418e05f3f9312568f0b3b9bd128","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\scripts\\tag-widgets.js","hash":"78d14c05c6205762f73ad3df420d9c6e78b9cd4e","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\layout\\category.ejs","hash":"5677b70953e6a33038a0e03eaa06e45c10ec7d73","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\layout\\archive.ejs","hash":"6fa81f4b699cd741cc29c01c1582f83bf96d68a5","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\layout\\page.ejs","hash":"5aac8f921e4bd5256b78494579dd7b5bf7cf04e8","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\layout\\layout.ejs","hash":"ea86e5b8f64957145ff52f5e2660e62ff92e0b05","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\layout\\index.ejs","hash":"e8343115da69f29d0c8cd820f32280372b8bb3a0","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\layout\\post.ejs","hash":"1c6ab2012390c7d0de206f76ac5c93287976c776","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\.github\\ISSUE_TEMPLATE\\bug_report.yml","hash":"b07412f7926bd6bc9a2d327ce9c7ae67e548ba66","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\.github\\workflows\\auto-release.yml","hash":"bb8f12db86ed191d831ef4036afeb047a41dce85","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\layout\\tag.ejs","hash":"5677b70953e6a33038a0e03eaa06e45c10ec7d73","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\.github\\ISSUE_TEMPLATE\\feature_request.yml","hash":"7200fed1dfaaaa4d54f9c61fe1239f0ee040a6c0","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\.github\\workflows\\build-demo.yml","hash":"a9db5770d0840e4d3072c1de70505be07339b7f5","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\.github\\workflows\\build-test.yml","hash":"47e843a2c76a84720e059665cce259a8d40453f0","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\scripts\\lib\\cdn.js","hash":"4d408c31df9605ac9d45a3cea53fcd1ab70178df","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\layout\\_comments\\disqusjs.ejs","hash":"703b125ce33489c9be62a2c6ccfc913af9d0ca05","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\layout\\_comments\\gitalk.ejs","hash":"a7dd0402150a31345ff11a946e64e4632add231a","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\layout\\_comments\\gitment.ejs","hash":"7366111beed060f528e6ab6a1e907444d61519f5","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\layout\\_comments\\twikoo.ejs","hash":"7d0ac9d25737c75ab1236dd54c22d0a8c61f288e","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\layout\\_comments\\livere.ejs","hash":"9f8998afe3ed7431c571fa20a40595364b2b7490","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\layout\\_comments\\valine.ejs","hash":"209c463bc047bac75b9ebe45e8cf87f6255a6368","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\layout\\_comments\\disqus.ejs","hash":"38a80a494e861be233b145675696ad9699aeeba0","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\layout\\_comments\\waline.ejs","hash":"58223eb81e7a43c565f05c6364dbafb500c9341a","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\layout\\_pages\\tags.ejs","hash":"70b9ce41a0e149e60788ac6d16864fea5b3311e3","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\layout\\_pages\\search-page.ejs","hash":"3dc81379363c8ad0bedf8489a3e6200841ff2c79","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\layout\\_plugins\\mermaid.ejs","hash":"5fcfeb3d566c17f915631638fdc98f511dd70a74","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\layout\\_partial\\after-footer.ejs","hash":"845436f26d99727db15ee61641545d9b059ab3a5","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\layout\\_pages\\404.ejs","hash":"b29697cfdbbf641c8efdff7d0273a4883e678f42","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\layout\\_pages\\categories.ejs","hash":"39a1c79de03dbc8295c9da59cebec15ae30dd632","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\layout\\_partial\\footer.ejs","hash":"81d7a752efa37681134924b41b67c2718f3fb24a","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\layout\\_partial\\head.ejs","hash":"4fa031008ae00c8c41013ce7b0eacfd052b36f2f","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\layout\\_partial\\header.ejs","hash":"5a0c9e8d4e20bc0cc3cd397843ab4315ed9845c5","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\layout\\_widget\\tagcloud.ejs","hash":"223730bfe007f26d5279cb66f1da9222c7d64c62","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\layout\\_widget\\about.ejs","hash":"25cde6dff270c41ff9bb37242e3e6aa6b85761a4","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\layout\\_widget\\posts.ejs","hash":"43461f2e3cb32b9092dcd9a977098ff8be6a3f68","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\layout\\_tools\\player.ejs","hash":"af36d7c6cb593af243f5342028bb337364e9afaf","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\layout\\_partial\\sidebar.ejs","hash":"46b53d4131e1fce463054b5c4399cbd6ddd2f0fd","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\layout\\_widget\\toc.ejs","hash":"a2c8f900369ada4dfa9793ac496a5eafc38502a9","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\layout\\_widget\\category.ejs","hash":"1f24ccfd175fabc83c7ea81f3412e78e65b8f3ab","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\src\\js\\candy.js","hash":"95b61e65d186b3a8571198557b150420c337be4b","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\layout\\_tools\\share.ejs","hash":"3f7369fc6344965f12315e5214aa9eee3fe8b5f1","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\src\\js\\kr-dark.js","hash":"ae92359b7c023f78707c8065e337f478fa8f7c9a","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\src\\js\\pjax.js","hash":"eb7faea4766e78898006de756363c0dfdead610e","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\src\\js\\snow.js","hash":"293a7690f41f83ac367ec019c728efdb1330e598","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\src\\js\\local-search.js","hash":"fe79206f66b0f1bd5279e7356127bdbe31f3540a","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\src\\scss\\kratosr.scss","hash":"74e8629f5bfe2a243c7a3b40cdad04deb7e43037","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\src\\scss\\kr-color-dark.scss","hash":"2459be4f923caa5398858593af325db0dfb65eac","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\src\\js\\kratosr.js","hash":"3599d62423959cd49bad3b054ed8c47cf780ef4a","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\css\\kr-color-dark.min.css","hash":"e34eae2e3742c82c1d02fe60194e7a53e2311120","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\css\\kratosr.min.css","hash":"29e869837e0048ee2c1c18bb0aecabf134f64738","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\css\\prismjs.min.css","hash":"6f2def0d76387c908324f38f845516c7f2d559d7","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\images\\avatar.webp","hash":"3ed6e4e1e08e9c2700aa149d1f9e068fb02947cd","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\images\\alipay.webp","hash":"01fa6151d2122f0470ee6f38ac8e4ced6c81912e","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\images\\about.webp","hash":"ca0fb739ab4426e7895742c1d8d52df1e14468e8","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\images\\banner.webp","hash":"7c5093243bfd581a633ba8a905e2d379cfa78c00","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\images\\404.webp","hash":"d2e2bd5cc2627a2b04d5e449a67949a2605ae13e","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\images\\comment_dark.webp","hash":"7756b5a69f2a85a2d1c4251e3055bfa0218aa385","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\images\\failure.ico","hash":"5eec5c163400d8ece74286da49130da1ead3f6f6","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\js\\candy.min.js","hash":"7f17a90d71223ebccd1e7446236a8f820ea812ac","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\images\\bg.webp","hash":"f232b442b64eaa90f45a48ff04d8e7d352caf212","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\images\\bg_dark.webp","hash":"f232b442b64eaa90f45a48ff04d8e7d352caf212","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\images\\comment.webp","hash":"7756b5a69f2a85a2d1c4251e3055bfa0218aa385","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\js\\kr-dark.min.js","hash":"8ff673018b5688e47f89fe461e30bf30abb81c6e","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\js\\kratosr.min.js","hash":"7569d604a7ebb178f4d07e0e8a7f276e082541ba","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\js\\local-search.min.js","hash":"8ed9ec22fa7a835c9f5f6e96b8368ae912e9afd0","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\js\\pjax.min.js","hash":"d01942adc7832b2705b96494261896d392977680","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\js\\snow.min.js","hash":"91356fb104c7f178f4972e4e709c69cea5d14633","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\maps\\candy.min.js.map","hash":"505411543a8c7fdee9d81891e7ae69d2552bb480","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\maps\\kr-dark.min.js.map","hash":"5cffc40b5bfa266ec05798f0fca9ba050eb461f4","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\maps\\kr-color-dark.min.css.map","hash":"ed26a486d8a0005e86a17c61efa9aaf2f5dc8cd9","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\maps\\kratosr.min.js.map","hash":"e5114f2211110385cca10ff22596354e650785d3","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\maps\\light.min.css.map","hash":"525abe619bc422b08fde586dbba5c835aa084c59","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\maps\\local-search.min.js.map","hash":"b982889304a495d435e2da32ebfe33846e986bf9","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\maps\\night-blue.min.css.map","hash":"ec0859ab631cb8a9afdfeef883daf3420606afcc","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\maps\\pjax.min.js.map","hash":"ad5ef0c6a3076450aa6e51f3503f40f6e3ebf5e2","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\maps\\night-bright.min.css.map","hash":"2e06a59b8ec11b0c4a4806d23e0dae9802c41c12","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\maps\\prismjs.min.css.map","hash":"3c7bf5a131ccfa521c4d277fdbcdeb88258ccc87","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\maps\\snow.min.js.map","hash":"ca2b8edf152fe02ffb75c130111531ede230f594","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\src\\scss\\kr-color\\base.scss","hash":"24c697283e2c8f2385ea1ee8d4cbb3e1cd68ea20","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\src\\scss\\kr-color\\default.scss","hash":"bd0d7444a9f6865986f4d30e783495981f11efb9","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\css\\highlight\\light.min.css","hash":"0c2ee23e4f7a443f90b65905e72f1fca3a89137d","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\css\\highlight\\night-blue.min.css","hash":"5f298f7125dcf08fed56d393a65b027c447a4c67","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\css\\highlight\\night-bright.min.css","hash":"a2bbbb95cb63124d0f5bc9c351bcf31455b8ecf8","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\css\\highlight\\night-eighties.min.css","hash":"eafd77c47ada4f8120d683a66cf486426b260205","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\css\\highlight\\night.min.css","hash":"379e2f99b3b92a710a241f5770ca43237a74238e","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\images\\wechat.webp","hash":"06f3997bf554768c04cb588198c7b3d68c21b8e9","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\images\\psr.webp","hash":"bf457bf84bca767bac1bd2b960d91c53ba3fbdee","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\maps\\night-eighties.min.css.map","hash":"55c13f2e4cd0e7e3d2b9b91133d4c49e77942a43","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\images\\thumb\\thumb_1.webp","hash":"a818f050112ceb75e3a60dc1673a10783b254595","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\src\\scss\\highlight\\style.scss","hash":"aca64b080abf33dceb24920bca56cca2dc42949e","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\images\\thumb\\thumb_11.webp","hash":"08d8d91e2b01768842abb47cd48a0f07d22d070c","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\maps\\night.min.css.map","hash":"20c8105676d6fb8a82a61ca87c7f9e9881ca9d38","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\images\\thumb\\thumb_10.webp","hash":"4983eeca7886bbe7c09b0c79f4774302fdfa1315","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\images\\thumb\\thumb_12.webp","hash":"b6b8e1281f9146925e45e937cb4d5b28bcabe957","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\images\\thumb\\thumb_15.webp","hash":"8629f2a7d3b0192549f809e6b7479159af0222da","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\images\\banner_dark.webp","hash":"5589986444825e2b75c369d419ff736d3a396bac","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\images\\thumb\\thumb_14.webp","hash":"f9300e2b45c1f061ec8cc21527142dafc558a9e6","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\images\\thumb\\thumb_17.webp","hash":"b5a036ec234a23c820a89d1c640b1f2e8dd3dfa4","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\images\\thumb\\thumb_13.webp","hash":"c4c9050637f4ffa3cb7d782f59dadc993ac3a6de","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\images\\thumb\\thumb_16.webp","hash":"61714ccffd55d6fa74cf94bcdd5a464da04ce891","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\images\\thumb\\thumb_19.webp","hash":"15e0cd0cbe5c7166915a4b68680681beccc2afef","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\images\\thumb\\thumb_18.webp","hash":"5bc78b9d6cb0a0cf6daa3a35b93e575777a49ddd","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\images\\thumb\\thumb_20.webp","hash":"4ab961d94a0d3abbefc7f6d9188a889ec2225e7a","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\images\\thumb\\thumb_2.webp","hash":"1bcf7461c2b9408b8a893013fa425eb46701faf6","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\images\\thumb\\thumb_5.webp","hash":"ba384ada1c2a17b67036addd68ffa1f604ab5a41","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\images\\thumb\\thumb_4.webp","hash":"1d0f136590632e7ba31f5510d24891ba443f1f33","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\images\\thumb\\thumb_3.webp","hash":"3faffd2575e0751526249c5c56a2a5045a21363b","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\images\\thumb\\thumb_6.webp","hash":"c2d8b68971dacd111566526f64d94932f5c6f076","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\qrcode_js@1.0.0\\README.md","hash":"1a8e6fb255a22f8233dff9815ab8790bada84b3d","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\qrcode_js@1.0.0\\LICENSE","hash":"7041717dd3a7d35354f94321b666e11977c7610e","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\qrcode_js@1.0.0\\bower.json","hash":"99449e46555b0ba514eca8246f1621048db97aa5","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\qrcode_js@1.0.0\\index.html","hash":"7314a123d8a9acbd51321d4f538ba4b36b0673b5","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\qrcode_js@1.0.0\\index-svg.html","hash":"3c856315a2467efcd00b278c570fbc7897021d98","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\qrcode_js@1.0.0\\index.svg","hash":"15730a03273bba608180e8b182453ae393b3c3e0","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\qrcode_js@1.0.0\\qrcode.min.js","hash":"2d06c1f823f34c19981c6ae0b0eb0f5861c5e14b","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\qrcode_js@1.0.0\\package.json","hash":"b77af52b956e89bd76c6bf75cc33f0eca47c0bf4","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\qrcode_js@1.0.0\\qrcode.js","hash":"8fa3048613aab15c7f7edc3ac74a84e90375126d","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\nprogress@0.2.0\\History.md","hash":"38f837f30c75bed4b8990b36fdf540fe3c63ccd3","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\nprogress@0.2.0\\License.md","hash":"bc3e61d337e51c177534c644c20f190148d7905e","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\nprogress@0.2.0\\Readme.md","hash":"63959b38ef0747eadd6f731b48d7aded7edc227b","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\nprogress@0.2.0\\Notes.md","hash":"e7b5de6240b6918cbdccc708a06e4b20555966c1","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\nprogress@0.2.0\\nprogress.css","hash":"17ca817a091da9dcf5fe0f2f1e1f2eea60a33149","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\nprogress@0.2.0\\bower.json","hash":"55980d38b6f24ec91f44579bcd38c667986368c5","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\nprogress@0.2.0\\component.json","hash":"ecbc4792d8583f73050dd4d918fea8073a7ded60","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\nprogress@0.2.0\\nprogress.js","hash":"a7e1146d2021c42e68b599dc8bcc69d44fc31df3","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\nprogress@0.2.0\\package.json","hash":"574122118ffc8d4705e58806a13612553bc41588","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\images\\thumb\\thumb_9.webp","hash":"bca69e7d56982b43c52e9ffa17c8d5bb268834d8","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\src\\scss\\highlight\\theme\\night-blue.scss","hash":"e174fc14362d931c12032d41eecc39e8ab7eb452","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\src\\scss\\highlight\\theme\\night-bright.scss","hash":"22b764e26356b43dc5e04dac923f62349f7ac0b5","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\src\\scss\\highlight\\theme\\night.scss","hash":"dbbd50f45908214efc2bfb820b92756e07838a50","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\src\\scss\\highlight\\theme\\light.scss","hash":"d7262b8d0d66734102e4276811dcc10b2c0ae02a","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\aplayer@1.10.1\\dist\\APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\src\\scss\\highlight\\theme\\night-eighties.scss","hash":"891f792df1e7a82cd60a2436cc65e7030e9492e8","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\aplayer@1.10.1\\dist\\APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\aplayer@1.10.1\\dist\\APlayer.min.css.map","hash":"c59d2bc9472922cf6ef9a99e052dbee6cc7e6b36","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\disqusjs@1.3.0\\dist\\disqus.js","hash":"b79249dfb619836cfd1251cb3c3d5c603bc55e61","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\disqusjs@1.3.0\\dist\\disqusjs.css","hash":"0d8ae5946142b17f9a75683c7649cf73d6fdbe17","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\font-awesome@4.7.0\\css\\font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\font-awesome@4.7.0\\css\\font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\font-awesome@4.7.0\\css\\font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\gitalk@1.7.2\\dist\\gitalk.css","hash":"61d71cb30f5f34cbb1f2b5bc469784d6cb908c22","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\gitalk@1.7.2\\dist\\gitalk.css.map","hash":"9dda04c29af8da6ac13a507beefea6fce4d7032e","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\gitment@0.0.3\\dist\\constants.js","hash":"08f6c79bf52239cbdd457bc0a94df395f578ee07","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\gitment@0.0.3\\dist\\constants.js.map","hash":"6b7b473ef4bba09ea572b3baaac73c122372439e","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\gitment@0.0.3\\dist\\gitment.js.map","hash":"2cb4d20d09b110268e0ea8c199f72501aa2d66e8","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\gitment@0.0.3\\dist\\gitment.js","hash":"df37d9fe8c1a0a1fb2883e5bcb93f880bb2bbf2e","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\gitment@0.0.3\\dist\\icons.js.map","hash":"5604e4382d787a9a1976359d92bb9827f11c2c2b","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\gitment@0.0.3\\dist\\utils.js","hash":"df76ada59b1cf94a7ea1d44c56a6624d248b4228","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\gitment@0.0.3\\dist\\icons.js","hash":"d303f91799600aa8c7f5f5bb18c652fafac4359d","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\gitment@0.0.3\\dist\\utils.js.map","hash":"6f99a8c2269c938d4422f3a244a8086f89800890","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\layui.js","hash":"be7bcdcb4eb932f3e700e63584661f19b4139739","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\mermaid@9.1.1\\dist\\mermaid.esm.min.mjs.LICENSE.txt","hash":"38165332beeccd3551309f85addb2354f2d18676","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\mermaid@9.1.1\\dist\\mermaid.min.js.LICENSE.txt","hash":"38165332beeccd3551309f85addb2354f2d18676","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\nprogress@0.2.0\\test\\component.html","hash":"5965cc7f9bb812ada1ffcd6abec39124c20a4ef8","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\meting@2.0.1\\dist\\Meting.min.js","hash":"f2b3d20b8bd64ccd031c64628f2b1323078ae324","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\nprogress@0.2.0\\test\\test.js","hash":"5c795debb89ec7d35ba1ec1e8ccbab0a7a353d78","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\twikoo@1.5.11\\dist\\twikoo.all.min.js.LICENSE.txt","hash":"c00fe261d987618ec25243062c089a6982d4480c","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\twikoo@1.5.11\\dist\\twikoo.min.js.LICENSE.txt","hash":"c00fe261d987618ec25243062c089a6982d4480c","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\valine@1.4.18\\dist\\escape.min.js","hash":"4f91bb0e3a71ce6421b303c6c32bb3fb3e751192","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\valine@1.4.18\\dist\\detect.min.js","hash":"596d6dcbe379f78a2ec655188d7bfa7182848e03","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@fancyapps\\fancybox@3.5.7\\dist\\jquery.fancybox.css","hash":"e43435fb9eaa918f5b8e35c9e110124b8bd13751","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\bootstrap@3.3.4\\dist\\fonts\\glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@fancyapps\\fancybox@3.5.7\\dist\\jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\bootstrap@3.3.4\\dist\\fonts\\glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\bootstrap@3.3.4\\dist\\fonts\\glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\bootstrap@3.3.4\\dist\\fonts\\glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\api.cjs","hash":"2da315666c52a2a0205da342f3fc7808834d0231","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\api.d.cts","hash":"c1cafa6064ccb6851580d9f11600124c060db78b","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\api.d.mts","hash":"c1cafa6064ccb6851580d9f11600124c060db78b","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\api.cjs.map","hash":"555cf9adc857430a799507a250f6ae8cf4454268","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\api.d.ts","hash":"c1cafa6064ccb6851580d9f11600124c060db78b","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\api.mjs","hash":"208a0b855cf31a54c2130f0aaa0bc7fb3ff766a4","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\api.mjs.map","hash":"4a590871076e07d59664a0fda40d037a6d2f2344","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\comment.cjs.map","hash":"1d162b21f3b9b513036b53ed45950f7c35e6e0f5","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\comment.cjs","hash":"48777cf6661b69f54cebc970896a4b7528add2ad","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\comment.d.ts","hash":"376c612b7771eec314f855e69e82523d4f7f922f","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\comment.d.cts","hash":"376c612b7771eec314f855e69e82523d4f7f922f","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\comment.d.mts","hash":"376c612b7771eec314f855e69e82523d4f7f922f","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\comment.js","hash":"a3e6d8ccf4e6ba2251487e83b79b580153d2b515","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\comment.mjs","hash":"d6b7d79d2b213888f829e7b44ff312aae3cd2378","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\comment.js.map","hash":"ab28febbf60a2979a8baca97c958a05c2555fbd4","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\comment.mjs.map","hash":"efdc8c853f806168f32b4433a19bda6f62c3f5bf","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\component.mjs","hash":"395fabdd03cb56bc0757b14a06a70470dbe0259e","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\legacy.umd.d.ts","hash":"b957f75fde95eb046a31ce075d6e311a2d7450d0","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\pageview.d.cts","hash":"4b3fad71d77ead2ad05e4dfe9e0906a4e025a233","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\pageview.cjs","hash":"ff6d9246e7b256eae10aa8c0d35f3b201b1ac8b7","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\pageview.cjs.map","hash":"d29ca67cfab54c0ff984438d47060aee70e6fa15","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\pageview.d.ts","hash":"4b3fad71d77ead2ad05e4dfe9e0906a4e025a233","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\pageview.js.map","hash":"dfa4f18a6ed4dec6232ae770ac66d30158e45b27","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\pageview.d.mts","hash":"4b3fad71d77ead2ad05e4dfe9e0906a4e025a233","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\pageview.js","hash":"ceea6a5a7b83c99ea92cf338ed05f5803ce9a943","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\pageview.mjs","hash":"4dc75845f6c827a0c1c8d6a92e7a0602bd03f2a1","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\pageview.mjs.map","hash":"67ae874c2c6fdcbe3ba5ad7f3895a52b518f4924","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\shim.cjs","hash":"1fad1bb7c23bd023d34bafd94c7f3fb937222766","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\shim.d.cts","hash":"92c855188103bc5d5bbbaaf5346a57346e241e5c","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\shim.d.mts","hash":"92c855188103bc5d5bbbaaf5346a57346e241e5c","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\shim.mjs","hash":"0c7689080af2d07976a56ea09ec75f8a360e9663","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\waline-meta.css","hash":"4c5e417fb615505112fa87eb466eda52e8a90ec0","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\waline-meta.css.map","hash":"f3796986f06b46a16a17995b9642922c3d029764","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\waline.css","hash":"6722bd03953e1f8c48c3e01b5776a68e5f901928","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\waline.css.map","hash":"14c2e889034c99033dbac74a4bdbba9e53801a3d","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\waline.d.cts","hash":"92c855188103bc5d5bbbaaf5346a57346e241e5c","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\waline.d.ts","hash":"92c855188103bc5d5bbbaaf5346a57346e241e5c","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\waline.d.mts","hash":"92c855188103bc5d5bbbaaf5346a57346e241e5c","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\bootstrap@3.3.4\\dist\\js\\bootstrap.min.js","hash":"27947c0c0fa837da9bdfdfc36f649c25f54bd1c0","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\bootstrap@3.3.4\\dist\\js\\npm.js","hash":"e2b7590d6ec1fdac66b01fdf66ae0879f53b1262","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\bootstrap@3.3.4\\dist\\css\\bootstrap-theme.min.css","hash":"fc6b4268fbd57ad95d2b41a1d4d6866f222fbdb2","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\bootstrap@3.3.4\\dist\\css\\bootstrap-theme.css.map","hash":"ccb7ff3435bb5cff1fe9643fc0ac8cdde2dcd177","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\bootstrap@3.3.4\\dist\\css\\bootstrap-theme.css","hash":"a22e254bf086bf442a09344afe0e6cf188f5a1d5","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\gitment@0.0.3\\dist\\theme\\default.js","hash":"449e59ac4b6b9c66384ee123e1523b5392d684a5","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\gitment@0.0.3\\dist\\theme\\default.js.map","hash":"0b7317800be0ea17fa142c7bb26f7e8158b54447","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\layui.mobile.css","hash":"f15da6c149002dd57ea25b8346534c8161c86e3c","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\font\\iconfont.woff","hash":"6133b92b4e5c3866675b2656ceae14606fa01eb0","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\font\\iconfont.eot","hash":"de1bec30d0ef87af6ab83ab6a269c3c59bc83124","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\font\\iconfont.woff2","hash":"c9b04ae5b10f88f8bc7c48840164f468ee7b10b0","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\modules\\code.css","hash":"d7adeb3ada7c3c069aa6d098f953e0a87cfb49ef","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\font\\iconfont.ttf","hash":"5d2b8777c623bb6e96577cee675489d0299ffa1f","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\0.gif","hash":"87db440c06299666a8a1f407a6008c5bf6d70817","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\10.gif","hash":"04fe5b26b7e2c980d12ad7157a4ce908c2a74f14","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\11.gif","hash":"170c2e16dd383e26d9d68406eb217dbf191ea14e","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\12.gif","hash":"f5da3f33448e67537e3df8ff63b010247b06841c","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\1.gif","hash":"e6da9a45ecb8c766a8f7c2362ccf2976d20d17a9","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\13.gif","hash":"0afcb6c47cb53fa4a8467d7d7bf00ec464df2f8e","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\15.gif","hash":"a0f216d0aaaeec369109e4b581eacd4e83e5ccb6","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\16.gif","hash":"54db2506b93b76c58174177245dcc6ef3fd0591f","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\14.gif","hash":"1af45520e97328498b1a281b6955df5029fc9679","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\18.gif","hash":"eeee84a351d6e84d291b0c27e5d70014a3a2748d","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\19.gif","hash":"620b2afa4c36cbfdd09c57807d8a662a5267ea51","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\17.gif","hash":"0b88c01b477d4ca98eb99a665c0ab8738551aeec","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\2.gif","hash":"43b3ca892341431f697e1326aa693c1f252922be","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\21.gif","hash":"86d3d5273ffd13841d246698eb648d85e178c4dc","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\20.gif","hash":"7f1cefe1db5c5ee6a9b0eea4d9618cba4b1ac790","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\22.gif","hash":"dcad257d86505e921618f7d85b60bf6ac2ce319d","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\24.gif","hash":"02a263028625496740eea9a50141a4ad98d826a1","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\23.gif","hash":"43295056d287f3da526dfb77915edc3de7551e3e","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\25.gif","hash":"05eeb7a9c42a2cd3876417944143078ce514a8b9","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\27.gif","hash":"814bad015177103646b0216367fa9707361998d3","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\26.gif","hash":"153c5f602881b04bed23d5c7d21a977563075ee2","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\3.gif","hash":"339482962bc4995e16e99ac9de9fc067636fd79e","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\28.gif","hash":"5830d72546907c962b6c9003fa923798a67b0406","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\29.gif","hash":"ef1d583626e7447f546995a5b296f34eb3364902","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\30.gif","hash":"886222551781040325cfd3307fbfba2a1d434a9e","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\32.gif","hash":"9af01aea73b614e5820a00bcc890840493f9dd70","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\31.gif","hash":"29043ca9d16adf6574d4d7efde1af7a615689931","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\33.gif","hash":"5f02bc5ec8d6220a872f1ca1fa2abaa92d46c361","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\34.gif","hash":"e0e500feecd8274490a3bdbf64d2555c16a86261","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\35.gif","hash":"141ae180796db9800770dc9dbb8c9beda6f170e8","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\images\\thumb\\thumb_7.webp","hash":"4be8fe8ea1b3563b78924062e3aa013cd5c4e82b","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\36.gif","hash":"55abcc242354c9c1c73538db5d8c7b984de5ca52","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\39.gif","hash":"6380eb13d87fc4242d2c6eec57f482ac8ca1ad1f","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\4.gif","hash":"878c3da67e6aec79c9b8dba6f34368586f4bd097","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\37.gif","hash":"850b9425421c3072a4898154d41776c02a4d64f7","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\38.gif","hash":"336cb3cbe0fd6cac96cd7cd5ca847c6a01f95b50","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\40.gif","hash":"c1b0fef186697125b66c1b4617fa3f9abc4d92eb","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\41.gif","hash":"c37fb5c43ea499a005d88075a392ed2e09c331df","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\42.gif","hash":"86f11fca6a9c42d3678ec8af35c077a9790ce777","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\43.gif","hash":"6a16279bea1179b3fd3a45736ecffd983a42272d","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\46.gif","hash":"b6c74edb2dc383e0f3e28a0859fa87683fea18e2","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\44.gif","hash":"32a9fa973626a3a06646095aeeecb919923f7d16","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\47.gif","hash":"653e07693ee719cafbce662bb5e410646fe4695a","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\49.gif","hash":"dbf616c5537074ace036340bdddf7948c138c3d7","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\48.gif","hash":"8a8483cd4e3b4b6ac0567eab41c5655ace4b3a81","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\5.gif","hash":"cf43cfcf14bbc7f8e430b74a97eb3b260f16b08c","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\51.gif","hash":"1ef1419f1ba2fd28e7de676ae5c388074646be53","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\50.gif","hash":"94a521d4f9a69c4eb59f5bbe673c8803246bdf5e","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\54.gif","hash":"75c738c517217f6b09d51ca3036cf54a01891c4d","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\52.gif","hash":"b516f6bd28cee1fe34144d897b702989782be4ec","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\53.gif","hash":"a03f9bbb0202d24d3313286f60ce08b214c013d2","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\55.gif","hash":"c446b5eca2cce1faa7f2147a8b646cc774011de1","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\56.gif","hash":"a71c1ef36706c4ddf7959c68d6c40920db3efe67","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\57.gif","hash":"b797ac8509a8f8bc328b10153e0026449a6139ec","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\6.gif","hash":"697d8f2262c535cd61808a564b21fc10ea93f0db","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\58.gif","hash":"5c70cba8adb0b42c0da4d922498c265e5d8034d7","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\59.gif","hash":"c50da42e6f2ec33112261f46c30e5ea5b4a0f889","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\62.gif","hash":"a839a263600c034bb11411a7f762dfa917155d10","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\60.gif","hash":"bdb24b7ec836fbf6c60c4d7ad97d73f041a154a8","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\61.gif","hash":"a5db56b975970ebe7048a5c824604d64559392b9","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\63.gif","hash":"28e9ec7a3882fec8c63dd731b06a9bbcc179aff7","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\65.gif","hash":"93cab4423539955a25d17c83da6aee277a6402aa","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\64.gif","hash":"38a537e9ac930736e162be81c13c5f708ff948bd","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\68.gif","hash":"e779199003a7415a29d50ecf0bbfed04e031f1ab","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\66.gif","hash":"6efe452b1f7a697db1c654130a9c2b872f528654","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\67.gif","hash":"50e2ed8f7773e60ae7d40b612db98554b8277b6e","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\69.gif","hash":"76ac840c5bc5ad44302daa921e7217149576b89e","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\70.gif","hash":"7c2641bef26579d9f90bdc0b740357527dd6e484","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\9.gif","hash":"8df9fc1055efeffdb72d499c064c05445adaa9be","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\71.gif","hash":"c6323d6d6d262011faed18e758e9e83e7b6812b8","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\7.gif","hash":"ad4e2ea1864a85f5729a1347c2f8c49fdb3b2def","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\aplayer@1.10.1\\dist\\.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\8.gif","hash":"43baffc48b0fbe649ed920bad713e2ccab9b7344","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\images\\face\\45.gif","hash":"864dfc9b99f5641f6d5a0081dc14d84872c1b3c6","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\lay\\modules\\carousel.js","hash":"ff770a94f4e7edd26f4449909e3d72644de83149","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\lay\\modules\\code.js","hash":"31972b8e26aac0f3b1233ad76c45187a39f4d977","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\lay\\modules\\colorpicker.js","hash":"0234f7a6eba2238583fe4644c0a247dacd67f73b","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\lay\\modules\\element.js","hash":"1900e7f8bca28958e0a495731c7b3957ea0157c6","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\lay\\modules\\form.js","hash":"6ed3220f5b8cbee7f287ca851dd5d294790281ee","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\lay\\modules\\laydate.js","hash":"53e871827a2c0bc04ec239e9461a5eb18a309075","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\lay\\modules\\layedit.js","hash":"ce8c049188c64ec3cd3d302f8e72d0094d85c462","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\lay\\modules\\flow.js","hash":"b6b4ffe415022a6788767906b837e2894057371b","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\lay\\modules\\layer.js","hash":"448f76fa3ccfb66a5d86b02cf785f67adf0d8033","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\lay\\modules\\layim.js","hash":"c79d7e577901f2ceab86f01f00cc4c26ff1b038e","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\lay\\modules\\laytpl.js","hash":"b79191723a99f3e52b56e0afbd183d7338b9cfd4","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\lay\\modules\\laypage.js","hash":"fec79457cffad05f261ab518e9d69bbebab548f0","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\lay\\modules\\rate.js","hash":"c3a4b2dad9e829afb8cfae69203eef8ede02191b","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\lay\\modules\\slider.js","hash":"c4e37a45ff9ae08f90492f894d86e7bec7542b26","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\lay\\modules\\mobile.js","hash":"0f82e8ce6b6deb51afdc307f488fb24c6dd02dbc","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\lay\\modules\\table.js","hash":"3a18563a832e11ae642bf6c2a8634a18768f2dbb","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\lay\\modules\\transfer.js","hash":"e85e366ff7ca8a49d195e149ec971cb6893b8409","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\lay\\modules\\tree.js","hash":"5a0c3d9b31a49d8e30e13ef187894d9d07bec69e","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\lay\\modules\\util.js","hash":"e5e39048df40763ddfff8ec271a6f8070fcb4f4e","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\lay\\modules\\upload.js","hash":"8eef1ed175c49a7f09f6ce472a7d12138ed8f8ed","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\valine@1.4.18\\dist\\plugins\\emojis\\index.js","hash":"452e66f0b900282eab6f98743592793361ccbc65","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\modules\\layim\\html\\chatlog.html","hash":"64591e08bb5af1d22e976ba3b3175075c7e6cd12","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\valine@1.4.18\\dist\\plugins\\emojis\\light.json","hash":"3ac2cd3cc07efff7c30ece9857b0527c5fc534d3","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\modules\\layim\\layim.css","hash":"a669bd1141c1df237631738d41f9d0032f4ba0a3","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\modules\\layim\\html\\find.html","hash":"ed8e6a3564bb52fc7adc8f19c7be34f25fe97222","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\modules\\layim\\html\\getmsg.json","hash":"3a83d94b0d8bdb96459e36ea042a72768ea3b348","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\modules\\layim\\html\\msgbox.html","hash":"521979a7d5b54e6c00dedaa897ae547065da9b2c","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\modules\\layim\\mobile\\layim.css","hash":"0af51b5e2280a03cefcde3e4cf6662d274cc64c6","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\modules\\layim\\skin\\2.jpg","hash":"ee9e802e6a46b5b698a4d0c36249c0085b192c68","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\modules\\layim\\skin\\1.jpg","hash":"f0ba9086fa730c9c80b89f25ff440b740a4b06df","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\modules\\layim\\skin\\5.jpg","hash":"a7c37d5401127afeb1ddd930c9ad9f0e3fab3d31","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\modules\\layim\\skin\\3.jpg","hash":"56cd08ca560acd37d377626b1b67cc4947bfe314","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\modules\\layim\\skin\\4.jpg","hash":"e018753c3fbd420f8987e53f8a9fc62428ecc18d","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\modules\\layim\\skin\\logo.jpg","hash":"3014e3081d5d4164143936fcf61e7080e81faf38","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\modules\\laydate\\default\\laydate.css","hash":"bc0f2f7396ca62c86bc07c2db1b73ca83de3cbdb","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\modules\\layim\\voice\\default.mp3","hash":"18ac4168a61de5cd4a35f814e97365945de94ab0","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\modules\\layer\\default\\icon-ext.png","hash":"ddf2a30ad34bac4e9a1250f29c46ac0823d62a12","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\modules\\layer\\default\\icon.png","hash":"fe47ec617507e9ce5f6ce7ac9b179a3c9231882b","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\modules\\layer\\default\\loading-0.gif","hash":"ba81388bbac5bc223f94489b97a95a13f3c78e47","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\modules\\layer\\default\\layer.css","hash":"ed6fefb1501b3bcd720919f9ce55bb322b5d7ec5","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\modules\\layer\\default\\loading-1.gif","hash":"49e54acbf5674212195e581848ec0d490282448f","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\modules\\layer\\default\\loading-2.gif","hash":"c641615e851254111e268da42d72ae684b3ce967","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\qrcode_js@1.0.0\\jquery.min.js","hash":"a8c8a5caf9765b4ccb90d708045518e219a9af5d","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\font-awesome@4.7.0\\fonts\\fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\font-awesome@4.7.0\\fonts\\fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\jquery@3.6.0\\dist\\jquery.min.js","hash":"b82d238d4e31fdf618bae8ac11a6c812c03dd0d4","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\jquery@3.6.0\\dist\\jquery.slim.min.js","hash":"d1c6704e94efe2d465fc161b6381e127d35acd81","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\jquery@3.6.0\\dist\\jquery.slim.min.map","hash":"17a9498757f0b358580ffce586bbc97ae897e8d8","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@fancyapps\\fancybox@3.5.7\\dist\\jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\bootstrap@3.3.4\\dist\\fonts\\glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\bootstrap@3.3.4\\dist\\js\\bootstrap.js","hash":"542cfd539f0cad650342c8cab8baf1cdbcd5fea6","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\bootstrap@3.3.4\\dist\\css\\bootstrap.min.css","hash":"ed29315e0ffb3f14382431f2724235bf67f44eb3","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\css\\layui.css","hash":"e15327d5c8f4c82909edc97977b277207e01364d","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\lay\\modules\\jquery.js","hash":"36456de559419079e1096890c7e9a97ae1bbf1be","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\maps\\kratosr.min.css.map","hash":"a36c6cd991e8c539a261bc86cdf39510d85bc3f6","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\aplayer@1.10.1\\dist\\APlayer.min.js.map","hash":"31a19da0f0cb6b00ec212eafa847f31af86788df","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\font-awesome@4.7.0\\fonts\\FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\font-awesome@4.7.0\\fonts\\fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\font-awesome@4.7.0\\fonts\\fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\gitment@0.0.3\\dist\\gitment.browser.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\jquery@3.6.0\\dist\\jquery.min.map","hash":"c98b6a5cb27af645c8bfb525fcad3569f3917d5b","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\valine@1.4.18\\dist\\Valine.Pure.min.js","hash":"227fb19caf17f4330ac24cb952af466eeaae5c43","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\valine@1.4.18\\dist\\Valine.min.js","hash":"d081a412c63411a75a3a880ddece65335d1c3ee8","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@fancyapps\\fancybox@3.5.7\\dist\\jquery.fancybox.js","hash":"27f034e5db8c32e268e2959b9a7c1258d36e4510","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\component.mjs.map","hash":"a45fac56302df2ee67ff4f074d50a0d84db98868","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\legacy.umd.js.map","hash":"3f5d438f4128604826d03944bbb158ba19ee2e10","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\legacy.umd.js","hash":"ced943a8fb34fa3810b910f30733ef7a6d9b563c","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\shim.cjs.map","hash":"74229c9c2f85c73ae1082fe49e89bb789845b90b","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\shim.mjs.map","hash":"800a3ce3650dbaeec78783b4c60b4f70d7959b6d","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\waline.cjs.map","hash":"eff335e17db76d0b1008d534b8e857c90a7a2d03","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\waline.cjs","hash":"7e9d8f4500857833f184905bb698eacc9f1d1c64","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\waline.mjs.map","hash":"2e0fdc9d2c9425c645443bc1d2c2f45e41606faa","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\waline.js.map","hash":"94be543349586850de68359ce689e792d012876a","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\waline.mjs","hash":"b709889f62a6df6fd09e423c5999764ea6ef29e8","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\bootstrap@3.3.4\\dist\\css\\bootstrap.css","hash":"f2183455571b19311a235bd5aa204e694ade8e94","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\jquery@3.6.0\\dist\\jquery.slim.js","hash":"77ec5d7bdb33634ff7d76837e36f0a7240c21e86","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\valine@1.4.18\\dist\\Valine.min.umd.js","hash":"90de88757741f89ad68c8d3765174437454e2303","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\@waline\\client@2.14.1\\dist\\waline.js","hash":"6919aef34a57cb0a4e1b75149124e17816ae71c5","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\gitment@0.0.3\\dist\\gitment.browser.js.map","hash":"72dc603fb7be8b623d1a402419b42c36723367bb","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\jquery@3.6.0\\dist\\jquery.js","hash":"af32f706407ab08f800c5e697cce92466e735847","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\layui.all.js","hash":"4fbff21286558e3cb817072d76ae326db4378c6e","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\valine@1.4.18\\dist\\Valine.Pure.min.js.map","hash":"40e15912aae8beff90cbb8ae235cd6fcd36f87dc","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\valine@1.4.18\\dist\\Valine.min.umd.js.map","hash":"6fe9ac91ca5074bcbc696f887802e8304e31aaea","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\layui-src@2.5.5\\dist\\font\\iconfont.svg","hash":"d484cee6f2461c9194b28878a1d1a677ffdbb78c","modified":1712909724000},{"_id":"source\\_posts\\研究方向\\中国计算机学会推荐国际学术会议和期刊目录-2019.pdf","hash":"6a1d60317503cc286bffee54296425938e8c22da","modified":1710379027188},{"_id":"themes\\kratos-rebirth\\source\\vendors\\twikoo@1.5.11\\dist\\twikoo.min.js","hash":"e547de978c573d0e7beda7ad74829ce6fef6b058","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\valine@1.4.18\\dist\\Valine.min.js.map","hash":"fb6f3071e92d08b0c66808ff9cfd190a0341d93d","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\bootstrap@3.3.4\\dist\\css\\bootstrap.css.map","hash":"2e1d08a9694cd5a694eabca746cfad95fb99653e","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\font-awesome@4.7.0\\fonts\\fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\twikoo@1.5.11\\dist\\twikoo.all.min.js","hash":"31c6669a90a33ee5af66ceaf47996ad8fd8b962e","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\gitalk@1.7.2\\dist\\gitalk.min.js","hash":"564fc7c731d05fa70d71ef853a2c8cc7725739e2","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\mermaid@9.1.1\\dist\\mermaid.esm.min.mjs","hash":"c01a600693e204abd02d0bf056a98a49e8a78d6e","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\mermaid@9.1.1\\dist\\mermaid.min.js","hash":"6bee48c26c32b90f50519f125890fcbb04779da6","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\mermaid@9.1.1\\dist\\mermaid.core.js","hash":"7952663a721317158468875349956182465b0701","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\mermaid@9.1.1\\dist\\mermaid.core.js.map","hash":"1d19d75bea55a0c0062661bb0fe5ad4135f68d8a","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\gitalk@1.7.2\\dist\\gitalk-component.js","hash":"fe4c44fa48522e9b2675f3a652d83d8aaec11ad8","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\gitalk@1.7.2\\dist\\gitalk.js","hash":"540a80bafeba53826127d556487541332ecd6ed1","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\gitalk@1.7.2\\dist\\gitalk-component.js.map","hash":"6f118aa575a5da5449d0c171f1c85fa5e43f80ff","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\gitalk@1.7.2\\dist\\gitalk.js.map","hash":"b5d129e59c5a1ca46395fbf7466432983178ebba","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\mermaid@9.1.1\\dist\\mermaid.esm.min.mjs.map","hash":"0ad921fcf8f5f79cf5fdf5deb5b4ffc21e501ff0","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\mermaid@9.1.1\\dist\\mermaid.min.js.map","hash":"bd1138557833d1ec29ce678d2f994e053f180423","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\mermaid@9.1.1\\dist\\mermaid.js.map","hash":"199ed9c41ad0bec69a69514beb6f39f7b3a78ae5","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\gitalk@1.7.2\\dist\\gitalk.min.js.map","hash":"6a9f6d47092f2557b346c0eabbd5907a1b12a9e7","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\vendors\\mermaid@9.1.1\\dist\\mermaid.js","hash":"e1f5d58724700b9cd810bb4e295ac93b6724578d","modified":1712909724000},{"_id":"themes\\kratos-rebirth\\source\\images\\thumb\\thumb_8.webp","hash":"9e6d74786d8459440d68c409eb654364dd279f8a","modified":1712909724000},{"_id":"public/search.json","hash":"a41ba386c230702cfef6bcfe4c2b05ddf1e736ce","modified":1713841041000},{"_id":"public/config/main.json","hash":"12419277a2ead591289cc16b63d744caaace640a","modified":1713841041000},{"_id":"public/2024/04/22/随手记/index.html","hash":"1a28774915000254a22b84c953baf79adcb704e8","modified":1713841041000},{"_id":"public/2024/04/22/XinKa/index.html","hash":"1c09267991bbc73b45c81806f1e1ca45f209a67f","modified":1713841041000},{"_id":"public/2024/04/22/TEMP：组会铺垫/index.html","hash":"db95f139bd310a1fe36da0b3f608b65284ba66d1","modified":1713841041000},{"_id":"public/2024/04/22/TEMP：中铁/index.html","hash":"df88e7b5a9f01f77f5b6dec82d3d2e99c3f6348f","modified":1713841041000},{"_id":"public/2024/04/22/TEMP：论文思路/index.html","hash":"21cf90349fdc60042f1d1465f79e41777ba3e7d8","modified":1713841041000},{"_id":"public/2024/04/22/英语学习/英语单词/index.html","hash":"12ca9102749ca7833c72791584c684b0090cffb1","modified":1713841041000},{"_id":"public/2024/04/22/英语学习/英语短语/index.html","hash":"5d50d245b8a0b3867f03ab40e61bccbe05a06f67","modified":1713841041000},{"_id":"public/2024/04/22/英语学习/英语学习/index.html","hash":"a954fbe51354f787055afe1650b31bbb376210b5","modified":1713841041000},{"_id":"public/2024/04/22/研究方向/研究/index.html","hash":"2317de57c3bfca71f43937b6400e6097838949c2","modified":1713841041000},{"_id":"public/2024/04/22/研究方向/检索工具/index.html","hash":"2241190b4e08fd14c3c2bc031d62a273b666b587","modified":1713841041000},{"_id":"public/2024/04/22/研究方向/方向：密码生成/index.html","hash":"76badb341ea8d328b345fff41ebde7d592ed586b","modified":1713841041000},{"_id":"public/2024/04/22/研究方向/方向调研/index.html","hash":"99231a812e52b75f1bd1ae88ab206b2d822e9ae0","modified":1713841041000},{"_id":"public/2024/04/22/研究方向/会议调研/index.html","hash":"818634af5222eb160bec821ebfcdf962009e34be","modified":1713841041000},{"_id":"public/2024/04/22/研究方向/PASS_RF/index.html","hash":"bd7a6148a83e42de933c567d469c8c80e8a73469","modified":1713841041000},{"_id":"public/2024/04/22/项目经历/项目经历/index.html","hash":"7e331bb3cfd0e5fec76edb0d621fd87f00d3865a","modified":1713841041000},{"_id":"public/2024/04/22/项目经历/TinyKV/TinyKV 项目要求/index.html","hash":"5420499c3add034c2560ae3ef003d61cf72230b8","modified":1713841041000},{"_id":"public/2024/04/22/项目经历/TinyKV/Raft 协议/index.html","hash":"0000f48a5d185a7e9b6de4d07326105304df5e31","modified":1713841041000},{"_id":"public/2024/04/22/项目经历/TinyKV/TinyKV 项目日志/index.html","hash":"2b1374853fc08f0f013b550b7281385929c7fdae","modified":1713841041000},{"_id":"public/2024/04/22/项目经历/MimaPJ/MMPJ 日志/index.html","hash":"b29d32e524ba22d1a770ff48b9987da71f4a6d07","modified":1713841041000},{"_id":"public/2024/04/22/算法题目/STL/index.html","hash":"4510436be9628753afbacecc814d1f8a40f58b16","modified":1713841041000},{"_id":"public/2024/04/22/算法题目/问题分析/index.html","hash":"8ea2c181b2c421d5d6758310c2aeca8903a2d305","modified":1713841041000},{"_id":"public/2024/04/22/生活琐事/祝词/index.html","hash":"db439858dd48044882a425e1a36a632b0877e19b","modified":1713841041000},{"_id":"public/2024/04/22/赛事活动/蓝桥杯/index.html","hash":"b377367e74a5575217b6c413df5366ff568bb79a","modified":1713841041000},{"_id":"public/2024/04/22/赛事活动/百度之星程序设计大赛/index.html","hash":"057a871ae1fc54333a34e0ca8d9ffc052c2146ed","modified":1713841041000},{"_id":"public/2024/04/22/赛事活动/啊 比赛汇总/index.html","hash":"037d5cc3c7be5616595b69fd56d48b611e513c31","modified":1713841041000},{"_id":"public/2024/04/22/赛事活动/华为软件精英挑战赛/index.html","hash":"56e2608ed40911bd66b1cc6c313410aea78890fb","modified":1713841041000},{"_id":"public/2024/04/22/赛事活动/华为软件精英挑战赛——配置/index.html","hash":"e98b1cccdb5c4901b074b25638b9c707b7303a74","modified":1713841041000},{"_id":"public/2024/04/22/赛事活动/中兴捧月/index.html","hash":"8cb254bf985ef66ee98adf89abaecbb0e394607a","modified":1713841041000},{"_id":"public/2024/04/22/赛事活动/CCPC 中国大学生网络预选赛/index.html","hash":"324d52fd83da4aab17b5a846bda111e6bdbbc797","modified":1713841041000},{"_id":"public/2024/04/22/赛事活动/ICPC 国际大学生程序设计竞赛/index.html","hash":"442fff877e3e31710461fde04faa34a175d657a1","modified":1713841041000},{"_id":"public/2024/04/22/赛事活动/TEMP/index.html","hash":"ccf57b8183824fccd0315dc4bc7705fef0e88440","modified":1713841041000},{"_id":"public/2024/04/22/赛事活动/Google Code Jam/index.html","hash":"d455ec3628cf589c22cbb77f7b67c45f27d0dcb0","modified":1713841041000},{"_id":"public/2024/04/22/日程安排/近期计划/index.html","hash":"bc41f2cd353ade3b3c8aef59b7a9cd6a7cf24ae4","modified":1713841041000},{"_id":"public/2024/04/22/日程安排/草稿/index.html","hash":"42b6082ff03eaf5205e0898ca9256130fb9df1d4","modified":1713841041000},{"_id":"public/2024/04/22/日程安排/工作日志/index.html","hash":"bc3954da4f83ec9f57c4d5296d5496aef5547588","modified":1713841041000},{"_id":"public/2024/04/22/日程安排/IDL/index.html","hash":"f99157af592407b96bf9a2e018eb3a0a74d7cd60","modified":1713841041000},{"_id":"public/2024/04/22/日程安排/今日计划/index.html","hash":"ca8a9c615b9298d99a1e93b91ebaede9f8d6dc55","modified":1713841041000},{"_id":"public/2024/04/22/日程安排/TEMP/index.html","hash":"085698c9ce1016452705dd0fe1e27a0d452f394f","modified":1713841041000},{"_id":"public/2024/04/22/认知社会/caremyself/index.html","hash":"04c351760c14da7c8927092135916087be2e4ca6","modified":1713841041000},{"_id":"public/2024/04/22/认知社会/careall/index.html","hash":"f6e8d92bc0a62fb59937f66600e0d5de032dfbb1","modified":1713841041000},{"_id":"public/2024/04/22/人工智能/数据集/index.html","hash":"8bb025e55e00879e43448dfe97d0ca3283a5c9f5","modified":1713841041000},{"_id":"public/2024/04/22/人工智能/机器学习基本概念/index.html","hash":"6319d38f8eb0c4c893aa46cb1682cad3a07eeeeb","modified":1713841041000},{"_id":"public/2024/04/22/人工智能/深度学习基本概念/index.html","hash":"3912587f739c775e7f4181be7f42783e3617feb2","modified":1713841041000},{"_id":"public/2024/04/22/人工智能/常见模型/Transformer/index.html","hash":"a0c4c47bae1a084f2a2c8b75f0b06d02a5a5c070","modified":1713841041000},{"_id":"public/2024/04/22/人工智能/常见模型/GAN/index.html","hash":"366f089062980cde24525717910394535b991502","modified":1713841041000},{"_id":"public/2024/04/22/人工智能/常见模型/变分编码器/index.html","hash":"9c76fbd5d7d867af3d9e84689aa82316396ff156","modified":1713841041000},{"_id":"public/2024/04/22/人工智能/常见模型/扩散模型/index.html","hash":"e590488d50d55e90852f31ff6a408a728aa2f0e2","modified":1713841041000},{"_id":"public/2024/04/22/人工智能/常见模型/生成模型/index.html","hash":"f239a666843a46d0df2c2bfb9d0893a4c8b2168e","modified":1713841041000},{"_id":"public/2024/04/22/人工智能/大语言模型/微信项目/index.html","hash":"36c5324d61d32c445b1c8216f6120f4bb5d6c1c5","modified":1713841041000},{"_id":"public/2024/04/22/人工智能/大语言模型/大模型入门/index.html","hash":"574a8748f737bb6b231d09d3549111de3dbcb8bd","modified":1713841041000},{"_id":"public/2024/04/22/人工智能/大语言模型/MoEs/index.html","hash":"c71ce620a8548a82fbbff9361f3891811edffc46","modified":1713841041000},{"_id":"public/2024/04/22/人工智能/大语言模型/Prompt/index.html","hash":"c8cff683a34d0014ba4269f618e95d9f9016e47a","modified":1713841041000},{"_id":"public/2024/04/22/人工智能/大语言模型/RAG 项目/index.html","hash":"c34e025f9cbac73885d9f6bca8c1274768679388","modified":1713841041000},{"_id":"public/2024/04/22/人工智能/大语言模型/RAG 检索增强/index.html","hash":"047012dc9361e563f8c215ed2d4c231efe4fa752","modified":1713841041000},{"_id":"public/2024/04/22/人工智能/AI 学习/index.html","hash":"35bb8f8be98424f74effe74c23de5fe848d2248f","modified":1713841041000},{"_id":"public/2024/04/22/人工智能/AI 最新进展/index.html","hash":"701ba27d653a1dcd8661dccbd465fd7a3bc66024","modified":1713841041000},{"_id":"public/2024/04/22/人工智能/大语言模型/Finetuning/index.html","hash":"f49cdcc69ac6348dc4524de4ca34bc4dc0d92ed6","modified":1713841041000},{"_id":"public/2024/04/22/人工智能/大语言模型/GAI 的应用/index.html","hash":"cc2fe9cf56ef8ab3e3608c3b9f96101174c3447d","modified":1713841041000},{"_id":"public/2024/04/22/人工智能/大语言模型/GAI 的工作原理/index.html","hash":"4c431a34f0aa594b4a3aa675063bdb806d65441b","modified":1713841041000},{"_id":"public/2024/04/22/论文笔记/语法密码分析/index.html","hash":"a96fee50afaddb12dc2dc54182381137bd0fa619","modified":1713841041000},{"_id":"public/2024/04/22/论文笔记/未命名/index.html","hash":"bb9586bd76654f53c7f130b1dd3b84af811ddf93","modified":1713841041000},{"_id":"public/2024/04/22/论文笔记/语义密码模型和密码语言模式分析/index.html","hash":"9521d63de26170ef6df624a62ec74dba226a4225","modified":1713841041000},{"_id":"public/2024/04/22/论文笔记/基于深度学习的口令安全关键技术研究/index.html","hash":"57962b2924154ec4b0544411bf78437fcc50c833","modified":1713841041000},{"_id":"public/2024/04/22/论文笔记/明文口令生成模型/index.html","hash":"d50cce42353a1674b0c2c5c768ae58f9398bd572","modified":1713841041000},{"_id":"public/2024/04/22/论文笔记/复现/复现：PassGPT/index.html","hash":"674ea03e4d822f88a48dea78487e028f0248d9b2","modified":1713841041000},{"_id":"public/2024/04/22/论文笔记/TEMP/index.html","hash":"2667f6f858a96edd941af6fc8aa599f693c29f15","modified":1713841041000},{"_id":"public/2024/04/22/论文笔记/REDPACK/index.html","hash":"fba3559c5ece606c2d0d6fc47cd55eaf191ffd0d","modified":1713841041000},{"_id":"public/2024/04/22/论文笔记/Pass_RNN/index.html","hash":"4a25cf1b0db3d1f27d4d40e283f313bc136ae863","modified":1713841041000},{"_id":"public/2024/04/22/论文笔记/PassGPT/index.html","hash":"c4b557599de261aab4440cddc56eb3b744ceb99a","modified":1713841041000},{"_id":"public/2024/04/22/论文笔记/PassGAN/index.html","hash":"e784966b6e1d8b4d39764c35fd9668c0feacee26","modified":1713841041000},{"_id":"public/2024/04/22/论文笔记/PassDiff/index.html","hash":"aad41a959b1ec1d7a0131f1d3cb16cd823e8038f","modified":1713841041000},{"_id":"public/2024/04/22/论文笔记/PassBERT/index.html","hash":"4d2b8fd7cc14d5f0ac4311d557cac910330a3dbe","modified":1713841041000},{"_id":"public/2024/04/22/论文笔记/Pass improved Transformer/index.html","hash":"b829e068a41b51c39b06fa9088a5807738f504bb","modified":1713841041000},{"_id":"public/2024/04/22/论文笔记/GuessFuse/index.html","hash":"1157758fa0810f58f4517f863494dae5de2a0f14","modified":1713841041000},{"_id":"public/2024/04/22/论文笔记/AReview/index.html","hash":"74b188f4d41e4599885d7ce72826004ed99ed8e8","modified":1713841041000},{"_id":"public/2024/04/22/课程作业/6G技术发展报告/index.html","hash":"28e4ff6c61901fa806fef85b5159b2d7afc78222","modified":1713841041000},{"_id":"public/2024/04/22/工具教程/配置：Windows/index.html","hash":"a8a2088c012f2dd75cbff3f965165721faa89b03","modified":1713841041000},{"_id":"public/2024/04/22/工具教程/配置：python 安装文档/index.html","hash":"47ed89cf0e37ce0236a4030660a734fd45228165","modified":1713841041000},{"_id":"public/2024/04/22/工具教程/配置：VMWare/index.html","hash":"a8302071bcf17575e7a0cdfdd93298661aee5140","modified":1713841041000},{"_id":"public/2024/04/22/工具教程/配置：Linux 系统/index.html","hash":"36626f2db47d09b15fcb8f453bd905d7f6e221f9","modified":1713841041000},{"_id":"public/2024/04/22/工具教程/教程：Wandb/index.html","hash":"90e450fb91ae747805fa640d8e6e66ffbb1d6c1e","modified":1713841041000},{"_id":"public/2024/04/22/工具教程/教程：git/index.html","hash":"cd64b3de534b756c620de634ebc148a0ef136697","modified":1713841041000},{"_id":"public/2024/04/22/工具教程/教程：Rime 输入法/index.html","hash":"e70548a3346ee394c37e4b5b15f44fab22da22e9","modified":1713841041000},{"_id":"public/2024/04/22/工具教程/教程：Obsidian/index.html","hash":"f9d8c156120108a23f4ab0ad7125b1b648a99a97","modified":1713841041000},{"_id":"public/2024/04/22/工具教程/教程：MD 数学公式语法/index.html","hash":"9bd68fd90cc236ecbfb3c111b8fb429104c96d0e","modified":1713841041000},{"_id":"public/2024/04/22/工具教程/教程：Linux 指令/index.html","hash":"c3034e7e01b7eefb56eba98ff78e5b7b966ed53f","modified":1713841041000},{"_id":"public/2024/04/22/工具教程/教程：Hexo/index.html","hash":"9482e88ab9765bb9a435e94b4010c2a011388c87","modified":1713841041000},{"_id":"public/2024/04/22/工具教程/教程：GPU 相关/index.html","hash":"f26009c5ada932e37e9fec0583f20b694cad2921","modified":1713841041000},{"_id":"public/2024/04/22/工具教程/工具教程/index.html","hash":"de8d0a64c6ab26546d59e85407870351e96607f5","modified":1713841041000},{"_id":"public/2024/04/22/编程语言/Python/python 高级/index.html","hash":"e7662b32ec7ed13524e4e34a7960251d78bc1d2d","modified":1713841041000},{"_id":"public/2024/04/22/编程语言/GO_lang/grpc/grpc_1/index.html","hash":"db22a7545e0327640f02a742bb3539bc16375997","modified":1713841041000},{"_id":"public/2024/04/22/编程语言/GO_lang/go语言学习记录/index.html","hash":"c2d1f137a4f45e75d28432d70daa529bc3133aba","modified":1713841041000},{"_id":"public/2024/04/22/编程语言/GO_lang/go 高级/index.html","hash":"9615d371d4279befa7debdefee9148591f9742e2","modified":1713841041000},{"_id":"public/2024/04/22/编程语言/GO_lang/go 基础/index.html","hash":"6bf5960a138866ccaaf61062ed760c40b31f518d","modified":1713841041000},{"_id":"public/2024/04/22/毕业设计/TEMP/index.html","hash":"1a0d445e66f6f9b3a32d3e5f0f3d69c39843a089","modified":1713841041000},{"_id":"public/2024/04/22/test/index.html","hash":"60ebe30dae76a3f7fda81ee2c6e0b3aae934ebc5","modified":1713841041000},{"_id":"public/2024/04/22/hello-world/index.html","hash":"60a9dcf7f29769ad0b2ec8ff71cb99c4f5af1e1e","modified":1713841041000},{"_id":"public/archives/index.html","hash":"90116ae281ecb2e6642620b474e4314aecf18913","modified":1713841041000},{"_id":"public/archives/page/2/index.html","hash":"edc326375dd47c637ac2998cdcfda4025de7c0eb","modified":1713841041000},{"_id":"public/archives/page/3/index.html","hash":"a7d7287eff0b0fc5b258d4a2ea4d5b34a2e1c060","modified":1713841041000},{"_id":"public/archives/page/4/index.html","hash":"d9e25879f4d4225de8a1af84c3a0d1427ac05a3d","modified":1713841041000},{"_id":"public/archives/page/5/index.html","hash":"fd1e925e7378c6536b9d9752973c8d44328b8980","modified":1713841041000},{"_id":"public/archives/page/6/index.html","hash":"bfaa9d717e7b1828df7e77b634242e46fca9a8b6","modified":1713841041000},{"_id":"public/archives/page/7/index.html","hash":"68740702a270ec1ac6c374ca6a89959e1ed15f81","modified":1713841041000},{"_id":"public/archives/page/8/index.html","hash":"e38f8815b53dfbcd45d55a9cfa7b05e03ad2239f","modified":1713841041000},{"_id":"public/archives/page/9/index.html","hash":"242b06c8a3af6d15d82bec7636a0390b7a0bee59","modified":1713841041000},{"_id":"public/archives/page/10/index.html","hash":"b2dbfd72b048372f94d9772e6bdcf074d22a8fc8","modified":1713841041000},{"_id":"public/archives/2024/index.html","hash":"aaf69134a409b2588f7c1386f078731f1691cf09","modified":1713841041000},{"_id":"public/archives/2024/page/2/index.html","hash":"cb540baa3fe146a1dd4a153efcfcda7033b25dc1","modified":1713841041000},{"_id":"public/archives/2024/page/3/index.html","hash":"b28a914f6ab31a286bb562b5f3e2b8a243868386","modified":1713841041000},{"_id":"public/archives/2024/page/4/index.html","hash":"eae593382ffb2b4b34637c80846c5a14b016f828","modified":1713841041000},{"_id":"public/archives/2024/page/5/index.html","hash":"2a61089c506e49a9d4d87313cfe6ee611dc5b54e","modified":1713841041000},{"_id":"public/archives/2024/page/6/index.html","hash":"ff93d661c419a228f3c9c61d1c2f9e02825572fd","modified":1713841041000},{"_id":"public/archives/2024/page/7/index.html","hash":"0eff3dc8c3c89eeb06f43c303b38c7f1fe3cee7a","modified":1713841041000},{"_id":"public/archives/2024/page/8/index.html","hash":"8eea1605f8474498ebac20f7599f214c0929c91f","modified":1713841041000},{"_id":"public/archives/2024/page/9/index.html","hash":"cd10032ae1254340dc0a0f2f2bbf6e69b4b305c1","modified":1713841041000},{"_id":"public/archives/2024/page/10/index.html","hash":"edc57bb9ad95dd15c0a9bd914a174b331f8e22e7","modified":1713841041000},{"_id":"public/archives/2024/04/index.html","hash":"a7dbd9cb030e181c23c89a31bacedc9ecc44506c","modified":1713841041000},{"_id":"public/archives/2024/04/page/2/index.html","hash":"dec32fe54892e7ca87492574183865e77729b603","modified":1713841041000},{"_id":"public/archives/2024/04/page/3/index.html","hash":"912fac05e65e5328e6b2f92afde8bd6fa77659a7","modified":1713841041000},{"_id":"public/archives/2024/04/page/4/index.html","hash":"63b70ac20c24142dbe559c725d74d143d68cad97","modified":1713841041000},{"_id":"public/archives/2024/04/page/5/index.html","hash":"67d181708ce80d4d8f2ea2da9277d24532ec157f","modified":1713841041000},{"_id":"public/archives/2024/04/page/6/index.html","hash":"7bf0df0cd60fed524a93e4542278595b4b922cff","modified":1713841041000},{"_id":"public/archives/2024/04/page/7/index.html","hash":"edc92470b8b3e929cb72ca8246a8adcabe786036","modified":1713841041000},{"_id":"public/archives/2024/04/page/8/index.html","hash":"e5639f1b0ee0926bd49cc0808a992ea2b648705d","modified":1713841041000},{"_id":"public/archives/2024/04/page/9/index.html","hash":"95fc4aeb871090bbc76f36d69c83c9ba553772d8","modified":1713841041000},{"_id":"public/archives/2024/04/page/10/index.html","hash":"f7756cd7df8f2561fdd191e682aa2d086af60d60","modified":1713841041000},{"_id":"public/index.html","hash":"3fb4e689ceccfe7d146c35687b5121669851398e","modified":1713841041000},{"_id":"public/page/2/index.html","hash":"c5244ffdf6be3b58c716b794de2a757ed6515bab","modified":1713841041000},{"_id":"public/page/3/index.html","hash":"b567096b39da574a7b42fa6593c9b69f20df36b0","modified":1713841041000},{"_id":"public/page/4/index.html","hash":"c501234bea5404fff45b799ab09d6531b82ead8f","modified":1713841041000},{"_id":"public/page/5/index.html","hash":"a760b683c82581252ffd3dbb7eccb99177e8dac7","modified":1713841041000},{"_id":"public/page/6/index.html","hash":"9d49b4327a758a3afb6378b479c0411d1191088e","modified":1713841041000},{"_id":"public/page/7/index.html","hash":"b1466a646456e9d3afea31036b429354c2650979","modified":1713841041000},{"_id":"public/page/8/index.html","hash":"001561fb468c3109e4a07553d54b6f2c7212b243","modified":1713841041000},{"_id":"public/page/9/index.html","hash":"fe3cbffd9f9b5349540e13af76ad523e3b496197","modified":1713841041000},{"_id":"public/page/10/index.html","hash":"963c739d6939e5b4f776e40798028c4d4db3ed53","modified":1713841041000},{"_id":"public/404.html","hash":"ecfdef2e858fb321a52bed7f17b74c16bc0a9126","modified":1713841041000},{"_id":"public/tags/index.html","hash":"d24f29c333a2edfd1f9b7ba44117e8f164581b70","modified":1713841041000},{"_id":"public/categories/index.html","hash":"8d685783bcc7e866b6d6c4716f4b67dce053bed5","modified":1713841041000},{"_id":"public/search/index.html","hash":"f760f521e5f200c8f3d73ec40bb5a8b8f804fda0","modified":1713841041000},{"_id":"public/images/about.webp","hash":"ca0fb739ab4426e7895742c1d8d52df1e14468e8","modified":1713841041000},{"_id":"public/images/404.webp","hash":"d2e2bd5cc2627a2b04d5e449a67949a2605ae13e","modified":1713841041000},{"_id":"public/images/avatar.webp","hash":"3ed6e4e1e08e9c2700aa149d1f9e068fb02947cd","modified":1713841041000},{"_id":"public/images/banner.webp","hash":"7c5093243bfd581a633ba8a905e2d379cfa78c00","modified":1713841041000},{"_id":"public/images/alipay.webp","hash":"01fa6151d2122f0470ee6f38ac8e4ced6c81912e","modified":1713841041000},{"_id":"public/images/bg.webp","hash":"f232b442b64eaa90f45a48ff04d8e7d352caf212","modified":1713841041000},{"_id":"public/images/banner_dark.webp","hash":"5589986444825e2b75c369d419ff736d3a396bac","modified":1713841041000},{"_id":"public/images/comment.webp","hash":"7756b5a69f2a85a2d1c4251e3055bfa0218aa385","modified":1713841041000},{"_id":"public/images/failure.ico","hash":"5eec5c163400d8ece74286da49130da1ead3f6f6","modified":1713841041000},{"_id":"public/images/comment_dark.webp","hash":"7756b5a69f2a85a2d1c4251e3055bfa0218aa385","modified":1713841041000},{"_id":"public/images/psr.webp","hash":"bf457bf84bca767bac1bd2b960d91c53ba3fbdee","modified":1713841041000},{"_id":"public/maps/candy.min.js.map","hash":"505411543a8c7fdee9d81891e7ae69d2552bb480","modified":1713841041000},{"_id":"public/images/wechat.webp","hash":"06f3997bf554768c04cb588198c7b3d68c21b8e9","modified":1713841041000},{"_id":"public/maps/kr-color-dark.min.css.map","hash":"ed26a486d8a0005e86a17c61efa9aaf2f5dc8cd9","modified":1713841041000},{"_id":"public/maps/kr-dark.min.js.map","hash":"5cffc40b5bfa266ec05798f0fca9ba050eb461f4","modified":1713841041000},{"_id":"public/maps/light.min.css.map","hash":"525abe619bc422b08fde586dbba5c835aa084c59","modified":1713841041000},{"_id":"public/maps/kratosr.min.js.map","hash":"e5114f2211110385cca10ff22596354e650785d3","modified":1713841041000},{"_id":"public/maps/night-blue.min.css.map","hash":"ec0859ab631cb8a9afdfeef883daf3420606afcc","modified":1713841041000},{"_id":"public/maps/night-eighties.min.css.map","hash":"55c13f2e4cd0e7e3d2b9b91133d4c49e77942a43","modified":1713841041000},{"_id":"public/maps/local-search.min.js.map","hash":"b982889304a495d435e2da32ebfe33846e986bf9","modified":1713841041000},{"_id":"public/maps/night.min.css.map","hash":"20c8105676d6fb8a82a61ca87c7f9e9881ca9d38","modified":1713841041000},{"_id":"public/maps/night-bright.min.css.map","hash":"2e06a59b8ec11b0c4a4806d23e0dae9802c41c12","modified":1713841041000},{"_id":"public/maps/pjax.min.js.map","hash":"ad5ef0c6a3076450aa6e51f3503f40f6e3ebf5e2","modified":1713841041000},{"_id":"public/maps/snow.min.js.map","hash":"ca2b8edf152fe02ffb75c130111531ede230f594","modified":1713841041000},{"_id":"public/maps/prismjs.min.css.map","hash":"3c7bf5a131ccfa521c4d277fdbcdeb88258ccc87","modified":1713841041000},{"_id":"public/images/thumb/thumb_1.webp","hash":"a818f050112ceb75e3a60dc1673a10783b254595","modified":1713841041000},{"_id":"public/images/thumb/thumb_10.webp","hash":"4983eeca7886bbe7c09b0c79f4774302fdfa1315","modified":1713841041000},{"_id":"public/images/thumb/thumb_11.webp","hash":"08d8d91e2b01768842abb47cd48a0f07d22d070c","modified":1713841041000},{"_id":"public/images/thumb/thumb_13.webp","hash":"c4c9050637f4ffa3cb7d782f59dadc993ac3a6de","modified":1713841041000},{"_id":"public/images/thumb/thumb_12.webp","hash":"b6b8e1281f9146925e45e937cb4d5b28bcabe957","modified":1713841041000},{"_id":"public/images/thumb/thumb_15.webp","hash":"8629f2a7d3b0192549f809e6b7479159af0222da","modified":1713841041000},{"_id":"public/images/thumb/thumb_14.webp","hash":"f9300e2b45c1f061ec8cc21527142dafc558a9e6","modified":1713841041000},{"_id":"public/images/thumb/thumb_18.webp","hash":"5bc78b9d6cb0a0cf6daa3a35b93e575777a49ddd","modified":1713841041000},{"_id":"public/images/thumb/thumb_17.webp","hash":"b5a036ec234a23c820a89d1c640b1f2e8dd3dfa4","modified":1713841041000},{"_id":"public/images/thumb/thumb_16.webp","hash":"61714ccffd55d6fa74cf94bcdd5a464da04ce891","modified":1713841041000},{"_id":"public/images/thumb/thumb_3.webp","hash":"3faffd2575e0751526249c5c56a2a5045a21363b","modified":1713841041000},{"_id":"public/images/thumb/thumb_20.webp","hash":"4ab961d94a0d3abbefc7f6d9188a889ec2225e7a","modified":1713841041000},{"_id":"public/images/thumb/thumb_19.webp","hash":"15e0cd0cbe5c7166915a4b68680681beccc2afef","modified":1713841041000},{"_id":"public/images/thumb/thumb_4.webp","hash":"1d0f136590632e7ba31f5510d24891ba443f1f33","modified":1713841041000},{"_id":"public/images/thumb/thumb_8.webp","hash":"9e6d74786d8459440d68c409eb654364dd279f8a","modified":1713841041000},{"_id":"public/images/thumb/thumb_7.webp","hash":"4be8fe8ea1b3563b78924062e3aa013cd5c4e82b","modified":1713841041000},{"_id":"public/images/thumb/thumb_9.webp","hash":"bca69e7d56982b43c52e9ffa17c8d5bb268834d8","modified":1713841041000},{"_id":"public/vendors/qrcode_js@1.0.0/LICENSE","hash":"7041717dd3a7d35354f94321b666e11977c7610e","modified":1713841041000},{"_id":"public/images/thumb/thumb_2.webp","hash":"1bcf7461c2b9408b8a893013fa425eb46701faf6","modified":1713841041000},{"_id":"public/images/thumb/thumb_5.webp","hash":"ba384ada1c2a17b67036addd68ffa1f604ab5a41","modified":1713841041000},{"_id":"public/images/thumb/thumb_6.webp","hash":"c2d8b68971dacd111566526f64d94932f5c6f076","modified":1713841041000},{"_id":"public/vendors/aplayer@1.10.1/dist/APlayer.min.css.map","hash":"c59d2bc9472922cf6ef9a99e052dbee6cc7e6b36","modified":1713841041000},{"_id":"public/vendors/qrcode_js@1.0.0/index.svg","hash":"15730a03273bba608180e8b182453ae393b3c3e0","modified":1713841041000},{"_id":"public/vendors/font-awesome@4.7.0/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1713841041000},{"_id":"public/vendors/gitalk@1.7.2/dist/gitalk.css.map","hash":"9dda04c29af8da6ac13a507beefea6fce4d7032e","modified":1713841041000},{"_id":"public/vendors/gitment@0.0.3/dist/gitment.js.map","hash":"2cb4d20d09b110268e0ea8c199f72501aa2d66e8","modified":1713841041000},{"_id":"public/vendors/gitment@0.0.3/dist/constants.js.map","hash":"6b7b473ef4bba09ea572b3baaac73c122372439e","modified":1713841041000},{"_id":"public/vendors/gitment@0.0.3/dist/icons.js.map","hash":"5604e4382d787a9a1976359d92bb9827f11c2c2b","modified":1713841041000},{"_id":"public/vendors/gitment@0.0.3/dist/utils.js.map","hash":"6f99a8c2269c938d4422f3a244a8086f89800890","modified":1713841041000},{"_id":"public/vendors/mermaid@9.1.1/dist/mermaid.esm.min.mjs.LICENSE.txt","hash":"38165332beeccd3551309f85addb2354f2d18676","modified":1713841041000},{"_id":"public/vendors/mermaid@9.1.1/dist/mermaid.min.js.LICENSE.txt","hash":"38165332beeccd3551309f85addb2354f2d18676","modified":1713841041000},{"_id":"public/vendors/twikoo@1.5.11/dist/twikoo.all.min.js.LICENSE.txt","hash":"c00fe261d987618ec25243062c089a6982d4480c","modified":1713841041000},{"_id":"public/images/bg_dark.webp","hash":"f232b442b64eaa90f45a48ff04d8e7d352caf212","modified":1713841041000},{"_id":"public/vendors/twikoo@1.5.11/dist/twikoo.min.js.LICENSE.txt","hash":"c00fe261d987618ec25243062c089a6982d4480c","modified":1713841041000},{"_id":"public/vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1713841041000},{"_id":"public/vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1713841041000},{"_id":"public/vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1713841041000},{"_id":"public/vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/api.cjs","hash":"2da315666c52a2a0205da342f3fc7808834d0231","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/api.cjs.map","hash":"555cf9adc857430a799507a250f6ae8cf4454268","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/api.d.cts","hash":"c1cafa6064ccb6851580d9f11600124c060db78b","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/api.mjs","hash":"208a0b855cf31a54c2130f0aaa0bc7fb3ff766a4","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/api.d.ts","hash":"c1cafa6064ccb6851580d9f11600124c060db78b","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/comment.cjs.map","hash":"1d162b21f3b9b513036b53ed45950f7c35e6e0f5","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/api.mjs.map","hash":"4a590871076e07d59664a0fda40d037a6d2f2344","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/api.d.mts","hash":"c1cafa6064ccb6851580d9f11600124c060db78b","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/comment.cjs","hash":"48777cf6661b69f54cebc970896a4b7528add2ad","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/comment.d.ts","hash":"376c612b7771eec314f855e69e82523d4f7f922f","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/comment.d.cts","hash":"376c612b7771eec314f855e69e82523d4f7f922f","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/comment.d.mts","hash":"376c612b7771eec314f855e69e82523d4f7f922f","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/comment.mjs","hash":"d6b7d79d2b213888f829e7b44ff312aae3cd2378","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/comment.js.map","hash":"ab28febbf60a2979a8baca97c958a05c2555fbd4","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/comment.mjs.map","hash":"efdc8c853f806168f32b4433a19bda6f62c3f5bf","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/component.mjs","hash":"395fabdd03cb56bc0757b14a06a70470dbe0259e","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/legacy.umd.d.ts","hash":"b957f75fde95eb046a31ce075d6e311a2d7450d0","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/pageview.cjs","hash":"ff6d9246e7b256eae10aa8c0d35f3b201b1ac8b7","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/pageview.cjs.map","hash":"d29ca67cfab54c0ff984438d47060aee70e6fa15","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/pageview.d.cts","hash":"4b3fad71d77ead2ad05e4dfe9e0906a4e025a233","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/pageview.d.ts","hash":"4b3fad71d77ead2ad05e4dfe9e0906a4e025a233","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/pageview.d.mts","hash":"4b3fad71d77ead2ad05e4dfe9e0906a4e025a233","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/pageview.js.map","hash":"dfa4f18a6ed4dec6232ae770ac66d30158e45b27","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/pageview.mjs.map","hash":"67ae874c2c6fdcbe3ba5ad7f3895a52b518f4924","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/pageview.mjs","hash":"4dc75845f6c827a0c1c8d6a92e7a0602bd03f2a1","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/shim.d.cts","hash":"92c855188103bc5d5bbbaaf5346a57346e241e5c","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/shim.cjs","hash":"1fad1bb7c23bd023d34bafd94c7f3fb937222766","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/shim.d.mts","hash":"92c855188103bc5d5bbbaaf5346a57346e241e5c","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/waline-meta.css.map","hash":"f3796986f06b46a16a17995b9642922c3d029764","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/shim.mjs","hash":"0c7689080af2d07976a56ea09ec75f8a360e9663","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/waline.css.map","hash":"14c2e889034c99033dbac74a4bdbba9e53801a3d","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/waline.d.mts","hash":"92c855188103bc5d5bbbaaf5346a57346e241e5c","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/waline.d.cts","hash":"92c855188103bc5d5bbbaaf5346a57346e241e5c","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/waline.d.ts","hash":"92c855188103bc5d5bbbaaf5346a57346e241e5c","modified":1713841041000},{"_id":"public/vendors/bootstrap@3.3.4/dist/css/bootstrap-theme.css.map","hash":"ccb7ff3435bb5cff1fe9643fc0ac8cdde2dcd177","modified":1713841041000},{"_id":"public/vendors/gitment@0.0.3/dist/theme/default.js.map","hash":"0b7317800be0ea17fa142c7bb26f7e8158b54447","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/font/iconfont.woff","hash":"6133b92b4e5c3866675b2656ceae14606fa01eb0","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/font/iconfont.eot","hash":"de1bec30d0ef87af6ab83ab6a269c3c59bc83124","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/0.gif","hash":"87db440c06299666a8a1f407a6008c5bf6d70817","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/font/iconfont.woff2","hash":"c9b04ae5b10f88f8bc7c48840164f468ee7b10b0","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/10.gif","hash":"04fe5b26b7e2c980d12ad7157a4ce908c2a74f14","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/font/iconfont.ttf","hash":"5d2b8777c623bb6e96577cee675489d0299ffa1f","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/11.gif","hash":"170c2e16dd383e26d9d68406eb217dbf191ea14e","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/1.gif","hash":"e6da9a45ecb8c766a8f7c2362ccf2976d20d17a9","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/14.gif","hash":"1af45520e97328498b1a281b6955df5029fc9679","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/15.gif","hash":"a0f216d0aaaeec369109e4b581eacd4e83e5ccb6","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/12.gif","hash":"f5da3f33448e67537e3df8ff63b010247b06841c","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/13.gif","hash":"0afcb6c47cb53fa4a8467d7d7bf00ec464df2f8e","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/18.gif","hash":"eeee84a351d6e84d291b0c27e5d70014a3a2748d","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/19.gif","hash":"620b2afa4c36cbfdd09c57807d8a662a5267ea51","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/17.gif","hash":"0b88c01b477d4ca98eb99a665c0ab8738551aeec","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/16.gif","hash":"54db2506b93b76c58174177245dcc6ef3fd0591f","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/21.gif","hash":"86d3d5273ffd13841d246698eb648d85e178c4dc","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/20.gif","hash":"7f1cefe1db5c5ee6a9b0eea4d9618cba4b1ac790","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/2.gif","hash":"43b3ca892341431f697e1326aa693c1f252922be","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/24.gif","hash":"02a263028625496740eea9a50141a4ad98d826a1","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/22.gif","hash":"dcad257d86505e921618f7d85b60bf6ac2ce319d","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/23.gif","hash":"43295056d287f3da526dfb77915edc3de7551e3e","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/25.gif","hash":"05eeb7a9c42a2cd3876417944143078ce514a8b9","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/26.gif","hash":"153c5f602881b04bed23d5c7d21a977563075ee2","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/28.gif","hash":"5830d72546907c962b6c9003fa923798a67b0406","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/3.gif","hash":"339482962bc4995e16e99ac9de9fc067636fd79e","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/29.gif","hash":"ef1d583626e7447f546995a5b296f34eb3364902","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/27.gif","hash":"814bad015177103646b0216367fa9707361998d3","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/30.gif","hash":"886222551781040325cfd3307fbfba2a1d434a9e","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/33.gif","hash":"5f02bc5ec8d6220a872f1ca1fa2abaa92d46c361","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/34.gif","hash":"e0e500feecd8274490a3bdbf64d2555c16a86261","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/31.gif","hash":"29043ca9d16adf6574d4d7efde1af7a615689931","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/35.gif","hash":"141ae180796db9800770dc9dbb8c9beda6f170e8","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/32.gif","hash":"9af01aea73b614e5820a00bcc890840493f9dd70","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/37.gif","hash":"850b9425421c3072a4898154d41776c02a4d64f7","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/36.gif","hash":"55abcc242354c9c1c73538db5d8c7b984de5ca52","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/4.gif","hash":"878c3da67e6aec79c9b8dba6f34368586f4bd097","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/39.gif","hash":"6380eb13d87fc4242d2c6eec57f482ac8ca1ad1f","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/40.gif","hash":"c1b0fef186697125b66c1b4617fa3f9abc4d92eb","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/38.gif","hash":"336cb3cbe0fd6cac96cd7cd5ca847c6a01f95b50","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/42.gif","hash":"86f11fca6a9c42d3678ec8af35c077a9790ce777","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/44.gif","hash":"32a9fa973626a3a06646095aeeecb919923f7d16","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/47.gif","hash":"653e07693ee719cafbce662bb5e410646fe4695a","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/46.gif","hash":"b6c74edb2dc383e0f3e28a0859fa87683fea18e2","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/41.gif","hash":"c37fb5c43ea499a005d88075a392ed2e09c331df","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/43.gif","hash":"6a16279bea1179b3fd3a45736ecffd983a42272d","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/5.gif","hash":"cf43cfcf14bbc7f8e430b74a97eb3b260f16b08c","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/49.gif","hash":"dbf616c5537074ace036340bdddf7948c138c3d7","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/48.gif","hash":"8a8483cd4e3b4b6ac0567eab41c5655ace4b3a81","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/51.gif","hash":"1ef1419f1ba2fd28e7de676ae5c388074646be53","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/52.gif","hash":"b516f6bd28cee1fe34144d897b702989782be4ec","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/54.gif","hash":"75c738c517217f6b09d51ca3036cf54a01891c4d","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/53.gif","hash":"a03f9bbb0202d24d3313286f60ce08b214c013d2","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/55.gif","hash":"c446b5eca2cce1faa7f2147a8b646cc774011de1","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/57.gif","hash":"b797ac8509a8f8bc328b10153e0026449a6139ec","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/56.gif","hash":"a71c1ef36706c4ddf7959c68d6c40920db3efe67","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/6.gif","hash":"697d8f2262c535cd61808a564b21fc10ea93f0db","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/58.gif","hash":"5c70cba8adb0b42c0da4d922498c265e5d8034d7","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/59.gif","hash":"c50da42e6f2ec33112261f46c30e5ea5b4a0f889","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/50.gif","hash":"94a521d4f9a69c4eb59f5bbe673c8803246bdf5e","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/62.gif","hash":"a839a263600c034bb11411a7f762dfa917155d10","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/60.gif","hash":"bdb24b7ec836fbf6c60c4d7ad97d73f041a154a8","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/61.gif","hash":"a5db56b975970ebe7048a5c824604d64559392b9","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/63.gif","hash":"28e9ec7a3882fec8c63dd731b06a9bbcc179aff7","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/65.gif","hash":"93cab4423539955a25d17c83da6aee277a6402aa","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/66.gif","hash":"6efe452b1f7a697db1c654130a9c2b872f528654","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/68.gif","hash":"e779199003a7415a29d50ecf0bbfed04e031f1ab","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/64.gif","hash":"38a537e9ac930736e162be81c13c5f708ff948bd","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/67.gif","hash":"50e2ed8f7773e60ae7d40b612db98554b8277b6e","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/69.gif","hash":"76ac840c5bc5ad44302daa921e7217149576b89e","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/9.gif","hash":"8df9fc1055efeffdb72d499c064c05445adaa9be","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/70.gif","hash":"7c2641bef26579d9f90bdc0b740357527dd6e484","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/71.gif","hash":"c6323d6d6d262011faed18e758e9e83e7b6812b8","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/8.gif","hash":"43baffc48b0fbe649ed920bad713e2ccab9b7344","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/7.gif","hash":"ad4e2ea1864a85f5729a1347c2f8c49fdb3b2def","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/45.gif","hash":"864dfc9b99f5641f6d5a0081dc14d84872c1b3c6","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/css/modules/layim/skin/1.jpg","hash":"f0ba9086fa730c9c80b89f25ff440b740a4b06df","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/css/modules/layim/skin/4.jpg","hash":"e018753c3fbd420f8987e53f8a9fc62428ecc18d","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/css/modules/layim/skin/2.jpg","hash":"ee9e802e6a46b5b698a4d0c36249c0085b192c68","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/css/modules/layim/skin/5.jpg","hash":"a7c37d5401127afeb1ddd930c9ad9f0e3fab3d31","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/css/modules/layim/skin/logo.jpg","hash":"3014e3081d5d4164143936fcf61e7080e81faf38","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/css/modules/layim/skin/3.jpg","hash":"56cd08ca560acd37d377626b1b67cc4947bfe314","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/css/modules/layer/default/icon-ext.png","hash":"ddf2a30ad34bac4e9a1250f29c46ac0823d62a12","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/css/modules/layer/default/loading-0.gif","hash":"ba81388bbac5bc223f94489b97a95a13f3c78e47","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/css/modules/layer/default/loading-1.gif","hash":"49e54acbf5674212195e581848ec0d490282448f","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/css/modules/layim/voice/default.mp3","hash":"18ac4168a61de5cd4a35f814e97365945de94ab0","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/css/modules/layer/default/loading-2.gif","hash":"c641615e851254111e268da42d72ae684b3ce967","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/css/modules/layer/default/icon.png","hash":"fe47ec617507e9ce5f6ce7ac9b179a3c9231882b","modified":1713841041000},{"_id":"public/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1713841041000},{"_id":"public/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1713841041000},{"_id":"public/vendors/jquery@3.6.0/dist/jquery.slim.min.map","hash":"17a9498757f0b358580ffce586bbc97ae897e8d8","modified":1713841041000},{"_id":"public/vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1713841041000},{"_id":"public/css/kr-color-dark.min.css","hash":"e34eae2e3742c82c1d02fe60194e7a53e2311120","modified":1713841041000},{"_id":"public/css/kratosr.min.css","hash":"29e869837e0048ee2c1c18bb0aecabf134f64738","modified":1713841041000},{"_id":"public/js/kr-dark.min.js","hash":"8ff673018b5688e47f89fe461e30bf30abb81c6e","modified":1713841041000},{"_id":"public/js/candy.min.js","hash":"7f17a90d71223ebccd1e7446236a8f820ea812ac","modified":1713841041000},{"_id":"public/js/kratosr.min.js","hash":"7569d604a7ebb178f4d07e0e8a7f276e082541ba","modified":1713841041000},{"_id":"public/js/local-search.min.js","hash":"8ed9ec22fa7a835c9f5f6e96b8368ae912e9afd0","modified":1713841041000},{"_id":"public/css/prismjs.min.css","hash":"6f2def0d76387c908324f38f845516c7f2d559d7","modified":1713841041000},{"_id":"public/js/pjax.min.js","hash":"d01942adc7832b2705b96494261896d392977680","modified":1713841041000},{"_id":"public/css/highlight/light.min.css","hash":"0c2ee23e4f7a443f90b65905e72f1fca3a89137d","modified":1713841041000},{"_id":"public/js/snow.min.js","hash":"91356fb104c7f178f4972e4e709c69cea5d14633","modified":1713841041000},{"_id":"public/css/highlight/night-blue.min.css","hash":"5f298f7125dcf08fed56d393a65b027c447a4c67","modified":1713841041000},{"_id":"public/css/highlight/night-bright.min.css","hash":"a2bbbb95cb63124d0f5bc9c351bcf31455b8ecf8","modified":1713841041000},{"_id":"public/css/highlight/night-eighties.min.css","hash":"eafd77c47ada4f8120d683a66cf486426b260205","modified":1713841041000},{"_id":"public/vendors/qrcode_js@1.0.0/bower.json","hash":"bfceae0aa93856efb11b7b42982f6eb47827cbc5","modified":1713841041000},{"_id":"public/css/highlight/night.min.css","hash":"379e2f99b3b92a710a241f5770ca43237a74238e","modified":1713841041000},{"_id":"public/vendors/qrcode_js@1.0.0/index-svg.html","hash":"3c856315a2467efcd00b278c570fbc7897021d98","modified":1713841041000},{"_id":"public/vendors/qrcode_js@1.0.0/index.html","hash":"7314a123d8a9acbd51321d4f538ba4b36b0673b5","modified":1713841041000},{"_id":"public/vendors/qrcode_js@1.0.0/package.json","hash":"6acacb64a9f64d33725a45caedccd5ebbc09204b","modified":1713841041000},{"_id":"public/vendors/qrcode_js@1.0.0/qrcode.min.js","hash":"2d06c1f823f34c19981c6ae0b0eb0f5861c5e14b","modified":1713841041000},{"_id":"public/vendors/qrcode_js@1.0.0/README.html","hash":"067c801ff5318365b2caddcf66b7afa873e504eb","modified":1713841041000},{"_id":"public/vendors/nprogress@0.2.0/History.html","hash":"576033eb7d1287eeaf5490b6eb3b67bf10a5c660","modified":1713841041000},{"_id":"public/vendors/nprogress@0.2.0/License.html","hash":"3c0164de84ebc7a78d5ec706f718917f38e3d51e","modified":1713841041000},{"_id":"public/vendors/nprogress@0.2.0/Readme.html","hash":"94cbb34616455bc25fb85e95222d618acfc68460","modified":1713841041000},{"_id":"public/vendors/nprogress@0.2.0/component.json","hash":"d4264f50a37fedfe55d6d2aef7c99ab08614be80","modified":1713841041000},{"_id":"public/vendors/nprogress@0.2.0/Notes.html","hash":"b9e3e7915863568cff48a5c4dc9dbddfc88d692d","modified":1713841041000},{"_id":"public/vendors/nprogress@0.2.0/bower.json","hash":"1877b30670d27ff643245d681b3d9abf6651ddb2","modified":1713841041000},{"_id":"public/vendors/nprogress@0.2.0/nprogress.css","hash":"17ca817a091da9dcf5fe0f2f1e1f2eea60a33149","modified":1713841041000},{"_id":"public/vendors/qrcode_js@1.0.0/qrcode.js","hash":"8fa3048613aab15c7f7edc3ac74a84e90375126d","modified":1713841041000},{"_id":"public/vendors/aplayer@1.10.1/dist/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1713841041000},{"_id":"public/vendors/nprogress@0.2.0/nprogress.js","hash":"a7e1146d2021c42e68b599dc8bcc69d44fc31df3","modified":1713841041000},{"_id":"public/vendors/nprogress@0.2.0/package.json","hash":"3818c6a9823f00b3f62c365077764b2567bc9be0","modified":1713841041000},{"_id":"public/vendors/qrcode_js@1.0.0/jquery.min.js","hash":"a8c8a5caf9765b4ccb90d708045518e219a9af5d","modified":1713841041000},{"_id":"public/vendors/aplayer@1.10.1/dist/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1713841041000},{"_id":"public/vendors/disqusjs@1.3.0/dist/disqusjs.css","hash":"0d8ae5946142b17f9a75683c7649cf73d6fdbe17","modified":1713841041000},{"_id":"public/vendors/disqusjs@1.3.0/dist/disqus.js","hash":"b79249dfb619836cfd1251cb3c3d5c603bc55e61","modified":1713841041000},{"_id":"public/vendors/font-awesome@4.7.0/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1713841041000},{"_id":"public/vendors/font-awesome@4.7.0/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1713841041000},{"_id":"public/vendors/gitalk@1.7.2/dist/gitalk.css","hash":"61d71cb30f5f34cbb1f2b5bc469784d6cb908c22","modified":1713841041000},{"_id":"public/vendors/gitment@0.0.3/dist/constants.js","hash":"08f6c79bf52239cbdd457bc0a94df395f578ee07","modified":1713841041000},{"_id":"public/vendors/gitment@0.0.3/dist/gitment.js","hash":"df37d9fe8c1a0a1fb2883e5bcb93f880bb2bbf2e","modified":1713841041000},{"_id":"public/vendors/gitment@0.0.3/dist/gitment.browser.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1713841041000},{"_id":"public/vendors/gitment@0.0.3/dist/utils.js","hash":"df76ada59b1cf94a7ea1d44c56a6624d248b4228","modified":1713841041000},{"_id":"public/vendors/gitment@0.0.3/dist/icons.js","hash":"d303f91799600aa8c7f5f5bb18c652fafac4359d","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/layui.js","hash":"be7bcdcb4eb932f3e700e63584661f19b4139739","modified":1713841041000},{"_id":"public/vendors/jquery@3.6.0/dist/jquery.min.js","hash":"b82d238d4e31fdf618bae8ac11a6c812c03dd0d4","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/layui.all.js","hash":"4fbff21286558e3cb817072d76ae326db4378c6e","modified":1713841041000},{"_id":"public/vendors/jquery@3.6.0/dist/jquery.js","hash":"af32f706407ab08f800c5e697cce92466e735847","modified":1713841041000},{"_id":"public/vendors/jquery@3.6.0/dist/jquery.slim.js","hash":"77ec5d7bdb33634ff7d76837e36f0a7240c21e86","modified":1713841041000},{"_id":"public/vendors/nprogress@0.2.0/test/component.html","hash":"5965cc7f9bb812ada1ffcd6abec39124c20a4ef8","modified":1713841041000},{"_id":"public/vendors/meting@2.0.1/dist/Meting.min.js","hash":"f2b3d20b8bd64ccd031c64628f2b1323078ae324","modified":1713841041000},{"_id":"public/vendors/nprogress@0.2.0/test/test.js","hash":"5c795debb89ec7d35ba1ec1e8ccbab0a7a353d78","modified":1713841041000},{"_id":"public/vendors/jquery@3.6.0/dist/jquery.slim.min.js","hash":"d1c6704e94efe2d465fc161b6381e127d35acd81","modified":1713841041000},{"_id":"public/vendors/twikoo@1.5.11/dist/twikoo.min.js","hash":"e547de978c573d0e7beda7ad74829ce6fef6b058","modified":1713841041000},{"_id":"public/vendors/valine@1.4.18/dist/Valine.min.js","hash":"d081a412c63411a75a3a880ddece65335d1c3ee8","modified":1713841041000},{"_id":"public/vendors/valine@1.4.18/dist/escape.min.js","hash":"4f91bb0e3a71ce6421b303c6c32bb3fb3e751192","modified":1713841041000},{"_id":"public/vendors/valine@1.4.18/dist/detect.min.js","hash":"596d6dcbe379f78a2ec655188d7bfa7182848e03","modified":1713841041000},{"_id":"public/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.css","hash":"e43435fb9eaa918f5b8e35c9e110124b8bd13751","modified":1713841041000},{"_id":"public/vendors/valine@1.4.18/dist/Valine.Pure.min.js","hash":"227fb19caf17f4330ac24cb952af466eeaae5c43","modified":1713841041000},{"_id":"public/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1713841041000},{"_id":"public/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/pageview.js","hash":"ceea6a5a7b83c99ea92cf338ed05f5803ce9a943","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/comment.js","hash":"a3e6d8ccf4e6ba2251487e83b79b580153d2b515","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/waline-meta.css","hash":"4c5e417fb615505112fa87eb466eda52e8a90ec0","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/waline.css","hash":"6722bd03953e1f8c48c3e01b5776a68e5f901928","modified":1713841041000},{"_id":"public/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.js","hash":"27f034e5db8c32e268e2959b9a7c1258d36e4510","modified":1713841041000},{"_id":"public/vendors/bootstrap@3.3.4/dist/js/bootstrap.min.js","hash":"27947c0c0fa837da9bdfdfc36f649c25f54bd1c0","modified":1713841041000},{"_id":"public/vendors/bootstrap@3.3.4/dist/js/npm.js","hash":"e2b7590d6ec1fdac66b01fdf66ae0879f53b1262","modified":1713841041000},{"_id":"public/vendors/bootstrap@3.3.4/dist/css/bootstrap-theme.min.css","hash":"fc6b4268fbd57ad95d2b41a1d4d6866f222fbdb2","modified":1713841041000},{"_id":"public/vendors/bootstrap@3.3.4/dist/css/bootstrap-theme.css","hash":"a22e254bf086bf442a09344afe0e6cf188f5a1d5","modified":1713841041000},{"_id":"public/vendors/bootstrap@3.3.4/dist/js/bootstrap.js","hash":"542cfd539f0cad650342c8cab8baf1cdbcd5fea6","modified":1713841041000},{"_id":"public/vendors/valine@1.4.18/dist/Valine.min.umd.js","hash":"90de88757741f89ad68c8d3765174437454e2303","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/waline.js","hash":"6919aef34a57cb0a4e1b75149124e17816ae71c5","modified":1713841041000},{"_id":"public/vendors/gitment@0.0.3/dist/theme/default.js","hash":"449e59ac4b6b9c66384ee123e1523b5392d684a5","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/legacy.umd.js","hash":"ced943a8fb34fa3810b910f30733ef7a6d9b563c","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/css/layui.mobile.css","hash":"f15da6c149002dd57ea25b8346534c8161c86e3c","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/css/modules/code.css","hash":"d7adeb3ada7c3c069aa6d098f953e0a87cfb49ef","modified":1713841041000},{"_id":"public/vendors/bootstrap@3.3.4/dist/css/bootstrap.min.css","hash":"ed29315e0ffb3f14382431f2724235bf67f44eb3","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/lay/modules/carousel.js","hash":"ff770a94f4e7edd26f4449909e3d72644de83149","modified":1713841041000},{"_id":"public/vendors/bootstrap@3.3.4/dist/css/bootstrap.css","hash":"f2183455571b19311a235bd5aa204e694ade8e94","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/lay/modules/code.js","hash":"31972b8e26aac0f3b1233ad76c45187a39f4d977","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/css/layui.css","hash":"e15327d5c8f4c82909edc97977b277207e01364d","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/lay/modules/flow.js","hash":"b6b4ffe415022a6788767906b837e2894057371b","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/lay/modules/form.js","hash":"6ed3220f5b8cbee7f287ca851dd5d294790281ee","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/lay/modules/colorpicker.js","hash":"0234f7a6eba2238583fe4644c0a247dacd67f73b","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/lay/modules/element.js","hash":"1900e7f8bca28958e0a495731c7b3957ea0157c6","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/lay/modules/laydate.js","hash":"53e871827a2c0bc04ec239e9461a5eb18a309075","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/lay/modules/layedit.js","hash":"ce8c049188c64ec3cd3d302f8e72d0094d85c462","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/lay/modules/layim.js","hash":"c79d7e577901f2ceab86f01f00cc4c26ff1b038e","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/lay/modules/layer.js","hash":"448f76fa3ccfb66a5d86b02cf785f67adf0d8033","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/lay/modules/laytpl.js","hash":"b79191723a99f3e52b56e0afbd183d7338b9cfd4","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/lay/modules/rate.js","hash":"c3a4b2dad9e829afb8cfae69203eef8ede02191b","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/lay/modules/slider.js","hash":"c4e37a45ff9ae08f90492f894d86e7bec7542b26","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/lay/modules/laypage.js","hash":"fec79457cffad05f261ab518e9d69bbebab548f0","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/lay/modules/util.js","hash":"e5e39048df40763ddfff8ec271a6f8070fcb4f4e","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/lay/modules/transfer.js","hash":"e85e366ff7ca8a49d195e149ec971cb6893b8409","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/lay/modules/jquery.js","hash":"36456de559419079e1096890c7e9a97ae1bbf1be","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/lay/modules/upload.js","hash":"8eef1ed175c49a7f09f6ce472a7d12138ed8f8ed","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/lay/modules/tree.js","hash":"5a0c3d9b31a49d8e30e13ef187894d9d07bec69e","modified":1713841041000},{"_id":"public/vendors/valine@1.4.18/dist/plugins/emojis/index.js","hash":"452e66f0b900282eab6f98743592793361ccbc65","modified":1713841041000},{"_id":"public/vendors/valine@1.4.18/dist/plugins/emojis/light.json","hash":"6d6234de38a90d00582d3413239954bb6609e01e","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/lay/modules/mobile.js","hash":"0f82e8ce6b6deb51afdc307f488fb24c6dd02dbc","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/css/modules/layim/html/chatlog.html","hash":"64591e08bb5af1d22e976ba3b3175075c7e6cd12","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/lay/modules/table.js","hash":"3a18563a832e11ae642bf6c2a8634a18768f2dbb","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/css/modules/layim/html/find.html","hash":"ed8e6a3564bb52fc7adc8f19c7be34f25fe97222","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/css/modules/layim/layim.css","hash":"a669bd1141c1df237631738d41f9d0032f4ba0a3","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/css/modules/layim/html/getmsg.json","hash":"15f2e7c561b0de87b8e2ea84682d3bf10f41b6f2","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/css/modules/layim/html/msgbox.html","hash":"521979a7d5b54e6c00dedaa897ae547065da9b2c","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/css/modules/layer/default/layer.css","hash":"ed6fefb1501b3bcd720919f9ce55bb322b5d7ec5","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/css/modules/layim/mobile/layim.css","hash":"0af51b5e2280a03cefcde3e4cf6662d274cc64c6","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/css/modules/laydate/default/laydate.css","hash":"bc0f2f7396ca62c86bc07c2db1b73ca83de3cbdb","modified":1713841041000},{"_id":"public/maps/kratosr.min.css.map","hash":"a36c6cd991e8c539a261bc86cdf39510d85bc3f6","modified":1713841041000},{"_id":"public/vendors/aplayer@1.10.1/dist/APlayer.min.js.map","hash":"31a19da0f0cb6b00ec212eafa847f31af86788df","modified":1713841041000},{"_id":"public/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1713841041000},{"_id":"public/vendors/font-awesome@4.7.0/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1713841041000},{"_id":"public/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1713841041000},{"_id":"public/vendors/jquery@3.6.0/dist/jquery.min.map","hash":"c98b6a5cb27af645c8bfb525fcad3569f3917d5b","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/legacy.umd.js.map","hash":"3f5d438f4128604826d03944bbb158ba19ee2e10","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/component.mjs.map","hash":"a45fac56302df2ee67ff4f074d50a0d84db98868","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/shim.cjs.map","hash":"74229c9c2f85c73ae1082fe49e89bb789845b90b","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/waline.cjs.map","hash":"eff335e17db76d0b1008d534b8e857c90a7a2d03","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/shim.mjs.map","hash":"800a3ce3650dbaeec78783b4c60b4f70d7959b6d","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/waline.cjs","hash":"7e9d8f4500857833f184905bb698eacc9f1d1c64","modified":1713841041000},{"_id":"public/vendors/gitalk@1.7.2/dist/gitalk.min.js","hash":"564fc7c731d05fa70d71ef853a2c8cc7725739e2","modified":1713841041000},{"_id":"public/vendors/twikoo@1.5.11/dist/twikoo.all.min.js","hash":"31c6669a90a33ee5af66ceaf47996ad8fd8b962e","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/waline.js.map","hash":"94be543349586850de68359ce689e792d012876a","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/waline.mjs.map","hash":"2e0fdc9d2c9425c645443bc1d2c2f45e41606faa","modified":1713841041000},{"_id":"public/vendors/@waline/client@2.14.1/dist/waline.mjs","hash":"b709889f62a6df6fd09e423c5999764ea6ef29e8","modified":1713841041000},{"_id":"public/vendors/mermaid@9.1.1/dist/mermaid.core.js","hash":"7952663a721317158468875349956182465b0701","modified":1713841041000},{"_id":"public/vendors/mermaid@9.1.1/dist/mermaid.min.js","hash":"6bee48c26c32b90f50519f125890fcbb04779da6","modified":1713841041000},{"_id":"public/vendors/gitment@0.0.3/dist/gitment.browser.js.map","hash":"72dc603fb7be8b623d1a402419b42c36723367bb","modified":1713841041000},{"_id":"public/vendors/valine@1.4.18/dist/Valine.Pure.min.js.map","hash":"40e15912aae8beff90cbb8ae235cd6fcd36f87dc","modified":1713841041000},{"_id":"public/vendors/valine@1.4.18/dist/Valine.min.umd.js.map","hash":"6fe9ac91ca5074bcbc696f887802e8304e31aaea","modified":1713841041000},{"_id":"public/vendors/gitalk@1.7.2/dist/gitalk-component.js","hash":"fe4c44fa48522e9b2675f3a652d83d8aaec11ad8","modified":1713841041000},{"_id":"public/vendors/layui-src@2.5.5/dist/font/iconfont.svg","hash":"d484cee6f2461c9194b28878a1d1a677ffdbb78c","modified":1713841041000},{"_id":"public/vendors/valine@1.4.18/dist/Valine.min.js.map","hash":"fb6f3071e92d08b0c66808ff9cfd190a0341d93d","modified":1713841041000},{"_id":"public/vendors/gitalk@1.7.2/dist/gitalk.js","hash":"540a80bafeba53826127d556487541332ecd6ed1","modified":1713841041000},{"_id":"public/vendors/bootstrap@3.3.4/dist/css/bootstrap.css.map","hash":"2e1d08a9694cd5a694eabca746cfad95fb99653e","modified":1713841041000},{"_id":"public/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1713841041000},{"_id":"public/vendors/mermaid@9.1.1/dist/mermaid.js","hash":"e1f5d58724700b9cd810bb4e295ac93b6724578d","modified":1713841041000},{"_id":"public/vendors/mermaid@9.1.1/dist/mermaid.esm.min.mjs","hash":"c01a600693e204abd02d0bf056a98a49e8a78d6e","modified":1713841041000},{"_id":"public/vendors/mermaid@9.1.1/dist/mermaid.core.js.map","hash":"1d19d75bea55a0c0062661bb0fe5ad4135f68d8a","modified":1713841041000},{"_id":"public/vendors/gitalk@1.7.2/dist/gitalk-component.js.map","hash":"6f118aa575a5da5449d0c171f1c85fa5e43f80ff","modified":1713841041000},{"_id":"public/vendors/gitalk@1.7.2/dist/gitalk.js.map","hash":"b5d129e59c5a1ca46395fbf7466432983178ebba","modified":1713841041000},{"_id":"public/vendors/mermaid@9.1.1/dist/mermaid.esm.min.mjs.map","hash":"0ad921fcf8f5f79cf5fdf5deb5b4ffc21e501ff0","modified":1713841041000},{"_id":"public/vendors/mermaid@9.1.1/dist/mermaid.min.js.map","hash":"bd1138557833d1ec29ce678d2f994e053f180423","modified":1713841041000},{"_id":"public/vendors/mermaid@9.1.1/dist/mermaid.js.map","hash":"199ed9c41ad0bec69a69514beb6f39f7b3a78ae5","modified":1713841041000},{"_id":"public/vendors/gitalk@1.7.2/dist/gitalk.min.js.map","hash":"6a9f6d47092f2557b346c0eabbd5907a1b12a9e7","modified":1713841041000}],"Category":[],"Data":[],"Page":[],"Post":[{"_content":"\n如何 把 词性标注：这个 概念 连接到 密码的只是 学习 这个领域。\n\n如果要用 专家模型，如何对数据进行分类？分几类？\n","source":"_posts/TEMP：论文思路.md","raw":"\n如何 把 词性标注：这个 概念 连接到 密码的只是 学习 这个领域。\n\n如果要用 专家模型，如何对数据进行分类？分几类？\n","slug":"TEMP：论文思路","published":1,"date":"2024-04-22T13:14:49.407Z","updated":"2024-04-17T13:33:48.681Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf020000kgg44lp5fj0x","content":"<p>如何 把 词性标注：这个 概念 连接到 密码的只是 学习 这个领域。</p>\n<p>如果要用 专家模型，如何对数据进行分类？分几类？</p>\n","excerpt":"","more":"<p>如何 把 词性标注：这个 概念 连接到 密码的只是 学习 这个领域。</p>\n<p>如果要用 专家模型，如何对数据进行分类？分几类？</p>\n"},{"title":"Hello Worldaaaaaaa","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello Worldaaaaaaa\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2024-04-22T08:33:35.137Z","updated":"2024-04-22T13:06:13.945Z","comments":1,"layout":"post","photos":[],"_id":"clvbspf050001kgg468fg2008","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"Hello Worldaaaaaaa","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n# 密码学的诞生和发展\n\n密码学的诞生和发展是一个跨越数千年、涉及多个学科领域的复杂过程。从最初的古典密码学到现代的公钥密码系统，密码学经历了显著的演变和进步。\n\n在古代，人们为了安全通信而采用了一些原始的方法，这些方法包括但不限于代换密码和置换密码7。例如，古罗马人使用凯撒密码（一种简单的替换加密技术），而阿拉伯人在9世纪就已经有了关于密码学的书籍，其中al-Kindī是已知最古老的密码学著作的作者13。这表明密码学的概念至少可以追溯到公元9世纪，而且阿拉伯人在密码学的发展上做出了重要贡献。\n\n进入中世纪，随着通信技术的进步，特别是印刷术的发明，密码学开始逐渐发展成为一个更为系统化的学科。这一时期，密码学主要是一门艺术而非科学，其核心手段主要是代换和置换9。\n\n20世纪初至中期，随着计算机科学和信息论的发展，密码学开始逐渐转变为一门科学。C.E.Shannon的《保密系统的通信理论》标志着现代密码学理论的起点20。Shannon的工作强调了信息理论在设计安全通信系统中的重要性，为后来的密码学研究奠定了理论基础。\n\n随后，W·Diffie和M.E.Hellman的工作进一步推动了密码学的发展，他们提出的公钥密码体制彻底改变了密码学的研究方向20。公钥密码体制的最大特点是使用两个不同但相关的密钥——一个公钥用于加密信息，一个私钥用于解密信息——从而实现了加密和解密能力的分离2。\n\n进入21世纪，随着网络技术的飞速发展和量子计算的兴起，密码学面临着新的挑战和机遇。量子计算机的出现使得传统的加密方法面临被破解的风险，因此研究抗量子攻击的密码体制变得尤为重要2。此外，随着云计算、大数据等新技术的应用，现代密码学也面临着新的需求和挑战，如多方通信模式、异地计算模式等3。\n\n总之，密码学从最初的简单方法发展到今天的复杂系统，经历了从古典密码学到现代密码学的演变过程。这一过程不仅涉及到数学、计算机科学等多个学科领域的知识和技术的进步，还包括对新兴技术应用的需求响应。未来，随着技术的不断进步和社会需求的变化，密码学将继续演化和发展，以应对新的安全挑战。\n# 密码学的应用，重点 office 的加密过程原理\n密码学的应用在Office文件加密过程中扮演着至关重要的角色。随着信息技术的快速发展，信息安全成为了全球性的关注点，尤其是在办公软件中文件的安全性问题10。Microsoft Office作为广泛使用的办公软件，其文件的安全性主要通过加密技术来实现14。自Office97发布以来，Microsoft公司对Office办公软件的文件加密功能进行了不断的改进，但文件加密的安全性仍然难以保证1。\n\n近年来，为了提高Office文档加密的安全性，研究者们提出了使用新的加密算法的方法。例如，2019年的研究讨论了将新的加密算法O'zDSt1105:2009和第一个哈希算法O'zDSt1106:2009应用于Microsoft Office文档加密的方法2。这种方法不仅适用于Microsoft Word 2016，还可以应用于Microsoft Office产品的其他文档，通过设计和实现下一代加密提供者来应用这些新算法，从而提高了加密Microsoft Office文档的相对加密稳定性2。\n\n此外，密码学的基本原理和技术也在不断发展中。现代密码体制主要分为公钥体制和私钥体制两大类12。公钥体制允许公开加密密钥而仅需保密解密密钥，具有数字签名、鉴别等功能，被广泛应用于金融、商业等社会生活各领域12。而私钥体制又称为单钥体制，其加密、解密密钥相同12。这些密码体制的发展和应用，为Office文档加密提供了技术支持。\n\n然而，尽管采用了先进的加密技术，Office文档的加密安全仍然面临挑战。例如，随着计算机速度的快速提升和新解码方法的提出，文档安全性受到了质疑5。此外，网络办公系统存在的安全漏洞也为黑客攻击办公系统提供了机会9。因此，除了采用强大的加密技术外，还需要从计算机技术和网络安全管理两方面入手，解决网络存在的漏洞，制定网络安全策略，以确保在安全可靠的网络环境下进行信息化办公9。\n\n总之，密码学在Office文件加密过程中的应用是多方面的，包括采用新的加密算法提高安全性2、利用公钥和私钥体制进行数据加密和解密12，以及面对安全挑战时采取综合措施保护信息安全9。随着技术的不断进步和安全需求的不断提高，密码学在保障Office文档安全方面的作用将会越来越重要。\n\n# 当前密码破解的研究\n\n\n# 引出本系统","source":"_posts/TEMP：中铁.md","raw":"---\ntitle: Hello Worldaaaaaaa\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n# 密码学的诞生和发展\n\n密码学的诞生和发展是一个跨越数千年、涉及多个学科领域的复杂过程。从最初的古典密码学到现代的公钥密码系统，密码学经历了显著的演变和进步。\n\n在古代，人们为了安全通信而采用了一些原始的方法，这些方法包括但不限于代换密码和置换密码7。例如，古罗马人使用凯撒密码（一种简单的替换加密技术），而阿拉伯人在9世纪就已经有了关于密码学的书籍，其中al-Kindī是已知最古老的密码学著作的作者13。这表明密码学的概念至少可以追溯到公元9世纪，而且阿拉伯人在密码学的发展上做出了重要贡献。\n\n进入中世纪，随着通信技术的进步，特别是印刷术的发明，密码学开始逐渐发展成为一个更为系统化的学科。这一时期，密码学主要是一门艺术而非科学，其核心手段主要是代换和置换9。\n\n20世纪初至中期，随着计算机科学和信息论的发展，密码学开始逐渐转变为一门科学。C.E.Shannon的《保密系统的通信理论》标志着现代密码学理论的起点20。Shannon的工作强调了信息理论在设计安全通信系统中的重要性，为后来的密码学研究奠定了理论基础。\n\n随后，W·Diffie和M.E.Hellman的工作进一步推动了密码学的发展，他们提出的公钥密码体制彻底改变了密码学的研究方向20。公钥密码体制的最大特点是使用两个不同但相关的密钥——一个公钥用于加密信息，一个私钥用于解密信息——从而实现了加密和解密能力的分离2。\n\n进入21世纪，随着网络技术的飞速发展和量子计算的兴起，密码学面临着新的挑战和机遇。量子计算机的出现使得传统的加密方法面临被破解的风险，因此研究抗量子攻击的密码体制变得尤为重要2。此外，随着云计算、大数据等新技术的应用，现代密码学也面临着新的需求和挑战，如多方通信模式、异地计算模式等3。\n\n总之，密码学从最初的简单方法发展到今天的复杂系统，经历了从古典密码学到现代密码学的演变过程。这一过程不仅涉及到数学、计算机科学等多个学科领域的知识和技术的进步，还包括对新兴技术应用的需求响应。未来，随着技术的不断进步和社会需求的变化，密码学将继续演化和发展，以应对新的安全挑战。\n# 密码学的应用，重点 office 的加密过程原理\n密码学的应用在Office文件加密过程中扮演着至关重要的角色。随着信息技术的快速发展，信息安全成为了全球性的关注点，尤其是在办公软件中文件的安全性问题10。Microsoft Office作为广泛使用的办公软件，其文件的安全性主要通过加密技术来实现14。自Office97发布以来，Microsoft公司对Office办公软件的文件加密功能进行了不断的改进，但文件加密的安全性仍然难以保证1。\n\n近年来，为了提高Office文档加密的安全性，研究者们提出了使用新的加密算法的方法。例如，2019年的研究讨论了将新的加密算法O'zDSt1105:2009和第一个哈希算法O'zDSt1106:2009应用于Microsoft Office文档加密的方法2。这种方法不仅适用于Microsoft Word 2016，还可以应用于Microsoft Office产品的其他文档，通过设计和实现下一代加密提供者来应用这些新算法，从而提高了加密Microsoft Office文档的相对加密稳定性2。\n\n此外，密码学的基本原理和技术也在不断发展中。现代密码体制主要分为公钥体制和私钥体制两大类12。公钥体制允许公开加密密钥而仅需保密解密密钥，具有数字签名、鉴别等功能，被广泛应用于金融、商业等社会生活各领域12。而私钥体制又称为单钥体制，其加密、解密密钥相同12。这些密码体制的发展和应用，为Office文档加密提供了技术支持。\n\n然而，尽管采用了先进的加密技术，Office文档的加密安全仍然面临挑战。例如，随着计算机速度的快速提升和新解码方法的提出，文档安全性受到了质疑5。此外，网络办公系统存在的安全漏洞也为黑客攻击办公系统提供了机会9。因此，除了采用强大的加密技术外，还需要从计算机技术和网络安全管理两方面入手，解决网络存在的漏洞，制定网络安全策略，以确保在安全可靠的网络环境下进行信息化办公9。\n\n总之，密码学在Office文件加密过程中的应用是多方面的，包括采用新的加密算法提高安全性2、利用公钥和私钥体制进行数据加密和解密12，以及面对安全挑战时采取综合措施保护信息安全9。随着技术的不断进步和安全需求的不断提高，密码学在保障Office文档安全方面的作用将会越来越重要。\n\n# 当前密码破解的研究\n\n\n# 引出本系统","slug":"TEMP：中铁","published":1,"date":"2024-04-22T13:14:49.444Z","updated":"2024-04-22T13:43:28.745Z","comments":1,"layout":"post","photos":[],"_id":"clvbspf060002kgg40jk06uag","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h1 id=\"密码学的诞生和发展\"><a href=\"#密码学的诞生和发展\" class=\"headerlink\" title=\"密码学的诞生和发展\"></a>密码学的诞生和发展</h1><p>密码学的诞生和发展是一个跨越数千年、涉及多个学科领域的复杂过程。从最初的古典密码学到现代的公钥密码系统，密码学经历了显著的演变和进步。</p>\n<p>在古代，人们为了安全通信而采用了一些原始的方法，这些方法包括但不限于代换密码和置换密码7。例如，古罗马人使用凯撒密码（一种简单的替换加密技术），而阿拉伯人在9世纪就已经有了关于密码学的书籍，其中al-Kindī是已知最古老的密码学著作的作者13。这表明密码学的概念至少可以追溯到公元9世纪，而且阿拉伯人在密码学的发展上做出了重要贡献。</p>\n<p>进入中世纪，随着通信技术的进步，特别是印刷术的发明，密码学开始逐渐发展成为一个更为系统化的学科。这一时期，密码学主要是一门艺术而非科学，其核心手段主要是代换和置换9。</p>\n<p>20世纪初至中期，随着计算机科学和信息论的发展，密码学开始逐渐转变为一门科学。C.E.Shannon的《保密系统的通信理论》标志着现代密码学理论的起点20。Shannon的工作强调了信息理论在设计安全通信系统中的重要性，为后来的密码学研究奠定了理论基础。</p>\n<p>随后，W·Diffie和M.E.Hellman的工作进一步推动了密码学的发展，他们提出的公钥密码体制彻底改变了密码学的研究方向20。公钥密码体制的最大特点是使用两个不同但相关的密钥——一个公钥用于加密信息，一个私钥用于解密信息——从而实现了加密和解密能力的分离2。</p>\n<p>进入21世纪，随着网络技术的飞速发展和量子计算的兴起，密码学面临着新的挑战和机遇。量子计算机的出现使得传统的加密方法面临被破解的风险，因此研究抗量子攻击的密码体制变得尤为重要2。此外，随着云计算、大数据等新技术的应用，现代密码学也面临着新的需求和挑战，如多方通信模式、异地计算模式等3。</p>\n<p>总之，密码学从最初的简单方法发展到今天的复杂系统，经历了从古典密码学到现代密码学的演变过程。这一过程不仅涉及到数学、计算机科学等多个学科领域的知识和技术的进步，还包括对新兴技术应用的需求响应。未来，随着技术的不断进步和社会需求的变化，密码学将继续演化和发展，以应对新的安全挑战。</p>\n<h1 id=\"密码学的应用，重点-office-的加密过程原理\"><a href=\"#密码学的应用，重点-office-的加密过程原理\" class=\"headerlink\" title=\"密码学的应用，重点 office 的加密过程原理\"></a>密码学的应用，重点 office 的加密过程原理</h1><p>密码学的应用在Office文件加密过程中扮演着至关重要的角色。随着信息技术的快速发展，信息安全成为了全球性的关注点，尤其是在办公软件中文件的安全性问题10。Microsoft Office作为广泛使用的办公软件，其文件的安全性主要通过加密技术来实现14。自Office97发布以来，Microsoft公司对Office办公软件的文件加密功能进行了不断的改进，但文件加密的安全性仍然难以保证1。</p>\n<p>近年来，为了提高Office文档加密的安全性，研究者们提出了使用新的加密算法的方法。例如，2019年的研究讨论了将新的加密算法O’zDSt1105:2009和第一个哈希算法O’zDSt1106:2009应用于Microsoft Office文档加密的方法2。这种方法不仅适用于Microsoft Word 2016，还可以应用于Microsoft Office产品的其他文档，通过设计和实现下一代加密提供者来应用这些新算法，从而提高了加密Microsoft Office文档的相对加密稳定性2。</p>\n<p>此外，密码学的基本原理和技术也在不断发展中。现代密码体制主要分为公钥体制和私钥体制两大类12。公钥体制允许公开加密密钥而仅需保密解密密钥，具有数字签名、鉴别等功能，被广泛应用于金融、商业等社会生活各领域12。而私钥体制又称为单钥体制，其加密、解密密钥相同12。这些密码体制的发展和应用，为Office文档加密提供了技术支持。</p>\n<p>然而，尽管采用了先进的加密技术，Office文档的加密安全仍然面临挑战。例如，随着计算机速度的快速提升和新解码方法的提出，文档安全性受到了质疑5。此外，网络办公系统存在的安全漏洞也为黑客攻击办公系统提供了机会9。因此，除了采用强大的加密技术外，还需要从计算机技术和网络安全管理两方面入手，解决网络存在的漏洞，制定网络安全策略，以确保在安全可靠的网络环境下进行信息化办公9。</p>\n<p>总之，密码学在Office文件加密过程中的应用是多方面的，包括采用新的加密算法提高安全性2、利用公钥和私钥体制进行数据加密和解密12，以及面对安全挑战时采取综合措施保护信息安全9。随着技术的不断进步和安全需求的不断提高，密码学在保障Office文档安全方面的作用将会越来越重要。</p>\n<h1 id=\"当前密码破解的研究\"><a href=\"#当前密码破解的研究\" class=\"headerlink\" title=\"当前密码破解的研究\"></a>当前密码破解的研究</h1><h1 id=\"引出本系统\"><a href=\"#引出本系统\" class=\"headerlink\" title=\"引出本系统\"></a>引出本系统</h1>","excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h1 id=\"密码学的诞生和发展\"><a href=\"#密码学的诞生和发展\" class=\"headerlink\" title=\"密码学的诞生和发展\"></a>密码学的诞生和发展</h1><p>密码学的诞生和发展是一个跨越数千年、涉及多个学科领域的复杂过程。从最初的古典密码学到现代的公钥密码系统，密码学经历了显著的演变和进步。</p>\n<p>在古代，人们为了安全通信而采用了一些原始的方法，这些方法包括但不限于代换密码和置换密码7。例如，古罗马人使用凯撒密码（一种简单的替换加密技术），而阿拉伯人在9世纪就已经有了关于密码学的书籍，其中al-Kindī是已知最古老的密码学著作的作者13。这表明密码学的概念至少可以追溯到公元9世纪，而且阿拉伯人在密码学的发展上做出了重要贡献。</p>\n<p>进入中世纪，随着通信技术的进步，特别是印刷术的发明，密码学开始逐渐发展成为一个更为系统化的学科。这一时期，密码学主要是一门艺术而非科学，其核心手段主要是代换和置换9。</p>\n<p>20世纪初至中期，随着计算机科学和信息论的发展，密码学开始逐渐转变为一门科学。C.E.Shannon的《保密系统的通信理论》标志着现代密码学理论的起点20。Shannon的工作强调了信息理论在设计安全通信系统中的重要性，为后来的密码学研究奠定了理论基础。</p>\n<p>随后，W·Diffie和M.E.Hellman的工作进一步推动了密码学的发展，他们提出的公钥密码体制彻底改变了密码学的研究方向20。公钥密码体制的最大特点是使用两个不同但相关的密钥——一个公钥用于加密信息，一个私钥用于解密信息——从而实现了加密和解密能力的分离2。</p>\n<p>进入21世纪，随着网络技术的飞速发展和量子计算的兴起，密码学面临着新的挑战和机遇。量子计算机的出现使得传统的加密方法面临被破解的风险，因此研究抗量子攻击的密码体制变得尤为重要2。此外，随着云计算、大数据等新技术的应用，现代密码学也面临着新的需求和挑战，如多方通信模式、异地计算模式等3。</p>\n<p>总之，密码学从最初的简单方法发展到今天的复杂系统，经历了从古典密码学到现代密码学的演变过程。这一过程不仅涉及到数学、计算机科学等多个学科领域的知识和技术的进步，还包括对新兴技术应用的需求响应。未来，随着技术的不断进步和社会需求的变化，密码学将继续演化和发展，以应对新的安全挑战。</p>\n<h1 id=\"密码学的应用，重点-office-的加密过程原理\"><a href=\"#密码学的应用，重点-office-的加密过程原理\" class=\"headerlink\" title=\"密码学的应用，重点 office 的加密过程原理\"></a>密码学的应用，重点 office 的加密过程原理</h1><p>密码学的应用在Office文件加密过程中扮演着至关重要的角色。随着信息技术的快速发展，信息安全成为了全球性的关注点，尤其是在办公软件中文件的安全性问题10。Microsoft Office作为广泛使用的办公软件，其文件的安全性主要通过加密技术来实现14。自Office97发布以来，Microsoft公司对Office办公软件的文件加密功能进行了不断的改进，但文件加密的安全性仍然难以保证1。</p>\n<p>近年来，为了提高Office文档加密的安全性，研究者们提出了使用新的加密算法的方法。例如，2019年的研究讨论了将新的加密算法O’zDSt1105:2009和第一个哈希算法O’zDSt1106:2009应用于Microsoft Office文档加密的方法2。这种方法不仅适用于Microsoft Word 2016，还可以应用于Microsoft Office产品的其他文档，通过设计和实现下一代加密提供者来应用这些新算法，从而提高了加密Microsoft Office文档的相对加密稳定性2。</p>\n<p>此外，密码学的基本原理和技术也在不断发展中。现代密码体制主要分为公钥体制和私钥体制两大类12。公钥体制允许公开加密密钥而仅需保密解密密钥，具有数字签名、鉴别等功能，被广泛应用于金融、商业等社会生活各领域12。而私钥体制又称为单钥体制，其加密、解密密钥相同12。这些密码体制的发展和应用，为Office文档加密提供了技术支持。</p>\n<p>然而，尽管采用了先进的加密技术，Office文档的加密安全仍然面临挑战。例如，随着计算机速度的快速提升和新解码方法的提出，文档安全性受到了质疑5。此外，网络办公系统存在的安全漏洞也为黑客攻击办公系统提供了机会9。因此，除了采用强大的加密技术外，还需要从计算机技术和网络安全管理两方面入手，解决网络存在的漏洞，制定网络安全策略，以确保在安全可靠的网络环境下进行信息化办公9。</p>\n<p>总之，密码学在Office文件加密过程中的应用是多方面的，包括采用新的加密算法提高安全性2、利用公钥和私钥体制进行数据加密和解密12，以及面对安全挑战时采取综合措施保护信息安全9。随着技术的不断进步和安全需求的不断提高，密码学在保障Office文档安全方面的作用将会越来越重要。</p>\n<h1 id=\"当前密码破解的研究\"><a href=\"#当前密码破解的研究\" class=\"headerlink\" title=\"当前密码破解的研究\"></a>当前密码破解的研究</h1><h1 id=\"引出本系统\"><a href=\"#引出本系统\" class=\"headerlink\" title=\"引出本系统\"></a>引出本系统</h1>"},{"_content":"# 日程安排\n[[今日计划]]\n[[近期计划]]\n\n# 研究\n[[研究]]\n\n\n\n# 工具使用\n[[工具教程]]\n# 环境配置\n\n[[配置：Windows]]\n\n# 语言学习\n\n[[go语言学习记录]]\n\n[[英语学习]]\n\n# 数据收集\n[[数据集]]\n\n# AI 学习\n[[AI 学习]]\n# 日常\n\n[[工作日志]]","source":"_posts/XinKa.md","raw":"# 日程安排\n[[今日计划]]\n[[近期计划]]\n\n# 研究\n[[研究]]\n\n\n\n# 工具使用\n[[工具教程]]\n# 环境配置\n\n[[配置：Windows]]\n\n# 语言学习\n\n[[go语言学习记录]]\n\n[[英语学习]]\n\n# 数据收集\n[[数据集]]\n\n# AI 学习\n[[AI 学习]]\n# 日常\n\n[[工作日志]]","slug":"XinKa","published":1,"date":"2024-04-22T13:14:49.540Z","updated":"2024-03-30T09:30:51.582Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf070003kgg47lct68uc","content":"<h1 id=\"日程安排\"><a href=\"#日程安排\" class=\"headerlink\" title=\"日程安排\"></a>日程安排</h1><p>[[今日计划]]<br>[[近期计划]]</p>\n<h1 id=\"研究\"><a href=\"#研究\" class=\"headerlink\" title=\"研究\"></a>研究</h1><p>[[研究]]</p>\n<h1 id=\"工具使用\"><a href=\"#工具使用\" class=\"headerlink\" title=\"工具使用\"></a>工具使用</h1><p>[[工具教程]]</p>\n<h1 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h1><p>[[配置：Windows]]</p>\n<h1 id=\"语言学习\"><a href=\"#语言学习\" class=\"headerlink\" title=\"语言学习\"></a>语言学习</h1><p>[[go语言学习记录]]</p>\n<p>[[英语学习]]</p>\n<h1 id=\"数据收集\"><a href=\"#数据收集\" class=\"headerlink\" title=\"数据收集\"></a>数据收集</h1><p>[[数据集]]</p>\n<h1 id=\"AI-学习\"><a href=\"#AI-学习\" class=\"headerlink\" title=\"AI 学习\"></a>AI 学习</h1><p>[[AI 学习]]</p>\n<h1 id=\"日常\"><a href=\"#日常\" class=\"headerlink\" title=\"日常\"></a>日常</h1><p>[[工作日志]]</p>\n","excerpt":"","more":"<h1 id=\"日程安排\"><a href=\"#日程安排\" class=\"headerlink\" title=\"日程安排\"></a>日程安排</h1><p>[[今日计划]]<br>[[近期计划]]</p>\n<h1 id=\"研究\"><a href=\"#研究\" class=\"headerlink\" title=\"研究\"></a>研究</h1><p>[[研究]]</p>\n<h1 id=\"工具使用\"><a href=\"#工具使用\" class=\"headerlink\" title=\"工具使用\"></a>工具使用</h1><p>[[工具教程]]</p>\n<h1 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h1><p>[[配置：Windows]]</p>\n<h1 id=\"语言学习\"><a href=\"#语言学习\" class=\"headerlink\" title=\"语言学习\"></a>语言学习</h1><p>[[go语言学习记录]]</p>\n<p>[[英语学习]]</p>\n<h1 id=\"数据收集\"><a href=\"#数据收集\" class=\"headerlink\" title=\"数据收集\"></a>数据收集</h1><p>[[数据集]]</p>\n<h1 id=\"AI-学习\"><a href=\"#AI-学习\" class=\"headerlink\" title=\"AI 学习\"></a>AI 学习</h1><p>[[AI 学习]]</p>\n<h1 id=\"日常\"><a href=\"#日常\" class=\"headerlink\" title=\"日常\"></a>日常</h1><p>[[工作日志]]</p>\n"},{"_content":"这是一个测试文件","source":"_posts/test.md","raw":"这是一个测试文件","slug":"test","published":1,"date":"2024-04-22T12:47:56.511Z","updated":"2024-04-22T12:48:09.761Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf070004kgg42gcr7x1a","content":"<p>这是一个测试文件</p>\n","excerpt":"","more":"<p>这是一个测试文件</p>\n"},{"_content":"","source":"_posts/TEMP：组会铺垫.md","raw":"","slug":"TEMP：组会铺垫","published":1,"date":"2024-04-22T13:14:49.496Z","updated":"2024-03-21T02:36:30.966Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf080005kgg48ykh7e0t","content":"","excerpt":"","more":""},{"_content":"\n# 教程\n\n书籍：[动手学深度学习](https://zh.d2l.ai/index.html)\n\n# 基础知识\n[[机器学习基本概念]]\n[[深度学习基本概念]]\n\n# 常见模型\n[[GAN]]\n[[变分编码器]]\n[[扩散模型]]\n[[大模型入门]]\n\n自注意力机制\n是一种用于处理序列数据的机制，它允许模型在编码一个特定位置的单词时，可以关注到其他位置的单词。在这种机制下，每个单词都会与序列中的其他单词进行交互，以便更好地理解上下文。\n\n在自注意力机制中，输入序列被表示为一个矩阵，其中每一行代表一个输入位置，每列代表该位置对应的特征。\n\n在自注意力机制中，每个输入位置都与其他位置进行交互，并通过计算注意力权重来获取其他位置的信息。这个注意力权重决定了每个位置对其他位置的关注程度，从而可以捕捉到全局的上下文信息。","source":"_posts/人工智能/AI 学习.md","raw":"\n# 教程\n\n书籍：[动手学深度学习](https://zh.d2l.ai/index.html)\n\n# 基础知识\n[[机器学习基本概念]]\n[[深度学习基本概念]]\n\n# 常见模型\n[[GAN]]\n[[变分编码器]]\n[[扩散模型]]\n[[大模型入门]]\n\n自注意力机制\n是一种用于处理序列数据的机制，它允许模型在编码一个特定位置的单词时，可以关注到其他位置的单词。在这种机制下，每个单词都会与序列中的其他单词进行交互，以便更好地理解上下文。\n\n在自注意力机制中，输入序列被表示为一个矩阵，其中每一行代表一个输入位置，每列代表该位置对应的特征。\n\n在自注意力机制中，每个输入位置都与其他位置进行交互，并通过计算注意力权重来获取其他位置的信息。这个注意力权重决定了每个位置对其他位置的关注程度，从而可以捕捉到全局的上下文信息。","slug":"人工智能/AI 学习","published":1,"date":"2024-04-22T13:14:48.974Z","updated":"2024-04-17T13:08:53.012Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf080006kgg41phqcqao","content":"<h1 id=\"教程\"><a href=\"#教程\" class=\"headerlink\" title=\"教程\"></a>教程</h1><p>书籍：<a href=\"https://zh.d2l.ai/index.html\">动手学深度学习</a></p>\n<h1 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h1><p>[[机器学习基本概念]]<br>[[深度学习基本概念]]</p>\n<h1 id=\"常见模型\"><a href=\"#常见模型\" class=\"headerlink\" title=\"常见模型\"></a>常见模型</h1><p>[[GAN]]<br>[[变分编码器]]<br>[[扩散模型]]<br>[[大模型入门]]</p>\n<p>自注意力机制<br>是一种用于处理序列数据的机制，它允许模型在编码一个特定位置的单词时，可以关注到其他位置的单词。在这种机制下，每个单词都会与序列中的其他单词进行交互，以便更好地理解上下文。</p>\n<p>在自注意力机制中，输入序列被表示为一个矩阵，其中每一行代表一个输入位置，每列代表该位置对应的特征。</p>\n<p>在自注意力机制中，每个输入位置都与其他位置进行交互，并通过计算注意力权重来获取其他位置的信息。这个注意力权重决定了每个位置对其他位置的关注程度，从而可以捕捉到全局的上下文信息。</p>\n","excerpt":"","more":"<h1 id=\"教程\"><a href=\"#教程\" class=\"headerlink\" title=\"教程\"></a>教程</h1><p>书籍：<a href=\"https://zh.d2l.ai/index.html\">动手学深度学习</a></p>\n<h1 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h1><p>[[机器学习基本概念]]<br>[[深度学习基本概念]]</p>\n<h1 id=\"常见模型\"><a href=\"#常见模型\" class=\"headerlink\" title=\"常见模型\"></a>常见模型</h1><p>[[GAN]]<br>[[变分编码器]]<br>[[扩散模型]]<br>[[大模型入门]]</p>\n<p>自注意力机制<br>是一种用于处理序列数据的机制，它允许模型在编码一个特定位置的单词时，可以关注到其他位置的单词。在这种机制下，每个单词都会与序列中的其他单词进行交互，以便更好地理解上下文。</p>\n<p>在自注意力机制中，输入序列被表示为一个矩阵，其中每一行代表一个输入位置，每列代表该位置对应的特征。</p>\n<p>在自注意力机制中，每个输入位置都与其他位置进行交互，并通过计算注意力权重来获取其他位置的信息。这个注意力权重决定了每个位置对其他位置的关注程度，从而可以捕捉到全局的上下文信息。</p>\n"},{"_content":"[2023年值得关注的十篇人工智能研究论文 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/675441597)\n\n","source":"_posts/人工智能/AI 最新进展.md","raw":"[2023年值得关注的十篇人工智能研究论文 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/675441597)\n\n","slug":"人工智能/AI 最新进展","published":1,"date":"2024-04-22T13:14:48.974Z","updated":"2024-04-17T13:11:42.609Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf090007kgg45xfc2hgd","content":"<p><a href=\"https://zhuanlan.zhihu.com/p/675441597\">2023年值得关注的十篇人工智能研究论文 - 知乎 (zhihu.com)</a></p>\n","excerpt":"","more":"<p><a href=\"https://zhuanlan.zhihu.com/p/675441597\">2023年值得关注的十篇人工智能研究论文 - 知乎 (zhihu.com)</a></p>\n"},{"_content":"113.54.151.70\nlm lm^985211\nroot root^985211\n\n\n笔记发送。\nhttps://github.com/halo-sigs/obsidian-halo/blob/main/README.zh-CN.md\n\n个人博客\nhttps://github.com/Cyunong/hexo-theme-yilia\n\n\nReplicaChecker ensures region has the best replicas.\nIncluding the following:\nReplica number management.\nUnhealthy replica management, mainly used for disaster recovery of TiKV.\nLocation management, mainly used for cross data center deployment.\nReplicaChecker 确保区域拥有最好的副本。\n包括以下内容：\n副本编号管理。\n不健康副本管理，主要用于 TiKV 的容灾。\n位置管理，主要用于跨数据中心部署。","source":"_posts/随手记.md","raw":"113.54.151.70\nlm lm^985211\nroot root^985211\n\n\n笔记发送。\nhttps://github.com/halo-sigs/obsidian-halo/blob/main/README.zh-CN.md\n\n个人博客\nhttps://github.com/Cyunong/hexo-theme-yilia\n\n\nReplicaChecker ensures region has the best replicas.\nIncluding the following:\nReplica number management.\nUnhealthy replica management, mainly used for disaster recovery of TiKV.\nLocation management, mainly used for cross data center deployment.\nReplicaChecker 确保区域拥有最好的副本。\n包括以下内容：\n副本编号管理。\n不健康副本管理，主要用于 TiKV 的容灾。\n位置管理，主要用于跨数据中心部署。","slug":"随手记","published":1,"date":"2024-04-22T13:14:49.575Z","updated":"2024-04-21T07:10:52.824Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf090008kgg49a7pgqpz","content":"<p>113.54.151.70<br>lm lm^985211<br>root root^985211</p>\n<p>笔记发送。<br><a href=\"https://github.com/halo-sigs/obsidian-halo/blob/main/README.zh-CN.md\">https://github.com/halo-sigs/obsidian-halo/blob/main/README.zh-CN.md</a></p>\n<p>个人博客<br><a href=\"https://github.com/Cyunong/hexo-theme-yilia\">https://github.com/Cyunong/hexo-theme-yilia</a></p>\n<p>ReplicaChecker ensures region has the best replicas.<br>Including the following:<br>Replica number management.<br>Unhealthy replica management, mainly used for disaster recovery of TiKV.<br>Location management, mainly used for cross data center deployment.<br>ReplicaChecker 确保区域拥有最好的副本。<br>包括以下内容：<br>副本编号管理。<br>不健康副本管理，主要用于 TiKV 的容灾。<br>位置管理，主要用于跨数据中心部署。</p>\n","excerpt":"","more":"<p>113.54.151.70<br>lm lm^985211<br>root root^985211</p>\n<p>笔记发送。<br><a href=\"https://github.com/halo-sigs/obsidian-halo/blob/main/README.zh-CN.md\">https://github.com/halo-sigs/obsidian-halo/blob/main/README.zh-CN.md</a></p>\n<p>个人博客<br><a href=\"https://github.com/Cyunong/hexo-theme-yilia\">https://github.com/Cyunong/hexo-theme-yilia</a></p>\n<p>ReplicaChecker ensures region has the best replicas.<br>Including the following:<br>Replica number management.<br>Unhealthy replica management, mainly used for disaster recovery of TiKV.<br>Location management, mainly used for cross data center deployment.<br>ReplicaChecker 确保区域拥有最好的副本。<br>包括以下内容：<br>副本编号管理。<br>不健康副本管理，主要用于 TiKV 的容灾。<br>位置管理，主要用于跨数据中心部署。</p>\n"},{"_content":"[[教程：Obsidian]]\n[[教程：MD 数学公式语法]]\n[[教程：Linux 指令]]\n[[教程：Rime 输入法]]\n[[配置：python 安装文档]]\n[[配置：Linux 系统]]\n[[配置：Windows]]\n","source":"_posts/工具教程/工具教程.md","raw":"[[教程：Obsidian]]\n[[教程：MD 数学公式语法]]\n[[教程：Linux 指令]]\n[[教程：Rime 输入法]]\n[[配置：python 安装文档]]\n[[配置：Linux 系统]]\n[[配置：Windows]]\n","slug":"工具教程/工具教程","published":1,"date":"2024-04-22T13:14:48.751Z","updated":"2024-04-18T12:25:32.967Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf090009kgg48ejybjqj","content":"<p>[[教程：Obsidian]]<br>[[教程：MD 数学公式语法]]<br>[[教程：Linux 指令]]<br>[[教程：Rime 输入法]]<br>[[配置：python 安装文档]]<br>[[配置：Linux 系统]]<br>[[配置：Windows]]</p>\n","excerpt":"","more":"<p>[[教程：Obsidian]]<br>[[教程：MD 数学公式语法]]<br>[[教程：Linux 指令]]<br>[[教程：Rime 输入法]]<br>[[配置：python 安装文档]]<br>[[配置：Linux 系统]]<br>[[配置：Windows]]</p>\n"},{"_content":"\n| 数据集    | 网址                                                                                         |\n| ------ | ------------------------------------------------------------------------------------------ |\n| 密码     | [Index of /passwords/ (skullsecurity.org)](https://downloads.skullsecurity.org/passwords/) |\n| WPA 密码 | https://github.com/berzerk0/Probable-Wordlists/tree/master/Real-Passwords/WPA-Length       |\n| 密码     | https://wiki.skullsecurity.org/index.php/Passwords                                         |\n","source":"_posts/人工智能/数据集.md","raw":"\n| 数据集    | 网址                                                                                         |\n| ------ | ------------------------------------------------------------------------------------------ |\n| 密码     | [Index of /passwords/ (skullsecurity.org)](https://downloads.skullsecurity.org/passwords/) |\n| WPA 密码 | https://github.com/berzerk0/Probable-Wordlists/tree/master/Real-Passwords/WPA-Length       |\n| 密码     | https://wiki.skullsecurity.org/index.php/Passwords                                         |\n","slug":"人工智能/数据集","published":1,"date":"2024-04-22T13:14:49.007Z","updated":"2024-03-21T04:41:19.702Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0a000akgg45abhe3md","content":"<table>\n<thead>\n<tr>\n<th>数据集</th>\n<th>网址</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>密码</td>\n<td><a href=\"https://downloads.skullsecurity.org/passwords/\">Index of &#x2F;passwords&#x2F; (skullsecurity.org)</a></td>\n</tr>\n<tr>\n<td>WPA 密码</td>\n<td><a href=\"https://github.com/berzerk0/Probable-Wordlists/tree/master/Real-Passwords/WPA-Length\">https://github.com/berzerk0/Probable-Wordlists/tree/master/Real-Passwords/WPA-Length</a></td>\n</tr>\n<tr>\n<td>密码</td>\n<td><a href=\"https://wiki.skullsecurity.org/index.php/Passwords\">https://wiki.skullsecurity.org/index.php/Passwords</a></td>\n</tr>\n</tbody></table>\n","excerpt":"","more":"<table>\n<thead>\n<tr>\n<th>数据集</th>\n<th>网址</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>密码</td>\n<td><a href=\"https://downloads.skullsecurity.org/passwords/\">Index of &#x2F;passwords&#x2F; (skullsecurity.org)</a></td>\n</tr>\n<tr>\n<td>WPA 密码</td>\n<td><a href=\"https://github.com/berzerk0/Probable-Wordlists/tree/master/Real-Passwords/WPA-Length\">https://github.com/berzerk0/Probable-Wordlists/tree/master/Real-Passwords/WPA-Length</a></td>\n</tr>\n<tr>\n<td>密码</td>\n<td><a href=\"https://wiki.skullsecurity.org/index.php/Passwords\">https://wiki.skullsecurity.org/index.php/Passwords</a></td>\n</tr>\n</tbody></table>\n"},{"_content":"# 在线差查看 gpu 的配置 \n\n1. 查看GPU 名称\n\tlshw -C display\n2. 在线查看 GPU 配置\n\t[GPU 配置信息](https://www.techpowerup.com/gpu-specs/)\n\n\n# GPU 驱动安装\n\n1. 从NVIDIA官网下载最新的NVIDIA驱动程序。\n\n   从官方网址下进行下载（打开慢把.com换成.cn）\n   [Official Drivers | NVIDIA![icon-default.png?t=N7T8](D:\\Users\\fyn\\Documents\\Note\\Typora\\字典生成\\python文档.assets\\icon-default-17058459398052.png)https://www.nvidia.com/Download/index.aspx?lang=en-us](https://www.nvidia.com/Download/index.aspx?lang=en-us)\n   \n2. 使用root用户登录系统，然后运行以下命令：\n\n\t\\# sh NVIDIA-Linux-x86_64-xxx.run\n\n3. 按照提示完成安装。\n\t1. -no-nouveau-check：安装驱动时禁用nouveau\n\t2. -no-opengl-files：只安装驱动文件，不安装OpenGL文件\n\n安装完成后，您可以使用 nvidia-smi 命令查看 NVIDIA GPU 的状态。\n","source":"_posts/工具教程/教程：GPU 相关.md","raw":"# 在线差查看 gpu 的配置 \n\n1. 查看GPU 名称\n\tlshw -C display\n2. 在线查看 GPU 配置\n\t[GPU 配置信息](https://www.techpowerup.com/gpu-specs/)\n\n\n# GPU 驱动安装\n\n1. 从NVIDIA官网下载最新的NVIDIA驱动程序。\n\n   从官方网址下进行下载（打开慢把.com换成.cn）\n   [Official Drivers | NVIDIA![icon-default.png?t=N7T8](D:\\Users\\fyn\\Documents\\Note\\Typora\\字典生成\\python文档.assets\\icon-default-17058459398052.png)https://www.nvidia.com/Download/index.aspx?lang=en-us](https://www.nvidia.com/Download/index.aspx?lang=en-us)\n   \n2. 使用root用户登录系统，然后运行以下命令：\n\n\t\\# sh NVIDIA-Linux-x86_64-xxx.run\n\n3. 按照提示完成安装。\n\t1. -no-nouveau-check：安装驱动时禁用nouveau\n\t2. -no-opengl-files：只安装驱动文件，不安装OpenGL文件\n\n安装完成后，您可以使用 nvidia-smi 命令查看 NVIDIA GPU 的状态。\n","slug":"工具教程/教程：GPU 相关","published":1,"date":"2024-04-22T13:14:48.752Z","updated":"2024-03-22T01:44:26.089Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0a000bkgg453yd6mqm","content":"<h1 id=\"在线差查看-gpu-的配置\"><a href=\"#在线差查看-gpu-的配置\" class=\"headerlink\" title=\"在线差查看 gpu 的配置\"></a>在线差查看 gpu 的配置</h1><ol>\n<li>查看GPU 名称<br> lshw -C display</li>\n<li>在线查看 GPU 配置<br> <a href=\"https://www.techpowerup.com/gpu-specs/\">GPU 配置信息</a></li>\n</ol>\n<h1 id=\"GPU-驱动安装\"><a href=\"#GPU-驱动安装\" class=\"headerlink\" title=\"GPU 驱动安装\"></a>GPU 驱动安装</h1><ol>\n<li><p>从NVIDIA官网下载最新的NVIDIA驱动程序。</p>\n<p>从官方网址下进行下载（打开慢把.com换成.cn）<br><a href=\"https://www.nvidia.com/Download/index.aspx?lang=en-us\">Official Drivers | NVIDIA<img src=\"D:\\Users\\fyn\\Documents\\Note\\Typora\\字典生成\\python文档.assets\\icon-default-17058459398052.png\" alt=\"icon-default.png?t=N7T8\">https://www.nvidia.com/Download/index.aspx?lang=en-us</a></p>\n</li>\n<li><p>使用root用户登录系统，然后运行以下命令：</p>\n<p> # sh NVIDIA-Linux-x86_64-xxx.run</p>\n</li>\n<li><p>按照提示完成安装。</p>\n<ol>\n<li>-no-nouveau-check：安装驱动时禁用nouveau</li>\n<li>-no-opengl-files：只安装驱动文件，不安装OpenGL文件</li>\n</ol>\n</li>\n</ol>\n<p>安装完成后，您可以使用 nvidia-smi 命令查看 NVIDIA GPU 的状态。</p>\n","excerpt":"","more":"<h1 id=\"在线差查看-gpu-的配置\"><a href=\"#在线差查看-gpu-的配置\" class=\"headerlink\" title=\"在线差查看 gpu 的配置\"></a>在线差查看 gpu 的配置</h1><ol>\n<li>查看GPU 名称<br> lshw -C display</li>\n<li>在线查看 GPU 配置<br> <a href=\"https://www.techpowerup.com/gpu-specs/\">GPU 配置信息</a></li>\n</ol>\n<h1 id=\"GPU-驱动安装\"><a href=\"#GPU-驱动安装\" class=\"headerlink\" title=\"GPU 驱动安装\"></a>GPU 驱动安装</h1><ol>\n<li><p>从NVIDIA官网下载最新的NVIDIA驱动程序。</p>\n<p>从官方网址下进行下载（打开慢把.com换成.cn）<br><a href=\"https://www.nvidia.com/Download/index.aspx?lang=en-us\">Official Drivers | NVIDIA<img src=\"D:\\Users\\fyn\\Documents\\Note\\Typora\\字典生成\\python文档.assets\\icon-default-17058459398052.png\" alt=\"icon-default.png?t=N7T8\">https://www.nvidia.com/Download/index.aspx?lang=en-us</a></p>\n</li>\n<li><p>使用root用户登录系统，然后运行以下命令：</p>\n<p> # sh NVIDIA-Linux-x86_64-xxx.run</p>\n</li>\n<li><p>按照提示完成安装。</p>\n<ol>\n<li>-no-nouveau-check：安装驱动时禁用nouveau</li>\n<li>-no-opengl-files：只安装驱动文件，不安装OpenGL文件</li>\n</ol>\n</li>\n</ol>\n<p>安装完成后，您可以使用 nvidia-smi 命令查看 NVIDIA GPU 的状态。</p>\n"},{"_content":"### 监督学习与无监督学习\n#### 监督学习\n任务：学习一个映射函数，给定任意输入响应做一个好的预测输出。\n本质：学习输入到输出的映射的统计规律。\n常见情景：回归，分类，标注。（区别在于变量的取值类型）\n（1）当输入变量和输出变量均为连续值变量时得到回归任务，它主要用于学习输入变量和输出变量之间的数值映射关系，常见的回归任务有价格预测、趋势预测等，处理回归任务时常用的机器学习模型有最小二乘回归、非线性回归等。\n（2）无论其输入变量为离散值还是连续值，当输出变量为有限个离散值时得到分类任务，分类任务是被人们讨论和应用最广泛的任务，它通常用于分门别类，常见的分类任务有图片类别识别、用户分类、文本分类等，处理分类任务时常用的机器学习模型有：k近邻、朴素贝叶斯、决策树、逻辑斯蒂回归模型、支持向量机、神经网络等。\n（3）当输入变量和输出变量均为变量序列时得到标注任务，它是分类问题的一种推广，用于学习输入序列和输出序列的映射关系，典型的标注任务有自然语言处理中的词性标注、信息抽取等，处理标注任务时常用的机器学习模型有隐马尔科夫模型和条件随机场等\n##### 分类\n监督学习是学习一个模型，然后利用该模型对给定的输入预测相应的输出，我们可将模型写成函数形式 Y=f(X) 或条件概率分布形式 P(Y|X) 。\n###### 判别模型&生成模型：根据条件概率的计算方式\n1. [[判别模型]]\n\t1. 建模方式：直接对 P(Y|X)  进行建模，它试图描述在给定输入特征 X 的情况下，标签信息 Y 的分布，\n\t2. 典型判别模型包括： 近邻法、感知机、决策树、逻辑回归和条件随机场等。\n\t3. 评价：判别模型对条件概率模型直接建模，无法反映训练数据本身的概率特性，但是以分类问题为例，判别模型在寻找最优分类面的过程中，学习了不同类别数据之间的差异。另外，判别模型可以对数据进行各种程度上的抽象、降维，因此可以简化学习问题，学习准确率更高。\n2. [[生成模型]]\n\t1. 对数据特征 X 和标签 Y 的联合分布 p(X,Y) 进行建模，然后利用条件概率公式，即可计算 p(Y|X) ，如下所示:\n\t\t$p(Y|X) = \\frac {p(X,Y)}{p(X)}$\n\t\t一般将其转换为易为计算的方式，如下所示\n\t\t$p(Y|X) = \\frac {p(X|Y)*p(Y)}{p(X)}$\n\t2. 举例：朴素贝叶斯方法和隐马尔科夫模型等。\n\t\t1. 在朴素贝叶斯方法中，我们通过训练集学习到先验概率分布 p(Y) 和条件概率分布 p(Y|X)，则可得到联合概率分布 p(X,Y)；\n\t\t2. 隐马尔可夫模型中，我们通过训练集学习到初始概率分布、状态转移概率矩阵和观测概率矩阵，则得到了一个可以表示状态序列与观测序列联合分布的马尔可夫模型。\n\t3. 评价：生成模型直接学习联合分布，可以更好地表示数据的分布，更好反映同类数据的相似度。当样本数量比较大时，生成模型往往可以更好地收敛到真实模型上，其收敛速度快。另外，生成模型可以处理含有隐变量的情况，而判别模型对此无能为力。生成模型也可以通过计算边缘分布而检测某些异常值。但实践中，生成模型计算开销一般比较大，而且多数情况下其效果不如判别模型。\n\n\n#### 无监督学习\n和监督学习比较：\n1. 无监督学习和监督学习最大的区别就是标签的有无。在监督学习中，训练模型的任务是学习输入特征到标签的映射，\n2. 而无监督学习中只有样本的特征向量，故无监督学习的任务是对数据进行深入“挖掘”，其本质是学习数据中的统计规律或潜在结构。对于无监督学习的深入研究对深度学习的复兴上起到了关键的作用。\n3. 相比于无监督学习除了拥有额外的标签信息外，还需要有测试样本。机器学习模型在训练集中学习“规律”，然后对测试集使用这种“规律”来评价模型的效果，而无监督学习不需要测试样本，整个过程只需要训练集的参与。\n4. 另外，无监督学习相比于监督学习一般拥有更好的拓展性，它在完成训练目标的同时，通常还额外学习到了样本的表示，我们可以将这些表示直接用于其他的任务。\n常见任务：降维、聚类、概率模型估计。\n（1）降维任务主要用于处理数据的高维度问题，真实数据的特征维度过大容易造成模型的拟合度与可用性降低，我们可以通过降维算法对高维度数据进行“压缩”使之变成低维度向量，从而提高数据的可用性，常用的算法有主成分分析、因子分析、隐含狄利克雷分布等，包括早期的自编码器也可用于数据降维。\n（2）聚类任务主要将样本依据一定的规则进行类别分配，即通过衡量样本之间的距离、密度等指标，将关系“近”的样本聚为同一类，以此实现样本的自动分类，常用的算法有层次聚类、k-means聚类、谱聚类等。\n （3）在概率模型估计任务中，对于一个可以生成样本的概率模型，我们使用样本对概率模型的结构、参数进行学习，使得概率模型生成的样本与训练样本最相似。其中一种比较简单的概率密度估计任务便是对随机变量的概率密度函数进行学习，常用的算法有极大似然估计、对抗生成网络、变分自编码器等，这部分内容非常丰富。\n \n#### 半监督学习\n 半监督学习是介于监督学习和无监督学习的一种方式，即只有小部分训练样本带有标签信息，而大多数训练样本的标签信息空缺。半监督学习包括直推和归纳两类模式，直推半监督学习只对给定的训练数据进行处理，它使用训练数据集中有类别标签和无类别标签的样本进行训练，预测其中无标签样本的标签信息；归纳半监督学习不仅预测训练数据集中无标签样本的标签，更主要的是预测未知样本的标签，两者的区别在于需要预测标签的样本是否出现在训练集中。半监督学习一般用于四类学习场景：半监督分类、半监督回归、半监督聚类、半监督降维等。\n \n\n### 上下文无关语法\n上下文无关语法（Context-Free Grammar）和概率上下文无关语法（Probabilistic Context-Free Grammar）的概念。\n\n上下文无关语法是一种形式语言描述方法，用于定义一类语言的语法结构。它由一组产生式规则组成，每个规则包含一个非终结符和一个由非终结符和终结符组成的字符串。其中，α是一个单变量，表示非终结符，而β是由变量或最终值组成的字符串。这些产生式规则定义了从一个起始样本开始，通过替换非终结符，逐步生成包含所有最终值的字符串集合。上下文无关语法的特点是，无论α出现在哪个上下文中，都可以自由地用β替换，而不需要考虑α的上下文。\n\n概率上下文无关语法是在上下文无关语法的基础上引入了概率特性。每个产生式规则都被赋予一个概率值，表示该规则被应用的概率。这样，概率上下文无关语法可以用于建模具有统计特性的语言。例如，在自然语言处理中，可以使用概率上下文无关语法来生成句子或解析句子的结构，并为每个规则分配适当的概率。\n\n总结来说，上下文无关语法是一种用于描述语言的语法结构的方法，其中产生式规则定义了从起始样本开始生成所有最终值的字符串。概率上下文无关语法在上下文无关语法的基础上引入了概率特性，使其适用于建模具有统计特性的语言。\n\n### 多视图学习\n多视图学习（Multi-view Learning）是一种机器学习方法，旨在利用来自多个视图或多个特征表示的数据来改善学习性能。在多视图学习中，数据样本可以从不同的视角或特征空间中获取多个不同的表示。通过综合这些多个视图的信息，多视图学习可以提供更全面和准确的数据描述，从而改善模型的泛化能力和学习结果。\n\n传统的机器学习方法通常假设数据特征是从单个视图或特征空间中提取的，因此忽略了不同视图之间的相关性和互补性。而多视图学习则通过融合多个视图的信息来克服这个限制。它可以应用于各种领域和任务，如模式识别、图像处理、文本分类、推荐系统等。\n\n多视图学习的关键挑战是如何有效地利用不同视图之间的相关性。常见的多视图学习方法包括以下几种：\n\n1. 基于特征融合的方法：将不同视图的特征进行融合，生成一个更综合和丰富的特征表示。常见的融合方法包括特征级融合、决策级融合和模型级融合等。\n    \n2. 基于共享表示学习的方法：通过学习一个共享的低维表示空间，将不同视图的数据映射到该共享空间中。这样可以使不同视图之间的相关性更加明显，便于后续的学习和推理。\n    \n3. 基于多示例学习的方法：将多个视图看作是一个示例的不同表示，通过多示例学习的方式来进行模型训练和预测。这种方法适用于存在不完全标注的数据集，其中每个示例可能有多个视图的表示。\n    \n\n多视图学习方法可以提供更全面和准确的数据建模，从而改善学习性能。它可以利用不同视图的互补信息，提取更丰富的特征表示，并减少数据表示的不确定性。这使得多视图学习成为处理复杂数据和提高模型性能的有效工具。\n\n### 随机投影（SimHash）\n\nTODO：[https://zhuanlan.zhihu.com/p/92155250](https://zhuanlan.zhihu.com/p/92155250)\n\n1. **SimHash 算法**：SimHash 是一种用于计算文本或数据的哈希值的算法。它的主要思想是将文本或数据转换为二进制向量，其中相似的文本或数据会产生相似的哈希值。这种相似性哈希算法被广泛应用于文本去重、相似文档聚类和相似性搜索等任务。\n    \n2. **随机投影**：随机投影是一种降维技术，用于将高维数据映射到低维空间。在随机投影 SimHash 中，通过使用随机生成的投影矩阵将高维特征向量映射到低维二进制码。\n    \n3. **哈希函数**：随机投影 SimHash 使用哈希函数来将投影后的低维向量转换为二进制码。常用的哈希函数是符号哈希函数，它根据投影后的特征向量的符号（正负）来决定对应二进制码的取值（0 或 1）。\n    \n4. **相似性匹配**：通过计算 SimHash 值之间的汉明距离（Hamming Distance），可以判断文本或数据之间的相似性。汉明距离是指两个等长字符串之间相对位置不同的字符的个数。汉明距离越小，表示文本或数据之间越相似。\n    \n\n### 线性特征 & 非线性特征\n\n1. 线性特征：特征和目标的关系可以用一条直线来拟合。\n    \n2. 非线性特征：特征和目标之间的关系不可以用一条直线来拟合\n    \n\n### 弱分类器 & 强分类器\n\n1. 弱分类器：准确率在 60% ~80%之间，即：比随即预测好，但是准确率不高。e.g. CART（分类与回归树）\n    \n2. 强分类器：准确率在90%以上。\n    \n\n### 分类任务 & 回归任务\n\n1. 分类任务（Classification）\n    \n    1. 目标：将输入实例分配到预定义的类别中。\n        \n    2. 过程：模型通过学习输入特征与响应类别之间的关系，来预测新的未知示例所属类别。\n        \n    3. 输出：输出是离散的，通常是表示类别的标签或类别的概率分布。\n        \n2. 回归任务（Regression）\n    \n    1. 目标：预测连续的数值输出。\n        \n    2. 过程：模型通过学习输入特征与响应输出值之间的关系，来预测新的未知示例的数值结果。\n        \n    3. 输出：这是一个连续的数值输出。\n        \n\n注意：有些机器学习算法可以同时用于分类和回归任务，例如决策树和支持向量机等。这些算法可以根据任务的要求进行适当的调整和配置。\n\n### LR、DT、SVM的对比\n\n1. 所谓分类问题就是在特征空间内寻找决策边界线。而三种算法决定了生成的边界线的不同形状。\n    \n2. 如何在多维特征空间中选择合适的算法：\n    \n    1. 先选逻辑回归，如果效果不怎么样，可以将它的结果作为基准来参考\n        \n    2. 试试决策树（随机森林）是否可以大幅度提升模型性能。即使没有把它当作最终模型，也可以使用随机森林来移除噪声变量。\n        \n    3. 如果特征的数量和观测样本特别多，那么当资源和时间充足时，使用SVM不失为一种选择。\n        \n\n### 逻辑回归（Logistic Regression）\n\n1. 目的：解决分类问题。\n    \n2. 核心：特征权重的线性组合、sigmoid 函数的计算和损失函数的最小化。\n    \n3. 特点：逻辑回归的决策边界总是一条直线（或者一个平面，在更高维度上是超平面）。\n    \n4. 优势：\n    \n    1. 适用于处理接近线性可分的分类问题。\n        \n    2. 结果不是一个离散值或者确切的类别。而是一个与每个观测样本相关的概率列表，所以可以用不同的标准和常用的性能指标来分析这个概率分数，得到不同的分类结果。\n        \n    3. 时间和内存需求上相当高效。可以用于分布式数据，用较少的资源处理大型数据\n        \n        > 低内存消耗：逻辑回归模型只需要存储特征权重，而不需要存储大量的训练数据。相比之下，其他复杂的模型（如神经网络）可能需要存储大量的中间参数和计算图，导致更高的内存消耗。\n        \n    4. 对数据中小噪声的棒鲁性很好。\n        \n    5. 逻辑回归广泛应用于工业问题上。\n        \n5. 地位：解决工业规模问题最流行的算法\n    \n6. 缺点：\n    \n    1. 在效率和算法实现的易用性方面并不出众。\n        \n    2. 当特征数目很大并且还丢失了大部分数据时，逻辑回归就会表现的力不从心。\n        \n    3. 当类别变量过多时也会力不从心\n        \n    4. 对于非线性特征，需要进行转换。\n        \n    5. 依赖于全部数据。\n        \n\n### 决策树（Decisoin Trees）\n\n1. 目的：解决分类问题 & 逻辑回归问题。\n    \n2. 结构：按照层次结构的规则生成的。\n    \n3. 特性：对单向变换或者非线性特征并不关心。(不需要变换来捕获数据中的非线性相关性，可以用他的划分方式自适应处理非线性关系)。\n    \n    > 单向变换：如指数、对数变换。\n    \n4. 优势：如果边界是非线性的，并且能通过不断将特征空间分为矩形来模拟，那么决策树是比逻辑回归更好的选择。\n    \n    1. 直观的决策规则；\n        \n    2. 可以处理非线性特征；\n        \n    3. 考虑了变量之间的相互作用；\n        \n5. 缺点：\n    \n    1. 训练集上的效果高于测试集，即过拟合【随机森林克服了此缺点】；\n        \n    2. 没有将排名分数作为直接结果；\n        \n6. 针对离散数据的分类决策树\n    \n    1. 定义：预测任务的输入和输出都是离散值\n        \n    2. 例子：ID3、C4.5\n        \n    3. 原始决策树：不断选择，优先选择信息熵最小的特征进行分组\n        \n        > 信息熵：越大，表示特征的信息量越大，越离散，按照这个特征分组之后，样本的混乱程度越大。e.g. 特征某个水平的值出现的概率与取对数的积和。\n        \n    4. ID3：使用信息增益来度量特征对分类的帮助大小\n        \n        > 信息增益：使用一个特征对数据进行分组之后各组样本的有序程度会更高，熵会降低，分组前后熵的差值就是这个特征带来的信息增益。信息增益越大，说明这个特征越有助于分组。分组之前算一次，分组之后算一次。\n        \n    5. C4.5 算法：在信息增益的基础上构造了一个新的特征质量度量指标：信息中增益比\n        \n        > 信息增益比：按照性别划分之后对成年的的信息增益/分组之前对性别的信息增益\n        \n    \n\n### 支持向量机（Support Vector Machine,SVM）\n\n1. 目的：解决分类问题 & 逻辑回归问题\n    \n2. 特点：依靠边界样本来建立需要的分离曲线。它可以处理非线性决策边界。（对边界依赖）\n    \n3. 结构：把特征空间映射到核空间，使得各个类别线性可分。把特征空间又增加一个维度。\n    \n    > 1. **核函数**：SVM使用核函数来将输入特征映射到高维特征空间，从而使得原本在低维空间中非线性可分的问题在高维空间中变得线性可分。核函数的作用是通过计算样本在高维空间中的内积来隐式地表示非线性特征之间的相互作用。常用的核函数包括多项式核函数、高斯核函数（径向基函数）等。\n    >     \n    > 2. **大间隔原则**：SVM的优化目标是找到一个最大间隔的超平面来划分不同类别的样本。通过最大化间隔，SVM能够在特征空间中找到一条边界，使得不同类别的样本尽可能分开。这种大间隔原则使得SVM对于非线性特征之间的相互作用更加鲁棒，能够更好地处理非线性关系。\n    >     \n    > 3. **非线性核函数**：除了线性核函数，SVM还可以使用非线性核函数，如多项式核函数和高斯核函数。这些核函数能够捕捉非线性特征之间的相互作用，将数据映射到高维特征空间中，并在高维空间中构建一个线性超平面来进行分类。这样，SVM能够处理非线性特征之间的相互作用，提高模型的表达能力。\n    >     \n    \n4. 优点\n    \n    1. 能够处理大型特征空间\n        \n    2. 能够处理非线性特征之间的相互作用\n        \n    3. 无需依赖整个数据\n        \n5. 缺点：\n    \n    1. 当观测样本很多时，效率并不是很高\n        \n    2. 有时候很难找到一个合适的核函数\n        \n\n### 分类与回归树（Classification and Regression Tree,CART）\n\n1. 概念：一种经典决策树，可以用来处理涉及连续数据的分类或者回归任务。\n    \n2. 思想：一些学者采用类似随机投影的思路，将自变量的取值空间切分为若干个碎块，并假设这个空间碎块内的所有样本的因变量取值接近(甚至相同)——在这种思想的指导下，出现了一种非常经典的回归模型，即CART回归树。\n    \n3. 由来：\n    \n    1. 特征为连续变量：不能直接使用特征取值，选择用于分割样本的特征取值\n        \n    2. 输出为连续变量：基尼系数和信息增益并不能作为分组质量的表征。使用！回归树！\n        \n4. 关键：设计一个标准，用来指导机器按照最有利于准确计算因变量的情况来切分特征空间。\n    \n    1. e.g.:切分特征空间的标准：MES\n        \n5. 代码：[https://github.com/lipengyuer/DataScience/blob/master/src/algoritm/CARTRegression.py](https://github.com/lipengyuer/DataScience/blob/master/src/algoritm/CARTRegression.py)\n    \n\n### 集成学习\n\n概念：通过组合多个基本模型的预测结果，以获得更好的整体预测性能。\n\n目的：组合多个弱分类器或者回归器来创建一个强分类器或者回归器。\n\n1. bagging\n    \n    通过对原数据集的抽样，得到多份采样数据集，使用弱学习器分别在这多份采样数据集上学习， 而后使用集成策略将结果整合起来（e.g. 分类问题用投票法，回归问题用加权法） e.g. 随机森林（Random Forest）\n    \n2. stacking\n    \n    使用不同的学习方法学习同一份数据，得到多个学习器， 而后使用另一个学习器，学习以上多个学习器的输出到真实标签的映射 boosting 按序处理多个弱学习器，排在后的学习器重点学习排在前的学习器无法处理好的那些数据 e.g. Ada\n    \n3. Boost\n    \n    一个学习器学完后，根据其对数据集分类的正确与否，调整下一个学习器学习时，数据集各条数据被采样到的概率，达成调整数据集分布的作用。而后多个学习器按照各自的正确率集成在一\n    \n\n### 随机森林\n\n1. 是决策树一个非常优秀的扩展，同时也剥夺了商业规则和易解释性。\n    \n    1. 树很多，使用多数投票规则使得模型变得更加复杂，\n        \n    2. 决策树变量之间也存在相互作用。\n        \n\n\n### 变分贝叶斯方法\n\n参考：[Variational Bayesian methods](https://en.wikipedia.org/wiki/Variational_Bayesian_methods)\n变分贝叶斯方法是一系列用于逼近贝叶斯推理和机器学习中出现的棘手积分的技术。它们通常用于由观察变量（通常称为“数据”）以及未知参数和潜在变量组成的复杂统计模型，这三种类型的随机变量之间具有各种关系，正如图形模型所描述的那样。正如贝叶斯推理中的典型情况一样，参数和潜在变量被分组为“未观察到的变量”。变分贝叶斯方法主要用于两个目的：\n1. 为未观测变量的后验概率提供分析近似，以便对这些变量进行统计推断。\n2. 导出观察数据的边际可能性（有时称为证据）的下限（即给定模型的数据的边际概率，对未观察的变量进行边缘化）。这通常用于执行模型选择，一般思想是给定模型的边际，可能性较高表明该模型对数据的拟合更好，因此所讨论的模型是生成数据的模型的概率更大。 （另请参阅贝叶斯因子文章。）\n。。。。。\n\n### 拉普拉斯平滑\n（Laplace smoothing），也称为加一平滑（Add-One smoothing），是一种用于处理概率估计中的零概率问题的技术。它是一种简单而常用的平滑方法，可用于解决在计算概率时可能出现的数据稀疏性和零概率的情况。\n\n在概率估计中，当我们根据样本数据计算事件的概率时，有时会遇到某些事件在样本中未出现的情况，导致概率估计为零。这在实际应用中可能不太合理，因为我们不能简单地认为未观察到的事件的概率为零。\n\n拉普拉斯平滑通过在计算概率时为每个事件的计数值（或频率）增加一个常数（通常为1），来解决零概率问题。这个常数被称为平滑因子或平滑参数。通过这种方法，即使某个事件在样本中未出现，它的概率仍然会被估计为一个非零值。\n\n拉普拉斯平滑的概率估计公式如下：  \nP(x) = (count(x) + 1) / (N + V)\n\n其中，P(x)表示事件x的平滑概率，count(x)表示在样本中观察到事件x的次数，N表示总观测次数，V表示事件的可能取值数量（即事件的种类数）。\n\n应用方面，拉普拉斯平滑广泛用于自然语言处理（NLP）中的语言模型，特别是n-gram语言模型。在n-gram模型中，用于估计概率的数据通常是文本中的n个连续词语序列。拉普拉斯平滑可以解决在计算概率时可能出现的未观察到的n-gram序列的问题，提高语言模型的鲁棒性和泛化能力。\n\n除了语言模型，拉普拉斯平滑还可以应用于其他概率估计问题，如朴素贝叶斯分类器、信息检索中的查询扩展和推荐系统等。它可以有效地处理数据稀疏性问题，并提供更合理的概率估计结果。\n\n### 强化学习\n当谈到强化学习（Reinforcement Learning，RL）时，我们在机器学习中讨论的是一种范例和方法。它主要用于描述和解决智能代理与环境交互的学习问题，目标是通过学习一种策略或行为序列来最大化累积的回报或实现特定目标。\n\n在强化学习中，我们有一个智能代理（agent），它根据环境的状态（state）选择动作（action），并与环境进行交互。环境会根据代理采取的动作以及当前的状态，返回给代理一个奖励信号（reward）和下一个状态。代理的目标是通过与环境的交互，通过尝试和错误的方式来学习一个最佳策略，以使得长期累积的回报最大化。\n\n在强化学习中，代理通过学习价值函数（value function）或策略函数（policy function）来指导其决策过程。价值函数可以评估给定状态或状态动作对的价值，而策略函数定义了在给定状态下选择动作的方式。代理通过与环境的交互不断更新这些函数，以改进其决策能力。\n\n强化学习的一个重要概念是探索（exploration）与利用（exploitation）的权衡。探索是指代理通过尝试新的动作来发现更多的知识，而利用是指代理根据已知信息选择最优动作以获得最大回报。强化学习算法需要在探索和利用之间找到平衡，以达到最佳的学习效果。\n\n总结起来，强化学习是一种机器学习方法，用于解决智能代理与环境交互的学习问题。代理通过学习策略或行为序列来最大化累积回报或实现特定目标。在这个过程中，代理通过与环境的交互不断更新价值函数和策略函数，以改进其决策能力。探索与利用的权衡是强化学习中需要解决的重要问题之一。\n\n\n\n### 参考资料：\n\n1. [https://www.jianshu.com/p/743cf2357b28](https://www.jianshu.com/p/743cf2357b28)\n    \n2. [https://zhuanlan.zhihu.com/p/53183016](https://zhuanlan.zhihu.com/p/53183016)\n    \n3. CART回归：[https://zhuanlan.zhihu.com/p/128472955](https://zhuanlan.zhihu.com/p/128472955)","source":"_posts/人工智能/机器学习基本概念.md","raw":"### 监督学习与无监督学习\n#### 监督学习\n任务：学习一个映射函数，给定任意输入响应做一个好的预测输出。\n本质：学习输入到输出的映射的统计规律。\n常见情景：回归，分类，标注。（区别在于变量的取值类型）\n（1）当输入变量和输出变量均为连续值变量时得到回归任务，它主要用于学习输入变量和输出变量之间的数值映射关系，常见的回归任务有价格预测、趋势预测等，处理回归任务时常用的机器学习模型有最小二乘回归、非线性回归等。\n（2）无论其输入变量为离散值还是连续值，当输出变量为有限个离散值时得到分类任务，分类任务是被人们讨论和应用最广泛的任务，它通常用于分门别类，常见的分类任务有图片类别识别、用户分类、文本分类等，处理分类任务时常用的机器学习模型有：k近邻、朴素贝叶斯、决策树、逻辑斯蒂回归模型、支持向量机、神经网络等。\n（3）当输入变量和输出变量均为变量序列时得到标注任务，它是分类问题的一种推广，用于学习输入序列和输出序列的映射关系，典型的标注任务有自然语言处理中的词性标注、信息抽取等，处理标注任务时常用的机器学习模型有隐马尔科夫模型和条件随机场等\n##### 分类\n监督学习是学习一个模型，然后利用该模型对给定的输入预测相应的输出，我们可将模型写成函数形式 Y=f(X) 或条件概率分布形式 P(Y|X) 。\n###### 判别模型&生成模型：根据条件概率的计算方式\n1. [[判别模型]]\n\t1. 建模方式：直接对 P(Y|X)  进行建模，它试图描述在给定输入特征 X 的情况下，标签信息 Y 的分布，\n\t2. 典型判别模型包括： 近邻法、感知机、决策树、逻辑回归和条件随机场等。\n\t3. 评价：判别模型对条件概率模型直接建模，无法反映训练数据本身的概率特性，但是以分类问题为例，判别模型在寻找最优分类面的过程中，学习了不同类别数据之间的差异。另外，判别模型可以对数据进行各种程度上的抽象、降维，因此可以简化学习问题，学习准确率更高。\n2. [[生成模型]]\n\t1. 对数据特征 X 和标签 Y 的联合分布 p(X,Y) 进行建模，然后利用条件概率公式，即可计算 p(Y|X) ，如下所示:\n\t\t$p(Y|X) = \\frac {p(X,Y)}{p(X)}$\n\t\t一般将其转换为易为计算的方式，如下所示\n\t\t$p(Y|X) = \\frac {p(X|Y)*p(Y)}{p(X)}$\n\t2. 举例：朴素贝叶斯方法和隐马尔科夫模型等。\n\t\t1. 在朴素贝叶斯方法中，我们通过训练集学习到先验概率分布 p(Y) 和条件概率分布 p(Y|X)，则可得到联合概率分布 p(X,Y)；\n\t\t2. 隐马尔可夫模型中，我们通过训练集学习到初始概率分布、状态转移概率矩阵和观测概率矩阵，则得到了一个可以表示状态序列与观测序列联合分布的马尔可夫模型。\n\t3. 评价：生成模型直接学习联合分布，可以更好地表示数据的分布，更好反映同类数据的相似度。当样本数量比较大时，生成模型往往可以更好地收敛到真实模型上，其收敛速度快。另外，生成模型可以处理含有隐变量的情况，而判别模型对此无能为力。生成模型也可以通过计算边缘分布而检测某些异常值。但实践中，生成模型计算开销一般比较大，而且多数情况下其效果不如判别模型。\n\n\n#### 无监督学习\n和监督学习比较：\n1. 无监督学习和监督学习最大的区别就是标签的有无。在监督学习中，训练模型的任务是学习输入特征到标签的映射，\n2. 而无监督学习中只有样本的特征向量，故无监督学习的任务是对数据进行深入“挖掘”，其本质是学习数据中的统计规律或潜在结构。对于无监督学习的深入研究对深度学习的复兴上起到了关键的作用。\n3. 相比于无监督学习除了拥有额外的标签信息外，还需要有测试样本。机器学习模型在训练集中学习“规律”，然后对测试集使用这种“规律”来评价模型的效果，而无监督学习不需要测试样本，整个过程只需要训练集的参与。\n4. 另外，无监督学习相比于监督学习一般拥有更好的拓展性，它在完成训练目标的同时，通常还额外学习到了样本的表示，我们可以将这些表示直接用于其他的任务。\n常见任务：降维、聚类、概率模型估计。\n（1）降维任务主要用于处理数据的高维度问题，真实数据的特征维度过大容易造成模型的拟合度与可用性降低，我们可以通过降维算法对高维度数据进行“压缩”使之变成低维度向量，从而提高数据的可用性，常用的算法有主成分分析、因子分析、隐含狄利克雷分布等，包括早期的自编码器也可用于数据降维。\n（2）聚类任务主要将样本依据一定的规则进行类别分配，即通过衡量样本之间的距离、密度等指标，将关系“近”的样本聚为同一类，以此实现样本的自动分类，常用的算法有层次聚类、k-means聚类、谱聚类等。\n （3）在概率模型估计任务中，对于一个可以生成样本的概率模型，我们使用样本对概率模型的结构、参数进行学习，使得概率模型生成的样本与训练样本最相似。其中一种比较简单的概率密度估计任务便是对随机变量的概率密度函数进行学习，常用的算法有极大似然估计、对抗生成网络、变分自编码器等，这部分内容非常丰富。\n \n#### 半监督学习\n 半监督学习是介于监督学习和无监督学习的一种方式，即只有小部分训练样本带有标签信息，而大多数训练样本的标签信息空缺。半监督学习包括直推和归纳两类模式，直推半监督学习只对给定的训练数据进行处理，它使用训练数据集中有类别标签和无类别标签的样本进行训练，预测其中无标签样本的标签信息；归纳半监督学习不仅预测训练数据集中无标签样本的标签，更主要的是预测未知样本的标签，两者的区别在于需要预测标签的样本是否出现在训练集中。半监督学习一般用于四类学习场景：半监督分类、半监督回归、半监督聚类、半监督降维等。\n \n\n### 上下文无关语法\n上下文无关语法（Context-Free Grammar）和概率上下文无关语法（Probabilistic Context-Free Grammar）的概念。\n\n上下文无关语法是一种形式语言描述方法，用于定义一类语言的语法结构。它由一组产生式规则组成，每个规则包含一个非终结符和一个由非终结符和终结符组成的字符串。其中，α是一个单变量，表示非终结符，而β是由变量或最终值组成的字符串。这些产生式规则定义了从一个起始样本开始，通过替换非终结符，逐步生成包含所有最终值的字符串集合。上下文无关语法的特点是，无论α出现在哪个上下文中，都可以自由地用β替换，而不需要考虑α的上下文。\n\n概率上下文无关语法是在上下文无关语法的基础上引入了概率特性。每个产生式规则都被赋予一个概率值，表示该规则被应用的概率。这样，概率上下文无关语法可以用于建模具有统计特性的语言。例如，在自然语言处理中，可以使用概率上下文无关语法来生成句子或解析句子的结构，并为每个规则分配适当的概率。\n\n总结来说，上下文无关语法是一种用于描述语言的语法结构的方法，其中产生式规则定义了从起始样本开始生成所有最终值的字符串。概率上下文无关语法在上下文无关语法的基础上引入了概率特性，使其适用于建模具有统计特性的语言。\n\n### 多视图学习\n多视图学习（Multi-view Learning）是一种机器学习方法，旨在利用来自多个视图或多个特征表示的数据来改善学习性能。在多视图学习中，数据样本可以从不同的视角或特征空间中获取多个不同的表示。通过综合这些多个视图的信息，多视图学习可以提供更全面和准确的数据描述，从而改善模型的泛化能力和学习结果。\n\n传统的机器学习方法通常假设数据特征是从单个视图或特征空间中提取的，因此忽略了不同视图之间的相关性和互补性。而多视图学习则通过融合多个视图的信息来克服这个限制。它可以应用于各种领域和任务，如模式识别、图像处理、文本分类、推荐系统等。\n\n多视图学习的关键挑战是如何有效地利用不同视图之间的相关性。常见的多视图学习方法包括以下几种：\n\n1. 基于特征融合的方法：将不同视图的特征进行融合，生成一个更综合和丰富的特征表示。常见的融合方法包括特征级融合、决策级融合和模型级融合等。\n    \n2. 基于共享表示学习的方法：通过学习一个共享的低维表示空间，将不同视图的数据映射到该共享空间中。这样可以使不同视图之间的相关性更加明显，便于后续的学习和推理。\n    \n3. 基于多示例学习的方法：将多个视图看作是一个示例的不同表示，通过多示例学习的方式来进行模型训练和预测。这种方法适用于存在不完全标注的数据集，其中每个示例可能有多个视图的表示。\n    \n\n多视图学习方法可以提供更全面和准确的数据建模，从而改善学习性能。它可以利用不同视图的互补信息，提取更丰富的特征表示，并减少数据表示的不确定性。这使得多视图学习成为处理复杂数据和提高模型性能的有效工具。\n\n### 随机投影（SimHash）\n\nTODO：[https://zhuanlan.zhihu.com/p/92155250](https://zhuanlan.zhihu.com/p/92155250)\n\n1. **SimHash 算法**：SimHash 是一种用于计算文本或数据的哈希值的算法。它的主要思想是将文本或数据转换为二进制向量，其中相似的文本或数据会产生相似的哈希值。这种相似性哈希算法被广泛应用于文本去重、相似文档聚类和相似性搜索等任务。\n    \n2. **随机投影**：随机投影是一种降维技术，用于将高维数据映射到低维空间。在随机投影 SimHash 中，通过使用随机生成的投影矩阵将高维特征向量映射到低维二进制码。\n    \n3. **哈希函数**：随机投影 SimHash 使用哈希函数来将投影后的低维向量转换为二进制码。常用的哈希函数是符号哈希函数，它根据投影后的特征向量的符号（正负）来决定对应二进制码的取值（0 或 1）。\n    \n4. **相似性匹配**：通过计算 SimHash 值之间的汉明距离（Hamming Distance），可以判断文本或数据之间的相似性。汉明距离是指两个等长字符串之间相对位置不同的字符的个数。汉明距离越小，表示文本或数据之间越相似。\n    \n\n### 线性特征 & 非线性特征\n\n1. 线性特征：特征和目标的关系可以用一条直线来拟合。\n    \n2. 非线性特征：特征和目标之间的关系不可以用一条直线来拟合\n    \n\n### 弱分类器 & 强分类器\n\n1. 弱分类器：准确率在 60% ~80%之间，即：比随即预测好，但是准确率不高。e.g. CART（分类与回归树）\n    \n2. 强分类器：准确率在90%以上。\n    \n\n### 分类任务 & 回归任务\n\n1. 分类任务（Classification）\n    \n    1. 目标：将输入实例分配到预定义的类别中。\n        \n    2. 过程：模型通过学习输入特征与响应类别之间的关系，来预测新的未知示例所属类别。\n        \n    3. 输出：输出是离散的，通常是表示类别的标签或类别的概率分布。\n        \n2. 回归任务（Regression）\n    \n    1. 目标：预测连续的数值输出。\n        \n    2. 过程：模型通过学习输入特征与响应输出值之间的关系，来预测新的未知示例的数值结果。\n        \n    3. 输出：这是一个连续的数值输出。\n        \n\n注意：有些机器学习算法可以同时用于分类和回归任务，例如决策树和支持向量机等。这些算法可以根据任务的要求进行适当的调整和配置。\n\n### LR、DT、SVM的对比\n\n1. 所谓分类问题就是在特征空间内寻找决策边界线。而三种算法决定了生成的边界线的不同形状。\n    \n2. 如何在多维特征空间中选择合适的算法：\n    \n    1. 先选逻辑回归，如果效果不怎么样，可以将它的结果作为基准来参考\n        \n    2. 试试决策树（随机森林）是否可以大幅度提升模型性能。即使没有把它当作最终模型，也可以使用随机森林来移除噪声变量。\n        \n    3. 如果特征的数量和观测样本特别多，那么当资源和时间充足时，使用SVM不失为一种选择。\n        \n\n### 逻辑回归（Logistic Regression）\n\n1. 目的：解决分类问题。\n    \n2. 核心：特征权重的线性组合、sigmoid 函数的计算和损失函数的最小化。\n    \n3. 特点：逻辑回归的决策边界总是一条直线（或者一个平面，在更高维度上是超平面）。\n    \n4. 优势：\n    \n    1. 适用于处理接近线性可分的分类问题。\n        \n    2. 结果不是一个离散值或者确切的类别。而是一个与每个观测样本相关的概率列表，所以可以用不同的标准和常用的性能指标来分析这个概率分数，得到不同的分类结果。\n        \n    3. 时间和内存需求上相当高效。可以用于分布式数据，用较少的资源处理大型数据\n        \n        > 低内存消耗：逻辑回归模型只需要存储特征权重，而不需要存储大量的训练数据。相比之下，其他复杂的模型（如神经网络）可能需要存储大量的中间参数和计算图，导致更高的内存消耗。\n        \n    4. 对数据中小噪声的棒鲁性很好。\n        \n    5. 逻辑回归广泛应用于工业问题上。\n        \n5. 地位：解决工业规模问题最流行的算法\n    \n6. 缺点：\n    \n    1. 在效率和算法实现的易用性方面并不出众。\n        \n    2. 当特征数目很大并且还丢失了大部分数据时，逻辑回归就会表现的力不从心。\n        \n    3. 当类别变量过多时也会力不从心\n        \n    4. 对于非线性特征，需要进行转换。\n        \n    5. 依赖于全部数据。\n        \n\n### 决策树（Decisoin Trees）\n\n1. 目的：解决分类问题 & 逻辑回归问题。\n    \n2. 结构：按照层次结构的规则生成的。\n    \n3. 特性：对单向变换或者非线性特征并不关心。(不需要变换来捕获数据中的非线性相关性，可以用他的划分方式自适应处理非线性关系)。\n    \n    > 单向变换：如指数、对数变换。\n    \n4. 优势：如果边界是非线性的，并且能通过不断将特征空间分为矩形来模拟，那么决策树是比逻辑回归更好的选择。\n    \n    1. 直观的决策规则；\n        \n    2. 可以处理非线性特征；\n        \n    3. 考虑了变量之间的相互作用；\n        \n5. 缺点：\n    \n    1. 训练集上的效果高于测试集，即过拟合【随机森林克服了此缺点】；\n        \n    2. 没有将排名分数作为直接结果；\n        \n6. 针对离散数据的分类决策树\n    \n    1. 定义：预测任务的输入和输出都是离散值\n        \n    2. 例子：ID3、C4.5\n        \n    3. 原始决策树：不断选择，优先选择信息熵最小的特征进行分组\n        \n        > 信息熵：越大，表示特征的信息量越大，越离散，按照这个特征分组之后，样本的混乱程度越大。e.g. 特征某个水平的值出现的概率与取对数的积和。\n        \n    4. ID3：使用信息增益来度量特征对分类的帮助大小\n        \n        > 信息增益：使用一个特征对数据进行分组之后各组样本的有序程度会更高，熵会降低，分组前后熵的差值就是这个特征带来的信息增益。信息增益越大，说明这个特征越有助于分组。分组之前算一次，分组之后算一次。\n        \n    5. C4.5 算法：在信息增益的基础上构造了一个新的特征质量度量指标：信息中增益比\n        \n        > 信息增益比：按照性别划分之后对成年的的信息增益/分组之前对性别的信息增益\n        \n    \n\n### 支持向量机（Support Vector Machine,SVM）\n\n1. 目的：解决分类问题 & 逻辑回归问题\n    \n2. 特点：依靠边界样本来建立需要的分离曲线。它可以处理非线性决策边界。（对边界依赖）\n    \n3. 结构：把特征空间映射到核空间，使得各个类别线性可分。把特征空间又增加一个维度。\n    \n    > 1. **核函数**：SVM使用核函数来将输入特征映射到高维特征空间，从而使得原本在低维空间中非线性可分的问题在高维空间中变得线性可分。核函数的作用是通过计算样本在高维空间中的内积来隐式地表示非线性特征之间的相互作用。常用的核函数包括多项式核函数、高斯核函数（径向基函数）等。\n    >     \n    > 2. **大间隔原则**：SVM的优化目标是找到一个最大间隔的超平面来划分不同类别的样本。通过最大化间隔，SVM能够在特征空间中找到一条边界，使得不同类别的样本尽可能分开。这种大间隔原则使得SVM对于非线性特征之间的相互作用更加鲁棒，能够更好地处理非线性关系。\n    >     \n    > 3. **非线性核函数**：除了线性核函数，SVM还可以使用非线性核函数，如多项式核函数和高斯核函数。这些核函数能够捕捉非线性特征之间的相互作用，将数据映射到高维特征空间中，并在高维空间中构建一个线性超平面来进行分类。这样，SVM能够处理非线性特征之间的相互作用，提高模型的表达能力。\n    >     \n    \n4. 优点\n    \n    1. 能够处理大型特征空间\n        \n    2. 能够处理非线性特征之间的相互作用\n        \n    3. 无需依赖整个数据\n        \n5. 缺点：\n    \n    1. 当观测样本很多时，效率并不是很高\n        \n    2. 有时候很难找到一个合适的核函数\n        \n\n### 分类与回归树（Classification and Regression Tree,CART）\n\n1. 概念：一种经典决策树，可以用来处理涉及连续数据的分类或者回归任务。\n    \n2. 思想：一些学者采用类似随机投影的思路，将自变量的取值空间切分为若干个碎块，并假设这个空间碎块内的所有样本的因变量取值接近(甚至相同)——在这种思想的指导下，出现了一种非常经典的回归模型，即CART回归树。\n    \n3. 由来：\n    \n    1. 特征为连续变量：不能直接使用特征取值，选择用于分割样本的特征取值\n        \n    2. 输出为连续变量：基尼系数和信息增益并不能作为分组质量的表征。使用！回归树！\n        \n4. 关键：设计一个标准，用来指导机器按照最有利于准确计算因变量的情况来切分特征空间。\n    \n    1. e.g.:切分特征空间的标准：MES\n        \n5. 代码：[https://github.com/lipengyuer/DataScience/blob/master/src/algoritm/CARTRegression.py](https://github.com/lipengyuer/DataScience/blob/master/src/algoritm/CARTRegression.py)\n    \n\n### 集成学习\n\n概念：通过组合多个基本模型的预测结果，以获得更好的整体预测性能。\n\n目的：组合多个弱分类器或者回归器来创建一个强分类器或者回归器。\n\n1. bagging\n    \n    通过对原数据集的抽样，得到多份采样数据集，使用弱学习器分别在这多份采样数据集上学习， 而后使用集成策略将结果整合起来（e.g. 分类问题用投票法，回归问题用加权法） e.g. 随机森林（Random Forest）\n    \n2. stacking\n    \n    使用不同的学习方法学习同一份数据，得到多个学习器， 而后使用另一个学习器，学习以上多个学习器的输出到真实标签的映射 boosting 按序处理多个弱学习器，排在后的学习器重点学习排在前的学习器无法处理好的那些数据 e.g. Ada\n    \n3. Boost\n    \n    一个学习器学完后，根据其对数据集分类的正确与否，调整下一个学习器学习时，数据集各条数据被采样到的概率，达成调整数据集分布的作用。而后多个学习器按照各自的正确率集成在一\n    \n\n### 随机森林\n\n1. 是决策树一个非常优秀的扩展，同时也剥夺了商业规则和易解释性。\n    \n    1. 树很多，使用多数投票规则使得模型变得更加复杂，\n        \n    2. 决策树变量之间也存在相互作用。\n        \n\n\n### 变分贝叶斯方法\n\n参考：[Variational Bayesian methods](https://en.wikipedia.org/wiki/Variational_Bayesian_methods)\n变分贝叶斯方法是一系列用于逼近贝叶斯推理和机器学习中出现的棘手积分的技术。它们通常用于由观察变量（通常称为“数据”）以及未知参数和潜在变量组成的复杂统计模型，这三种类型的随机变量之间具有各种关系，正如图形模型所描述的那样。正如贝叶斯推理中的典型情况一样，参数和潜在变量被分组为“未观察到的变量”。变分贝叶斯方法主要用于两个目的：\n1. 为未观测变量的后验概率提供分析近似，以便对这些变量进行统计推断。\n2. 导出观察数据的边际可能性（有时称为证据）的下限（即给定模型的数据的边际概率，对未观察的变量进行边缘化）。这通常用于执行模型选择，一般思想是给定模型的边际，可能性较高表明该模型对数据的拟合更好，因此所讨论的模型是生成数据的模型的概率更大。 （另请参阅贝叶斯因子文章。）\n。。。。。\n\n### 拉普拉斯平滑\n（Laplace smoothing），也称为加一平滑（Add-One smoothing），是一种用于处理概率估计中的零概率问题的技术。它是一种简单而常用的平滑方法，可用于解决在计算概率时可能出现的数据稀疏性和零概率的情况。\n\n在概率估计中，当我们根据样本数据计算事件的概率时，有时会遇到某些事件在样本中未出现的情况，导致概率估计为零。这在实际应用中可能不太合理，因为我们不能简单地认为未观察到的事件的概率为零。\n\n拉普拉斯平滑通过在计算概率时为每个事件的计数值（或频率）增加一个常数（通常为1），来解决零概率问题。这个常数被称为平滑因子或平滑参数。通过这种方法，即使某个事件在样本中未出现，它的概率仍然会被估计为一个非零值。\n\n拉普拉斯平滑的概率估计公式如下：  \nP(x) = (count(x) + 1) / (N + V)\n\n其中，P(x)表示事件x的平滑概率，count(x)表示在样本中观察到事件x的次数，N表示总观测次数，V表示事件的可能取值数量（即事件的种类数）。\n\n应用方面，拉普拉斯平滑广泛用于自然语言处理（NLP）中的语言模型，特别是n-gram语言模型。在n-gram模型中，用于估计概率的数据通常是文本中的n个连续词语序列。拉普拉斯平滑可以解决在计算概率时可能出现的未观察到的n-gram序列的问题，提高语言模型的鲁棒性和泛化能力。\n\n除了语言模型，拉普拉斯平滑还可以应用于其他概率估计问题，如朴素贝叶斯分类器、信息检索中的查询扩展和推荐系统等。它可以有效地处理数据稀疏性问题，并提供更合理的概率估计结果。\n\n### 强化学习\n当谈到强化学习（Reinforcement Learning，RL）时，我们在机器学习中讨论的是一种范例和方法。它主要用于描述和解决智能代理与环境交互的学习问题，目标是通过学习一种策略或行为序列来最大化累积的回报或实现特定目标。\n\n在强化学习中，我们有一个智能代理（agent），它根据环境的状态（state）选择动作（action），并与环境进行交互。环境会根据代理采取的动作以及当前的状态，返回给代理一个奖励信号（reward）和下一个状态。代理的目标是通过与环境的交互，通过尝试和错误的方式来学习一个最佳策略，以使得长期累积的回报最大化。\n\n在强化学习中，代理通过学习价值函数（value function）或策略函数（policy function）来指导其决策过程。价值函数可以评估给定状态或状态动作对的价值，而策略函数定义了在给定状态下选择动作的方式。代理通过与环境的交互不断更新这些函数，以改进其决策能力。\n\n强化学习的一个重要概念是探索（exploration）与利用（exploitation）的权衡。探索是指代理通过尝试新的动作来发现更多的知识，而利用是指代理根据已知信息选择最优动作以获得最大回报。强化学习算法需要在探索和利用之间找到平衡，以达到最佳的学习效果。\n\n总结起来，强化学习是一种机器学习方法，用于解决智能代理与环境交互的学习问题。代理通过学习策略或行为序列来最大化累积回报或实现特定目标。在这个过程中，代理通过与环境的交互不断更新价值函数和策略函数，以改进其决策能力。探索与利用的权衡是强化学习中需要解决的重要问题之一。\n\n\n\n### 参考资料：\n\n1. [https://www.jianshu.com/p/743cf2357b28](https://www.jianshu.com/p/743cf2357b28)\n    \n2. [https://zhuanlan.zhihu.com/p/53183016](https://zhuanlan.zhihu.com/p/53183016)\n    \n3. CART回归：[https://zhuanlan.zhihu.com/p/128472955](https://zhuanlan.zhihu.com/p/128472955)","slug":"人工智能/机器学习基本概念","published":1,"date":"2024-04-22T13:14:49.007Z","updated":"2024-04-18T02:11:49.845Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0a000ckgg4hely5g81","content":"<h3 id=\"监督学习与无监督学习\"><a href=\"#监督学习与无监督学习\" class=\"headerlink\" title=\"监督学习与无监督学习\"></a>监督学习与无监督学习</h3><h4 id=\"监督学习\"><a href=\"#监督学习\" class=\"headerlink\" title=\"监督学习\"></a>监督学习</h4><p>任务：学习一个映射函数，给定任意输入响应做一个好的预测输出。<br>本质：学习输入到输出的映射的统计规律。<br>常见情景：回归，分类，标注。（区别在于变量的取值类型）<br>（1）当输入变量和输出变量均为连续值变量时得到回归任务，它主要用于学习输入变量和输出变量之间的数值映射关系，常见的回归任务有价格预测、趋势预测等，处理回归任务时常用的机器学习模型有最小二乘回归、非线性回归等。<br>（2）无论其输入变量为离散值还是连续值，当输出变量为有限个离散值时得到分类任务，分类任务是被人们讨论和应用最广泛的任务，它通常用于分门别类，常见的分类任务有图片类别识别、用户分类、文本分类等，处理分类任务时常用的机器学习模型有：k近邻、朴素贝叶斯、决策树、逻辑斯蒂回归模型、支持向量机、神经网络等。<br>（3）当输入变量和输出变量均为变量序列时得到标注任务，它是分类问题的一种推广，用于学习输入序列和输出序列的映射关系，典型的标注任务有自然语言处理中的词性标注、信息抽取等，处理标注任务时常用的机器学习模型有隐马尔科夫模型和条件随机场等</p>\n<h5 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h5><p>监督学习是学习一个模型，然后利用该模型对给定的输入预测相应的输出，我们可将模型写成函数形式 Y&#x3D;f(X) 或条件概率分布形式 P(Y|X) 。</p>\n<h6 id=\"判别模型-生成模型：根据条件概率的计算方式\"><a href=\"#判别模型-生成模型：根据条件概率的计算方式\" class=\"headerlink\" title=\"判别模型&amp;生成模型：根据条件概率的计算方式\"></a>判别模型&amp;生成模型：根据条件概率的计算方式</h6><ol>\n<li>[[判别模型]]<ol>\n<li>建模方式：直接对 P(Y|X)  进行建模，它试图描述在给定输入特征 X 的情况下，标签信息 Y 的分布，</li>\n<li>典型判别模型包括： 近邻法、感知机、决策树、逻辑回归和条件随机场等。</li>\n<li>评价：判别模型对条件概率模型直接建模，无法反映训练数据本身的概率特性，但是以分类问题为例，判别模型在寻找最优分类面的过程中，学习了不同类别数据之间的差异。另外，判别模型可以对数据进行各种程度上的抽象、降维，因此可以简化学习问题，学习准确率更高。</li>\n</ol>\n</li>\n<li>[[生成模型]]<ol>\n<li>对数据特征 X 和标签 Y 的联合分布 p(X,Y) 进行建模，然后利用条件概率公式，即可计算 p(Y|X) ，如下所示:<br> $p(Y|X) &#x3D; \\frac {p(X,Y)}{p(X)}$<br> 一般将其转换为易为计算的方式，如下所示<br> $p(Y|X) &#x3D; \\frac {p(X|Y)*p(Y)}{p(X)}$</li>\n<li>举例：朴素贝叶斯方法和隐马尔科夫模型等。<ol>\n<li>在朴素贝叶斯方法中，我们通过训练集学习到先验概率分布 p(Y) 和条件概率分布 p(Y|X)，则可得到联合概率分布 p(X,Y)；</li>\n<li>隐马尔可夫模型中，我们通过训练集学习到初始概率分布、状态转移概率矩阵和观测概率矩阵，则得到了一个可以表示状态序列与观测序列联合分布的马尔可夫模型。</li>\n</ol>\n</li>\n<li>评价：生成模型直接学习联合分布，可以更好地表示数据的分布，更好反映同类数据的相似度。当样本数量比较大时，生成模型往往可以更好地收敛到真实模型上，其收敛速度快。另外，生成模型可以处理含有隐变量的情况，而判别模型对此无能为力。生成模型也可以通过计算边缘分布而检测某些异常值。但实践中，生成模型计算开销一般比较大，而且多数情况下其效果不如判别模型。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"无监督学习\"><a href=\"#无监督学习\" class=\"headerlink\" title=\"无监督学习\"></a>无监督学习</h4><p>和监督学习比较：</p>\n<ol>\n<li>无监督学习和监督学习最大的区别就是标签的有无。在监督学习中，训练模型的任务是学习输入特征到标签的映射，</li>\n<li>而无监督学习中只有样本的特征向量，故无监督学习的任务是对数据进行深入“挖掘”，其本质是学习数据中的统计规律或潜在结构。对于无监督学习的深入研究对深度学习的复兴上起到了关键的作用。</li>\n<li>相比于无监督学习除了拥有额外的标签信息外，还需要有测试样本。机器学习模型在训练集中学习“规律”，然后对测试集使用这种“规律”来评价模型的效果，而无监督学习不需要测试样本，整个过程只需要训练集的参与。</li>\n<li>另外，无监督学习相比于监督学习一般拥有更好的拓展性，它在完成训练目标的同时，通常还额外学习到了样本的表示，我们可以将这些表示直接用于其他的任务。<br>常见任务：降维、聚类、概率模型估计。<br>（1）降维任务主要用于处理数据的高维度问题，真实数据的特征维度过大容易造成模型的拟合度与可用性降低，我们可以通过降维算法对高维度数据进行“压缩”使之变成低维度向量，从而提高数据的可用性，常用的算法有主成分分析、因子分析、隐含狄利克雷分布等，包括早期的自编码器也可用于数据降维。<br>（2）聚类任务主要将样本依据一定的规则进行类别分配，即通过衡量样本之间的距离、密度等指标，将关系“近”的样本聚为同一类，以此实现样本的自动分类，常用的算法有层次聚类、k-means聚类、谱聚类等。<br> （3）在概率模型估计任务中，对于一个可以生成样本的概率模型，我们使用样本对概率模型的结构、参数进行学习，使得概率模型生成的样本与训练样本最相似。其中一种比较简单的概率密度估计任务便是对随机变量的概率密度函数进行学习，常用的算法有极大似然估计、对抗生成网络、变分自编码器等，这部分内容非常丰富。</li>\n</ol>\n<h4 id=\"半监督学习\"><a href=\"#半监督学习\" class=\"headerlink\" title=\"半监督学习\"></a>半监督学习</h4><p> 半监督学习是介于监督学习和无监督学习的一种方式，即只有小部分训练样本带有标签信息，而大多数训练样本的标签信息空缺。半监督学习包括直推和归纳两类模式，直推半监督学习只对给定的训练数据进行处理，它使用训练数据集中有类别标签和无类别标签的样本进行训练，预测其中无标签样本的标签信息；归纳半监督学习不仅预测训练数据集中无标签样本的标签，更主要的是预测未知样本的标签，两者的区别在于需要预测标签的样本是否出现在训练集中。半监督学习一般用于四类学习场景：半监督分类、半监督回归、半监督聚类、半监督降维等。</p>\n<h3 id=\"上下文无关语法\"><a href=\"#上下文无关语法\" class=\"headerlink\" title=\"上下文无关语法\"></a>上下文无关语法</h3><p>上下文无关语法（Context-Free Grammar）和概率上下文无关语法（Probabilistic Context-Free Grammar）的概念。</p>\n<p>上下文无关语法是一种形式语言描述方法，用于定义一类语言的语法结构。它由一组产生式规则组成，每个规则包含一个非终结符和一个由非终结符和终结符组成的字符串。其中，α是一个单变量，表示非终结符，而β是由变量或最终值组成的字符串。这些产生式规则定义了从一个起始样本开始，通过替换非终结符，逐步生成包含所有最终值的字符串集合。上下文无关语法的特点是，无论α出现在哪个上下文中，都可以自由地用β替换，而不需要考虑α的上下文。</p>\n<p>概率上下文无关语法是在上下文无关语法的基础上引入了概率特性。每个产生式规则都被赋予一个概率值，表示该规则被应用的概率。这样，概率上下文无关语法可以用于建模具有统计特性的语言。例如，在自然语言处理中，可以使用概率上下文无关语法来生成句子或解析句子的结构，并为每个规则分配适当的概率。</p>\n<p>总结来说，上下文无关语法是一种用于描述语言的语法结构的方法，其中产生式规则定义了从起始样本开始生成所有最终值的字符串。概率上下文无关语法在上下文无关语法的基础上引入了概率特性，使其适用于建模具有统计特性的语言。</p>\n<h3 id=\"多视图学习\"><a href=\"#多视图学习\" class=\"headerlink\" title=\"多视图学习\"></a>多视图学习</h3><p>多视图学习（Multi-view Learning）是一种机器学习方法，旨在利用来自多个视图或多个特征表示的数据来改善学习性能。在多视图学习中，数据样本可以从不同的视角或特征空间中获取多个不同的表示。通过综合这些多个视图的信息，多视图学习可以提供更全面和准确的数据描述，从而改善模型的泛化能力和学习结果。</p>\n<p>传统的机器学习方法通常假设数据特征是从单个视图或特征空间中提取的，因此忽略了不同视图之间的相关性和互补性。而多视图学习则通过融合多个视图的信息来克服这个限制。它可以应用于各种领域和任务，如模式识别、图像处理、文本分类、推荐系统等。</p>\n<p>多视图学习的关键挑战是如何有效地利用不同视图之间的相关性。常见的多视图学习方法包括以下几种：</p>\n<ol>\n<li><p>基于特征融合的方法：将不同视图的特征进行融合，生成一个更综合和丰富的特征表示。常见的融合方法包括特征级融合、决策级融合和模型级融合等。</p>\n</li>\n<li><p>基于共享表示学习的方法：通过学习一个共享的低维表示空间，将不同视图的数据映射到该共享空间中。这样可以使不同视图之间的相关性更加明显，便于后续的学习和推理。</p>\n</li>\n<li><p>基于多示例学习的方法：将多个视图看作是一个示例的不同表示，通过多示例学习的方式来进行模型训练和预测。这种方法适用于存在不完全标注的数据集，其中每个示例可能有多个视图的表示。</p>\n</li>\n</ol>\n<p>多视图学习方法可以提供更全面和准确的数据建模，从而改善学习性能。它可以利用不同视图的互补信息，提取更丰富的特征表示，并减少数据表示的不确定性。这使得多视图学习成为处理复杂数据和提高模型性能的有效工具。</p>\n<h3 id=\"随机投影（SimHash）\"><a href=\"#随机投影（SimHash）\" class=\"headerlink\" title=\"随机投影（SimHash）\"></a>随机投影（SimHash）</h3><p>TODO：<a href=\"https://zhuanlan.zhihu.com/p/92155250\">https://zhuanlan.zhihu.com/p/92155250</a></p>\n<ol>\n<li><p><strong>SimHash 算法</strong>：SimHash 是一种用于计算文本或数据的哈希值的算法。它的主要思想是将文本或数据转换为二进制向量，其中相似的文本或数据会产生相似的哈希值。这种相似性哈希算法被广泛应用于文本去重、相似文档聚类和相似性搜索等任务。</p>\n</li>\n<li><p><strong>随机投影</strong>：随机投影是一种降维技术，用于将高维数据映射到低维空间。在随机投影 SimHash 中，通过使用随机生成的投影矩阵将高维特征向量映射到低维二进制码。</p>\n</li>\n<li><p><strong>哈希函数</strong>：随机投影 SimHash 使用哈希函数来将投影后的低维向量转换为二进制码。常用的哈希函数是符号哈希函数，它根据投影后的特征向量的符号（正负）来决定对应二进制码的取值（0 或 1）。</p>\n</li>\n<li><p><strong>相似性匹配</strong>：通过计算 SimHash 值之间的汉明距离（Hamming Distance），可以判断文本或数据之间的相似性。汉明距离是指两个等长字符串之间相对位置不同的字符的个数。汉明距离越小，表示文本或数据之间越相似。</p>\n</li>\n</ol>\n<h3 id=\"线性特征-非线性特征\"><a href=\"#线性特征-非线性特征\" class=\"headerlink\" title=\"线性特征 &amp; 非线性特征\"></a>线性特征 &amp; 非线性特征</h3><ol>\n<li><p>线性特征：特征和目标的关系可以用一条直线来拟合。</p>\n</li>\n<li><p>非线性特征：特征和目标之间的关系不可以用一条直线来拟合</p>\n</li>\n</ol>\n<h3 id=\"弱分类器-强分类器\"><a href=\"#弱分类器-强分类器\" class=\"headerlink\" title=\"弱分类器 &amp; 强分类器\"></a>弱分类器 &amp; 强分类器</h3><ol>\n<li><p>弱分类器：准确率在 60% ~80%之间，即：比随即预测好，但是准确率不高。e.g. CART（分类与回归树）</p>\n</li>\n<li><p>强分类器：准确率在90%以上。</p>\n</li>\n</ol>\n<h3 id=\"分类任务-回归任务\"><a href=\"#分类任务-回归任务\" class=\"headerlink\" title=\"分类任务 &amp; 回归任务\"></a>分类任务 &amp; 回归任务</h3><ol>\n<li><p>分类任务（Classification）</p>\n<ol>\n<li><p>目标：将输入实例分配到预定义的类别中。</p>\n</li>\n<li><p>过程：模型通过学习输入特征与响应类别之间的关系，来预测新的未知示例所属类别。</p>\n</li>\n<li><p>输出：输出是离散的，通常是表示类别的标签或类别的概率分布。</p>\n</li>\n</ol>\n</li>\n<li><p>回归任务（Regression）</p>\n<ol>\n<li><p>目标：预测连续的数值输出。</p>\n</li>\n<li><p>过程：模型通过学习输入特征与响应输出值之间的关系，来预测新的未知示例的数值结果。</p>\n</li>\n<li><p>输出：这是一个连续的数值输出。</p>\n</li>\n</ol>\n</li>\n</ol>\n<p>注意：有些机器学习算法可以同时用于分类和回归任务，例如决策树和支持向量机等。这些算法可以根据任务的要求进行适当的调整和配置。</p>\n<h3 id=\"LR、DT、SVM的对比\"><a href=\"#LR、DT、SVM的对比\" class=\"headerlink\" title=\"LR、DT、SVM的对比\"></a>LR、DT、SVM的对比</h3><ol>\n<li><p>所谓分类问题就是在特征空间内寻找决策边界线。而三种算法决定了生成的边界线的不同形状。</p>\n</li>\n<li><p>如何在多维特征空间中选择合适的算法：</p>\n<ol>\n<li><p>先选逻辑回归，如果效果不怎么样，可以将它的结果作为基准来参考</p>\n</li>\n<li><p>试试决策树（随机森林）是否可以大幅度提升模型性能。即使没有把它当作最终模型，也可以使用随机森林来移除噪声变量。</p>\n</li>\n<li><p>如果特征的数量和观测样本特别多，那么当资源和时间充足时，使用SVM不失为一种选择。</p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"逻辑回归（Logistic-Regression）\"><a href=\"#逻辑回归（Logistic-Regression）\" class=\"headerlink\" title=\"逻辑回归（Logistic Regression）\"></a>逻辑回归（Logistic Regression）</h3><ol>\n<li><p>目的：解决分类问题。</p>\n</li>\n<li><p>核心：特征权重的线性组合、sigmoid 函数的计算和损失函数的最小化。</p>\n</li>\n<li><p>特点：逻辑回归的决策边界总是一条直线（或者一个平面，在更高维度上是超平面）。</p>\n</li>\n<li><p>优势：</p>\n<ol>\n<li><p>适用于处理接近线性可分的分类问题。</p>\n</li>\n<li><p>结果不是一个离散值或者确切的类别。而是一个与每个观测样本相关的概率列表，所以可以用不同的标准和常用的性能指标来分析这个概率分数，得到不同的分类结果。</p>\n</li>\n<li><p>时间和内存需求上相当高效。可以用于分布式数据，用较少的资源处理大型数据</p>\n<blockquote>\n<p>低内存消耗：逻辑回归模型只需要存储特征权重，而不需要存储大量的训练数据。相比之下，其他复杂的模型（如神经网络）可能需要存储大量的中间参数和计算图，导致更高的内存消耗。\n </p>\n</blockquote>\n</li>\n<li><p>对数据中小噪声的棒鲁性很好。</p>\n</li>\n<li><p>逻辑回归广泛应用于工业问题上。</p>\n</li>\n</ol>\n</li>\n<li><p>地位：解决工业规模问题最流行的算法</p>\n</li>\n<li><p>缺点：</p>\n<ol>\n<li><p>在效率和算法实现的易用性方面并不出众。</p>\n</li>\n<li><p>当特征数目很大并且还丢失了大部分数据时，逻辑回归就会表现的力不从心。</p>\n</li>\n<li><p>当类别变量过多时也会力不从心</p>\n</li>\n<li><p>对于非线性特征，需要进行转换。</p>\n</li>\n<li><p>依赖于全部数据。</p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"决策树（Decisoin-Trees）\"><a href=\"#决策树（Decisoin-Trees）\" class=\"headerlink\" title=\"决策树（Decisoin Trees）\"></a>决策树（Decisoin Trees）</h3><ol>\n<li><p>目的：解决分类问题 &amp; 逻辑回归问题。</p>\n</li>\n<li><p>结构：按照层次结构的规则生成的。</p>\n</li>\n<li><p>特性：对单向变换或者非线性特征并不关心。(不需要变换来捕获数据中的非线性相关性，可以用他的划分方式自适应处理非线性关系)。</p>\n<blockquote>\n<p>单向变换：如指数、对数变换。\n </p>\n</blockquote>\n</li>\n<li><p>优势：如果边界是非线性的，并且能通过不断将特征空间分为矩形来模拟，那么决策树是比逻辑回归更好的选择。</p>\n<ol>\n<li><p>直观的决策规则；</p>\n</li>\n<li><p>可以处理非线性特征；</p>\n</li>\n<li><p>考虑了变量之间的相互作用；</p>\n</li>\n</ol>\n</li>\n<li><p>缺点：</p>\n<ol>\n<li><p>训练集上的效果高于测试集，即过拟合【随机森林克服了此缺点】；</p>\n</li>\n<li><p>没有将排名分数作为直接结果；</p>\n</li>\n</ol>\n</li>\n<li><p>针对离散数据的分类决策树</p>\n<ol>\n<li><p>定义：预测任务的输入和输出都是离散值</p>\n</li>\n<li><p>例子：ID3、C4.5</p>\n</li>\n<li><p>原始决策树：不断选择，优先选择信息熵最小的特征进行分组</p>\n<blockquote>\n<p>信息熵：越大，表示特征的信息量越大，越离散，按照这个特征分组之后，样本的混乱程度越大。e.g. 特征某个水平的值出现的概率与取对数的积和。\n </p>\n</blockquote>\n</li>\n<li><p>ID3：使用信息增益来度量特征对分类的帮助大小</p>\n<blockquote>\n<p>信息增益：使用一个特征对数据进行分组之后各组样本的有序程度会更高，熵会降低，分组前后熵的差值就是这个特征带来的信息增益。信息增益越大，说明这个特征越有助于分组。分组之前算一次，分组之后算一次。\n </p>\n</blockquote>\n</li>\n<li><p>C4.5 算法：在信息增益的基础上构造了一个新的特征质量度量指标：信息中增益比</p>\n<blockquote>\n<p>信息增益比：按照性别划分之后对成年的的信息增益&#x2F;分组之前对性别的信息增益</p>\n</blockquote>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"支持向量机（Support-Vector-Machine-SVM）\"><a href=\"#支持向量机（Support-Vector-Machine-SVM）\" class=\"headerlink\" title=\"支持向量机（Support Vector Machine,SVM）\"></a>支持向量机（Support Vector Machine,SVM）</h3><ol>\n<li><p>目的：解决分类问题 &amp; 逻辑回归问题</p>\n</li>\n<li><p>特点：依靠边界样本来建立需要的分离曲线。它可以处理非线性决策边界。（对边界依赖）</p>\n</li>\n<li><p>结构：把特征空间映射到核空间，使得各个类别线性可分。把特征空间又增加一个维度。</p>\n<blockquote>\n<ol>\n<li><p><strong>核函数</strong>：SVM使用核函数来将输入特征映射到高维特征空间，从而使得原本在低维空间中非线性可分的问题在高维空间中变得线性可分。核函数的作用是通过计算样本在高维空间中的内积来隐式地表示非线性特征之间的相互作用。常用的核函数包括多项式核函数、高斯核函数（径向基函数）等。</p>\n</li>\n<li><p><strong>大间隔原则</strong>：SVM的优化目标是找到一个最大间隔的超平面来划分不同类别的样本。通过最大化间隔，SVM能够在特征空间中找到一条边界，使得不同类别的样本尽可能分开。这种大间隔原则使得SVM对于非线性特征之间的相互作用更加鲁棒，能够更好地处理非线性关系。</p>\n</li>\n<li><p><strong>非线性核函数</strong>：除了线性核函数，SVM还可以使用非线性核函数，如多项式核函数和高斯核函数。这些核函数能够捕捉非线性特征之间的相互作用，将数据映射到高维特征空间中，并在高维空间中构建一个线性超平面来进行分类。这样，SVM能够处理非线性特征之间的相互作用，提高模型的表达能力。</p>\n</li>\n</ol>\n</blockquote>\n</li>\n<li><p>优点</p>\n<ol>\n<li><p>能够处理大型特征空间</p>\n</li>\n<li><p>能够处理非线性特征之间的相互作用</p>\n</li>\n<li><p>无需依赖整个数据</p>\n</li>\n</ol>\n</li>\n<li><p>缺点：</p>\n<ol>\n<li><p>当观测样本很多时，效率并不是很高</p>\n</li>\n<li><p>有时候很难找到一个合适的核函数</p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"分类与回归树（Classification-and-Regression-Tree-CART）\"><a href=\"#分类与回归树（Classification-and-Regression-Tree-CART）\" class=\"headerlink\" title=\"分类与回归树（Classification and Regression Tree,CART）\"></a>分类与回归树（Classification and Regression Tree,CART）</h3><ol>\n<li><p>概念：一种经典决策树，可以用来处理涉及连续数据的分类或者回归任务。</p>\n</li>\n<li><p>思想：一些学者采用类似随机投影的思路，将自变量的取值空间切分为若干个碎块，并假设这个空间碎块内的所有样本的因变量取值接近(甚至相同)——在这种思想的指导下，出现了一种非常经典的回归模型，即CART回归树。</p>\n</li>\n<li><p>由来：</p>\n<ol>\n<li><p>特征为连续变量：不能直接使用特征取值，选择用于分割样本的特征取值</p>\n</li>\n<li><p>输出为连续变量：基尼系数和信息增益并不能作为分组质量的表征。使用！回归树！</p>\n</li>\n</ol>\n</li>\n<li><p>关键：设计一个标准，用来指导机器按照最有利于准确计算因变量的情况来切分特征空间。</p>\n<ol>\n<li>e.g.:切分特征空间的标准：MES</li>\n</ol>\n</li>\n<li><p>代码：<a href=\"https://github.com/lipengyuer/DataScience/blob/master/src/algoritm/CARTRegression.py\">https://github.com/lipengyuer/DataScience/blob/master/src/algoritm/CARTRegression.py</a></p>\n</li>\n</ol>\n<h3 id=\"集成学习\"><a href=\"#集成学习\" class=\"headerlink\" title=\"集成学习\"></a>集成学习</h3><p>概念：通过组合多个基本模型的预测结果，以获得更好的整体预测性能。</p>\n<p>目的：组合多个弱分类器或者回归器来创建一个强分类器或者回归器。</p>\n<ol>\n<li><p>bagging</p>\n<p> 通过对原数据集的抽样，得到多份采样数据集，使用弱学习器分别在这多份采样数据集上学习， 而后使用集成策略将结果整合起来（e.g. 分类问题用投票法，回归问题用加权法） e.g. 随机森林（Random Forest）</p>\n</li>\n<li><p>stacking</p>\n<p> 使用不同的学习方法学习同一份数据，得到多个学习器， 而后使用另一个学习器，学习以上多个学习器的输出到真实标签的映射 boosting 按序处理多个弱学习器，排在后的学习器重点学习排在前的学习器无法处理好的那些数据 e.g. Ada</p>\n</li>\n<li><p>Boost</p>\n<p> 一个学习器学完后，根据其对数据集分类的正确与否，调整下一个学习器学习时，数据集各条数据被采样到的概率，达成调整数据集分布的作用。而后多个学习器按照各自的正确率集成在一</p>\n</li>\n</ol>\n<h3 id=\"随机森林\"><a href=\"#随机森林\" class=\"headerlink\" title=\"随机森林\"></a>随机森林</h3><ol>\n<li><p>是决策树一个非常优秀的扩展，同时也剥夺了商业规则和易解释性。</p>\n<ol>\n<li><p>树很多，使用多数投票规则使得模型变得更加复杂，</p>\n</li>\n<li><p>决策树变量之间也存在相互作用。</p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"变分贝叶斯方法\"><a href=\"#变分贝叶斯方法\" class=\"headerlink\" title=\"变分贝叶斯方法\"></a>变分贝叶斯方法</h3><p>参考：<a href=\"https://en.wikipedia.org/wiki/Variational_Bayesian_methods\">Variational Bayesian methods</a><br>变分贝叶斯方法是一系列用于逼近贝叶斯推理和机器学习中出现的棘手积分的技术。它们通常用于由观察变量（通常称为“数据”）以及未知参数和潜在变量组成的复杂统计模型，这三种类型的随机变量之间具有各种关系，正如图形模型所描述的那样。正如贝叶斯推理中的典型情况一样，参数和潜在变量被分组为“未观察到的变量”。变分贝叶斯方法主要用于两个目的：</p>\n<ol>\n<li>为未观测变量的后验概率提供分析近似，以便对这些变量进行统计推断。</li>\n<li>导出观察数据的边际可能性（有时称为证据）的下限（即给定模型的数据的边际概率，对未观察的变量进行边缘化）。这通常用于执行模型选择，一般思想是给定模型的边际，可能性较高表明该模型对数据的拟合更好，因此所讨论的模型是生成数据的模型的概率更大。 （另请参阅贝叶斯因子文章。）<br>。。。。。</li>\n</ol>\n<h3 id=\"拉普拉斯平滑\"><a href=\"#拉普拉斯平滑\" class=\"headerlink\" title=\"拉普拉斯平滑\"></a>拉普拉斯平滑</h3><p>（Laplace smoothing），也称为加一平滑（Add-One smoothing），是一种用于处理概率估计中的零概率问题的技术。它是一种简单而常用的平滑方法，可用于解决在计算概率时可能出现的数据稀疏性和零概率的情况。</p>\n<p>在概率估计中，当我们根据样本数据计算事件的概率时，有时会遇到某些事件在样本中未出现的情况，导致概率估计为零。这在实际应用中可能不太合理，因为我们不能简单地认为未观察到的事件的概率为零。</p>\n<p>拉普拉斯平滑通过在计算概率时为每个事件的计数值（或频率）增加一个常数（通常为1），来解决零概率问题。这个常数被称为平滑因子或平滑参数。通过这种方法，即使某个事件在样本中未出现，它的概率仍然会被估计为一个非零值。</p>\n<p>拉普拉斯平滑的概率估计公式如下：<br>P(x) &#x3D; (count(x) + 1) &#x2F; (N + V)</p>\n<p>其中，P(x)表示事件x的平滑概率，count(x)表示在样本中观察到事件x的次数，N表示总观测次数，V表示事件的可能取值数量（即事件的种类数）。</p>\n<p>应用方面，拉普拉斯平滑广泛用于自然语言处理（NLP）中的语言模型，特别是n-gram语言模型。在n-gram模型中，用于估计概率的数据通常是文本中的n个连续词语序列。拉普拉斯平滑可以解决在计算概率时可能出现的未观察到的n-gram序列的问题，提高语言模型的鲁棒性和泛化能力。</p>\n<p>除了语言模型，拉普拉斯平滑还可以应用于其他概率估计问题，如朴素贝叶斯分类器、信息检索中的查询扩展和推荐系统等。它可以有效地处理数据稀疏性问题，并提供更合理的概率估计结果。</p>\n<h3 id=\"强化学习\"><a href=\"#强化学习\" class=\"headerlink\" title=\"强化学习\"></a>强化学习</h3><p>当谈到强化学习（Reinforcement Learning，RL）时，我们在机器学习中讨论的是一种范例和方法。它主要用于描述和解决智能代理与环境交互的学习问题，目标是通过学习一种策略或行为序列来最大化累积的回报或实现特定目标。</p>\n<p>在强化学习中，我们有一个智能代理（agent），它根据环境的状态（state）选择动作（action），并与环境进行交互。环境会根据代理采取的动作以及当前的状态，返回给代理一个奖励信号（reward）和下一个状态。代理的目标是通过与环境的交互，通过尝试和错误的方式来学习一个最佳策略，以使得长期累积的回报最大化。</p>\n<p>在强化学习中，代理通过学习价值函数（value function）或策略函数（policy function）来指导其决策过程。价值函数可以评估给定状态或状态动作对的价值，而策略函数定义了在给定状态下选择动作的方式。代理通过与环境的交互不断更新这些函数，以改进其决策能力。</p>\n<p>强化学习的一个重要概念是探索（exploration）与利用（exploitation）的权衡。探索是指代理通过尝试新的动作来发现更多的知识，而利用是指代理根据已知信息选择最优动作以获得最大回报。强化学习算法需要在探索和利用之间找到平衡，以达到最佳的学习效果。</p>\n<p>总结起来，强化学习是一种机器学习方法，用于解决智能代理与环境交互的学习问题。代理通过学习策略或行为序列来最大化累积回报或实现特定目标。在这个过程中，代理通过与环境的交互不断更新价值函数和策略函数，以改进其决策能力。探索与利用的权衡是强化学习中需要解决的重要问题之一。</p>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><ol>\n<li><p><a href=\"https://www.jianshu.com/p/743cf2357b28\">https://www.jianshu.com/p/743cf2357b28</a></p>\n</li>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/53183016\">https://zhuanlan.zhihu.com/p/53183016</a></p>\n</li>\n<li><p>CART回归：<a href=\"https://zhuanlan.zhihu.com/p/128472955\">https://zhuanlan.zhihu.com/p/128472955</a></p>\n</li>\n</ol>\n","excerpt":"","more":"<h3 id=\"监督学习与无监督学习\"><a href=\"#监督学习与无监督学习\" class=\"headerlink\" title=\"监督学习与无监督学习\"></a>监督学习与无监督学习</h3><h4 id=\"监督学习\"><a href=\"#监督学习\" class=\"headerlink\" title=\"监督学习\"></a>监督学习</h4><p>任务：学习一个映射函数，给定任意输入响应做一个好的预测输出。<br>本质：学习输入到输出的映射的统计规律。<br>常见情景：回归，分类，标注。（区别在于变量的取值类型）<br>（1）当输入变量和输出变量均为连续值变量时得到回归任务，它主要用于学习输入变量和输出变量之间的数值映射关系，常见的回归任务有价格预测、趋势预测等，处理回归任务时常用的机器学习模型有最小二乘回归、非线性回归等。<br>（2）无论其输入变量为离散值还是连续值，当输出变量为有限个离散值时得到分类任务，分类任务是被人们讨论和应用最广泛的任务，它通常用于分门别类，常见的分类任务有图片类别识别、用户分类、文本分类等，处理分类任务时常用的机器学习模型有：k近邻、朴素贝叶斯、决策树、逻辑斯蒂回归模型、支持向量机、神经网络等。<br>（3）当输入变量和输出变量均为变量序列时得到标注任务，它是分类问题的一种推广，用于学习输入序列和输出序列的映射关系，典型的标注任务有自然语言处理中的词性标注、信息抽取等，处理标注任务时常用的机器学习模型有隐马尔科夫模型和条件随机场等</p>\n<h5 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h5><p>监督学习是学习一个模型，然后利用该模型对给定的输入预测相应的输出，我们可将模型写成函数形式 Y&#x3D;f(X) 或条件概率分布形式 P(Y|X) 。</p>\n<h6 id=\"判别模型-生成模型：根据条件概率的计算方式\"><a href=\"#判别模型-生成模型：根据条件概率的计算方式\" class=\"headerlink\" title=\"判别模型&amp;生成模型：根据条件概率的计算方式\"></a>判别模型&amp;生成模型：根据条件概率的计算方式</h6><ol>\n<li>[[判别模型]]<ol>\n<li>建模方式：直接对 P(Y|X)  进行建模，它试图描述在给定输入特征 X 的情况下，标签信息 Y 的分布，</li>\n<li>典型判别模型包括： 近邻法、感知机、决策树、逻辑回归和条件随机场等。</li>\n<li>评价：判别模型对条件概率模型直接建模，无法反映训练数据本身的概率特性，但是以分类问题为例，判别模型在寻找最优分类面的过程中，学习了不同类别数据之间的差异。另外，判别模型可以对数据进行各种程度上的抽象、降维，因此可以简化学习问题，学习准确率更高。</li>\n</ol>\n</li>\n<li>[[生成模型]]<ol>\n<li>对数据特征 X 和标签 Y 的联合分布 p(X,Y) 进行建模，然后利用条件概率公式，即可计算 p(Y|X) ，如下所示:<br> $p(Y|X) &#x3D; \\frac {p(X,Y)}{p(X)}$<br> 一般将其转换为易为计算的方式，如下所示<br> $p(Y|X) &#x3D; \\frac {p(X|Y)*p(Y)}{p(X)}$</li>\n<li>举例：朴素贝叶斯方法和隐马尔科夫模型等。<ol>\n<li>在朴素贝叶斯方法中，我们通过训练集学习到先验概率分布 p(Y) 和条件概率分布 p(Y|X)，则可得到联合概率分布 p(X,Y)；</li>\n<li>隐马尔可夫模型中，我们通过训练集学习到初始概率分布、状态转移概率矩阵和观测概率矩阵，则得到了一个可以表示状态序列与观测序列联合分布的马尔可夫模型。</li>\n</ol>\n</li>\n<li>评价：生成模型直接学习联合分布，可以更好地表示数据的分布，更好反映同类数据的相似度。当样本数量比较大时，生成模型往往可以更好地收敛到真实模型上，其收敛速度快。另外，生成模型可以处理含有隐变量的情况，而判别模型对此无能为力。生成模型也可以通过计算边缘分布而检测某些异常值。但实践中，生成模型计算开销一般比较大，而且多数情况下其效果不如判别模型。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"无监督学习\"><a href=\"#无监督学习\" class=\"headerlink\" title=\"无监督学习\"></a>无监督学习</h4><p>和监督学习比较：</p>\n<ol>\n<li>无监督学习和监督学习最大的区别就是标签的有无。在监督学习中，训练模型的任务是学习输入特征到标签的映射，</li>\n<li>而无监督学习中只有样本的特征向量，故无监督学习的任务是对数据进行深入“挖掘”，其本质是学习数据中的统计规律或潜在结构。对于无监督学习的深入研究对深度学习的复兴上起到了关键的作用。</li>\n<li>相比于无监督学习除了拥有额外的标签信息外，还需要有测试样本。机器学习模型在训练集中学习“规律”，然后对测试集使用这种“规律”来评价模型的效果，而无监督学习不需要测试样本，整个过程只需要训练集的参与。</li>\n<li>另外，无监督学习相比于监督学习一般拥有更好的拓展性，它在完成训练目标的同时，通常还额外学习到了样本的表示，我们可以将这些表示直接用于其他的任务。<br>常见任务：降维、聚类、概率模型估计。<br>（1）降维任务主要用于处理数据的高维度问题，真实数据的特征维度过大容易造成模型的拟合度与可用性降低，我们可以通过降维算法对高维度数据进行“压缩”使之变成低维度向量，从而提高数据的可用性，常用的算法有主成分分析、因子分析、隐含狄利克雷分布等，包括早期的自编码器也可用于数据降维。<br>（2）聚类任务主要将样本依据一定的规则进行类别分配，即通过衡量样本之间的距离、密度等指标，将关系“近”的样本聚为同一类，以此实现样本的自动分类，常用的算法有层次聚类、k-means聚类、谱聚类等。<br> （3）在概率模型估计任务中，对于一个可以生成样本的概率模型，我们使用样本对概率模型的结构、参数进行学习，使得概率模型生成的样本与训练样本最相似。其中一种比较简单的概率密度估计任务便是对随机变量的概率密度函数进行学习，常用的算法有极大似然估计、对抗生成网络、变分自编码器等，这部分内容非常丰富。</li>\n</ol>\n<h4 id=\"半监督学习\"><a href=\"#半监督学习\" class=\"headerlink\" title=\"半监督学习\"></a>半监督学习</h4><p> 半监督学习是介于监督学习和无监督学习的一种方式，即只有小部分训练样本带有标签信息，而大多数训练样本的标签信息空缺。半监督学习包括直推和归纳两类模式，直推半监督学习只对给定的训练数据进行处理，它使用训练数据集中有类别标签和无类别标签的样本进行训练，预测其中无标签样本的标签信息；归纳半监督学习不仅预测训练数据集中无标签样本的标签，更主要的是预测未知样本的标签，两者的区别在于需要预测标签的样本是否出现在训练集中。半监督学习一般用于四类学习场景：半监督分类、半监督回归、半监督聚类、半监督降维等。</p>\n<h3 id=\"上下文无关语法\"><a href=\"#上下文无关语法\" class=\"headerlink\" title=\"上下文无关语法\"></a>上下文无关语法</h3><p>上下文无关语法（Context-Free Grammar）和概率上下文无关语法（Probabilistic Context-Free Grammar）的概念。</p>\n<p>上下文无关语法是一种形式语言描述方法，用于定义一类语言的语法结构。它由一组产生式规则组成，每个规则包含一个非终结符和一个由非终结符和终结符组成的字符串。其中，α是一个单变量，表示非终结符，而β是由变量或最终值组成的字符串。这些产生式规则定义了从一个起始样本开始，通过替换非终结符，逐步生成包含所有最终值的字符串集合。上下文无关语法的特点是，无论α出现在哪个上下文中，都可以自由地用β替换，而不需要考虑α的上下文。</p>\n<p>概率上下文无关语法是在上下文无关语法的基础上引入了概率特性。每个产生式规则都被赋予一个概率值，表示该规则被应用的概率。这样，概率上下文无关语法可以用于建模具有统计特性的语言。例如，在自然语言处理中，可以使用概率上下文无关语法来生成句子或解析句子的结构，并为每个规则分配适当的概率。</p>\n<p>总结来说，上下文无关语法是一种用于描述语言的语法结构的方法，其中产生式规则定义了从起始样本开始生成所有最终值的字符串。概率上下文无关语法在上下文无关语法的基础上引入了概率特性，使其适用于建模具有统计特性的语言。</p>\n<h3 id=\"多视图学习\"><a href=\"#多视图学习\" class=\"headerlink\" title=\"多视图学习\"></a>多视图学习</h3><p>多视图学习（Multi-view Learning）是一种机器学习方法，旨在利用来自多个视图或多个特征表示的数据来改善学习性能。在多视图学习中，数据样本可以从不同的视角或特征空间中获取多个不同的表示。通过综合这些多个视图的信息，多视图学习可以提供更全面和准确的数据描述，从而改善模型的泛化能力和学习结果。</p>\n<p>传统的机器学习方法通常假设数据特征是从单个视图或特征空间中提取的，因此忽略了不同视图之间的相关性和互补性。而多视图学习则通过融合多个视图的信息来克服这个限制。它可以应用于各种领域和任务，如模式识别、图像处理、文本分类、推荐系统等。</p>\n<p>多视图学习的关键挑战是如何有效地利用不同视图之间的相关性。常见的多视图学习方法包括以下几种：</p>\n<ol>\n<li><p>基于特征融合的方法：将不同视图的特征进行融合，生成一个更综合和丰富的特征表示。常见的融合方法包括特征级融合、决策级融合和模型级融合等。</p>\n</li>\n<li><p>基于共享表示学习的方法：通过学习一个共享的低维表示空间，将不同视图的数据映射到该共享空间中。这样可以使不同视图之间的相关性更加明显，便于后续的学习和推理。</p>\n</li>\n<li><p>基于多示例学习的方法：将多个视图看作是一个示例的不同表示，通过多示例学习的方式来进行模型训练和预测。这种方法适用于存在不完全标注的数据集，其中每个示例可能有多个视图的表示。</p>\n</li>\n</ol>\n<p>多视图学习方法可以提供更全面和准确的数据建模，从而改善学习性能。它可以利用不同视图的互补信息，提取更丰富的特征表示，并减少数据表示的不确定性。这使得多视图学习成为处理复杂数据和提高模型性能的有效工具。</p>\n<h3 id=\"随机投影（SimHash）\"><a href=\"#随机投影（SimHash）\" class=\"headerlink\" title=\"随机投影（SimHash）\"></a>随机投影（SimHash）</h3><p>TODO：<a href=\"https://zhuanlan.zhihu.com/p/92155250\">https://zhuanlan.zhihu.com/p/92155250</a></p>\n<ol>\n<li><p><strong>SimHash 算法</strong>：SimHash 是一种用于计算文本或数据的哈希值的算法。它的主要思想是将文本或数据转换为二进制向量，其中相似的文本或数据会产生相似的哈希值。这种相似性哈希算法被广泛应用于文本去重、相似文档聚类和相似性搜索等任务。</p>\n</li>\n<li><p><strong>随机投影</strong>：随机投影是一种降维技术，用于将高维数据映射到低维空间。在随机投影 SimHash 中，通过使用随机生成的投影矩阵将高维特征向量映射到低维二进制码。</p>\n</li>\n<li><p><strong>哈希函数</strong>：随机投影 SimHash 使用哈希函数来将投影后的低维向量转换为二进制码。常用的哈希函数是符号哈希函数，它根据投影后的特征向量的符号（正负）来决定对应二进制码的取值（0 或 1）。</p>\n</li>\n<li><p><strong>相似性匹配</strong>：通过计算 SimHash 值之间的汉明距离（Hamming Distance），可以判断文本或数据之间的相似性。汉明距离是指两个等长字符串之间相对位置不同的字符的个数。汉明距离越小，表示文本或数据之间越相似。</p>\n</li>\n</ol>\n<h3 id=\"线性特征-非线性特征\"><a href=\"#线性特征-非线性特征\" class=\"headerlink\" title=\"线性特征 &amp; 非线性特征\"></a>线性特征 &amp; 非线性特征</h3><ol>\n<li><p>线性特征：特征和目标的关系可以用一条直线来拟合。</p>\n</li>\n<li><p>非线性特征：特征和目标之间的关系不可以用一条直线来拟合</p>\n</li>\n</ol>\n<h3 id=\"弱分类器-强分类器\"><a href=\"#弱分类器-强分类器\" class=\"headerlink\" title=\"弱分类器 &amp; 强分类器\"></a>弱分类器 &amp; 强分类器</h3><ol>\n<li><p>弱分类器：准确率在 60% ~80%之间，即：比随即预测好，但是准确率不高。e.g. CART（分类与回归树）</p>\n</li>\n<li><p>强分类器：准确率在90%以上。</p>\n</li>\n</ol>\n<h3 id=\"分类任务-回归任务\"><a href=\"#分类任务-回归任务\" class=\"headerlink\" title=\"分类任务 &amp; 回归任务\"></a>分类任务 &amp; 回归任务</h3><ol>\n<li><p>分类任务（Classification）</p>\n<ol>\n<li><p>目标：将输入实例分配到预定义的类别中。</p>\n</li>\n<li><p>过程：模型通过学习输入特征与响应类别之间的关系，来预测新的未知示例所属类别。</p>\n</li>\n<li><p>输出：输出是离散的，通常是表示类别的标签或类别的概率分布。</p>\n</li>\n</ol>\n</li>\n<li><p>回归任务（Regression）</p>\n<ol>\n<li><p>目标：预测连续的数值输出。</p>\n</li>\n<li><p>过程：模型通过学习输入特征与响应输出值之间的关系，来预测新的未知示例的数值结果。</p>\n</li>\n<li><p>输出：这是一个连续的数值输出。</p>\n</li>\n</ol>\n</li>\n</ol>\n<p>注意：有些机器学习算法可以同时用于分类和回归任务，例如决策树和支持向量机等。这些算法可以根据任务的要求进行适当的调整和配置。</p>\n<h3 id=\"LR、DT、SVM的对比\"><a href=\"#LR、DT、SVM的对比\" class=\"headerlink\" title=\"LR、DT、SVM的对比\"></a>LR、DT、SVM的对比</h3><ol>\n<li><p>所谓分类问题就是在特征空间内寻找决策边界线。而三种算法决定了生成的边界线的不同形状。</p>\n</li>\n<li><p>如何在多维特征空间中选择合适的算法：</p>\n<ol>\n<li><p>先选逻辑回归，如果效果不怎么样，可以将它的结果作为基准来参考</p>\n</li>\n<li><p>试试决策树（随机森林）是否可以大幅度提升模型性能。即使没有把它当作最终模型，也可以使用随机森林来移除噪声变量。</p>\n</li>\n<li><p>如果特征的数量和观测样本特别多，那么当资源和时间充足时，使用SVM不失为一种选择。</p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"逻辑回归（Logistic-Regression）\"><a href=\"#逻辑回归（Logistic-Regression）\" class=\"headerlink\" title=\"逻辑回归（Logistic Regression）\"></a>逻辑回归（Logistic Regression）</h3><ol>\n<li><p>目的：解决分类问题。</p>\n</li>\n<li><p>核心：特征权重的线性组合、sigmoid 函数的计算和损失函数的最小化。</p>\n</li>\n<li><p>特点：逻辑回归的决策边界总是一条直线（或者一个平面，在更高维度上是超平面）。</p>\n</li>\n<li><p>优势：</p>\n<ol>\n<li><p>适用于处理接近线性可分的分类问题。</p>\n</li>\n<li><p>结果不是一个离散值或者确切的类别。而是一个与每个观测样本相关的概率列表，所以可以用不同的标准和常用的性能指标来分析这个概率分数，得到不同的分类结果。</p>\n</li>\n<li><p>时间和内存需求上相当高效。可以用于分布式数据，用较少的资源处理大型数据</p>\n<blockquote>\n<p>低内存消耗：逻辑回归模型只需要存储特征权重，而不需要存储大量的训练数据。相比之下，其他复杂的模型（如神经网络）可能需要存储大量的中间参数和计算图，导致更高的内存消耗。\n </p>\n</blockquote>\n</li>\n<li><p>对数据中小噪声的棒鲁性很好。</p>\n</li>\n<li><p>逻辑回归广泛应用于工业问题上。</p>\n</li>\n</ol>\n</li>\n<li><p>地位：解决工业规模问题最流行的算法</p>\n</li>\n<li><p>缺点：</p>\n<ol>\n<li><p>在效率和算法实现的易用性方面并不出众。</p>\n</li>\n<li><p>当特征数目很大并且还丢失了大部分数据时，逻辑回归就会表现的力不从心。</p>\n</li>\n<li><p>当类别变量过多时也会力不从心</p>\n</li>\n<li><p>对于非线性特征，需要进行转换。</p>\n</li>\n<li><p>依赖于全部数据。</p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"决策树（Decisoin-Trees）\"><a href=\"#决策树（Decisoin-Trees）\" class=\"headerlink\" title=\"决策树（Decisoin Trees）\"></a>决策树（Decisoin Trees）</h3><ol>\n<li><p>目的：解决分类问题 &amp; 逻辑回归问题。</p>\n</li>\n<li><p>结构：按照层次结构的规则生成的。</p>\n</li>\n<li><p>特性：对单向变换或者非线性特征并不关心。(不需要变换来捕获数据中的非线性相关性，可以用他的划分方式自适应处理非线性关系)。</p>\n<blockquote>\n<p>单向变换：如指数、对数变换。\n </p>\n</blockquote>\n</li>\n<li><p>优势：如果边界是非线性的，并且能通过不断将特征空间分为矩形来模拟，那么决策树是比逻辑回归更好的选择。</p>\n<ol>\n<li><p>直观的决策规则；</p>\n</li>\n<li><p>可以处理非线性特征；</p>\n</li>\n<li><p>考虑了变量之间的相互作用；</p>\n</li>\n</ol>\n</li>\n<li><p>缺点：</p>\n<ol>\n<li><p>训练集上的效果高于测试集，即过拟合【随机森林克服了此缺点】；</p>\n</li>\n<li><p>没有将排名分数作为直接结果；</p>\n</li>\n</ol>\n</li>\n<li><p>针对离散数据的分类决策树</p>\n<ol>\n<li><p>定义：预测任务的输入和输出都是离散值</p>\n</li>\n<li><p>例子：ID3、C4.5</p>\n</li>\n<li><p>原始决策树：不断选择，优先选择信息熵最小的特征进行分组</p>\n<blockquote>\n<p>信息熵：越大，表示特征的信息量越大，越离散，按照这个特征分组之后，样本的混乱程度越大。e.g. 特征某个水平的值出现的概率与取对数的积和。\n </p>\n</blockquote>\n</li>\n<li><p>ID3：使用信息增益来度量特征对分类的帮助大小</p>\n<blockquote>\n<p>信息增益：使用一个特征对数据进行分组之后各组样本的有序程度会更高，熵会降低，分组前后熵的差值就是这个特征带来的信息增益。信息增益越大，说明这个特征越有助于分组。分组之前算一次，分组之后算一次。\n </p>\n</blockquote>\n</li>\n<li><p>C4.5 算法：在信息增益的基础上构造了一个新的特征质量度量指标：信息中增益比</p>\n<blockquote>\n<p>信息增益比：按照性别划分之后对成年的的信息增益&#x2F;分组之前对性别的信息增益</p>\n</blockquote>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"支持向量机（Support-Vector-Machine-SVM）\"><a href=\"#支持向量机（Support-Vector-Machine-SVM）\" class=\"headerlink\" title=\"支持向量机（Support Vector Machine,SVM）\"></a>支持向量机（Support Vector Machine,SVM）</h3><ol>\n<li><p>目的：解决分类问题 &amp; 逻辑回归问题</p>\n</li>\n<li><p>特点：依靠边界样本来建立需要的分离曲线。它可以处理非线性决策边界。（对边界依赖）</p>\n</li>\n<li><p>结构：把特征空间映射到核空间，使得各个类别线性可分。把特征空间又增加一个维度。</p>\n<blockquote>\n<ol>\n<li><p><strong>核函数</strong>：SVM使用核函数来将输入特征映射到高维特征空间，从而使得原本在低维空间中非线性可分的问题在高维空间中变得线性可分。核函数的作用是通过计算样本在高维空间中的内积来隐式地表示非线性特征之间的相互作用。常用的核函数包括多项式核函数、高斯核函数（径向基函数）等。</p>\n</li>\n<li><p><strong>大间隔原则</strong>：SVM的优化目标是找到一个最大间隔的超平面来划分不同类别的样本。通过最大化间隔，SVM能够在特征空间中找到一条边界，使得不同类别的样本尽可能分开。这种大间隔原则使得SVM对于非线性特征之间的相互作用更加鲁棒，能够更好地处理非线性关系。</p>\n</li>\n<li><p><strong>非线性核函数</strong>：除了线性核函数，SVM还可以使用非线性核函数，如多项式核函数和高斯核函数。这些核函数能够捕捉非线性特征之间的相互作用，将数据映射到高维特征空间中，并在高维空间中构建一个线性超平面来进行分类。这样，SVM能够处理非线性特征之间的相互作用，提高模型的表达能力。</p>\n</li>\n</ol>\n</blockquote>\n</li>\n<li><p>优点</p>\n<ol>\n<li><p>能够处理大型特征空间</p>\n</li>\n<li><p>能够处理非线性特征之间的相互作用</p>\n</li>\n<li><p>无需依赖整个数据</p>\n</li>\n</ol>\n</li>\n<li><p>缺点：</p>\n<ol>\n<li><p>当观测样本很多时，效率并不是很高</p>\n</li>\n<li><p>有时候很难找到一个合适的核函数</p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"分类与回归树（Classification-and-Regression-Tree-CART）\"><a href=\"#分类与回归树（Classification-and-Regression-Tree-CART）\" class=\"headerlink\" title=\"分类与回归树（Classification and Regression Tree,CART）\"></a>分类与回归树（Classification and Regression Tree,CART）</h3><ol>\n<li><p>概念：一种经典决策树，可以用来处理涉及连续数据的分类或者回归任务。</p>\n</li>\n<li><p>思想：一些学者采用类似随机投影的思路，将自变量的取值空间切分为若干个碎块，并假设这个空间碎块内的所有样本的因变量取值接近(甚至相同)——在这种思想的指导下，出现了一种非常经典的回归模型，即CART回归树。</p>\n</li>\n<li><p>由来：</p>\n<ol>\n<li><p>特征为连续变量：不能直接使用特征取值，选择用于分割样本的特征取值</p>\n</li>\n<li><p>输出为连续变量：基尼系数和信息增益并不能作为分组质量的表征。使用！回归树！</p>\n</li>\n</ol>\n</li>\n<li><p>关键：设计一个标准，用来指导机器按照最有利于准确计算因变量的情况来切分特征空间。</p>\n<ol>\n<li>e.g.:切分特征空间的标准：MES</li>\n</ol>\n</li>\n<li><p>代码：<a href=\"https://github.com/lipengyuer/DataScience/blob/master/src/algoritm/CARTRegression.py\">https://github.com/lipengyuer/DataScience/blob/master/src/algoritm/CARTRegression.py</a></p>\n</li>\n</ol>\n<h3 id=\"集成学习\"><a href=\"#集成学习\" class=\"headerlink\" title=\"集成学习\"></a>集成学习</h3><p>概念：通过组合多个基本模型的预测结果，以获得更好的整体预测性能。</p>\n<p>目的：组合多个弱分类器或者回归器来创建一个强分类器或者回归器。</p>\n<ol>\n<li><p>bagging</p>\n<p> 通过对原数据集的抽样，得到多份采样数据集，使用弱学习器分别在这多份采样数据集上学习， 而后使用集成策略将结果整合起来（e.g. 分类问题用投票法，回归问题用加权法） e.g. 随机森林（Random Forest）</p>\n</li>\n<li><p>stacking</p>\n<p> 使用不同的学习方法学习同一份数据，得到多个学习器， 而后使用另一个学习器，学习以上多个学习器的输出到真实标签的映射 boosting 按序处理多个弱学习器，排在后的学习器重点学习排在前的学习器无法处理好的那些数据 e.g. Ada</p>\n</li>\n<li><p>Boost</p>\n<p> 一个学习器学完后，根据其对数据集分类的正确与否，调整下一个学习器学习时，数据集各条数据被采样到的概率，达成调整数据集分布的作用。而后多个学习器按照各自的正确率集成在一</p>\n</li>\n</ol>\n<h3 id=\"随机森林\"><a href=\"#随机森林\" class=\"headerlink\" title=\"随机森林\"></a>随机森林</h3><ol>\n<li><p>是决策树一个非常优秀的扩展，同时也剥夺了商业规则和易解释性。</p>\n<ol>\n<li><p>树很多，使用多数投票规则使得模型变得更加复杂，</p>\n</li>\n<li><p>决策树变量之间也存在相互作用。</p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"变分贝叶斯方法\"><a href=\"#变分贝叶斯方法\" class=\"headerlink\" title=\"变分贝叶斯方法\"></a>变分贝叶斯方法</h3><p>参考：<a href=\"https://en.wikipedia.org/wiki/Variational_Bayesian_methods\">Variational Bayesian methods</a><br>变分贝叶斯方法是一系列用于逼近贝叶斯推理和机器学习中出现的棘手积分的技术。它们通常用于由观察变量（通常称为“数据”）以及未知参数和潜在变量组成的复杂统计模型，这三种类型的随机变量之间具有各种关系，正如图形模型所描述的那样。正如贝叶斯推理中的典型情况一样，参数和潜在变量被分组为“未观察到的变量”。变分贝叶斯方法主要用于两个目的：</p>\n<ol>\n<li>为未观测变量的后验概率提供分析近似，以便对这些变量进行统计推断。</li>\n<li>导出观察数据的边际可能性（有时称为证据）的下限（即给定模型的数据的边际概率，对未观察的变量进行边缘化）。这通常用于执行模型选择，一般思想是给定模型的边际，可能性较高表明该模型对数据的拟合更好，因此所讨论的模型是生成数据的模型的概率更大。 （另请参阅贝叶斯因子文章。）<br>。。。。。</li>\n</ol>\n<h3 id=\"拉普拉斯平滑\"><a href=\"#拉普拉斯平滑\" class=\"headerlink\" title=\"拉普拉斯平滑\"></a>拉普拉斯平滑</h3><p>（Laplace smoothing），也称为加一平滑（Add-One smoothing），是一种用于处理概率估计中的零概率问题的技术。它是一种简单而常用的平滑方法，可用于解决在计算概率时可能出现的数据稀疏性和零概率的情况。</p>\n<p>在概率估计中，当我们根据样本数据计算事件的概率时，有时会遇到某些事件在样本中未出现的情况，导致概率估计为零。这在实际应用中可能不太合理，因为我们不能简单地认为未观察到的事件的概率为零。</p>\n<p>拉普拉斯平滑通过在计算概率时为每个事件的计数值（或频率）增加一个常数（通常为1），来解决零概率问题。这个常数被称为平滑因子或平滑参数。通过这种方法，即使某个事件在样本中未出现，它的概率仍然会被估计为一个非零值。</p>\n<p>拉普拉斯平滑的概率估计公式如下：<br>P(x) &#x3D; (count(x) + 1) &#x2F; (N + V)</p>\n<p>其中，P(x)表示事件x的平滑概率，count(x)表示在样本中观察到事件x的次数，N表示总观测次数，V表示事件的可能取值数量（即事件的种类数）。</p>\n<p>应用方面，拉普拉斯平滑广泛用于自然语言处理（NLP）中的语言模型，特别是n-gram语言模型。在n-gram模型中，用于估计概率的数据通常是文本中的n个连续词语序列。拉普拉斯平滑可以解决在计算概率时可能出现的未观察到的n-gram序列的问题，提高语言模型的鲁棒性和泛化能力。</p>\n<p>除了语言模型，拉普拉斯平滑还可以应用于其他概率估计问题，如朴素贝叶斯分类器、信息检索中的查询扩展和推荐系统等。它可以有效地处理数据稀疏性问题，并提供更合理的概率估计结果。</p>\n<h3 id=\"强化学习\"><a href=\"#强化学习\" class=\"headerlink\" title=\"强化学习\"></a>强化学习</h3><p>当谈到强化学习（Reinforcement Learning，RL）时，我们在机器学习中讨论的是一种范例和方法。它主要用于描述和解决智能代理与环境交互的学习问题，目标是通过学习一种策略或行为序列来最大化累积的回报或实现特定目标。</p>\n<p>在强化学习中，我们有一个智能代理（agent），它根据环境的状态（state）选择动作（action），并与环境进行交互。环境会根据代理采取的动作以及当前的状态，返回给代理一个奖励信号（reward）和下一个状态。代理的目标是通过与环境的交互，通过尝试和错误的方式来学习一个最佳策略，以使得长期累积的回报最大化。</p>\n<p>在强化学习中，代理通过学习价值函数（value function）或策略函数（policy function）来指导其决策过程。价值函数可以评估给定状态或状态动作对的价值，而策略函数定义了在给定状态下选择动作的方式。代理通过与环境的交互不断更新这些函数，以改进其决策能力。</p>\n<p>强化学习的一个重要概念是探索（exploration）与利用（exploitation）的权衡。探索是指代理通过尝试新的动作来发现更多的知识，而利用是指代理根据已知信息选择最优动作以获得最大回报。强化学习算法需要在探索和利用之间找到平衡，以达到最佳的学习效果。</p>\n<p>总结起来，强化学习是一种机器学习方法，用于解决智能代理与环境交互的学习问题。代理通过学习策略或行为序列来最大化累积回报或实现特定目标。在这个过程中，代理通过与环境的交互不断更新价值函数和策略函数，以改进其决策能力。探索与利用的权衡是强化学习中需要解决的重要问题之一。</p>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><ol>\n<li><p><a href=\"https://www.jianshu.com/p/743cf2357b28\">https://www.jianshu.com/p/743cf2357b28</a></p>\n</li>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/53183016\">https://zhuanlan.zhihu.com/p/53183016</a></p>\n</li>\n<li><p>CART回归：<a href=\"https://zhuanlan.zhihu.com/p/128472955\">https://zhuanlan.zhihu.com/p/128472955</a></p>\n</li>\n</ol>\n"},{"_content":"## 自注意力机制\n\n[https://0809zheng.github.io/2020/04/24/self-attention.html](https://0809zheng.github.io/2020/04/24/self-attention.html)\n\nTODO\n\n下面是关于NLP中常用的一些知识的简要说明：\n\n1. Attention（注意力机制）： Attention是一种**用于提升神经网络模型性能的机制**，特别是在序列任务中。它允许**模型在处理输入序列时将重点放在相关的部分上。**通过计算每个输入位置的权重，模型可以自适应地决定要关注哪些部分。注意力机制在机器翻译、文本摘要、问答系统等任务中得到广泛应用。\n    \n2. Transformer（变换器）： Transformer是一种基于注意力机制的神经网络架构，用于处理序列数据。它在自然语言处理任务中取得了重大突破，并成为许多最先进的模型的基础。Transformer通过自注意力机制（self-attention）来捕捉输入序列中的依赖关系，避免了传统循环神经网络中的顺序计算，并且能够并行处理输入。Transformer的典型应用包括机器翻译（如Google的Transformer模型）和语言模型。\n    \n3. BERT（Bidirectional Encoder Representations from Transformers）： BERT是一种预训练的语言表示模型，基于Transformer架构。通过在大规模文本数据上进行无监督的预训练，BERT可以学习出通用的语言表示，然后可以在各种下游任务上进行微调。BERT引入了掩码语言模型（Masked Language Model, MLM）和下一句预测（Next Sentence Prediction, NSP）等任务来训练模型。BERT的出现对各种NLP任务，如文本分类、命名实体识别、问答系统等都产生了显著影响。\n    \n4. GPT（Generative Pre-trained Transformer）： GPT是一种基于Transformer架构的预训练语言模型，用于生成文本。GPT通过在大规模文本数据上进行自监督的预训练，学习出对输入序列的概率分布建模能力。然后，可以使用该模型生成具有连贯性和语法正确性的文本。GPT模型在生成式任务中表现出色，如文本生成、对话系统、机器写作等。\n    \n5. Prompt（提示）： Prompt是指在进行自然语言处理任务时，向模型提供一种任务描述或问题陈述的方式。通过给定一个显式的提示文本，模型可以更好地理解任务需求和上下文，从而产生更准确的输出。Prompt工程化是近年来在NLP任务中的一种重要技术，它可以帮助改进模型的可控性、减少模型的偏见，并提高模型的性能。\n    \n\n下面是这些概念之间的关系：\n\n1. Attention（注意力机制）是Transformer（变换器）模型的核心组件之一。Transformer通过自注意力机制实现了对输入序列的建模，其中每个位置可以根据其与其他位置的相关性来调整其重要性。\n    \n2. Transformer是一种神经网络架构，被广泛用于自然语言处理任务。它的设计中包含了多头注意力机制，可以同时关注不同位置的不同方面。Transformer的出现使得处理长序列数据变得更加高效，并在机器翻译、文本生成等任务中取得了显著的性能提升。\n    \n3. BERT（Bidirectional Encoder Representations from Transformers）是基于Transformer的预训练语言模型。它通过大规模的无监督预训练，在理解上下文和建模语言表示方面取得了巨大成功。BERT的预训练模型可以通过微调适应各种下游任务，如文本分类、命名实体识别等。\n    \n4. GPT（Generative Pre-trained Transformer）也是基于Transformer的预训练语言模型，但其目标是生成连贯的文本。GPT通过自监督学习来提前训练一个语言模型，然后可以用于生成各种文本，如文章、对话等。GPT模型在生成式任务中表现出色，可以产生具有语法正确性和连贯性的文本。\n    \n5. Prompt（提示）是在进行NLP任务时向模型提供任务描述或问题陈述的方式。Prompt的引入主要是为了改进模型的可控性和减少模型的偏见。通过设计合适的提示文本，可以引导模型在特定任务上产生更准确、更符合预期的输出。\n    \n\n总体而言，Attention是一种机制，Transformer是一种基于Attention的网络架构，BERT和GPT是基于Transformer的预训练语言模型，而Prompt是一种用于指导模型输出的技术手段。它们在NLP领域中相互关联，相互借鉴，共同推动了自然语言处理技术的发展。\n\n## 深度卷积神经网络\n\n至少在网络的一层中使用卷积运算来代替一般的矩阵乘法运算的神经网络，因此命名为卷积神经网络\n\n![img](file://D:\\Users\\fyn\\Documents\\Note\\Typora\\%E5%AD%97%E5%85%B8%E7%94%9F%E6%88%90\\%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.assets\\b98e8b23b2eec30346b082aa1fbca27ca8c377ab.png@1256w_712h_!web-article-pic.webp?lastModify=1708588580)\n\n### 卷积核\n\n卷积核（kernel） ，一个权重矩阵，逐步在二维输入数据上“扫描”，卷积核“滑动”的同时，计算权重矩阵和扫描所得的数据矩阵的乘积，然后把结果汇总成一个输出像素。\n\n**大小一般为奇数：**原因\n\n1. 更容易 padding，计算结果为整数\n    \n2. 使用奇数大小的卷积核还可以保持对称性。对称性在卷积操作中是重要的，因为它可以确保输出特征图的空间分辨率与输入特征图相同。如果使用偶数大小的卷积核，由于缺少中心像素，可能会导致输出特征图的空间分辨率减小。\n    \n3. 在CNN中，进行卷积操作时一般会以卷积核模块的一个位置为基准进行滑动，这个基准通常就是卷积核模块的中心。 卷积核大小为奇数时，它具有一个中心元素，这使得在进行卷积操作时，可以确保输入图像的每个像素都有对应的卷积核元素与之对齐。这种中心对齐的特性有助于提取局部特征，同时减少了信息丢失的可能性。\n    \n\n### 卷积（Convolution）\n\n所谓的卷积运算，其实它被称为**互相关（cross-correlation）运算：**将图像矩阵中，从左到右，由上到下，取与滤波器同等大小的一部分，每一部分中的值与滤波器中的值对应相乘后求和，最后的结果组成一个矩阵，其中没有对核进行翻转。\n\n> 数学上，给定两个函数 f(x) 和 g(x) 的卷积运算表示为：\n> \n> (f * g)(x) = ∫[−∞,∞] f(t)g(x−t) dt\n> \n> 对于每一个 x 得到的值 是 g 在 x 偏移 t 处 的值乘以 f(t) (权重) 的累加值，\n\n![img](file://D:\\Users\\fyn\\Documents\\Note\\Typora\\%E5%AD%97%E5%85%B8%E7%94%9F%E6%88%90\\%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.assets\\d646245dc94d4788dc48d0fcf6cd358f9d29f2c6.gif@1256w_1334h_!web-article-pic.webp?lastModify=1708588580)\n\n**核心操作，用于提取特征**\n\n卷积运算具有一些重要的性质，例如交换律、结合律和分配律。\n\n深度学习里面所谓的卷积运算，其实它被称为**互相关（cross-correlation）运算：**将图像矩阵中，从左到右，由上到下，取与滤波器同等大小的一部分（f(x-t)），每一部分中的值与滤波器中的值（g(t)）对应相乘后求和，最后的结果组成一个矩阵，其中没有对核进行翻转。\n\n### 填充（Padding）\n\n**避免信息损失**\n\n输入图像与卷积核进行卷积后的结果中损失了部分值，输入图像的边缘被“修剪”掉了（边缘处只检测了部分像素点，丢失了图片边界处的众多信息）。这是因为边缘上的像素永远不会位于卷积核中心，而卷积核也没法扩展到边缘区域以外。\n\n这个结果我们是不能接受的，有时我们还希望输入和输出的大小应该保持一致。为解决这个问题，可以在进行卷积操作前，对原矩阵进行边界**填充（Padding）**，也就是在矩阵的边界上填充一些值，以增加矩阵的大小，通常都用“”来进行填充的。\n\n![img](file://D:\\Users\\fyn\\Documents\\Note\\Typora\\%E5%AD%97%E5%85%B8%E7%94%9F%E6%88%90\\%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.assets\\c883f882924c3bfe1784b2a8b1c507c3dbe42963.gif@1256w_1428h_!web-article-pic.webp?lastModify=1708588580)\n\n通过填充的方法，当卷积核扫描输入数据时，它能延伸到边缘以外的伪像素，从而使输出和输入size相同。\n\n常用的两种padding：\n\n（1）valid padding：不进行任何处理，只使用原始图像，不允许卷积核超出原始图像边界\n\n（2）same padding：进行填充，允许卷积核超出原始图像边界，并使得卷积后结果的大小与原来的一致 作者：2kb的卷心菜 [https://www.bilibili.com/read/cv16432604/](https://www.bilibili.com/read/cv16432604/) 出处：bilibili\n\n### 步长(Stride)\n\n**压缩一部分信息，或者使输出的尺寸小于输入的尺寸**\n\n[每天五分钟计算机视觉：卷积步长(Stride) (baidu.com)](https://baijiahao.baidu.com/s?id=1781826967010713030&wfr=spider&for=pc)\n\n**滑动卷积核时**，我们会先从输入的左上角开始，每次往左滑动一列或者往下滑动一行逐一计算输出，我们将**每次滑动的行数和列数**称为Stride，在之前的图片中，Stride=1；在下图中，Stride=2。\n\n![img](file://D:\\Users\\fyn\\Documents\\Note\\Typora\\%E5%AD%97%E5%85%B8%E7%94%9F%E6%88%90\\%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.assets\\af6e5cdf758fc9f2b6ba30235eae9e1c8128576b.gif@!web-article-pic.webp?lastModify=1708588580)\n\n[https://www.bilibili.com/read/cv16432604/](https://www.bilibili.com/read/cv16432604/) 出处：bilibili-2kb的卷心菜\n\n### 通道\n\n比如 RGB 有 红绿蓝三个 通道\n\n这里就要涉及到“卷积核”和“filter”这两个术语的区别。在只有一个通道的情况下，“卷积核”就相当于“filter”，这两个概念是可以互换的。但在一般情况下，它们是两个完全不同的概念。每个“filter”实际上恰好是“卷积核”的一个集合，在当前层，每个通道都对应一个卷积核，且这个卷积核是独一无二的。\n\n**多通道卷积的计算过程**：将矩阵与滤波器对应的每一个通道进行卷积运算，最后相加，形成一个单通道输出，加上偏置项后，我们得到了一个最终的单通道输出。如果存在多个filter，这时我们可以把这些最终的单通道输出组合成一个总输出。\n\n**某一层输出特征图的通道数**=当前层滤波器的个数。如上图所示，当只有一个filter时，输出特征图（4×4）的通道数为1；当有2个filter时，输出特征图（4×4×2）的通道数为2。\n\n### 降采样\n\n[https://zhuanlan.zhihu.com/p/46633171](https://zhuanlan.zhihu.com/p/46633171)\n\n概念：降采样指的是成比例缩小特征图宽和高的过程\n\n例子：比如从（W，H）变为（W/2，H/2）\n\n方法：\n\n1. stride 大于 1 的 pooling\n    \n2. stride 大于 1 的 conv\n    \n3. stride 大于 1 的 reorg（在[YOLOv2的论文](https://link.zhihu.com/?target=https%3A//arxiv.org/pdf/1612.08242.pdf)里叫passthrough layer）\n    \n\n比较：\n\n1. 1 和 2 在深度卷积神经网络中使用非常普遍，3 比较小众，由Joseph Redmon在YOLOv2中首次提出。\n    \n2. 1 和 2 的对比在[Striving for Simplicity: The All Convolutional Net](https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1412.6806)中有详述\n    \n    用stride=2的conv降采样的卷积神经网络效果与使用pooling降采样的卷积神经网络效果相当；**卷积神经网络小的时候，使用pooling降采样效果可能更好**，卷积神经网络大的时候，使用stride=2的conv降采样效果可能更好。\n    \n    pooling提供了一种非线性，这种非线性需要较深的conv叠加才能实现，因此当网络比较浅的时候，pooling有一定优势；但是当网络很深的时候，多层叠加的conv可以学到pooling所能提供的非线性，甚至能根据训练集学到比pooling更好的非线性，因此当网络比较深的时候，不使用pooling没多大关系，甚至更好。\n    \n    pooling的非线性是固定的，不可学习的，这种非线性其实就是一种先验。\n    \n3. 3 中降采样的优势在于能够较好的保留低层次的信息。**1 和 2 的降采样方式，好处是抽取的特征具有更强的语义性，坏处是会丢失一些细节信息**。而3这种降采样方式与1、2相反，**3 提取的特征语义性不强，但是能保留大量细节信息**。所以当我们既需要降采样，又需要不丢失细节信息的时候，3是一个非常合适的选择。\n    \n\n### 升采样\n\n**将输入特征图的尺寸放大或增加分辨率。**\n\n通常与卷积和池化等操作结合使用，用于逆向传播梯度、特征图的恢复或生成更高分辨率的输出。\n\n基本目标是增加特征图的空间尺寸，以便更好地捕获细节信息、提高特征的表达能力或生成更高分辨率的输出。\n\n方法：\n\n1. 反卷积（Transpose Convolution）：反卷积是一种常见的升采样方式，也称为转置卷积、分数步长卷积。它通过在**输入特征图之间插入零值**，并**使用带有适当步长的卷积核进行卷积操作来放大特征图的尺寸**。反卷积操作可以增加特征图的空间尺寸，并在某种程度上恢复输入特征图的细节。\n    \n2. 双线性插值（Bilinear Interpolation）：双线性插值是一种基于插值的升采样方法，通过**对输入特征图中的每个像素进行插值计算来生成更大尺寸的特征图。**它使用**周围四个像素的权重进行插值，保持了图像的平滑性和连续性**。\n    \n3. 最近邻插值（Nearest Neighbor Interpolation）：最近邻插值是一种简单的升采样方法，它将输入特征图中每个像素的值复制到放大后的特征图的相应位置。它在放大时**不进行插值计算，而是直接使用最近邻像素的值**。这种方法简单高效，但可能**会导致输出特征图的锯齿状边缘**。\n    \n4. 其他一些升采样技术，如子像素卷积（Subpixel Convolution）、转置卷积的变种（如反池化操作）、像素重排（Pixel Shuffle）等。这些方法在不同的应用场景中具有各自的优势和适用性。\n    \n\n### 池化层\n\n是一种常用的操作层，用于减小特征图的空间尺寸、降低计算量，并增强模型的平移不变性。输入特征图的局部区域进行聚合或采样来生成池化特征图。\n\n池化操作：通常在每个输入特征图的局部区域上应用，通过对区域内的特征进行聚合或采样，生成一个单一的值或特征。这个聚合或采样过程可以是简单的求最大值（最大池化，Max Pooling）或求平均值（平均池化，Average Pooling），也可以是其他聚合方式，如Lp范数池化。\n\n在池化操作中，可以通过调整池化窗口的大小和步幅来控制输出特征图的大小和感受野。池化窗口是应用池化操作的局部区域的大小，**步幅**是**池化窗口**在输入特征图上移动的距离。\n\n常见的池化操作及其特点：\n\n1. 最大池化（Max Pooling）：在池化窗口内选择最大值作为池化特征。最大池化有助于保留显著的特征，提高模型的平移不变性和鲁棒性。\n    \n2. 平均池化（Average Pooling）：在池化窗口内求特征的平均值作为池化特征。平均池化可以减少特征图的空间维度，并平滑特征。\n    \n3. Lp范数池化（Lp-norm Pooling）：在池化窗口内对特征进行Lp范数归一化，得到池化特征。Lp范数池化可以对特征进行归一化，并引入更多非线性。\n    \n\n池化操作在CNN中具有以下优势：\n\n- 减小特征图的空间尺寸，降低计算量和内存需求。\n    \n- 提取特征的局部不变性，使模型对目标在图像中的位置变化具有鲁棒性。\n    \n- 减少模型过拟合的风险，通过减少参数数量和引入局部平均化。\n    \n\n池化层通常与卷积层交替使用，以构建深层次的卷积神经网络结构。它在图像分类、目标检测、图像分割等任务中广泛应用，并在提高模型性能和减少计算资源消耗方面发挥着重要作用。\n\n### batch size\n\n\"batch size\"（批大小）是指在一次训练迭代中同时输入模型的样本数量。批大小决定了在每一次参数更新时，模型所看到的样本数量。\n\n理解批大小可以参考以下几点：\n\n1. **样本数量**：批大小表示一次训练中同时处理的样本数量。例如，如果批大小为32，则在每次参数更新时，模型将同时处理32个样本。\n    \n2. **内存和计算效率**：较大的批大小可以提高计算效率，因为同时处理多个样本可以充分利用并行计算的能力。然而，较大的批大小可能需要更多的内存存储模型的中间结果。\n    \n3. **梯度估计**：在训练过程中，批大小还会影响对梯度的估计。较大的批大小可以提供更准确的梯度估计，因为它们包含了更多的样本信息。然而，较小的批大小可能导致模型收敛更快，因为它们更频繁地更新参数。\n    \n4. **泛化能力**：较大的批大小可能会导致模型过度拟合训练数据，因为它们更倾向于记住样本特定的细节。较小的批大小可以提供更好的泛化能力，因为它们更强迫模型学习更一般化的特征。\n\n### epoch（时期） \n    Epoch（时期）是指将整个训练数据集（包含多个批次）在模型中进行一次完整的训练。在一个epoch中，模型会对数据集中的每个样本都进行一次前向传播和反向传播，并根据损失函数计算的梯度来更新模型的参数。\n\n训练过程通常涉及多个epoch，因为一次完整的训练可能不足以使模型达到最佳性能。通过进行多个epoch，模型可以多次观察和学习数据的不同方面，并逐渐改善其性能。每个epoch之间的样本顺序通常会被随机化，以避免模型对样本顺序的依赖。\n\n### 向前步骤\n\n**向前步骤（Forward Propagation）**：\n\n- 在向前步骤中，输入样本通过模型的前向计算过程，从输入层经过一系列的神经网络层传递，最终得到模型的输出预测结果。\n    \n- 在每一层中，通过对输入数据进行线性变换（加权和）和非线性变换（激活函数），将信息从前一层传递到后一层，直到到达输出层。\n    \n- 向前步骤的目的是计算出模型的预测结果，以便与真实标签进行比较，并计算出损失函数的值。\n    \n\n### 反向传播步骤\n\n**反向传播步骤（Backpropagation）**：\n\n- 在反向传播步骤中，根据向前步骤中计算得到的损失函数值，通过链式法则计算每个参数对损失的贡献度，并更新模型的参数。\n    \n- 反向传播通过对损失函数关于模型参数的偏导数进行计算，从输出层向输入层逐层传递，以确定每个参数的梯度。\n    \n- 梯度表示了损失函数对每个参数的变化率，利用梯度可以确定参数的更新方向和大小，以最小化损失函数\n\n### 梯度的惩罚程度\n梯度的惩罚程度是指在计算梯度时对其进行的限制或惩罚的程度。在深度学习中，常用的梯度惩罚方法是通过添加正则化项或其他惩罚项来约束模型的参数更新。\n\n#### 目的\n防止参数更新过大或过快，以避免模型的过拟合或不稳定情况。通过对梯度进行惩罚，可以限制参数更新的幅度，使其保持在合理的范围内。\n\n梯度惩罚的程度可以通过调整惩罚项的权重或超参数来控制。增加梯度惩罚的程度意味着更强烈地限制梯度的大小或方向，从而减缓参数更新的速度。相反，减少梯度惩罚的程度会使梯度对参数更新的限制更加宽松。\n\n惩罚程度的选择通常需要根据具体问题和数据集的特点进行调整。过强的梯度惩罚可能导致模型无法学习到有效的特征，而过弱的梯度惩罚可能导致模型过拟合或训练不稳定。因此，需要根据实际情况进行实验和调优，选择合适的梯度惩罚程度以获得最佳的模型性能。\n\n\n### 自动编码器\n\n自动编码器（Autoencoder，AE）是一种无监督学习模型，用于学习数据的特征表示和压缩。它由编码器（Encoder）和解码器（Decoder）组成。\n\n1. 欠完备自动编码器（Undercomplete Autoencoder）：  \n    欠完备自动编码器是指编码器的维度低于输入数据的维度。这种设置迫使模型学习数据的主要特征，因为编码器无法完全捕获原始数据的所有信息。通过限制编码器的容量，欠完备自动编码器可以捕捉数据中最显著的特征，从而实现特征选择和降维。\n    \n2. 正则化自动编码器（Regularized Autoencoder）：  \n    正则化自动编码器通过在损失函数中引入额外的正则化项来约束模型的学习过程，以防止过拟合。常见的正则化方法包括L1正则化和L2正则化。L1正则化通过增加编码器的稀疏性，鼓励模型只使用输入数据的少数关键特征。L2正则化通过限制权重的大小，使模型对输入数据的小变化具有鲁棒性。\n    \n3. 变分自动编码器（Variational Autoencoder，VAE）：  \n    变分自动编码器是一种生成性模型，与判别性模型（欠完备自动编码器和正则化自动编码器）不同，它可以生成新的数据样本。VAE通过在潜在空间中引入随机性，使得模型能够在潜在空间中进行随机采样，并通过解码器生成新的样本。在训练过程中，VAE通过最大化“证据下界”（evidence lower bound，ELBO）来优化模型参数，从而实现对潜在空间的建模。这使得VAE能够学习到数据的潜在分布，并通过从该分布中采样生成新的数据样本。 \n\n### CIFAR-10 和 CIFAR-100\n\nCIFAR[数据集](https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E9%9B%86&spm=1001.2101.3001.7020)是 [Visual Dictionary (Teaching computers to recognize objects)](http://groups.csail.mit.edu/vision/TinyImages/) 的子集，由三个教授收集，主要来自google和各类搜索引擎的图片。\n\n[cifar10和cifar100(简介&可视化)_cifar10和cifar100区别-CSDN博客](https://blog.csdn.net/disanda/article/details/90744243)\n\n### MNIST数据集\n\n[https://blog.csdn.net/Iron802/article/details/121826385](https://blog.csdn.net/Iron802/article/details/121826385)\n\nMNIST数据集是NIST（National Institute of Standards and Technology，美国国家标准与技术研究所）数据集的一个子集，MNIST 数据集可在 [http://yann.lecun.com/exdb/mnist/](http://yann.lecun.com/exdb/mnist/) 获取，主要包括四个文件：","source":"_posts/人工智能/深度学习基本概念.md","raw":"## 自注意力机制\n\n[https://0809zheng.github.io/2020/04/24/self-attention.html](https://0809zheng.github.io/2020/04/24/self-attention.html)\n\nTODO\n\n下面是关于NLP中常用的一些知识的简要说明：\n\n1. Attention（注意力机制）： Attention是一种**用于提升神经网络模型性能的机制**，特别是在序列任务中。它允许**模型在处理输入序列时将重点放在相关的部分上。**通过计算每个输入位置的权重，模型可以自适应地决定要关注哪些部分。注意力机制在机器翻译、文本摘要、问答系统等任务中得到广泛应用。\n    \n2. Transformer（变换器）： Transformer是一种基于注意力机制的神经网络架构，用于处理序列数据。它在自然语言处理任务中取得了重大突破，并成为许多最先进的模型的基础。Transformer通过自注意力机制（self-attention）来捕捉输入序列中的依赖关系，避免了传统循环神经网络中的顺序计算，并且能够并行处理输入。Transformer的典型应用包括机器翻译（如Google的Transformer模型）和语言模型。\n    \n3. BERT（Bidirectional Encoder Representations from Transformers）： BERT是一种预训练的语言表示模型，基于Transformer架构。通过在大规模文本数据上进行无监督的预训练，BERT可以学习出通用的语言表示，然后可以在各种下游任务上进行微调。BERT引入了掩码语言模型（Masked Language Model, MLM）和下一句预测（Next Sentence Prediction, NSP）等任务来训练模型。BERT的出现对各种NLP任务，如文本分类、命名实体识别、问答系统等都产生了显著影响。\n    \n4. GPT（Generative Pre-trained Transformer）： GPT是一种基于Transformer架构的预训练语言模型，用于生成文本。GPT通过在大规模文本数据上进行自监督的预训练，学习出对输入序列的概率分布建模能力。然后，可以使用该模型生成具有连贯性和语法正确性的文本。GPT模型在生成式任务中表现出色，如文本生成、对话系统、机器写作等。\n    \n5. Prompt（提示）： Prompt是指在进行自然语言处理任务时，向模型提供一种任务描述或问题陈述的方式。通过给定一个显式的提示文本，模型可以更好地理解任务需求和上下文，从而产生更准确的输出。Prompt工程化是近年来在NLP任务中的一种重要技术，它可以帮助改进模型的可控性、减少模型的偏见，并提高模型的性能。\n    \n\n下面是这些概念之间的关系：\n\n1. Attention（注意力机制）是Transformer（变换器）模型的核心组件之一。Transformer通过自注意力机制实现了对输入序列的建模，其中每个位置可以根据其与其他位置的相关性来调整其重要性。\n    \n2. Transformer是一种神经网络架构，被广泛用于自然语言处理任务。它的设计中包含了多头注意力机制，可以同时关注不同位置的不同方面。Transformer的出现使得处理长序列数据变得更加高效，并在机器翻译、文本生成等任务中取得了显著的性能提升。\n    \n3. BERT（Bidirectional Encoder Representations from Transformers）是基于Transformer的预训练语言模型。它通过大规模的无监督预训练，在理解上下文和建模语言表示方面取得了巨大成功。BERT的预训练模型可以通过微调适应各种下游任务，如文本分类、命名实体识别等。\n    \n4. GPT（Generative Pre-trained Transformer）也是基于Transformer的预训练语言模型，但其目标是生成连贯的文本。GPT通过自监督学习来提前训练一个语言模型，然后可以用于生成各种文本，如文章、对话等。GPT模型在生成式任务中表现出色，可以产生具有语法正确性和连贯性的文本。\n    \n5. Prompt（提示）是在进行NLP任务时向模型提供任务描述或问题陈述的方式。Prompt的引入主要是为了改进模型的可控性和减少模型的偏见。通过设计合适的提示文本，可以引导模型在特定任务上产生更准确、更符合预期的输出。\n    \n\n总体而言，Attention是一种机制，Transformer是一种基于Attention的网络架构，BERT和GPT是基于Transformer的预训练语言模型，而Prompt是一种用于指导模型输出的技术手段。它们在NLP领域中相互关联，相互借鉴，共同推动了自然语言处理技术的发展。\n\n## 深度卷积神经网络\n\n至少在网络的一层中使用卷积运算来代替一般的矩阵乘法运算的神经网络，因此命名为卷积神经网络\n\n![img](file://D:\\Users\\fyn\\Documents\\Note\\Typora\\%E5%AD%97%E5%85%B8%E7%94%9F%E6%88%90\\%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.assets\\b98e8b23b2eec30346b082aa1fbca27ca8c377ab.png@1256w_712h_!web-article-pic.webp?lastModify=1708588580)\n\n### 卷积核\n\n卷积核（kernel） ，一个权重矩阵，逐步在二维输入数据上“扫描”，卷积核“滑动”的同时，计算权重矩阵和扫描所得的数据矩阵的乘积，然后把结果汇总成一个输出像素。\n\n**大小一般为奇数：**原因\n\n1. 更容易 padding，计算结果为整数\n    \n2. 使用奇数大小的卷积核还可以保持对称性。对称性在卷积操作中是重要的，因为它可以确保输出特征图的空间分辨率与输入特征图相同。如果使用偶数大小的卷积核，由于缺少中心像素，可能会导致输出特征图的空间分辨率减小。\n    \n3. 在CNN中，进行卷积操作时一般会以卷积核模块的一个位置为基准进行滑动，这个基准通常就是卷积核模块的中心。 卷积核大小为奇数时，它具有一个中心元素，这使得在进行卷积操作时，可以确保输入图像的每个像素都有对应的卷积核元素与之对齐。这种中心对齐的特性有助于提取局部特征，同时减少了信息丢失的可能性。\n    \n\n### 卷积（Convolution）\n\n所谓的卷积运算，其实它被称为**互相关（cross-correlation）运算：**将图像矩阵中，从左到右，由上到下，取与滤波器同等大小的一部分，每一部分中的值与滤波器中的值对应相乘后求和，最后的结果组成一个矩阵，其中没有对核进行翻转。\n\n> 数学上，给定两个函数 f(x) 和 g(x) 的卷积运算表示为：\n> \n> (f * g)(x) = ∫[−∞,∞] f(t)g(x−t) dt\n> \n> 对于每一个 x 得到的值 是 g 在 x 偏移 t 处 的值乘以 f(t) (权重) 的累加值，\n\n![img](file://D:\\Users\\fyn\\Documents\\Note\\Typora\\%E5%AD%97%E5%85%B8%E7%94%9F%E6%88%90\\%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.assets\\d646245dc94d4788dc48d0fcf6cd358f9d29f2c6.gif@1256w_1334h_!web-article-pic.webp?lastModify=1708588580)\n\n**核心操作，用于提取特征**\n\n卷积运算具有一些重要的性质，例如交换律、结合律和分配律。\n\n深度学习里面所谓的卷积运算，其实它被称为**互相关（cross-correlation）运算：**将图像矩阵中，从左到右，由上到下，取与滤波器同等大小的一部分（f(x-t)），每一部分中的值与滤波器中的值（g(t)）对应相乘后求和，最后的结果组成一个矩阵，其中没有对核进行翻转。\n\n### 填充（Padding）\n\n**避免信息损失**\n\n输入图像与卷积核进行卷积后的结果中损失了部分值，输入图像的边缘被“修剪”掉了（边缘处只检测了部分像素点，丢失了图片边界处的众多信息）。这是因为边缘上的像素永远不会位于卷积核中心，而卷积核也没法扩展到边缘区域以外。\n\n这个结果我们是不能接受的，有时我们还希望输入和输出的大小应该保持一致。为解决这个问题，可以在进行卷积操作前，对原矩阵进行边界**填充（Padding）**，也就是在矩阵的边界上填充一些值，以增加矩阵的大小，通常都用“”来进行填充的。\n\n![img](file://D:\\Users\\fyn\\Documents\\Note\\Typora\\%E5%AD%97%E5%85%B8%E7%94%9F%E6%88%90\\%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.assets\\c883f882924c3bfe1784b2a8b1c507c3dbe42963.gif@1256w_1428h_!web-article-pic.webp?lastModify=1708588580)\n\n通过填充的方法，当卷积核扫描输入数据时，它能延伸到边缘以外的伪像素，从而使输出和输入size相同。\n\n常用的两种padding：\n\n（1）valid padding：不进行任何处理，只使用原始图像，不允许卷积核超出原始图像边界\n\n（2）same padding：进行填充，允许卷积核超出原始图像边界，并使得卷积后结果的大小与原来的一致 作者：2kb的卷心菜 [https://www.bilibili.com/read/cv16432604/](https://www.bilibili.com/read/cv16432604/) 出处：bilibili\n\n### 步长(Stride)\n\n**压缩一部分信息，或者使输出的尺寸小于输入的尺寸**\n\n[每天五分钟计算机视觉：卷积步长(Stride) (baidu.com)](https://baijiahao.baidu.com/s?id=1781826967010713030&wfr=spider&for=pc)\n\n**滑动卷积核时**，我们会先从输入的左上角开始，每次往左滑动一列或者往下滑动一行逐一计算输出，我们将**每次滑动的行数和列数**称为Stride，在之前的图片中，Stride=1；在下图中，Stride=2。\n\n![img](file://D:\\Users\\fyn\\Documents\\Note\\Typora\\%E5%AD%97%E5%85%B8%E7%94%9F%E6%88%90\\%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.assets\\af6e5cdf758fc9f2b6ba30235eae9e1c8128576b.gif@!web-article-pic.webp?lastModify=1708588580)\n\n[https://www.bilibili.com/read/cv16432604/](https://www.bilibili.com/read/cv16432604/) 出处：bilibili-2kb的卷心菜\n\n### 通道\n\n比如 RGB 有 红绿蓝三个 通道\n\n这里就要涉及到“卷积核”和“filter”这两个术语的区别。在只有一个通道的情况下，“卷积核”就相当于“filter”，这两个概念是可以互换的。但在一般情况下，它们是两个完全不同的概念。每个“filter”实际上恰好是“卷积核”的一个集合，在当前层，每个通道都对应一个卷积核，且这个卷积核是独一无二的。\n\n**多通道卷积的计算过程**：将矩阵与滤波器对应的每一个通道进行卷积运算，最后相加，形成一个单通道输出，加上偏置项后，我们得到了一个最终的单通道输出。如果存在多个filter，这时我们可以把这些最终的单通道输出组合成一个总输出。\n\n**某一层输出特征图的通道数**=当前层滤波器的个数。如上图所示，当只有一个filter时，输出特征图（4×4）的通道数为1；当有2个filter时，输出特征图（4×4×2）的通道数为2。\n\n### 降采样\n\n[https://zhuanlan.zhihu.com/p/46633171](https://zhuanlan.zhihu.com/p/46633171)\n\n概念：降采样指的是成比例缩小特征图宽和高的过程\n\n例子：比如从（W，H）变为（W/2，H/2）\n\n方法：\n\n1. stride 大于 1 的 pooling\n    \n2. stride 大于 1 的 conv\n    \n3. stride 大于 1 的 reorg（在[YOLOv2的论文](https://link.zhihu.com/?target=https%3A//arxiv.org/pdf/1612.08242.pdf)里叫passthrough layer）\n    \n\n比较：\n\n1. 1 和 2 在深度卷积神经网络中使用非常普遍，3 比较小众，由Joseph Redmon在YOLOv2中首次提出。\n    \n2. 1 和 2 的对比在[Striving for Simplicity: The All Convolutional Net](https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1412.6806)中有详述\n    \n    用stride=2的conv降采样的卷积神经网络效果与使用pooling降采样的卷积神经网络效果相当；**卷积神经网络小的时候，使用pooling降采样效果可能更好**，卷积神经网络大的时候，使用stride=2的conv降采样效果可能更好。\n    \n    pooling提供了一种非线性，这种非线性需要较深的conv叠加才能实现，因此当网络比较浅的时候，pooling有一定优势；但是当网络很深的时候，多层叠加的conv可以学到pooling所能提供的非线性，甚至能根据训练集学到比pooling更好的非线性，因此当网络比较深的时候，不使用pooling没多大关系，甚至更好。\n    \n    pooling的非线性是固定的，不可学习的，这种非线性其实就是一种先验。\n    \n3. 3 中降采样的优势在于能够较好的保留低层次的信息。**1 和 2 的降采样方式，好处是抽取的特征具有更强的语义性，坏处是会丢失一些细节信息**。而3这种降采样方式与1、2相反，**3 提取的特征语义性不强，但是能保留大量细节信息**。所以当我们既需要降采样，又需要不丢失细节信息的时候，3是一个非常合适的选择。\n    \n\n### 升采样\n\n**将输入特征图的尺寸放大或增加分辨率。**\n\n通常与卷积和池化等操作结合使用，用于逆向传播梯度、特征图的恢复或生成更高分辨率的输出。\n\n基本目标是增加特征图的空间尺寸，以便更好地捕获细节信息、提高特征的表达能力或生成更高分辨率的输出。\n\n方法：\n\n1. 反卷积（Transpose Convolution）：反卷积是一种常见的升采样方式，也称为转置卷积、分数步长卷积。它通过在**输入特征图之间插入零值**，并**使用带有适当步长的卷积核进行卷积操作来放大特征图的尺寸**。反卷积操作可以增加特征图的空间尺寸，并在某种程度上恢复输入特征图的细节。\n    \n2. 双线性插值（Bilinear Interpolation）：双线性插值是一种基于插值的升采样方法，通过**对输入特征图中的每个像素进行插值计算来生成更大尺寸的特征图。**它使用**周围四个像素的权重进行插值，保持了图像的平滑性和连续性**。\n    \n3. 最近邻插值（Nearest Neighbor Interpolation）：最近邻插值是一种简单的升采样方法，它将输入特征图中每个像素的值复制到放大后的特征图的相应位置。它在放大时**不进行插值计算，而是直接使用最近邻像素的值**。这种方法简单高效，但可能**会导致输出特征图的锯齿状边缘**。\n    \n4. 其他一些升采样技术，如子像素卷积（Subpixel Convolution）、转置卷积的变种（如反池化操作）、像素重排（Pixel Shuffle）等。这些方法在不同的应用场景中具有各自的优势和适用性。\n    \n\n### 池化层\n\n是一种常用的操作层，用于减小特征图的空间尺寸、降低计算量，并增强模型的平移不变性。输入特征图的局部区域进行聚合或采样来生成池化特征图。\n\n池化操作：通常在每个输入特征图的局部区域上应用，通过对区域内的特征进行聚合或采样，生成一个单一的值或特征。这个聚合或采样过程可以是简单的求最大值（最大池化，Max Pooling）或求平均值（平均池化，Average Pooling），也可以是其他聚合方式，如Lp范数池化。\n\n在池化操作中，可以通过调整池化窗口的大小和步幅来控制输出特征图的大小和感受野。池化窗口是应用池化操作的局部区域的大小，**步幅**是**池化窗口**在输入特征图上移动的距离。\n\n常见的池化操作及其特点：\n\n1. 最大池化（Max Pooling）：在池化窗口内选择最大值作为池化特征。最大池化有助于保留显著的特征，提高模型的平移不变性和鲁棒性。\n    \n2. 平均池化（Average Pooling）：在池化窗口内求特征的平均值作为池化特征。平均池化可以减少特征图的空间维度，并平滑特征。\n    \n3. Lp范数池化（Lp-norm Pooling）：在池化窗口内对特征进行Lp范数归一化，得到池化特征。Lp范数池化可以对特征进行归一化，并引入更多非线性。\n    \n\n池化操作在CNN中具有以下优势：\n\n- 减小特征图的空间尺寸，降低计算量和内存需求。\n    \n- 提取特征的局部不变性，使模型对目标在图像中的位置变化具有鲁棒性。\n    \n- 减少模型过拟合的风险，通过减少参数数量和引入局部平均化。\n    \n\n池化层通常与卷积层交替使用，以构建深层次的卷积神经网络结构。它在图像分类、目标检测、图像分割等任务中广泛应用，并在提高模型性能和减少计算资源消耗方面发挥着重要作用。\n\n### batch size\n\n\"batch size\"（批大小）是指在一次训练迭代中同时输入模型的样本数量。批大小决定了在每一次参数更新时，模型所看到的样本数量。\n\n理解批大小可以参考以下几点：\n\n1. **样本数量**：批大小表示一次训练中同时处理的样本数量。例如，如果批大小为32，则在每次参数更新时，模型将同时处理32个样本。\n    \n2. **内存和计算效率**：较大的批大小可以提高计算效率，因为同时处理多个样本可以充分利用并行计算的能力。然而，较大的批大小可能需要更多的内存存储模型的中间结果。\n    \n3. **梯度估计**：在训练过程中，批大小还会影响对梯度的估计。较大的批大小可以提供更准确的梯度估计，因为它们包含了更多的样本信息。然而，较小的批大小可能导致模型收敛更快，因为它们更频繁地更新参数。\n    \n4. **泛化能力**：较大的批大小可能会导致模型过度拟合训练数据，因为它们更倾向于记住样本特定的细节。较小的批大小可以提供更好的泛化能力，因为它们更强迫模型学习更一般化的特征。\n\n### epoch（时期） \n    Epoch（时期）是指将整个训练数据集（包含多个批次）在模型中进行一次完整的训练。在一个epoch中，模型会对数据集中的每个样本都进行一次前向传播和反向传播，并根据损失函数计算的梯度来更新模型的参数。\n\n训练过程通常涉及多个epoch，因为一次完整的训练可能不足以使模型达到最佳性能。通过进行多个epoch，模型可以多次观察和学习数据的不同方面，并逐渐改善其性能。每个epoch之间的样本顺序通常会被随机化，以避免模型对样本顺序的依赖。\n\n### 向前步骤\n\n**向前步骤（Forward Propagation）**：\n\n- 在向前步骤中，输入样本通过模型的前向计算过程，从输入层经过一系列的神经网络层传递，最终得到模型的输出预测结果。\n    \n- 在每一层中，通过对输入数据进行线性变换（加权和）和非线性变换（激活函数），将信息从前一层传递到后一层，直到到达输出层。\n    \n- 向前步骤的目的是计算出模型的预测结果，以便与真实标签进行比较，并计算出损失函数的值。\n    \n\n### 反向传播步骤\n\n**反向传播步骤（Backpropagation）**：\n\n- 在反向传播步骤中，根据向前步骤中计算得到的损失函数值，通过链式法则计算每个参数对损失的贡献度，并更新模型的参数。\n    \n- 反向传播通过对损失函数关于模型参数的偏导数进行计算，从输出层向输入层逐层传递，以确定每个参数的梯度。\n    \n- 梯度表示了损失函数对每个参数的变化率，利用梯度可以确定参数的更新方向和大小，以最小化损失函数\n\n### 梯度的惩罚程度\n梯度的惩罚程度是指在计算梯度时对其进行的限制或惩罚的程度。在深度学习中，常用的梯度惩罚方法是通过添加正则化项或其他惩罚项来约束模型的参数更新。\n\n#### 目的\n防止参数更新过大或过快，以避免模型的过拟合或不稳定情况。通过对梯度进行惩罚，可以限制参数更新的幅度，使其保持在合理的范围内。\n\n梯度惩罚的程度可以通过调整惩罚项的权重或超参数来控制。增加梯度惩罚的程度意味着更强烈地限制梯度的大小或方向，从而减缓参数更新的速度。相反，减少梯度惩罚的程度会使梯度对参数更新的限制更加宽松。\n\n惩罚程度的选择通常需要根据具体问题和数据集的特点进行调整。过强的梯度惩罚可能导致模型无法学习到有效的特征，而过弱的梯度惩罚可能导致模型过拟合或训练不稳定。因此，需要根据实际情况进行实验和调优，选择合适的梯度惩罚程度以获得最佳的模型性能。\n\n\n### 自动编码器\n\n自动编码器（Autoencoder，AE）是一种无监督学习模型，用于学习数据的特征表示和压缩。它由编码器（Encoder）和解码器（Decoder）组成。\n\n1. 欠完备自动编码器（Undercomplete Autoencoder）：  \n    欠完备自动编码器是指编码器的维度低于输入数据的维度。这种设置迫使模型学习数据的主要特征，因为编码器无法完全捕获原始数据的所有信息。通过限制编码器的容量，欠完备自动编码器可以捕捉数据中最显著的特征，从而实现特征选择和降维。\n    \n2. 正则化自动编码器（Regularized Autoencoder）：  \n    正则化自动编码器通过在损失函数中引入额外的正则化项来约束模型的学习过程，以防止过拟合。常见的正则化方法包括L1正则化和L2正则化。L1正则化通过增加编码器的稀疏性，鼓励模型只使用输入数据的少数关键特征。L2正则化通过限制权重的大小，使模型对输入数据的小变化具有鲁棒性。\n    \n3. 变分自动编码器（Variational Autoencoder，VAE）：  \n    变分自动编码器是一种生成性模型，与判别性模型（欠完备自动编码器和正则化自动编码器）不同，它可以生成新的数据样本。VAE通过在潜在空间中引入随机性，使得模型能够在潜在空间中进行随机采样，并通过解码器生成新的样本。在训练过程中，VAE通过最大化“证据下界”（evidence lower bound，ELBO）来优化模型参数，从而实现对潜在空间的建模。这使得VAE能够学习到数据的潜在分布，并通过从该分布中采样生成新的数据样本。 \n\n### CIFAR-10 和 CIFAR-100\n\nCIFAR[数据集](https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E9%9B%86&spm=1001.2101.3001.7020)是 [Visual Dictionary (Teaching computers to recognize objects)](http://groups.csail.mit.edu/vision/TinyImages/) 的子集，由三个教授收集，主要来自google和各类搜索引擎的图片。\n\n[cifar10和cifar100(简介&可视化)_cifar10和cifar100区别-CSDN博客](https://blog.csdn.net/disanda/article/details/90744243)\n\n### MNIST数据集\n\n[https://blog.csdn.net/Iron802/article/details/121826385](https://blog.csdn.net/Iron802/article/details/121826385)\n\nMNIST数据集是NIST（National Institute of Standards and Technology，美国国家标准与技术研究所）数据集的一个子集，MNIST 数据集可在 [http://yann.lecun.com/exdb/mnist/](http://yann.lecun.com/exdb/mnist/) 获取，主要包括四个文件：","slug":"人工智能/深度学习基本概念","published":1,"date":"2024-04-22T13:14:49.007Z","updated":"2024-04-16T12:13:52.773Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0b000dkgg4dyfh313t","content":"<h2 id=\"自注意力机制\"><a href=\"#自注意力机制\" class=\"headerlink\" title=\"自注意力机制\"></a>自注意力机制</h2><p><a href=\"https://0809zheng.github.io/2020/04/24/self-attention.html\">https://0809zheng.github.io/2020/04/24/self-attention.html</a></p>\n<p>TODO</p>\n<p>下面是关于NLP中常用的一些知识的简要说明：</p>\n<ol>\n<li><p>Attention（注意力机制）： Attention是一种<strong>用于提升神经网络模型性能的机制</strong>，特别是在序列任务中。它允许<strong>模型在处理输入序列时将重点放在相关的部分上。</strong>通过计算每个输入位置的权重，模型可以自适应地决定要关注哪些部分。注意力机制在机器翻译、文本摘要、问答系统等任务中得到广泛应用。</p>\n</li>\n<li><p>Transformer（变换器）： Transformer是一种基于注意力机制的神经网络架构，用于处理序列数据。它在自然语言处理任务中取得了重大突破，并成为许多最先进的模型的基础。Transformer通过自注意力机制（self-attention）来捕捉输入序列中的依赖关系，避免了传统循环神经网络中的顺序计算，并且能够并行处理输入。Transformer的典型应用包括机器翻译（如Google的Transformer模型）和语言模型。</p>\n</li>\n<li><p>BERT（Bidirectional Encoder Representations from Transformers）： BERT是一种预训练的语言表示模型，基于Transformer架构。通过在大规模文本数据上进行无监督的预训练，BERT可以学习出通用的语言表示，然后可以在各种下游任务上进行微调。BERT引入了掩码语言模型（Masked Language Model, MLM）和下一句预测（Next Sentence Prediction, NSP）等任务来训练模型。BERT的出现对各种NLP任务，如文本分类、命名实体识别、问答系统等都产生了显著影响。</p>\n</li>\n<li><p>GPT（Generative Pre-trained Transformer）： GPT是一种基于Transformer架构的预训练语言模型，用于生成文本。GPT通过在大规模文本数据上进行自监督的预训练，学习出对输入序列的概率分布建模能力。然后，可以使用该模型生成具有连贯性和语法正确性的文本。GPT模型在生成式任务中表现出色，如文本生成、对话系统、机器写作等。</p>\n</li>\n<li><p>Prompt（提示）： Prompt是指在进行自然语言处理任务时，向模型提供一种任务描述或问题陈述的方式。通过给定一个显式的提示文本，模型可以更好地理解任务需求和上下文，从而产生更准确的输出。Prompt工程化是近年来在NLP任务中的一种重要技术，它可以帮助改进模型的可控性、减少模型的偏见，并提高模型的性能。</p>\n</li>\n</ol>\n<p>下面是这些概念之间的关系：</p>\n<ol>\n<li><p>Attention（注意力机制）是Transformer（变换器）模型的核心组件之一。Transformer通过自注意力机制实现了对输入序列的建模，其中每个位置可以根据其与其他位置的相关性来调整其重要性。</p>\n</li>\n<li><p>Transformer是一种神经网络架构，被广泛用于自然语言处理任务。它的设计中包含了多头注意力机制，可以同时关注不同位置的不同方面。Transformer的出现使得处理长序列数据变得更加高效，并在机器翻译、文本生成等任务中取得了显著的性能提升。</p>\n</li>\n<li><p>BERT（Bidirectional Encoder Representations from Transformers）是基于Transformer的预训练语言模型。它通过大规模的无监督预训练，在理解上下文和建模语言表示方面取得了巨大成功。BERT的预训练模型可以通过微调适应各种下游任务，如文本分类、命名实体识别等。</p>\n</li>\n<li><p>GPT（Generative Pre-trained Transformer）也是基于Transformer的预训练语言模型，但其目标是生成连贯的文本。GPT通过自监督学习来提前训练一个语言模型，然后可以用于生成各种文本，如文章、对话等。GPT模型在生成式任务中表现出色，可以产生具有语法正确性和连贯性的文本。</p>\n</li>\n<li><p>Prompt（提示）是在进行NLP任务时向模型提供任务描述或问题陈述的方式。Prompt的引入主要是为了改进模型的可控性和减少模型的偏见。通过设计合适的提示文本，可以引导模型在特定任务上产生更准确、更符合预期的输出。</p>\n</li>\n</ol>\n<p>总体而言，Attention是一种机制，Transformer是一种基于Attention的网络架构，BERT和GPT是基于Transformer的预训练语言模型，而Prompt是一种用于指导模型输出的技术手段。它们在NLP领域中相互关联，相互借鉴，共同推动了自然语言处理技术的发展。</p>\n<h2 id=\"深度卷积神经网络\"><a href=\"#深度卷积神经网络\" class=\"headerlink\" title=\"深度卷积神经网络\"></a>深度卷积神经网络</h2><p>至少在网络的一层中使用卷积运算来代替一般的矩阵乘法运算的神经网络，因此命名为卷积神经网络</p>\n<p><img src=\"file://D:\\Users\\fyn\\Documents\\Note\\Typora%E5%AD%97%E5%85%B8%E7%94%9F%E6%88%90%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.assets\\b98e8b23b2eec30346b082aa1fbca27ca8c377ab.png@1256w_712h_!web-article-pic.webp?lastModify=1708588580\" alt=\"img\"></p>\n<h3 id=\"卷积核\"><a href=\"#卷积核\" class=\"headerlink\" title=\"卷积核\"></a>卷积核</h3><p>卷积核（kernel） ，一个权重矩阵，逐步在二维输入数据上“扫描”，卷积核“滑动”的同时，计算权重矩阵和扫描所得的数据矩阵的乘积，然后把结果汇总成一个输出像素。</p>\n<p><strong>大小一般为奇数：</strong>原因</p>\n<ol>\n<li><p>更容易 padding，计算结果为整数</p>\n</li>\n<li><p>使用奇数大小的卷积核还可以保持对称性。对称性在卷积操作中是重要的，因为它可以确保输出特征图的空间分辨率与输入特征图相同。如果使用偶数大小的卷积核，由于缺少中心像素，可能会导致输出特征图的空间分辨率减小。</p>\n</li>\n<li><p>在CNN中，进行卷积操作时一般会以卷积核模块的一个位置为基准进行滑动，这个基准通常就是卷积核模块的中心。 卷积核大小为奇数时，它具有一个中心元素，这使得在进行卷积操作时，可以确保输入图像的每个像素都有对应的卷积核元素与之对齐。这种中心对齐的特性有助于提取局部特征，同时减少了信息丢失的可能性。</p>\n</li>\n</ol>\n<h3 id=\"卷积（Convolution）\"><a href=\"#卷积（Convolution）\" class=\"headerlink\" title=\"卷积（Convolution）\"></a>卷积（Convolution）</h3><p>所谓的卷积运算，其实它被称为<strong>互相关（cross-correlation）运算：</strong>将图像矩阵中，从左到右，由上到下，取与滤波器同等大小的一部分，每一部分中的值与滤波器中的值对应相乘后求和，最后的结果组成一个矩阵，其中没有对核进行翻转。</p>\n<blockquote>\n<p>数学上，给定两个函数 f(x) 和 g(x) 的卷积运算表示为：</p>\n<p>(f * g)(x) &#x3D; ∫[−∞,∞] f(t)g(x−t) dt</p>\n<p>对于每一个 x 得到的值 是 g 在 x 偏移 t 处 的值乘以 f(t) (权重) 的累加值，</p>\n</blockquote>\n<p><img src=\"file://D:\\Users\\fyn\\Documents\\Note\\Typora%E5%AD%97%E5%85%B8%E7%94%9F%E6%88%90%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.assets\\d646245dc94d4788dc48d0fcf6cd358f9d29f2c6.gif@1256w_1334h_!web-article-pic.webp?lastModify=1708588580\" alt=\"img\"></p>\n<p><strong>核心操作，用于提取特征</strong></p>\n<p>卷积运算具有一些重要的性质，例如交换律、结合律和分配律。</p>\n<p>深度学习里面所谓的卷积运算，其实它被称为<strong>互相关（cross-correlation）运算：</strong>将图像矩阵中，从左到右，由上到下，取与滤波器同等大小的一部分（f(x-t)），每一部分中的值与滤波器中的值（g(t)）对应相乘后求和，最后的结果组成一个矩阵，其中没有对核进行翻转。</p>\n<h3 id=\"填充（Padding）\"><a href=\"#填充（Padding）\" class=\"headerlink\" title=\"填充（Padding）\"></a>填充（Padding）</h3><p><strong>避免信息损失</strong></p>\n<p>输入图像与卷积核进行卷积后的结果中损失了部分值，输入图像的边缘被“修剪”掉了（边缘处只检测了部分像素点，丢失了图片边界处的众多信息）。这是因为边缘上的像素永远不会位于卷积核中心，而卷积核也没法扩展到边缘区域以外。</p>\n<p>这个结果我们是不能接受的，有时我们还希望输入和输出的大小应该保持一致。为解决这个问题，可以在进行卷积操作前，对原矩阵进行边界<strong>填充（Padding）</strong>，也就是在矩阵的边界上填充一些值，以增加矩阵的大小，通常都用“”来进行填充的。</p>\n<p><img src=\"file://D:\\Users\\fyn\\Documents\\Note\\Typora%E5%AD%97%E5%85%B8%E7%94%9F%E6%88%90%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.assets\\c883f882924c3bfe1784b2a8b1c507c3dbe42963.gif@1256w_1428h_!web-article-pic.webp?lastModify=1708588580\" alt=\"img\"></p>\n<p>通过填充的方法，当卷积核扫描输入数据时，它能延伸到边缘以外的伪像素，从而使输出和输入size相同。</p>\n<p>常用的两种padding：</p>\n<p>（1）valid padding：不进行任何处理，只使用原始图像，不允许卷积核超出原始图像边界</p>\n<p>（2）same padding：进行填充，允许卷积核超出原始图像边界，并使得卷积后结果的大小与原来的一致 作者：2kb的卷心菜 <a href=\"https://www.bilibili.com/read/cv16432604/\">https://www.bilibili.com/read/cv16432604/</a> 出处：bilibili</p>\n<h3 id=\"步长-Stride\"><a href=\"#步长-Stride\" class=\"headerlink\" title=\"步长(Stride)\"></a>步长(Stride)</h3><p><strong>压缩一部分信息，或者使输出的尺寸小于输入的尺寸</strong></p>\n<p><a href=\"https://baijiahao.baidu.com/s?id=1781826967010713030&wfr=spider&for=pc\">每天五分钟计算机视觉：卷积步长(Stride) (baidu.com)</a></p>\n<p><strong>滑动卷积核时</strong>，我们会先从输入的左上角开始，每次往左滑动一列或者往下滑动一行逐一计算输出，我们将<strong>每次滑动的行数和列数</strong>称为Stride，在之前的图片中，Stride&#x3D;1；在下图中，Stride&#x3D;2。</p>\n<p><img src=\"file://D:\\Users\\fyn\\Documents\\Note\\Typora%E5%AD%97%E5%85%B8%E7%94%9F%E6%88%90%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.assets\\af6e5cdf758fc9f2b6ba30235eae9e1c8128576b.gif@!web-article-pic.webp?lastModify=1708588580\" alt=\"img\"></p>\n<p><a href=\"https://www.bilibili.com/read/cv16432604/\">https://www.bilibili.com/read/cv16432604/</a> 出处：bilibili-2kb的卷心菜</p>\n<h3 id=\"通道\"><a href=\"#通道\" class=\"headerlink\" title=\"通道\"></a>通道</h3><p>比如 RGB 有 红绿蓝三个 通道</p>\n<p>这里就要涉及到“卷积核”和“filter”这两个术语的区别。在只有一个通道的情况下，“卷积核”就相当于“filter”，这两个概念是可以互换的。但在一般情况下，它们是两个完全不同的概念。每个“filter”实际上恰好是“卷积核”的一个集合，在当前层，每个通道都对应一个卷积核，且这个卷积核是独一无二的。</p>\n<p><strong>多通道卷积的计算过程</strong>：将矩阵与滤波器对应的每一个通道进行卷积运算，最后相加，形成一个单通道输出，加上偏置项后，我们得到了一个最终的单通道输出。如果存在多个filter，这时我们可以把这些最终的单通道输出组合成一个总输出。</p>\n<p><strong>某一层输出特征图的通道数</strong>&#x3D;当前层滤波器的个数。如上图所示，当只有一个filter时，输出特征图（4×4）的通道数为1；当有2个filter时，输出特征图（4×4×2）的通道数为2。</p>\n<h3 id=\"降采样\"><a href=\"#降采样\" class=\"headerlink\" title=\"降采样\"></a>降采样</h3><p><a href=\"https://zhuanlan.zhihu.com/p/46633171\">https://zhuanlan.zhihu.com/p/46633171</a></p>\n<p>概念：降采样指的是成比例缩小特征图宽和高的过程</p>\n<p>例子：比如从（W，H）变为（W&#x2F;2，H&#x2F;2）</p>\n<p>方法：</p>\n<ol>\n<li><p>stride 大于 1 的 pooling</p>\n</li>\n<li><p>stride 大于 1 的 conv</p>\n</li>\n<li><p>stride 大于 1 的 reorg（在<a href=\"https://link.zhihu.com/?target=https://arxiv.org/pdf/1612.08242.pdf\">YOLOv2的论文</a>里叫passthrough layer）</p>\n</li>\n</ol>\n<p>比较：</p>\n<ol>\n<li><p>1 和 2 在深度卷积神经网络中使用非常普遍，3 比较小众，由Joseph Redmon在YOLOv2中首次提出。</p>\n</li>\n<li><p>1 和 2 的对比在<a href=\"https://link.zhihu.com/?target=https://arxiv.org/abs/1412.6806\">Striving for Simplicity: The All Convolutional Net</a>中有详述</p>\n<p> 用stride&#x3D;2的conv降采样的卷积神经网络效果与使用pooling降采样的卷积神经网络效果相当；<strong>卷积神经网络小的时候，使用pooling降采样效果可能更好</strong>，卷积神经网络大的时候，使用stride&#x3D;2的conv降采样效果可能更好。</p>\n<p> pooling提供了一种非线性，这种非线性需要较深的conv叠加才能实现，因此当网络比较浅的时候，pooling有一定优势；但是当网络很深的时候，多层叠加的conv可以学到pooling所能提供的非线性，甚至能根据训练集学到比pooling更好的非线性，因此当网络比较深的时候，不使用pooling没多大关系，甚至更好。</p>\n<p> pooling的非线性是固定的，不可学习的，这种非线性其实就是一种先验。</p>\n</li>\n<li><p>3 中降采样的优势在于能够较好的保留低层次的信息。<strong>1 和 2 的降采样方式，好处是抽取的特征具有更强的语义性，坏处是会丢失一些细节信息</strong>。而3这种降采样方式与1、2相反，<strong>3 提取的特征语义性不强，但是能保留大量细节信息</strong>。所以当我们既需要降采样，又需要不丢失细节信息的时候，3是一个非常合适的选择。</p>\n</li>\n</ol>\n<h3 id=\"升采样\"><a href=\"#升采样\" class=\"headerlink\" title=\"升采样\"></a>升采样</h3><p><strong>将输入特征图的尺寸放大或增加分辨率。</strong></p>\n<p>通常与卷积和池化等操作结合使用，用于逆向传播梯度、特征图的恢复或生成更高分辨率的输出。</p>\n<p>基本目标是增加特征图的空间尺寸，以便更好地捕获细节信息、提高特征的表达能力或生成更高分辨率的输出。</p>\n<p>方法：</p>\n<ol>\n<li><p>反卷积（Transpose Convolution）：反卷积是一种常见的升采样方式，也称为转置卷积、分数步长卷积。它通过在<strong>输入特征图之间插入零值</strong>，并<strong>使用带有适当步长的卷积核进行卷积操作来放大特征图的尺寸</strong>。反卷积操作可以增加特征图的空间尺寸，并在某种程度上恢复输入特征图的细节。</p>\n</li>\n<li><p>双线性插值（Bilinear Interpolation）：双线性插值是一种基于插值的升采样方法，通过<strong>对输入特征图中的每个像素进行插值计算来生成更大尺寸的特征图。</strong>它使用<strong>周围四个像素的权重进行插值，保持了图像的平滑性和连续性</strong>。</p>\n</li>\n<li><p>最近邻插值（Nearest Neighbor Interpolation）：最近邻插值是一种简单的升采样方法，它将输入特征图中每个像素的值复制到放大后的特征图的相应位置。它在放大时<strong>不进行插值计算，而是直接使用最近邻像素的值</strong>。这种方法简单高效，但可能<strong>会导致输出特征图的锯齿状边缘</strong>。</p>\n</li>\n<li><p>其他一些升采样技术，如子像素卷积（Subpixel Convolution）、转置卷积的变种（如反池化操作）、像素重排（Pixel Shuffle）等。这些方法在不同的应用场景中具有各自的优势和适用性。</p>\n</li>\n</ol>\n<h3 id=\"池化层\"><a href=\"#池化层\" class=\"headerlink\" title=\"池化层\"></a>池化层</h3><p>是一种常用的操作层，用于减小特征图的空间尺寸、降低计算量，并增强模型的平移不变性。输入特征图的局部区域进行聚合或采样来生成池化特征图。</p>\n<p>池化操作：通常在每个输入特征图的局部区域上应用，通过对区域内的特征进行聚合或采样，生成一个单一的值或特征。这个聚合或采样过程可以是简单的求最大值（最大池化，Max Pooling）或求平均值（平均池化，Average Pooling），也可以是其他聚合方式，如Lp范数池化。</p>\n<p>在池化操作中，可以通过调整池化窗口的大小和步幅来控制输出特征图的大小和感受野。池化窗口是应用池化操作的局部区域的大小，<strong>步幅</strong>是<strong>池化窗口</strong>在输入特征图上移动的距离。</p>\n<p>常见的池化操作及其特点：</p>\n<ol>\n<li><p>最大池化（Max Pooling）：在池化窗口内选择最大值作为池化特征。最大池化有助于保留显著的特征，提高模型的平移不变性和鲁棒性。</p>\n</li>\n<li><p>平均池化（Average Pooling）：在池化窗口内求特征的平均值作为池化特征。平均池化可以减少特征图的空间维度，并平滑特征。</p>\n</li>\n<li><p>Lp范数池化（Lp-norm Pooling）：在池化窗口内对特征进行Lp范数归一化，得到池化特征。Lp范数池化可以对特征进行归一化，并引入更多非线性。</p>\n</li>\n</ol>\n<p>池化操作在CNN中具有以下优势：</p>\n<ul>\n<li><p>减小特征图的空间尺寸，降低计算量和内存需求。</p>\n</li>\n<li><p>提取特征的局部不变性，使模型对目标在图像中的位置变化具有鲁棒性。</p>\n</li>\n<li><p>减少模型过拟合的风险，通过减少参数数量和引入局部平均化。</p>\n</li>\n</ul>\n<p>池化层通常与卷积层交替使用，以构建深层次的卷积神经网络结构。它在图像分类、目标检测、图像分割等任务中广泛应用，并在提高模型性能和减少计算资源消耗方面发挥着重要作用。</p>\n<h3 id=\"batch-size\"><a href=\"#batch-size\" class=\"headerlink\" title=\"batch size\"></a>batch size</h3><p>“batch size”（批大小）是指在一次训练迭代中同时输入模型的样本数量。批大小决定了在每一次参数更新时，模型所看到的样本数量。</p>\n<p>理解批大小可以参考以下几点：</p>\n<ol>\n<li><p><strong>样本数量</strong>：批大小表示一次训练中同时处理的样本数量。例如，如果批大小为32，则在每次参数更新时，模型将同时处理32个样本。</p>\n</li>\n<li><p><strong>内存和计算效率</strong>：较大的批大小可以提高计算效率，因为同时处理多个样本可以充分利用并行计算的能力。然而，较大的批大小可能需要更多的内存存储模型的中间结果。</p>\n</li>\n<li><p><strong>梯度估计</strong>：在训练过程中，批大小还会影响对梯度的估计。较大的批大小可以提供更准确的梯度估计，因为它们包含了更多的样本信息。然而，较小的批大小可能导致模型收敛更快，因为它们更频繁地更新参数。</p>\n</li>\n<li><p><strong>泛化能力</strong>：较大的批大小可能会导致模型过度拟合训练数据，因为它们更倾向于记住样本特定的细节。较小的批大小可以提供更好的泛化能力，因为它们更强迫模型学习更一般化的特征。</p>\n</li>\n</ol>\n<h3 id=\"epoch（时期）\"><a href=\"#epoch（时期）\" class=\"headerlink\" title=\"epoch（时期）\"></a>epoch（时期）</h3><pre><code>Epoch（时期）是指将整个训练数据集（包含多个批次）在模型中进行一次完整的训练。在一个epoch中，模型会对数据集中的每个样本都进行一次前向传播和反向传播，并根据损失函数计算的梯度来更新模型的参数。\n</code></pre>\n<p>训练过程通常涉及多个epoch，因为一次完整的训练可能不足以使模型达到最佳性能。通过进行多个epoch，模型可以多次观察和学习数据的不同方面，并逐渐改善其性能。每个epoch之间的样本顺序通常会被随机化，以避免模型对样本顺序的依赖。</p>\n<h3 id=\"向前步骤\"><a href=\"#向前步骤\" class=\"headerlink\" title=\"向前步骤\"></a>向前步骤</h3><p><strong>向前步骤（Forward Propagation）</strong>：</p>\n<ul>\n<li><p>在向前步骤中，输入样本通过模型的前向计算过程，从输入层经过一系列的神经网络层传递，最终得到模型的输出预测结果。</p>\n</li>\n<li><p>在每一层中，通过对输入数据进行线性变换（加权和）和非线性变换（激活函数），将信息从前一层传递到后一层，直到到达输出层。</p>\n</li>\n<li><p>向前步骤的目的是计算出模型的预测结果，以便与真实标签进行比较，并计算出损失函数的值。</p>\n</li>\n</ul>\n<h3 id=\"反向传播步骤\"><a href=\"#反向传播步骤\" class=\"headerlink\" title=\"反向传播步骤\"></a>反向传播步骤</h3><p><strong>反向传播步骤（Backpropagation）</strong>：</p>\n<ul>\n<li><p>在反向传播步骤中，根据向前步骤中计算得到的损失函数值，通过链式法则计算每个参数对损失的贡献度，并更新模型的参数。</p>\n</li>\n<li><p>反向传播通过对损失函数关于模型参数的偏导数进行计算，从输出层向输入层逐层传递，以确定每个参数的梯度。</p>\n</li>\n<li><p>梯度表示了损失函数对每个参数的变化率，利用梯度可以确定参数的更新方向和大小，以最小化损失函数</p>\n</li>\n</ul>\n<h3 id=\"梯度的惩罚程度\"><a href=\"#梯度的惩罚程度\" class=\"headerlink\" title=\"梯度的惩罚程度\"></a>梯度的惩罚程度</h3><p>梯度的惩罚程度是指在计算梯度时对其进行的限制或惩罚的程度。在深度学习中，常用的梯度惩罚方法是通过添加正则化项或其他惩罚项来约束模型的参数更新。</p>\n<h4 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h4><p>防止参数更新过大或过快，以避免模型的过拟合或不稳定情况。通过对梯度进行惩罚，可以限制参数更新的幅度，使其保持在合理的范围内。</p>\n<p>梯度惩罚的程度可以通过调整惩罚项的权重或超参数来控制。增加梯度惩罚的程度意味着更强烈地限制梯度的大小或方向，从而减缓参数更新的速度。相反，减少梯度惩罚的程度会使梯度对参数更新的限制更加宽松。</p>\n<p>惩罚程度的选择通常需要根据具体问题和数据集的特点进行调整。过强的梯度惩罚可能导致模型无法学习到有效的特征，而过弱的梯度惩罚可能导致模型过拟合或训练不稳定。因此，需要根据实际情况进行实验和调优，选择合适的梯度惩罚程度以获得最佳的模型性能。</p>\n<h3 id=\"自动编码器\"><a href=\"#自动编码器\" class=\"headerlink\" title=\"自动编码器\"></a>自动编码器</h3><p>自动编码器（Autoencoder，AE）是一种无监督学习模型，用于学习数据的特征表示和压缩。它由编码器（Encoder）和解码器（Decoder）组成。</p>\n<ol>\n<li><p>欠完备自动编码器（Undercomplete Autoencoder）：<br> 欠完备自动编码器是指编码器的维度低于输入数据的维度。这种设置迫使模型学习数据的主要特征，因为编码器无法完全捕获原始数据的所有信息。通过限制编码器的容量，欠完备自动编码器可以捕捉数据中最显著的特征，从而实现特征选择和降维。</p>\n</li>\n<li><p>正则化自动编码器（Regularized Autoencoder）：<br> 正则化自动编码器通过在损失函数中引入额外的正则化项来约束模型的学习过程，以防止过拟合。常见的正则化方法包括L1正则化和L2正则化。L1正则化通过增加编码器的稀疏性，鼓励模型只使用输入数据的少数关键特征。L2正则化通过限制权重的大小，使模型对输入数据的小变化具有鲁棒性。</p>\n</li>\n<li><p>变分自动编码器（Variational Autoencoder，VAE）：<br> 变分自动编码器是一种生成性模型，与判别性模型（欠完备自动编码器和正则化自动编码器）不同，它可以生成新的数据样本。VAE通过在潜在空间中引入随机性，使得模型能够在潜在空间中进行随机采样，并通过解码器生成新的样本。在训练过程中，VAE通过最大化“证据下界”（evidence lower bound，ELBO）来优化模型参数，从而实现对潜在空间的建模。这使得VAE能够学习到数据的潜在分布，并通过从该分布中采样生成新的数据样本。</p>\n</li>\n</ol>\n<h3 id=\"CIFAR-10-和-CIFAR-100\"><a href=\"#CIFAR-10-和-CIFAR-100\" class=\"headerlink\" title=\"CIFAR-10 和 CIFAR-100\"></a>CIFAR-10 和 CIFAR-100</h3><p>CIFAR<a href=\"https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E9%9B%86&spm=1001.2101.3001.7020\">数据集</a>是 <a href=\"http://groups.csail.mit.edu/vision/TinyImages/\">Visual Dictionary (Teaching computers to recognize objects)</a> 的子集，由三个教授收集，主要来自google和各类搜索引擎的图片。</p>\n<p><a href=\"https://blog.csdn.net/disanda/article/details/90744243\">cifar10和cifar100(简介&amp;可视化)_cifar10和cifar100区别-CSDN博客</a></p>\n<h3 id=\"MNIST数据集\"><a href=\"#MNIST数据集\" class=\"headerlink\" title=\"MNIST数据集\"></a>MNIST数据集</h3><p><a href=\"https://blog.csdn.net/Iron802/article/details/121826385\">https://blog.csdn.net/Iron802/article/details/121826385</a></p>\n<p>MNIST数据集是NIST（National Institute of Standards and Technology，美国国家标准与技术研究所）数据集的一个子集，MNIST 数据集可在 <a href=\"http://yann.lecun.com/exdb/mnist/\">http://yann.lecun.com/exdb/mnist/</a> 获取，主要包括四个文件：</p>\n","excerpt":"","more":"<h2 id=\"自注意力机制\"><a href=\"#自注意力机制\" class=\"headerlink\" title=\"自注意力机制\"></a>自注意力机制</h2><p><a href=\"https://0809zheng.github.io/2020/04/24/self-attention.html\">https://0809zheng.github.io/2020/04/24/self-attention.html</a></p>\n<p>TODO</p>\n<p>下面是关于NLP中常用的一些知识的简要说明：</p>\n<ol>\n<li><p>Attention（注意力机制）： Attention是一种<strong>用于提升神经网络模型性能的机制</strong>，特别是在序列任务中。它允许<strong>模型在处理输入序列时将重点放在相关的部分上。</strong>通过计算每个输入位置的权重，模型可以自适应地决定要关注哪些部分。注意力机制在机器翻译、文本摘要、问答系统等任务中得到广泛应用。</p>\n</li>\n<li><p>Transformer（变换器）： Transformer是一种基于注意力机制的神经网络架构，用于处理序列数据。它在自然语言处理任务中取得了重大突破，并成为许多最先进的模型的基础。Transformer通过自注意力机制（self-attention）来捕捉输入序列中的依赖关系，避免了传统循环神经网络中的顺序计算，并且能够并行处理输入。Transformer的典型应用包括机器翻译（如Google的Transformer模型）和语言模型。</p>\n</li>\n<li><p>BERT（Bidirectional Encoder Representations from Transformers）： BERT是一种预训练的语言表示模型，基于Transformer架构。通过在大规模文本数据上进行无监督的预训练，BERT可以学习出通用的语言表示，然后可以在各种下游任务上进行微调。BERT引入了掩码语言模型（Masked Language Model, MLM）和下一句预测（Next Sentence Prediction, NSP）等任务来训练模型。BERT的出现对各种NLP任务，如文本分类、命名实体识别、问答系统等都产生了显著影响。</p>\n</li>\n<li><p>GPT（Generative Pre-trained Transformer）： GPT是一种基于Transformer架构的预训练语言模型，用于生成文本。GPT通过在大规模文本数据上进行自监督的预训练，学习出对输入序列的概率分布建模能力。然后，可以使用该模型生成具有连贯性和语法正确性的文本。GPT模型在生成式任务中表现出色，如文本生成、对话系统、机器写作等。</p>\n</li>\n<li><p>Prompt（提示）： Prompt是指在进行自然语言处理任务时，向模型提供一种任务描述或问题陈述的方式。通过给定一个显式的提示文本，模型可以更好地理解任务需求和上下文，从而产生更准确的输出。Prompt工程化是近年来在NLP任务中的一种重要技术，它可以帮助改进模型的可控性、减少模型的偏见，并提高模型的性能。</p>\n</li>\n</ol>\n<p>下面是这些概念之间的关系：</p>\n<ol>\n<li><p>Attention（注意力机制）是Transformer（变换器）模型的核心组件之一。Transformer通过自注意力机制实现了对输入序列的建模，其中每个位置可以根据其与其他位置的相关性来调整其重要性。</p>\n</li>\n<li><p>Transformer是一种神经网络架构，被广泛用于自然语言处理任务。它的设计中包含了多头注意力机制，可以同时关注不同位置的不同方面。Transformer的出现使得处理长序列数据变得更加高效，并在机器翻译、文本生成等任务中取得了显著的性能提升。</p>\n</li>\n<li><p>BERT（Bidirectional Encoder Representations from Transformers）是基于Transformer的预训练语言模型。它通过大规模的无监督预训练，在理解上下文和建模语言表示方面取得了巨大成功。BERT的预训练模型可以通过微调适应各种下游任务，如文本分类、命名实体识别等。</p>\n</li>\n<li><p>GPT（Generative Pre-trained Transformer）也是基于Transformer的预训练语言模型，但其目标是生成连贯的文本。GPT通过自监督学习来提前训练一个语言模型，然后可以用于生成各种文本，如文章、对话等。GPT模型在生成式任务中表现出色，可以产生具有语法正确性和连贯性的文本。</p>\n</li>\n<li><p>Prompt（提示）是在进行NLP任务时向模型提供任务描述或问题陈述的方式。Prompt的引入主要是为了改进模型的可控性和减少模型的偏见。通过设计合适的提示文本，可以引导模型在特定任务上产生更准确、更符合预期的输出。</p>\n</li>\n</ol>\n<p>总体而言，Attention是一种机制，Transformer是一种基于Attention的网络架构，BERT和GPT是基于Transformer的预训练语言模型，而Prompt是一种用于指导模型输出的技术手段。它们在NLP领域中相互关联，相互借鉴，共同推动了自然语言处理技术的发展。</p>\n<h2 id=\"深度卷积神经网络\"><a href=\"#深度卷积神经网络\" class=\"headerlink\" title=\"深度卷积神经网络\"></a>深度卷积神经网络</h2><p>至少在网络的一层中使用卷积运算来代替一般的矩阵乘法运算的神经网络，因此命名为卷积神经网络</p>\n<p><img src=\"file://D:\\Users\\fyn\\Documents\\Note\\Typora%E5%AD%97%E5%85%B8%E7%94%9F%E6%88%90%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.assets\\b98e8b23b2eec30346b082aa1fbca27ca8c377ab.png@1256w_712h_!web-article-pic.webp?lastModify=1708588580\" alt=\"img\"></p>\n<h3 id=\"卷积核\"><a href=\"#卷积核\" class=\"headerlink\" title=\"卷积核\"></a>卷积核</h3><p>卷积核（kernel） ，一个权重矩阵，逐步在二维输入数据上“扫描”，卷积核“滑动”的同时，计算权重矩阵和扫描所得的数据矩阵的乘积，然后把结果汇总成一个输出像素。</p>\n<p><strong>大小一般为奇数：</strong>原因</p>\n<ol>\n<li><p>更容易 padding，计算结果为整数</p>\n</li>\n<li><p>使用奇数大小的卷积核还可以保持对称性。对称性在卷积操作中是重要的，因为它可以确保输出特征图的空间分辨率与输入特征图相同。如果使用偶数大小的卷积核，由于缺少中心像素，可能会导致输出特征图的空间分辨率减小。</p>\n</li>\n<li><p>在CNN中，进行卷积操作时一般会以卷积核模块的一个位置为基准进行滑动，这个基准通常就是卷积核模块的中心。 卷积核大小为奇数时，它具有一个中心元素，这使得在进行卷积操作时，可以确保输入图像的每个像素都有对应的卷积核元素与之对齐。这种中心对齐的特性有助于提取局部特征，同时减少了信息丢失的可能性。</p>\n</li>\n</ol>\n<h3 id=\"卷积（Convolution）\"><a href=\"#卷积（Convolution）\" class=\"headerlink\" title=\"卷积（Convolution）\"></a>卷积（Convolution）</h3><p>所谓的卷积运算，其实它被称为<strong>互相关（cross-correlation）运算：</strong>将图像矩阵中，从左到右，由上到下，取与滤波器同等大小的一部分，每一部分中的值与滤波器中的值对应相乘后求和，最后的结果组成一个矩阵，其中没有对核进行翻转。</p>\n<blockquote>\n<p>数学上，给定两个函数 f(x) 和 g(x) 的卷积运算表示为：</p>\n<p>(f * g)(x) &#x3D; ∫[−∞,∞] f(t)g(x−t) dt</p>\n<p>对于每一个 x 得到的值 是 g 在 x 偏移 t 处 的值乘以 f(t) (权重) 的累加值，</p>\n</blockquote>\n<p><img src=\"file://D:\\Users\\fyn\\Documents\\Note\\Typora%E5%AD%97%E5%85%B8%E7%94%9F%E6%88%90%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.assets\\d646245dc94d4788dc48d0fcf6cd358f9d29f2c6.gif@1256w_1334h_!web-article-pic.webp?lastModify=1708588580\" alt=\"img\"></p>\n<p><strong>核心操作，用于提取特征</strong></p>\n<p>卷积运算具有一些重要的性质，例如交换律、结合律和分配律。</p>\n<p>深度学习里面所谓的卷积运算，其实它被称为<strong>互相关（cross-correlation）运算：</strong>将图像矩阵中，从左到右，由上到下，取与滤波器同等大小的一部分（f(x-t)），每一部分中的值与滤波器中的值（g(t)）对应相乘后求和，最后的结果组成一个矩阵，其中没有对核进行翻转。</p>\n<h3 id=\"填充（Padding）\"><a href=\"#填充（Padding）\" class=\"headerlink\" title=\"填充（Padding）\"></a>填充（Padding）</h3><p><strong>避免信息损失</strong></p>\n<p>输入图像与卷积核进行卷积后的结果中损失了部分值，输入图像的边缘被“修剪”掉了（边缘处只检测了部分像素点，丢失了图片边界处的众多信息）。这是因为边缘上的像素永远不会位于卷积核中心，而卷积核也没法扩展到边缘区域以外。</p>\n<p>这个结果我们是不能接受的，有时我们还希望输入和输出的大小应该保持一致。为解决这个问题，可以在进行卷积操作前，对原矩阵进行边界<strong>填充（Padding）</strong>，也就是在矩阵的边界上填充一些值，以增加矩阵的大小，通常都用“”来进行填充的。</p>\n<p><img src=\"file://D:\\Users\\fyn\\Documents\\Note\\Typora%E5%AD%97%E5%85%B8%E7%94%9F%E6%88%90%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.assets\\c883f882924c3bfe1784b2a8b1c507c3dbe42963.gif@1256w_1428h_!web-article-pic.webp?lastModify=1708588580\" alt=\"img\"></p>\n<p>通过填充的方法，当卷积核扫描输入数据时，它能延伸到边缘以外的伪像素，从而使输出和输入size相同。</p>\n<p>常用的两种padding：</p>\n<p>（1）valid padding：不进行任何处理，只使用原始图像，不允许卷积核超出原始图像边界</p>\n<p>（2）same padding：进行填充，允许卷积核超出原始图像边界，并使得卷积后结果的大小与原来的一致 作者：2kb的卷心菜 <a href=\"https://www.bilibili.com/read/cv16432604/\">https://www.bilibili.com/read/cv16432604/</a> 出处：bilibili</p>\n<h3 id=\"步长-Stride\"><a href=\"#步长-Stride\" class=\"headerlink\" title=\"步长(Stride)\"></a>步长(Stride)</h3><p><strong>压缩一部分信息，或者使输出的尺寸小于输入的尺寸</strong></p>\n<p><a href=\"https://baijiahao.baidu.com/s?id=1781826967010713030&wfr=spider&for=pc\">每天五分钟计算机视觉：卷积步长(Stride) (baidu.com)</a></p>\n<p><strong>滑动卷积核时</strong>，我们会先从输入的左上角开始，每次往左滑动一列或者往下滑动一行逐一计算输出，我们将<strong>每次滑动的行数和列数</strong>称为Stride，在之前的图片中，Stride&#x3D;1；在下图中，Stride&#x3D;2。</p>\n<p><img src=\"file://D:\\Users\\fyn\\Documents\\Note\\Typora%E5%AD%97%E5%85%B8%E7%94%9F%E6%88%90%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.assets\\af6e5cdf758fc9f2b6ba30235eae9e1c8128576b.gif@!web-article-pic.webp?lastModify=1708588580\" alt=\"img\"></p>\n<p><a href=\"https://www.bilibili.com/read/cv16432604/\">https://www.bilibili.com/read/cv16432604/</a> 出处：bilibili-2kb的卷心菜</p>\n<h3 id=\"通道\"><a href=\"#通道\" class=\"headerlink\" title=\"通道\"></a>通道</h3><p>比如 RGB 有 红绿蓝三个 通道</p>\n<p>这里就要涉及到“卷积核”和“filter”这两个术语的区别。在只有一个通道的情况下，“卷积核”就相当于“filter”，这两个概念是可以互换的。但在一般情况下，它们是两个完全不同的概念。每个“filter”实际上恰好是“卷积核”的一个集合，在当前层，每个通道都对应一个卷积核，且这个卷积核是独一无二的。</p>\n<p><strong>多通道卷积的计算过程</strong>：将矩阵与滤波器对应的每一个通道进行卷积运算，最后相加，形成一个单通道输出，加上偏置项后，我们得到了一个最终的单通道输出。如果存在多个filter，这时我们可以把这些最终的单通道输出组合成一个总输出。</p>\n<p><strong>某一层输出特征图的通道数</strong>&#x3D;当前层滤波器的个数。如上图所示，当只有一个filter时，输出特征图（4×4）的通道数为1；当有2个filter时，输出特征图（4×4×2）的通道数为2。</p>\n<h3 id=\"降采样\"><a href=\"#降采样\" class=\"headerlink\" title=\"降采样\"></a>降采样</h3><p><a href=\"https://zhuanlan.zhihu.com/p/46633171\">https://zhuanlan.zhihu.com/p/46633171</a></p>\n<p>概念：降采样指的是成比例缩小特征图宽和高的过程</p>\n<p>例子：比如从（W，H）变为（W&#x2F;2，H&#x2F;2）</p>\n<p>方法：</p>\n<ol>\n<li><p>stride 大于 1 的 pooling</p>\n</li>\n<li><p>stride 大于 1 的 conv</p>\n</li>\n<li><p>stride 大于 1 的 reorg（在<a href=\"https://link.zhihu.com/?target=https://arxiv.org/pdf/1612.08242.pdf\">YOLOv2的论文</a>里叫passthrough layer）</p>\n</li>\n</ol>\n<p>比较：</p>\n<ol>\n<li><p>1 和 2 在深度卷积神经网络中使用非常普遍，3 比较小众，由Joseph Redmon在YOLOv2中首次提出。</p>\n</li>\n<li><p>1 和 2 的对比在<a href=\"https://link.zhihu.com/?target=https://arxiv.org/abs/1412.6806\">Striving for Simplicity: The All Convolutional Net</a>中有详述</p>\n<p> 用stride&#x3D;2的conv降采样的卷积神经网络效果与使用pooling降采样的卷积神经网络效果相当；<strong>卷积神经网络小的时候，使用pooling降采样效果可能更好</strong>，卷积神经网络大的时候，使用stride&#x3D;2的conv降采样效果可能更好。</p>\n<p> pooling提供了一种非线性，这种非线性需要较深的conv叠加才能实现，因此当网络比较浅的时候，pooling有一定优势；但是当网络很深的时候，多层叠加的conv可以学到pooling所能提供的非线性，甚至能根据训练集学到比pooling更好的非线性，因此当网络比较深的时候，不使用pooling没多大关系，甚至更好。</p>\n<p> pooling的非线性是固定的，不可学习的，这种非线性其实就是一种先验。</p>\n</li>\n<li><p>3 中降采样的优势在于能够较好的保留低层次的信息。<strong>1 和 2 的降采样方式，好处是抽取的特征具有更强的语义性，坏处是会丢失一些细节信息</strong>。而3这种降采样方式与1、2相反，<strong>3 提取的特征语义性不强，但是能保留大量细节信息</strong>。所以当我们既需要降采样，又需要不丢失细节信息的时候，3是一个非常合适的选择。</p>\n</li>\n</ol>\n<h3 id=\"升采样\"><a href=\"#升采样\" class=\"headerlink\" title=\"升采样\"></a>升采样</h3><p><strong>将输入特征图的尺寸放大或增加分辨率。</strong></p>\n<p>通常与卷积和池化等操作结合使用，用于逆向传播梯度、特征图的恢复或生成更高分辨率的输出。</p>\n<p>基本目标是增加特征图的空间尺寸，以便更好地捕获细节信息、提高特征的表达能力或生成更高分辨率的输出。</p>\n<p>方法：</p>\n<ol>\n<li><p>反卷积（Transpose Convolution）：反卷积是一种常见的升采样方式，也称为转置卷积、分数步长卷积。它通过在<strong>输入特征图之间插入零值</strong>，并<strong>使用带有适当步长的卷积核进行卷积操作来放大特征图的尺寸</strong>。反卷积操作可以增加特征图的空间尺寸，并在某种程度上恢复输入特征图的细节。</p>\n</li>\n<li><p>双线性插值（Bilinear Interpolation）：双线性插值是一种基于插值的升采样方法，通过<strong>对输入特征图中的每个像素进行插值计算来生成更大尺寸的特征图。</strong>它使用<strong>周围四个像素的权重进行插值，保持了图像的平滑性和连续性</strong>。</p>\n</li>\n<li><p>最近邻插值（Nearest Neighbor Interpolation）：最近邻插值是一种简单的升采样方法，它将输入特征图中每个像素的值复制到放大后的特征图的相应位置。它在放大时<strong>不进行插值计算，而是直接使用最近邻像素的值</strong>。这种方法简单高效，但可能<strong>会导致输出特征图的锯齿状边缘</strong>。</p>\n</li>\n<li><p>其他一些升采样技术，如子像素卷积（Subpixel Convolution）、转置卷积的变种（如反池化操作）、像素重排（Pixel Shuffle）等。这些方法在不同的应用场景中具有各自的优势和适用性。</p>\n</li>\n</ol>\n<h3 id=\"池化层\"><a href=\"#池化层\" class=\"headerlink\" title=\"池化层\"></a>池化层</h3><p>是一种常用的操作层，用于减小特征图的空间尺寸、降低计算量，并增强模型的平移不变性。输入特征图的局部区域进行聚合或采样来生成池化特征图。</p>\n<p>池化操作：通常在每个输入特征图的局部区域上应用，通过对区域内的特征进行聚合或采样，生成一个单一的值或特征。这个聚合或采样过程可以是简单的求最大值（最大池化，Max Pooling）或求平均值（平均池化，Average Pooling），也可以是其他聚合方式，如Lp范数池化。</p>\n<p>在池化操作中，可以通过调整池化窗口的大小和步幅来控制输出特征图的大小和感受野。池化窗口是应用池化操作的局部区域的大小，<strong>步幅</strong>是<strong>池化窗口</strong>在输入特征图上移动的距离。</p>\n<p>常见的池化操作及其特点：</p>\n<ol>\n<li><p>最大池化（Max Pooling）：在池化窗口内选择最大值作为池化特征。最大池化有助于保留显著的特征，提高模型的平移不变性和鲁棒性。</p>\n</li>\n<li><p>平均池化（Average Pooling）：在池化窗口内求特征的平均值作为池化特征。平均池化可以减少特征图的空间维度，并平滑特征。</p>\n</li>\n<li><p>Lp范数池化（Lp-norm Pooling）：在池化窗口内对特征进行Lp范数归一化，得到池化特征。Lp范数池化可以对特征进行归一化，并引入更多非线性。</p>\n</li>\n</ol>\n<p>池化操作在CNN中具有以下优势：</p>\n<ul>\n<li><p>减小特征图的空间尺寸，降低计算量和内存需求。</p>\n</li>\n<li><p>提取特征的局部不变性，使模型对目标在图像中的位置变化具有鲁棒性。</p>\n</li>\n<li><p>减少模型过拟合的风险，通过减少参数数量和引入局部平均化。</p>\n</li>\n</ul>\n<p>池化层通常与卷积层交替使用，以构建深层次的卷积神经网络结构。它在图像分类、目标检测、图像分割等任务中广泛应用，并在提高模型性能和减少计算资源消耗方面发挥着重要作用。</p>\n<h3 id=\"batch-size\"><a href=\"#batch-size\" class=\"headerlink\" title=\"batch size\"></a>batch size</h3><p>“batch size”（批大小）是指在一次训练迭代中同时输入模型的样本数量。批大小决定了在每一次参数更新时，模型所看到的样本数量。</p>\n<p>理解批大小可以参考以下几点：</p>\n<ol>\n<li><p><strong>样本数量</strong>：批大小表示一次训练中同时处理的样本数量。例如，如果批大小为32，则在每次参数更新时，模型将同时处理32个样本。</p>\n</li>\n<li><p><strong>内存和计算效率</strong>：较大的批大小可以提高计算效率，因为同时处理多个样本可以充分利用并行计算的能力。然而，较大的批大小可能需要更多的内存存储模型的中间结果。</p>\n</li>\n<li><p><strong>梯度估计</strong>：在训练过程中，批大小还会影响对梯度的估计。较大的批大小可以提供更准确的梯度估计，因为它们包含了更多的样本信息。然而，较小的批大小可能导致模型收敛更快，因为它们更频繁地更新参数。</p>\n</li>\n<li><p><strong>泛化能力</strong>：较大的批大小可能会导致模型过度拟合训练数据，因为它们更倾向于记住样本特定的细节。较小的批大小可以提供更好的泛化能力，因为它们更强迫模型学习更一般化的特征。</p>\n</li>\n</ol>\n<h3 id=\"epoch（时期）\"><a href=\"#epoch（时期）\" class=\"headerlink\" title=\"epoch（时期）\"></a>epoch（时期）</h3><pre><code>Epoch（时期）是指将整个训练数据集（包含多个批次）在模型中进行一次完整的训练。在一个epoch中，模型会对数据集中的每个样本都进行一次前向传播和反向传播，并根据损失函数计算的梯度来更新模型的参数。\n</code></pre>\n<p>训练过程通常涉及多个epoch，因为一次完整的训练可能不足以使模型达到最佳性能。通过进行多个epoch，模型可以多次观察和学习数据的不同方面，并逐渐改善其性能。每个epoch之间的样本顺序通常会被随机化，以避免模型对样本顺序的依赖。</p>\n<h3 id=\"向前步骤\"><a href=\"#向前步骤\" class=\"headerlink\" title=\"向前步骤\"></a>向前步骤</h3><p><strong>向前步骤（Forward Propagation）</strong>：</p>\n<ul>\n<li><p>在向前步骤中，输入样本通过模型的前向计算过程，从输入层经过一系列的神经网络层传递，最终得到模型的输出预测结果。</p>\n</li>\n<li><p>在每一层中，通过对输入数据进行线性变换（加权和）和非线性变换（激活函数），将信息从前一层传递到后一层，直到到达输出层。</p>\n</li>\n<li><p>向前步骤的目的是计算出模型的预测结果，以便与真实标签进行比较，并计算出损失函数的值。</p>\n</li>\n</ul>\n<h3 id=\"反向传播步骤\"><a href=\"#反向传播步骤\" class=\"headerlink\" title=\"反向传播步骤\"></a>反向传播步骤</h3><p><strong>反向传播步骤（Backpropagation）</strong>：</p>\n<ul>\n<li><p>在反向传播步骤中，根据向前步骤中计算得到的损失函数值，通过链式法则计算每个参数对损失的贡献度，并更新模型的参数。</p>\n</li>\n<li><p>反向传播通过对损失函数关于模型参数的偏导数进行计算，从输出层向输入层逐层传递，以确定每个参数的梯度。</p>\n</li>\n<li><p>梯度表示了损失函数对每个参数的变化率，利用梯度可以确定参数的更新方向和大小，以最小化损失函数</p>\n</li>\n</ul>\n<h3 id=\"梯度的惩罚程度\"><a href=\"#梯度的惩罚程度\" class=\"headerlink\" title=\"梯度的惩罚程度\"></a>梯度的惩罚程度</h3><p>梯度的惩罚程度是指在计算梯度时对其进行的限制或惩罚的程度。在深度学习中，常用的梯度惩罚方法是通过添加正则化项或其他惩罚项来约束模型的参数更新。</p>\n<h4 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h4><p>防止参数更新过大或过快，以避免模型的过拟合或不稳定情况。通过对梯度进行惩罚，可以限制参数更新的幅度，使其保持在合理的范围内。</p>\n<p>梯度惩罚的程度可以通过调整惩罚项的权重或超参数来控制。增加梯度惩罚的程度意味着更强烈地限制梯度的大小或方向，从而减缓参数更新的速度。相反，减少梯度惩罚的程度会使梯度对参数更新的限制更加宽松。</p>\n<p>惩罚程度的选择通常需要根据具体问题和数据集的特点进行调整。过强的梯度惩罚可能导致模型无法学习到有效的特征，而过弱的梯度惩罚可能导致模型过拟合或训练不稳定。因此，需要根据实际情况进行实验和调优，选择合适的梯度惩罚程度以获得最佳的模型性能。</p>\n<h3 id=\"自动编码器\"><a href=\"#自动编码器\" class=\"headerlink\" title=\"自动编码器\"></a>自动编码器</h3><p>自动编码器（Autoencoder，AE）是一种无监督学习模型，用于学习数据的特征表示和压缩。它由编码器（Encoder）和解码器（Decoder）组成。</p>\n<ol>\n<li><p>欠完备自动编码器（Undercomplete Autoencoder）：<br> 欠完备自动编码器是指编码器的维度低于输入数据的维度。这种设置迫使模型学习数据的主要特征，因为编码器无法完全捕获原始数据的所有信息。通过限制编码器的容量，欠完备自动编码器可以捕捉数据中最显著的特征，从而实现特征选择和降维。</p>\n</li>\n<li><p>正则化自动编码器（Regularized Autoencoder）：<br> 正则化自动编码器通过在损失函数中引入额外的正则化项来约束模型的学习过程，以防止过拟合。常见的正则化方法包括L1正则化和L2正则化。L1正则化通过增加编码器的稀疏性，鼓励模型只使用输入数据的少数关键特征。L2正则化通过限制权重的大小，使模型对输入数据的小变化具有鲁棒性。</p>\n</li>\n<li><p>变分自动编码器（Variational Autoencoder，VAE）：<br> 变分自动编码器是一种生成性模型，与判别性模型（欠完备自动编码器和正则化自动编码器）不同，它可以生成新的数据样本。VAE通过在潜在空间中引入随机性，使得模型能够在潜在空间中进行随机采样，并通过解码器生成新的样本。在训练过程中，VAE通过最大化“证据下界”（evidence lower bound，ELBO）来优化模型参数，从而实现对潜在空间的建模。这使得VAE能够学习到数据的潜在分布，并通过从该分布中采样生成新的数据样本。</p>\n</li>\n</ol>\n<h3 id=\"CIFAR-10-和-CIFAR-100\"><a href=\"#CIFAR-10-和-CIFAR-100\" class=\"headerlink\" title=\"CIFAR-10 和 CIFAR-100\"></a>CIFAR-10 和 CIFAR-100</h3><p>CIFAR<a href=\"https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E9%9B%86&spm=1001.2101.3001.7020\">数据集</a>是 <a href=\"http://groups.csail.mit.edu/vision/TinyImages/\">Visual Dictionary (Teaching computers to recognize objects)</a> 的子集，由三个教授收集，主要来自google和各类搜索引擎的图片。</p>\n<p><a href=\"https://blog.csdn.net/disanda/article/details/90744243\">cifar10和cifar100(简介&amp;可视化)_cifar10和cifar100区别-CSDN博客</a></p>\n<h3 id=\"MNIST数据集\"><a href=\"#MNIST数据集\" class=\"headerlink\" title=\"MNIST数据集\"></a>MNIST数据集</h3><p><a href=\"https://blog.csdn.net/Iron802/article/details/121826385\">https://blog.csdn.net/Iron802/article/details/121826385</a></p>\n<p>MNIST数据集是NIST（National Institute of Standards and Technology，美国国家标准与技术研究所）数据集的一个子集，MNIST 数据集可在 <a href=\"http://yann.lecun.com/exdb/mnist/\">http://yann.lecun.com/exdb/mnist/</a> 获取，主要包括四个文件：</p>\n"},{"_content":"\n\nHexo 基本操作\n[使用 Hexo 搭建个人博客并通过 GitHub部署到vercel - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/681696900)\n# 主题\n\n[Themes | Hexo](https://hexo.io/themes/)\n比较好看\nhttps://github.com/geektutu/hexo-theme-geektutu\n\n最好看的\n[Candinya/Kratos-Rebirth: 一只可爱的hexo主题 m(=•ェ•=)m~🍭 (github.com)](https://github.com/Candinya/Kratos-Rebirth)\n\n\n考虑一个 obsidian\n[Hexo+obsidian+github完美建站教程 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/613429644)\nobsidian 加入 hexo \n[Hexo + Obsidian + Git 完美的博客部署与编辑方案 | EsunR-Blog](https://blog.esunr.site/2022/07/e9b42b453d9f.html#3-1-%E5%B0%86-Hexo-%E9%A1%B9%E7%9B%AE%E5%AF%BC%E5%85%A5-Obsidian)\n","source":"_posts/工具教程/教程：Hexo.md","raw":"\n\nHexo 基本操作\n[使用 Hexo 搭建个人博客并通过 GitHub部署到vercel - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/681696900)\n# 主题\n\n[Themes | Hexo](https://hexo.io/themes/)\n比较好看\nhttps://github.com/geektutu/hexo-theme-geektutu\n\n最好看的\n[Candinya/Kratos-Rebirth: 一只可爱的hexo主题 m(=•ェ•=)m~🍭 (github.com)](https://github.com/Candinya/Kratos-Rebirth)\n\n\n考虑一个 obsidian\n[Hexo+obsidian+github完美建站教程 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/613429644)\nobsidian 加入 hexo \n[Hexo + Obsidian + Git 完美的博客部署与编辑方案 | EsunR-Blog](https://blog.esunr.site/2022/07/e9b42b453d9f.html#3-1-%E5%B0%86-Hexo-%E9%A1%B9%E7%9B%AE%E5%AF%BC%E5%85%A5-Obsidian)\n","slug":"工具教程/教程：Hexo","published":1,"date":"2024-04-22T13:14:48.753Z","updated":"2024-04-22T12:40:19.332Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0b000ekgg41dbafzzx","content":"<p>Hexo 基本操作<br><a href=\"https://zhuanlan.zhihu.com/p/681696900\">使用 Hexo 搭建个人博客并通过 GitHub部署到vercel - 知乎 (zhihu.com)</a></p>\n<h1 id=\"主题\"><a href=\"#主题\" class=\"headerlink\" title=\"主题\"></a>主题</h1><p><a href=\"https://hexo.io/themes/\">Themes | Hexo</a><br>比较好看<br><a href=\"https://github.com/geektutu/hexo-theme-geektutu\">https://github.com/geektutu/hexo-theme-geektutu</a></p>\n<p>最好看的<br><a href=\"https://github.com/Candinya/Kratos-Rebirth\">Candinya&#x2F;Kratos-Rebirth: 一只可爱的hexo主题 m(&#x3D;•ェ•&#x3D;)m~🍭 (github.com)</a></p>\n<p>考虑一个 obsidian<br><a href=\"https://zhuanlan.zhihu.com/p/613429644\">Hexo+obsidian+github完美建站教程 - 知乎 (zhihu.com)</a><br>obsidian 加入 hexo<br><a href=\"https://blog.esunr.site/2022/07/e9b42b453d9f.html#3-1-%E5%B0%86-Hexo-%E9%A1%B9%E7%9B%AE%E5%AF%BC%E5%85%A5-Obsidian\">Hexo + Obsidian + Git 完美的博客部署与编辑方案 | EsunR-Blog</a></p>\n","excerpt":"","more":"<p>Hexo 基本操作<br><a href=\"https://zhuanlan.zhihu.com/p/681696900\">使用 Hexo 搭建个人博客并通过 GitHub部署到vercel - 知乎 (zhihu.com)</a></p>\n<h1 id=\"主题\"><a href=\"#主题\" class=\"headerlink\" title=\"主题\"></a>主题</h1><p><a href=\"https://hexo.io/themes/\">Themes | Hexo</a><br>比较好看<br><a href=\"https://github.com/geektutu/hexo-theme-geektutu\">https://github.com/geektutu/hexo-theme-geektutu</a></p>\n<p>最好看的<br><a href=\"https://github.com/Candinya/Kratos-Rebirth\">Candinya&#x2F;Kratos-Rebirth: 一只可爱的hexo主题 m(&#x3D;•ェ•&#x3D;)m~🍭 (github.com)</a></p>\n<p>考虑一个 obsidian<br><a href=\"https://zhuanlan.zhihu.com/p/613429644\">Hexo+obsidian+github完美建站教程 - 知乎 (zhihu.com)</a><br>obsidian 加入 hexo<br><a href=\"https://blog.esunr.site/2022/07/e9b42b453d9f.html#3-1-%E5%B0%86-Hexo-%E9%A1%B9%E7%9B%AE%E5%AF%BC%E5%85%A5-Obsidian\">Hexo + Obsidian + Git 完美的博客部署与编辑方案 | EsunR-Blog</a></p>\n"},{"_content":"This is your new *vault*.\n\nMake a note of something, , or try [the Importer](https://help.obsidian.md/Plugins/Importer)!\n\nWhen you're ready, delete this note and make the vault your own.\n\n# 使用方式\n\n## 设置和使用教程\n\n### 笔记结构\n\n数据库 数据模性\nhttps://blog.csdn.net/loveCC_orange/article/details/123744808\n\n关系模型的数据结构\nhttps://blog.csdn.net/loveCC_orange/article/details/123744808\n关系模型的完整性约束\nhttps://zhuanlan.zhihu.com/p/138633959\n\n关系模型：https://zhuanlan.zhihu.com/p/138633959\n\nB+的主要完成函数，\n\n····代码\n\n实现流程\n\n\n说完了流程，这里不展现具体代码细节，举出例子加以理解\n","source":"_posts/工具教程/教程：Obsidian.md","raw":"This is your new *vault*.\n\nMake a note of something, , or try [the Importer](https://help.obsidian.md/Plugins/Importer)!\n\nWhen you're ready, delete this note and make the vault your own.\n\n# 使用方式\n\n## 设置和使用教程\n\n### 笔记结构\n\n数据库 数据模性\nhttps://blog.csdn.net/loveCC_orange/article/details/123744808\n\n关系模型的数据结构\nhttps://blog.csdn.net/loveCC_orange/article/details/123744808\n关系模型的完整性约束\nhttps://zhuanlan.zhihu.com/p/138633959\n\n关系模型：https://zhuanlan.zhihu.com/p/138633959\n\nB+的主要完成函数，\n\n····代码\n\n实现流程\n\n\n说完了流程，这里不展现具体代码细节，举出例子加以理解\n","slug":"工具教程/教程：Obsidian","published":1,"date":"2024-04-22T13:14:48.756Z","updated":"2024-02-22T02:35:04.892Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0b000fkgg44s5ze16f","content":"<p>This is your new <em>vault</em>.</p>\n<p>Make a note of something, , or try <a href=\"https://help.obsidian.md/Plugins/Importer\">the Importer</a>!</p>\n<p>When you’re ready, delete this note and make the vault your own.</p>\n<h1 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h1><h2 id=\"设置和使用教程\"><a href=\"#设置和使用教程\" class=\"headerlink\" title=\"设置和使用教程\"></a>设置和使用教程</h2><h3 id=\"笔记结构\"><a href=\"#笔记结构\" class=\"headerlink\" title=\"笔记结构\"></a>笔记结构</h3><p>数据库 数据模性<br><a href=\"https://blog.csdn.net/loveCC_orange/article/details/123744808\">https://blog.csdn.net/loveCC_orange/article/details/123744808</a></p>\n<p>关系模型的数据结构<br><a href=\"https://blog.csdn.net/loveCC_orange/article/details/123744808\">https://blog.csdn.net/loveCC_orange/article/details/123744808</a><br>关系模型的完整性约束<br><a href=\"https://zhuanlan.zhihu.com/p/138633959\">https://zhuanlan.zhihu.com/p/138633959</a></p>\n<p>关系模型：<a href=\"https://zhuanlan.zhihu.com/p/138633959\">https://zhuanlan.zhihu.com/p/138633959</a></p>\n<p>B+的主要完成函数，</p>\n<p>····代码</p>\n<p>实现流程</p>\n<p>说完了流程，这里不展现具体代码细节，举出例子加以理解</p>\n","excerpt":"","more":"<p>This is your new <em>vault</em>.</p>\n<p>Make a note of something, , or try <a href=\"https://help.obsidian.md/Plugins/Importer\">the Importer</a>!</p>\n<p>When you’re ready, delete this note and make the vault your own.</p>\n<h1 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h1><h2 id=\"设置和使用教程\"><a href=\"#设置和使用教程\" class=\"headerlink\" title=\"设置和使用教程\"></a>设置和使用教程</h2><h3 id=\"笔记结构\"><a href=\"#笔记结构\" class=\"headerlink\" title=\"笔记结构\"></a>笔记结构</h3><p>数据库 数据模性<br><a href=\"https://blog.csdn.net/loveCC_orange/article/details/123744808\">https://blog.csdn.net/loveCC_orange/article/details/123744808</a></p>\n<p>关系模型的数据结构<br><a href=\"https://blog.csdn.net/loveCC_orange/article/details/123744808\">https://blog.csdn.net/loveCC_orange/article/details/123744808</a><br>关系模型的完整性约束<br><a href=\"https://zhuanlan.zhihu.com/p/138633959\">https://zhuanlan.zhihu.com/p/138633959</a></p>\n<p>关系模型：<a href=\"https://zhuanlan.zhihu.com/p/138633959\">https://zhuanlan.zhihu.com/p/138633959</a></p>\n<p>B+的主要完成函数，</p>\n<p>····代码</p>\n<p>实现流程</p>\n<p>说完了流程，这里不展现具体代码细节，举出例子加以理解</p>\n"},{"_content":"# Zip\n> 将 /root/test 这个目录下所有文件和文件夹打包为当前目录下的 test.zip：\n\n```bash\nzip -q -r test.zip /home/test\n```\n\n> 将 /root/test 这个目录下所有文件和文件夹加密打包为当前目录下的 test.zip：\n\n```bash\nzip -q  -e -r test.zip /home/test\n```\n\n> 将 test.zip 解压到指定目录：\n\n```bash\nunzip -o -d /root test.zip\n```\n\n# Tar\n1. 解压缩到指定文件夹：\n\n```bash\ntar -xf archive.tar -C /path/to/destination\n```\n\n上述命令将解压缩名为 \"archive.tar\" 的 tar 文件到指定的目标文件夹 \"/path/to/destination\"\n\n2. 解压缩特定文件到指定位置：\n\n```bash\ntar -xf archive.tar /path/to/file -C /path/to/destination\n```\n\n上述命令将解压缩名为 \"archive.tar\" 的 tar 文件中的特定文件 \"/path/to/file\" 到指定的目标文件夹 \"/path/to/destination\"。\n\n3. 压缩为指定文件名：\n\n```\ntar -cf new_archive.tar /path/to/source\n```\n\n上述命令将把指定文件夹 \"/path/to/source\" 打包成名为 \"new_archive.tar\" 的 tar 文件。\n\n# Vim\n复制 yy 粘贴 p\n\n# Bzip2\n1. 安装\n```shell\napt-get install bzip2\n```\n2. 解压 `.bz2` 文件：\n\n```\nbzip2 -d file.bz2\n```\n\t其中，`file.bz2` 是你要解压的文件名。解压后的文件将会放置在当前目录，并且会去掉原始文件的 `.bz2` 扩展名。例如，如果你解压的文件名为 `example.bz2`，解压后会生成一个名为 `example` 的文件。\n\n3. 如果你想同时保留原始的 `.bz2` 文件，可以使用 `-k` 选项：\n\n```\nbzip2 -dk file.bz2\n```\n\n\t这样，解压后的文件和原始的 `.bz2` 文件都会存在。\n\n4. `bzip2` 命令也支持通过管道方式解压文件，例如：\n```\nbzcat file.bz2 > outputfile\n```\n\n\t上述命令将解压 `.bz2` 文件并将输出重定向到 `outputfile`。\n\n\n\n# GoLang\n## 安装\n\n>去 golang 的网站 [https://studygolang.com/dl](https://studygolang.com/dl)\n```sh\nwget https://studygolang.com/dl/golang/go1.20.3.linux-amd64.tar.gz\n```\n\n> 解压至 /usr/local \n```sh\ntar -C /usr/local -xzf go1.20.3.linux-amd64.tar.gz \n```\n> 修改终端文件 \n```sh\nexport GOROOT=/usr/local/go \nexport PATH=$PATH:$GOROOT/bin \nexport CGO_ENABLED=1\n\nexport PATH=\"/usr/bin:/bin:/usr/local/bin:/sbin:/usr/sbin:$PATH\"\n\n```\n\n>配置 \n```sh\ngo env -w GO111MODULE=on \ngo env -w GOPROXY=https://goproxy.cn,direct\n```\n\n\n\n\n\n\n\n# Docker \n## Docker 安装与卸载\n### Centos\n#### 安装\n1. 更新系统软件包列表：\n\n   ```bash\n   sudo yum update\n   ```\n\n2. 安装所需的依赖软件包，以便使用 Docker：\n\n   ```bash\n   sudo yum install -y yum-utils device-mapper-persistent-data lvm2\n   ```\n\n3. 添加 Docker 软件源：\n\n   ```bash\n   sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\n   ```\n\n4. 安装 Docker 引擎：\n\n   ```bash\n   sudo yum install -y docker-ce docker-ce-cli containerd.io\n   ```\n\n5. 启动 Docker 服务：\n\n   ```bash\n   sudo systemctl start docker\n   ```\n\n6. （可选）将当前用户添加到 Docker 用户组，以便无需使用 sudo 运行 Docker 命令：\n\n   ```bash\n   sudo usermod -aG docker $USER\n   ```\n\n   请注意，这将需要您重新登录才能生效。\n\n7. 验证 Docker 是否成功安装：\n\n   ```bash\n   docker version\n   ```\n\n   这将显示 Docker 引擎的版本信息。\n#### 卸载\n\n1. 停止 Docker 服务：运行以下命令停止正在运行的 Docker 服务：\n\n   ```bash\n   sudo systemctl stop docker\n   ```\n\n2. 删除 Docker 软件包：运行以下命令删除 Docker 软件包及其依赖项：\n\n   ```bash\n   sudo yum remove docker-ce docker-ce-cli containerd.io\n   ```\n\n3. 删除 Docker 数据和配置：运行以下命令删除 Docker 相关的数据和配置文件：\n\n   ```bash\n   sudo rm -rf /var/lib/docker\n   ```\n\n   请注意，这将删除 Docker 所有镜像、容器和卷数据，以及配置文件。如果您希望保留这些数据，请备份相应的目录。\n\n4. 删除 Docker 用户组：运行以下命令删除 Docker 用户组：\n\n   ```bash\n   sudo groupdel docker\n   ```\n\n   这将删除名为 \"docker\" 的用户组。如果您在安装 Docker 时没有创建该用户组，可能会出现错误提示，可以忽略此步骤。\n\n5. 删除 Docker 相关的存储库文件：如果您添加了 Docker 的存储库文件，请运行以下命令删除这些文件。存储库文件通常位于 `/etc/yum.repos.d/` 目录下，文件名可能类似于 `docker-ce.repo` 或 `docker.repo`。\n\n\t```bash\n   sudo rm -rf /etc/yum.repos.d/docker*.repo\n   ```\n\n   请注意，这一步仅适用于您手动添加了 Docker 的存储库文件的情况。\n6. 删除 Docker 命令。\n\t```bash\n\trm -rf /usr/bin/docker\n\t```\n\n完成上述步骤后，Docker 将从 CentOS 系统中被完全卸载。\n\n## Docker 使用\n\n> 创建一个容器，允许使用 GPU\n```sh\ndocker run -itd -v /home/fengyuening/container_2204/:/root/ --gpus all --name fyn_ubuntu_2204 ubuntu:22.04\n```\n\n> 产生基础镜像：\n```sh\ndocker build -f Dockerfile . -t bell/backend:1.0\ndocker pull mysql:5.7\n```\n\n> Docker保存为离线文件：\n```shell\ndocker save -o mysql-5.7.tar mysql:5.7\n```\n\n> 将离线文件载入镜像：\n```shell\ndocker load -i mysql-5.7.tar\n```\n\n> 修改镜像\n\tbell/backend:1.0作为基础镜像，对其进行修改产生新镜像。\n```shell\ndocker build -f Dockerfile2 . -t bell/backend:1.1\n```\n\n\n\n## Apach\n\n> 使用 ApacheBench (ab) 工具进行性能测试\n```shell\nab -c 400 -n 1000 http://localhost:8080/\n# - `ab`：是 ApacheBench 工具的命令。\n# - `-c 400`：表示并发请求数（concurrency），即同时发送的请求数量。在这个例子中，设置为 400，表示会同时发送 400 个请求。\n# - `-n 1000`：表示总请求数（number of requests），即发送的总请求数量。在这个例子中，设置为 1000，表示会发送总共 1000 个请求。\n# - `http://localhost:8080/`：表示待测试的目标 URL，即请求要发送到的服务器的地址和端口。\n```\n\t但是 17 年的一个帖子说`ab` 是一个糟糕的测试服务器的工具，它只是 http/1.0，甚至没有在这里使用 keepalive。尝试使用 -race 标志（如 `go build -race` ）构建服务器或使用 `go run -race main.go` 运行\n\n\n\n# 数据竞争检测 TODO\n\n使用 `-race` 标志可以在 Go 中进行数据竞争检测，以帮助发现并发程序中的潜在竞态条件。\n\n1. 构建服务器：\n    \n    - 打开终端或命令提示符。\n    - 进入服务器的代码目录。\n    - 运行以下命令：`go build -race`。\n    - 如果构建成功，则会生成一个可执行文件，可以使用 `./<可执行文件名>` 执行服务器。\n2. 运行服务器：\n    \n    - 打开终端或命令提示符。\n    - 进入服务器的代码目录。\n    - 运行以下命令：`go run -race main.go`。\n    - 这将使用 Go 运行时环境直接运行 `main.go` 文件，并启动服务器。\n\n使用 `-race` 标志构建或运行服务器后，Go 编译器/运行时将会执行数据竞争检测。如果检测到潜在的竞态条件，它将在终端或命令提示符中显示相关的警告或错误信息。\n\n注意，使用 `-race` 标志构建或运行服务器可能会增加程序的执行时间和资源消耗，因为数据竞争检测会引入一些额外的开销。因此，它通常用于开发和调试阶段，以帮助发现并解决并发问题，而不是在生产环境中使用。\n\n\n","source":"_posts/工具教程/教程：Linux 指令.md","raw":"# Zip\n> 将 /root/test 这个目录下所有文件和文件夹打包为当前目录下的 test.zip：\n\n```bash\nzip -q -r test.zip /home/test\n```\n\n> 将 /root/test 这个目录下所有文件和文件夹加密打包为当前目录下的 test.zip：\n\n```bash\nzip -q  -e -r test.zip /home/test\n```\n\n> 将 test.zip 解压到指定目录：\n\n```bash\nunzip -o -d /root test.zip\n```\n\n# Tar\n1. 解压缩到指定文件夹：\n\n```bash\ntar -xf archive.tar -C /path/to/destination\n```\n\n上述命令将解压缩名为 \"archive.tar\" 的 tar 文件到指定的目标文件夹 \"/path/to/destination\"\n\n2. 解压缩特定文件到指定位置：\n\n```bash\ntar -xf archive.tar /path/to/file -C /path/to/destination\n```\n\n上述命令将解压缩名为 \"archive.tar\" 的 tar 文件中的特定文件 \"/path/to/file\" 到指定的目标文件夹 \"/path/to/destination\"。\n\n3. 压缩为指定文件名：\n\n```\ntar -cf new_archive.tar /path/to/source\n```\n\n上述命令将把指定文件夹 \"/path/to/source\" 打包成名为 \"new_archive.tar\" 的 tar 文件。\n\n# Vim\n复制 yy 粘贴 p\n\n# Bzip2\n1. 安装\n```shell\napt-get install bzip2\n```\n2. 解压 `.bz2` 文件：\n\n```\nbzip2 -d file.bz2\n```\n\t其中，`file.bz2` 是你要解压的文件名。解压后的文件将会放置在当前目录，并且会去掉原始文件的 `.bz2` 扩展名。例如，如果你解压的文件名为 `example.bz2`，解压后会生成一个名为 `example` 的文件。\n\n3. 如果你想同时保留原始的 `.bz2` 文件，可以使用 `-k` 选项：\n\n```\nbzip2 -dk file.bz2\n```\n\n\t这样，解压后的文件和原始的 `.bz2` 文件都会存在。\n\n4. `bzip2` 命令也支持通过管道方式解压文件，例如：\n```\nbzcat file.bz2 > outputfile\n```\n\n\t上述命令将解压 `.bz2` 文件并将输出重定向到 `outputfile`。\n\n\n\n# GoLang\n## 安装\n\n>去 golang 的网站 [https://studygolang.com/dl](https://studygolang.com/dl)\n```sh\nwget https://studygolang.com/dl/golang/go1.20.3.linux-amd64.tar.gz\n```\n\n> 解压至 /usr/local \n```sh\ntar -C /usr/local -xzf go1.20.3.linux-amd64.tar.gz \n```\n> 修改终端文件 \n```sh\nexport GOROOT=/usr/local/go \nexport PATH=$PATH:$GOROOT/bin \nexport CGO_ENABLED=1\n\nexport PATH=\"/usr/bin:/bin:/usr/local/bin:/sbin:/usr/sbin:$PATH\"\n\n```\n\n>配置 \n```sh\ngo env -w GO111MODULE=on \ngo env -w GOPROXY=https://goproxy.cn,direct\n```\n\n\n\n\n\n\n\n# Docker \n## Docker 安装与卸载\n### Centos\n#### 安装\n1. 更新系统软件包列表：\n\n   ```bash\n   sudo yum update\n   ```\n\n2. 安装所需的依赖软件包，以便使用 Docker：\n\n   ```bash\n   sudo yum install -y yum-utils device-mapper-persistent-data lvm2\n   ```\n\n3. 添加 Docker 软件源：\n\n   ```bash\n   sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\n   ```\n\n4. 安装 Docker 引擎：\n\n   ```bash\n   sudo yum install -y docker-ce docker-ce-cli containerd.io\n   ```\n\n5. 启动 Docker 服务：\n\n   ```bash\n   sudo systemctl start docker\n   ```\n\n6. （可选）将当前用户添加到 Docker 用户组，以便无需使用 sudo 运行 Docker 命令：\n\n   ```bash\n   sudo usermod -aG docker $USER\n   ```\n\n   请注意，这将需要您重新登录才能生效。\n\n7. 验证 Docker 是否成功安装：\n\n   ```bash\n   docker version\n   ```\n\n   这将显示 Docker 引擎的版本信息。\n#### 卸载\n\n1. 停止 Docker 服务：运行以下命令停止正在运行的 Docker 服务：\n\n   ```bash\n   sudo systemctl stop docker\n   ```\n\n2. 删除 Docker 软件包：运行以下命令删除 Docker 软件包及其依赖项：\n\n   ```bash\n   sudo yum remove docker-ce docker-ce-cli containerd.io\n   ```\n\n3. 删除 Docker 数据和配置：运行以下命令删除 Docker 相关的数据和配置文件：\n\n   ```bash\n   sudo rm -rf /var/lib/docker\n   ```\n\n   请注意，这将删除 Docker 所有镜像、容器和卷数据，以及配置文件。如果您希望保留这些数据，请备份相应的目录。\n\n4. 删除 Docker 用户组：运行以下命令删除 Docker 用户组：\n\n   ```bash\n   sudo groupdel docker\n   ```\n\n   这将删除名为 \"docker\" 的用户组。如果您在安装 Docker 时没有创建该用户组，可能会出现错误提示，可以忽略此步骤。\n\n5. 删除 Docker 相关的存储库文件：如果您添加了 Docker 的存储库文件，请运行以下命令删除这些文件。存储库文件通常位于 `/etc/yum.repos.d/` 目录下，文件名可能类似于 `docker-ce.repo` 或 `docker.repo`。\n\n\t```bash\n   sudo rm -rf /etc/yum.repos.d/docker*.repo\n   ```\n\n   请注意，这一步仅适用于您手动添加了 Docker 的存储库文件的情况。\n6. 删除 Docker 命令。\n\t```bash\n\trm -rf /usr/bin/docker\n\t```\n\n完成上述步骤后，Docker 将从 CentOS 系统中被完全卸载。\n\n## Docker 使用\n\n> 创建一个容器，允许使用 GPU\n```sh\ndocker run -itd -v /home/fengyuening/container_2204/:/root/ --gpus all --name fyn_ubuntu_2204 ubuntu:22.04\n```\n\n> 产生基础镜像：\n```sh\ndocker build -f Dockerfile . -t bell/backend:1.0\ndocker pull mysql:5.7\n```\n\n> Docker保存为离线文件：\n```shell\ndocker save -o mysql-5.7.tar mysql:5.7\n```\n\n> 将离线文件载入镜像：\n```shell\ndocker load -i mysql-5.7.tar\n```\n\n> 修改镜像\n\tbell/backend:1.0作为基础镜像，对其进行修改产生新镜像。\n```shell\ndocker build -f Dockerfile2 . -t bell/backend:1.1\n```\n\n\n\n## Apach\n\n> 使用 ApacheBench (ab) 工具进行性能测试\n```shell\nab -c 400 -n 1000 http://localhost:8080/\n# - `ab`：是 ApacheBench 工具的命令。\n# - `-c 400`：表示并发请求数（concurrency），即同时发送的请求数量。在这个例子中，设置为 400，表示会同时发送 400 个请求。\n# - `-n 1000`：表示总请求数（number of requests），即发送的总请求数量。在这个例子中，设置为 1000，表示会发送总共 1000 个请求。\n# - `http://localhost:8080/`：表示待测试的目标 URL，即请求要发送到的服务器的地址和端口。\n```\n\t但是 17 年的一个帖子说`ab` 是一个糟糕的测试服务器的工具，它只是 http/1.0，甚至没有在这里使用 keepalive。尝试使用 -race 标志（如 `go build -race` ）构建服务器或使用 `go run -race main.go` 运行\n\n\n\n# 数据竞争检测 TODO\n\n使用 `-race` 标志可以在 Go 中进行数据竞争检测，以帮助发现并发程序中的潜在竞态条件。\n\n1. 构建服务器：\n    \n    - 打开终端或命令提示符。\n    - 进入服务器的代码目录。\n    - 运行以下命令：`go build -race`。\n    - 如果构建成功，则会生成一个可执行文件，可以使用 `./<可执行文件名>` 执行服务器。\n2. 运行服务器：\n    \n    - 打开终端或命令提示符。\n    - 进入服务器的代码目录。\n    - 运行以下命令：`go run -race main.go`。\n    - 这将使用 Go 运行时环境直接运行 `main.go` 文件，并启动服务器。\n\n使用 `-race` 标志构建或运行服务器后，Go 编译器/运行时将会执行数据竞争检测。如果检测到潜在的竞态条件，它将在终端或命令提示符中显示相关的警告或错误信息。\n\n注意，使用 `-race` 标志构建或运行服务器可能会增加程序的执行时间和资源消耗，因为数据竞争检测会引入一些额外的开销。因此，它通常用于开发和调试阶段，以帮助发现并解决并发问题，而不是在生产环境中使用。\n\n\n","slug":"工具教程/教程：Linux 指令","published":1,"date":"2024-04-22T13:14:48.755Z","updated":"2024-04-22T03:02:49.554Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0b000gkgg44z8yhcvg","content":"<h1 id=\"Zip\"><a href=\"#Zip\" class=\"headerlink\" title=\"Zip\"></a>Zip</h1><blockquote>\n<p>将 &#x2F;root&#x2F;test 这个目录下所有文件和文件夹打包为当前目录下的 test.zip：</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zip -q -r test.zip /home/test</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>将 &#x2F;root&#x2F;test 这个目录下所有文件和文件夹加密打包为当前目录下的 test.zip：</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zip -q  -e -r test.zip /home/test</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>将 test.zip 解压到指定目录：</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unzip -o -d /root test.zip</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Tar\"><a href=\"#Tar\" class=\"headerlink\" title=\"Tar\"></a>Tar</h1><ol>\n<li>解压缩到指定文件夹：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -xf archive.tar -C /path/to/destination</span><br></pre></td></tr></table></figure>\n\n<p>上述命令将解压缩名为 “archive.tar” 的 tar 文件到指定的目标文件夹 “&#x2F;path&#x2F;to&#x2F;destination”</p>\n<ol start=\"2\">\n<li>解压缩特定文件到指定位置：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -xf archive.tar /path/to/file -C /path/to/destination</span><br></pre></td></tr></table></figure>\n\n<p>上述命令将解压缩名为 “archive.tar” 的 tar 文件中的特定文件 “&#x2F;path&#x2F;to&#x2F;file” 到指定的目标文件夹 “&#x2F;path&#x2F;to&#x2F;destination”。</p>\n<ol start=\"3\">\n<li>压缩为指定文件名：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -cf new_archive.tar /path/to/source</span><br></pre></td></tr></table></figure>\n\n<p>上述命令将把指定文件夹 “&#x2F;path&#x2F;to&#x2F;source” 打包成名为 “new_archive.tar” 的 tar 文件。</p>\n<h1 id=\"Vim\"><a href=\"#Vim\" class=\"headerlink\" title=\"Vim\"></a>Vim</h1><p>复制 yy 粘贴 p</p>\n<h1 id=\"Bzip2\"><a href=\"#Bzip2\" class=\"headerlink\" title=\"Bzip2\"></a>Bzip2</h1><ol>\n<li>安装<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-get install bzip2</span><br></pre></td></tr></table></figure></li>\n<li>解压 <code>.bz2</code> 文件：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bzip2 -d file.bz2</span><br></pre></td></tr></table></figure>\n<pre><code>其中，`file.bz2` 是你要解压的文件名。解压后的文件将会放置在当前目录，并且会去掉原始文件的 `.bz2` 扩展名。例如，如果你解压的文件名为 `example.bz2`，解压后会生成一个名为 `example` 的文件。\n</code></pre>\n<ol start=\"3\">\n<li>如果你想同时保留原始的 <code>.bz2</code> 文件，可以使用 <code>-k</code> 选项：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bzip2 -dk file.bz2</span><br></pre></td></tr></table></figure>\n\n<pre><code>这样，解压后的文件和原始的 `.bz2` 文件都会存在。\n</code></pre>\n<ol start=\"4\">\n<li><code>bzip2</code> 命令也支持通过管道方式解压文件，例如：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bzcat file.bz2 &gt; outputfile</span><br></pre></td></tr></table></figure>\n\n 上述命令将解压 <code>.bz2</code> 文件并将输出重定向到 <code>outputfile</code>。</li>\n</ol>\n<h1 id=\"GoLang\"><a href=\"#GoLang\" class=\"headerlink\" title=\"GoLang\"></a>GoLang</h1><h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><blockquote>\n<p>去 golang 的网站 <a href=\"https://studygolang.com/dl\">https://studygolang.com/dl</a></p>\n</blockquote>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://studygolang.com/dl/golang/go1.20.3.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>解压至 &#x2F;usr&#x2F;local </p>\n</blockquote>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -C /usr/local -xzf go1.20.3.linux-amd64.tar.gz </span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>修改终端文件 </p>\n</blockquote>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> GOROOT=/usr/local/go </span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$PATH</span>:<span class=\"variable\">$GOROOT</span>/bin </span><br><span class=\"line\"><span class=\"built_in\">export</span> CGO_ENABLED=1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"string\">&quot;/usr/bin:/bin:/usr/local/bin:/sbin:/usr/sbin:<span class=\"variable\">$PATH</span>&quot;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>配置 </p>\n</blockquote>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go <span class=\"built_in\">env</span> -w GO111MODULE=on </span><br><span class=\"line\">go <span class=\"built_in\">env</span> -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<h1 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h1><h2 id=\"Docker-安装与卸载\"><a href=\"#Docker-安装与卸载\" class=\"headerlink\" title=\"Docker 安装与卸载\"></a>Docker 安装与卸载</h2><h3 id=\"Centos\"><a href=\"#Centos\" class=\"headerlink\" title=\"Centos\"></a>Centos</h3><h4 id=\"安装-1\"><a href=\"#安装-1\" class=\"headerlink\" title=\"安装\"></a>安装</h4><ol>\n<li><p>更新系统软件包列表：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum update</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装所需的依赖软件包，以便使用 Docker：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>添加 Docker 软件源：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装 Docker 引擎：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install -y docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动 Docker 服务：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl start docker</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>（可选）将当前用户添加到 Docker 用户组，以便无需使用 sudo 运行 Docker 命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo usermod -aG docker <span class=\"variable\">$USER</span></span><br></pre></td></tr></table></figure>\n\n<p>请注意，这将需要您重新登录才能生效。</p>\n</li>\n<li><p>验证 Docker 是否成功安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker version</span><br></pre></td></tr></table></figure>\n\n<p>这将显示 Docker 引擎的版本信息。</p>\n</li>\n</ol>\n<h4 id=\"卸载\"><a href=\"#卸载\" class=\"headerlink\" title=\"卸载\"></a>卸载</h4><ol>\n<li><p>停止 Docker 服务：运行以下命令停止正在运行的 Docker 服务：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl stop docker</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>删除 Docker 软件包：运行以下命令删除 Docker 软件包及其依赖项：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum remove docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>删除 Docker 数据和配置：运行以下命令删除 Docker 相关的数据和配置文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo <span class=\"built_in\">rm</span> -rf /var/lib/docker</span><br></pre></td></tr></table></figure>\n\n<p>请注意，这将删除 Docker 所有镜像、容器和卷数据，以及配置文件。如果您希望保留这些数据，请备份相应的目录。</p>\n</li>\n<li><p>删除 Docker 用户组：运行以下命令删除 Docker 用户组：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo groupdel docker</span><br></pre></td></tr></table></figure>\n\n<p>这将删除名为 “docker” 的用户组。如果您在安装 Docker 时没有创建该用户组，可能会出现错误提示，可以忽略此步骤。</p>\n</li>\n<li><p>删除 Docker 相关的存储库文件：如果您添加了 Docker 的存储库文件，请运行以下命令删除这些文件。存储库文件通常位于 <code>/etc/yum.repos.d/</code> 目录下，文件名可能类似于 <code>docker-ce.repo</code> 或 <code>docker.repo</code>。</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo <span class=\"built_in\">rm</span> -rf /etc/yum.repos.d/docker*.repo</span><br></pre></td></tr></table></figure>\n\n<p>请注意，这一步仅适用于您手动添加了 Docker 的存储库文件的情况。</p>\n</li>\n<li><p>删除 Docker 命令。</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">rm</span> -rf /usr/bin/docker</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>完成上述步骤后，Docker 将从 CentOS 系统中被完全卸载。</p>\n<h2 id=\"Docker-使用\"><a href=\"#Docker-使用\" class=\"headerlink\" title=\"Docker 使用\"></a>Docker 使用</h2><blockquote>\n<p>创建一个容器，允许使用 GPU</p>\n</blockquote>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -itd -v /home/fengyuening/container_2204/:/root/ --gpus all --name fyn_ubuntu_2204 ubuntu:22.04</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>产生基础镜像：</p>\n</blockquote>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -f Dockerfile . -t bell/backend:1.0</span><br><span class=\"line\">docker pull mysql:5.7</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Docker保存为离线文件：</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker save -o mysql-5.7.tar mysql:5.7</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>将离线文件载入镜像：</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker load -i mysql-5.7.tar</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>修改镜像<br>    bell&#x2F;backend:1.0作为基础镜像，对其进行修改产生新镜像。</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -f Dockerfile2 . -t bell/backend:1.1</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Apach\"><a href=\"#Apach\" class=\"headerlink\" title=\"Apach\"></a>Apach</h2><blockquote>\n<p>使用 ApacheBench (ab) 工具进行性能测试</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ab -c 400 -n 1000 http://localhost:8080/</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">- `ab`：是 ApacheBench 工具的命令。</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">- `-c 400`：表示并发请求数（concurrency），即同时发送的请求数量。在这个例子中，设置为 400，表示会同时发送 400 个请求。</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">- `-n 1000`：表示总请求数（number of requests），即发送的总请求数量。在这个例子中，设置为 1000，表示会发送总共 1000 个请求。</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">- `http://localhost:8080/`：表示待测试的目标 URL，即请求要发送到的服务器的地址和端口。</span></span><br></pre></td></tr></table></figure>\n<pre><code>但是 17 年的一个帖子说`ab` 是一个糟糕的测试服务器的工具，它只是 http/1.0，甚至没有在这里使用 keepalive。尝试使用 -race 标志（如 `go build -race` ）构建服务器或使用 `go run -race main.go` 运行\n</code></pre>\n<h1 id=\"数据竞争检测-TODO\"><a href=\"#数据竞争检测-TODO\" class=\"headerlink\" title=\"数据竞争检测 TODO\"></a>数据竞争检测 TODO</h1><p>使用 <code>-race</code> 标志可以在 Go 中进行数据竞争检测，以帮助发现并发程序中的潜在竞态条件。</p>\n<ol>\n<li><p>构建服务器：</p>\n<ul>\n<li>打开终端或命令提示符。</li>\n<li>进入服务器的代码目录。</li>\n<li>运行以下命令：<code>go build -race</code>。</li>\n<li>如果构建成功，则会生成一个可执行文件，可以使用 <code>./&lt;可执行文件名&gt;</code> 执行服务器。</li>\n</ul>\n</li>\n<li><p>运行服务器：</p>\n<ul>\n<li>打开终端或命令提示符。</li>\n<li>进入服务器的代码目录。</li>\n<li>运行以下命令：<code>go run -race main.go</code>。</li>\n<li>这将使用 Go 运行时环境直接运行 <code>main.go</code> 文件，并启动服务器。</li>\n</ul>\n</li>\n</ol>\n<p>使用 <code>-race</code> 标志构建或运行服务器后，Go 编译器&#x2F;运行时将会执行数据竞争检测。如果检测到潜在的竞态条件，它将在终端或命令提示符中显示相关的警告或错误信息。</p>\n<p>注意，使用 <code>-race</code> 标志构建或运行服务器可能会增加程序的执行时间和资源消耗，因为数据竞争检测会引入一些额外的开销。因此，它通常用于开发和调试阶段，以帮助发现并解决并发问题，而不是在生产环境中使用。</p>\n","excerpt":"","more":"<h1 id=\"Zip\"><a href=\"#Zip\" class=\"headerlink\" title=\"Zip\"></a>Zip</h1><blockquote>\n<p>将 &#x2F;root&#x2F;test 这个目录下所有文件和文件夹打包为当前目录下的 test.zip：</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zip -q -r test.zip /home/test</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>将 &#x2F;root&#x2F;test 这个目录下所有文件和文件夹加密打包为当前目录下的 test.zip：</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zip -q  -e -r test.zip /home/test</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>将 test.zip 解压到指定目录：</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unzip -o -d /root test.zip</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Tar\"><a href=\"#Tar\" class=\"headerlink\" title=\"Tar\"></a>Tar</h1><ol>\n<li>解压缩到指定文件夹：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -xf archive.tar -C /path/to/destination</span><br></pre></td></tr></table></figure>\n\n<p>上述命令将解压缩名为 “archive.tar” 的 tar 文件到指定的目标文件夹 “&#x2F;path&#x2F;to&#x2F;destination”</p>\n<ol start=\"2\">\n<li>解压缩特定文件到指定位置：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -xf archive.tar /path/to/file -C /path/to/destination</span><br></pre></td></tr></table></figure>\n\n<p>上述命令将解压缩名为 “archive.tar” 的 tar 文件中的特定文件 “&#x2F;path&#x2F;to&#x2F;file” 到指定的目标文件夹 “&#x2F;path&#x2F;to&#x2F;destination”。</p>\n<ol start=\"3\">\n<li>压缩为指定文件名：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -cf new_archive.tar /path/to/source</span><br></pre></td></tr></table></figure>\n\n<p>上述命令将把指定文件夹 “&#x2F;path&#x2F;to&#x2F;source” 打包成名为 “new_archive.tar” 的 tar 文件。</p>\n<h1 id=\"Vim\"><a href=\"#Vim\" class=\"headerlink\" title=\"Vim\"></a>Vim</h1><p>复制 yy 粘贴 p</p>\n<h1 id=\"Bzip2\"><a href=\"#Bzip2\" class=\"headerlink\" title=\"Bzip2\"></a>Bzip2</h1><ol>\n<li>安装<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-get install bzip2</span><br></pre></td></tr></table></figure></li>\n<li>解压 <code>.bz2</code> 文件：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bzip2 -d file.bz2</span><br></pre></td></tr></table></figure>\n<pre><code>其中，`file.bz2` 是你要解压的文件名。解压后的文件将会放置在当前目录，并且会去掉原始文件的 `.bz2` 扩展名。例如，如果你解压的文件名为 `example.bz2`，解压后会生成一个名为 `example` 的文件。\n</code></pre>\n<ol start=\"3\">\n<li>如果你想同时保留原始的 <code>.bz2</code> 文件，可以使用 <code>-k</code> 选项：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bzip2 -dk file.bz2</span><br></pre></td></tr></table></figure>\n\n<pre><code>这样，解压后的文件和原始的 `.bz2` 文件都会存在。\n</code></pre>\n<ol start=\"4\">\n<li><code>bzip2</code> 命令也支持通过管道方式解压文件，例如：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bzcat file.bz2 &gt; outputfile</span><br></pre></td></tr></table></figure>\n\n 上述命令将解压 <code>.bz2</code> 文件并将输出重定向到 <code>outputfile</code>。</li>\n</ol>\n<h1 id=\"GoLang\"><a href=\"#GoLang\" class=\"headerlink\" title=\"GoLang\"></a>GoLang</h1><h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><blockquote>\n<p>去 golang 的网站 <a href=\"https://studygolang.com/dl\">https://studygolang.com/dl</a></p>\n</blockquote>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://studygolang.com/dl/golang/go1.20.3.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>解压至 &#x2F;usr&#x2F;local </p>\n</blockquote>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -C /usr/local -xzf go1.20.3.linux-amd64.tar.gz </span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>修改终端文件 </p>\n</blockquote>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> GOROOT=/usr/local/go </span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$PATH</span>:<span class=\"variable\">$GOROOT</span>/bin </span><br><span class=\"line\"><span class=\"built_in\">export</span> CGO_ENABLED=1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"string\">&quot;/usr/bin:/bin:/usr/local/bin:/sbin:/usr/sbin:<span class=\"variable\">$PATH</span>&quot;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>配置 </p>\n</blockquote>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go <span class=\"built_in\">env</span> -w GO111MODULE=on </span><br><span class=\"line\">go <span class=\"built_in\">env</span> -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<h1 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h1><h2 id=\"Docker-安装与卸载\"><a href=\"#Docker-安装与卸载\" class=\"headerlink\" title=\"Docker 安装与卸载\"></a>Docker 安装与卸载</h2><h3 id=\"Centos\"><a href=\"#Centos\" class=\"headerlink\" title=\"Centos\"></a>Centos</h3><h4 id=\"安装-1\"><a href=\"#安装-1\" class=\"headerlink\" title=\"安装\"></a>安装</h4><ol>\n<li><p>更新系统软件包列表：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum update</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装所需的依赖软件包，以便使用 Docker：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>添加 Docker 软件源：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装 Docker 引擎：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install -y docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动 Docker 服务：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl start docker</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>（可选）将当前用户添加到 Docker 用户组，以便无需使用 sudo 运行 Docker 命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo usermod -aG docker <span class=\"variable\">$USER</span></span><br></pre></td></tr></table></figure>\n\n<p>请注意，这将需要您重新登录才能生效。</p>\n</li>\n<li><p>验证 Docker 是否成功安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker version</span><br></pre></td></tr></table></figure>\n\n<p>这将显示 Docker 引擎的版本信息。</p>\n</li>\n</ol>\n<h4 id=\"卸载\"><a href=\"#卸载\" class=\"headerlink\" title=\"卸载\"></a>卸载</h4><ol>\n<li><p>停止 Docker 服务：运行以下命令停止正在运行的 Docker 服务：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl stop docker</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>删除 Docker 软件包：运行以下命令删除 Docker 软件包及其依赖项：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum remove docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>删除 Docker 数据和配置：运行以下命令删除 Docker 相关的数据和配置文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo <span class=\"built_in\">rm</span> -rf /var/lib/docker</span><br></pre></td></tr></table></figure>\n\n<p>请注意，这将删除 Docker 所有镜像、容器和卷数据，以及配置文件。如果您希望保留这些数据，请备份相应的目录。</p>\n</li>\n<li><p>删除 Docker 用户组：运行以下命令删除 Docker 用户组：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo groupdel docker</span><br></pre></td></tr></table></figure>\n\n<p>这将删除名为 “docker” 的用户组。如果您在安装 Docker 时没有创建该用户组，可能会出现错误提示，可以忽略此步骤。</p>\n</li>\n<li><p>删除 Docker 相关的存储库文件：如果您添加了 Docker 的存储库文件，请运行以下命令删除这些文件。存储库文件通常位于 <code>/etc/yum.repos.d/</code> 目录下，文件名可能类似于 <code>docker-ce.repo</code> 或 <code>docker.repo</code>。</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo <span class=\"built_in\">rm</span> -rf /etc/yum.repos.d/docker*.repo</span><br></pre></td></tr></table></figure>\n\n<p>请注意，这一步仅适用于您手动添加了 Docker 的存储库文件的情况。</p>\n</li>\n<li><p>删除 Docker 命令。</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">rm</span> -rf /usr/bin/docker</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>完成上述步骤后，Docker 将从 CentOS 系统中被完全卸载。</p>\n<h2 id=\"Docker-使用\"><a href=\"#Docker-使用\" class=\"headerlink\" title=\"Docker 使用\"></a>Docker 使用</h2><blockquote>\n<p>创建一个容器，允许使用 GPU</p>\n</blockquote>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -itd -v /home/fengyuening/container_2204/:/root/ --gpus all --name fyn_ubuntu_2204 ubuntu:22.04</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>产生基础镜像：</p>\n</blockquote>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -f Dockerfile . -t bell/backend:1.0</span><br><span class=\"line\">docker pull mysql:5.7</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Docker保存为离线文件：</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker save -o mysql-5.7.tar mysql:5.7</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>将离线文件载入镜像：</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker load -i mysql-5.7.tar</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>修改镜像<br>    bell&#x2F;backend:1.0作为基础镜像，对其进行修改产生新镜像。</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -f Dockerfile2 . -t bell/backend:1.1</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Apach\"><a href=\"#Apach\" class=\"headerlink\" title=\"Apach\"></a>Apach</h2><blockquote>\n<p>使用 ApacheBench (ab) 工具进行性能测试</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ab -c 400 -n 1000 http://localhost:8080/</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">- `ab`：是 ApacheBench 工具的命令。</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">- `-c 400`：表示并发请求数（concurrency），即同时发送的请求数量。在这个例子中，设置为 400，表示会同时发送 400 个请求。</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">- `-n 1000`：表示总请求数（number of requests），即发送的总请求数量。在这个例子中，设置为 1000，表示会发送总共 1000 个请求。</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">- `http://localhost:8080/`：表示待测试的目标 URL，即请求要发送到的服务器的地址和端口。</span></span><br></pre></td></tr></table></figure>\n<pre><code>但是 17 年的一个帖子说`ab` 是一个糟糕的测试服务器的工具，它只是 http/1.0，甚至没有在这里使用 keepalive。尝试使用 -race 标志（如 `go build -race` ）构建服务器或使用 `go run -race main.go` 运行\n</code></pre>\n<h1 id=\"数据竞争检测-TODO\"><a href=\"#数据竞争检测-TODO\" class=\"headerlink\" title=\"数据竞争检测 TODO\"></a>数据竞争检测 TODO</h1><p>使用 <code>-race</code> 标志可以在 Go 中进行数据竞争检测，以帮助发现并发程序中的潜在竞态条件。</p>\n<ol>\n<li><p>构建服务器：</p>\n<ul>\n<li>打开终端或命令提示符。</li>\n<li>进入服务器的代码目录。</li>\n<li>运行以下命令：<code>go build -race</code>。</li>\n<li>如果构建成功，则会生成一个可执行文件，可以使用 <code>./&lt;可执行文件名&gt;</code> 执行服务器。</li>\n</ul>\n</li>\n<li><p>运行服务器：</p>\n<ul>\n<li>打开终端或命令提示符。</li>\n<li>进入服务器的代码目录。</li>\n<li>运行以下命令：<code>go run -race main.go</code>。</li>\n<li>这将使用 Go 运行时环境直接运行 <code>main.go</code> 文件，并启动服务器。</li>\n</ul>\n</li>\n</ol>\n<p>使用 <code>-race</code> 标志构建或运行服务器后，Go 编译器&#x2F;运行时将会执行数据竞争检测。如果检测到潜在的竞态条件，它将在终端或命令提示符中显示相关的警告或错误信息。</p>\n<p>注意，使用 <code>-race</code> 标志构建或运行服务器可能会增加程序的执行时间和资源消耗，因为数据竞争检测会引入一些额外的开销。因此，它通常用于开发和调试阶段，以帮助发现并解决并发问题，而不是在生产环境中使用。</p>\n"},{"_content":"_when_：有几种状态 composing、has_menu、paging\n\n_accept_：控制接受的按键 minus、equal,、period、comma、bracketleft、bracketright\n\n_send_：控制动作 Page_Up、Page_Down、Escape(清空输入码)\n\n`# # 快捷键# - { when: has_menu, accept: semicolon, send: 2 } # \":\" (分号)选择第 2 个候选词# - { when: has_menu, accept: apostrophe, send: 3 } # \"'\" (引号)选择第 3 个候选词# - { when: composing, accept: Shift+Tab, send: Shift+Left } # \"Shift+Tab\" 键向左选拼音分词# - { when: composing, accept: Control+a, send: Home } # \"Control+a\" 光标移至首# - { when: composing, accept: Control+e, send: End } # \"Control+e\" 光标移至尾# - { when: composing, accept: Control+g, send: Escape } # \"Control+g\" 清码# - { when: composing, accept: Return, send: Escape } # \"Return\" 回车清码# - { when: always, accept: Control+Shift+1, select: .next } # 切换输入方案# - { when: always, accept: Control+Shift+2, toggle: ascii_mode } # 中/英文切换# - { when: always, accept: Control+Shift+3, toggle: full_shape } # 全角/半角切换# - { when: always, accept: Control+Shift+4, toggle: simplification } # 繁简体切换# - { when: always, accept: Control+Shift+5, toggle: extended_charset } # 通用/增广切换（显示生僻字）# - { when: composing, accept: Control+b, send: Left } # \"Control+b\" 移动光标# - { when: composing, accept: Control+f, send: Right } # \"Control+f\" 向右选择候选词# - { when: composing, accept: Control+h, send: BackSpace } # \"Control+h\" 删除输入码`\n\nhttps://gist.github.com/lotem/2316704","source":"_posts/工具教程/教程：Rime 输入法.md","raw":"_when_：有几种状态 composing、has_menu、paging\n\n_accept_：控制接受的按键 minus、equal,、period、comma、bracketleft、bracketright\n\n_send_：控制动作 Page_Up、Page_Down、Escape(清空输入码)\n\n`# # 快捷键# - { when: has_menu, accept: semicolon, send: 2 } # \":\" (分号)选择第 2 个候选词# - { when: has_menu, accept: apostrophe, send: 3 } # \"'\" (引号)选择第 3 个候选词# - { when: composing, accept: Shift+Tab, send: Shift+Left } # \"Shift+Tab\" 键向左选拼音分词# - { when: composing, accept: Control+a, send: Home } # \"Control+a\" 光标移至首# - { when: composing, accept: Control+e, send: End } # \"Control+e\" 光标移至尾# - { when: composing, accept: Control+g, send: Escape } # \"Control+g\" 清码# - { when: composing, accept: Return, send: Escape } # \"Return\" 回车清码# - { when: always, accept: Control+Shift+1, select: .next } # 切换输入方案# - { when: always, accept: Control+Shift+2, toggle: ascii_mode } # 中/英文切换# - { when: always, accept: Control+Shift+3, toggle: full_shape } # 全角/半角切换# - { when: always, accept: Control+Shift+4, toggle: simplification } # 繁简体切换# - { when: always, accept: Control+Shift+5, toggle: extended_charset } # 通用/增广切换（显示生僻字）# - { when: composing, accept: Control+b, send: Left } # \"Control+b\" 移动光标# - { when: composing, accept: Control+f, send: Right } # \"Control+f\" 向右选择候选词# - { when: composing, accept: Control+h, send: BackSpace } # \"Control+h\" 删除输入码`\n\nhttps://gist.github.com/lotem/2316704","slug":"工具教程/教程：Rime 输入法","published":1,"date":"2024-04-22T13:14:48.758Z","updated":"2024-03-05T08:47:16.620Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0c000hkgg462nnh8cc","content":"<p>_when_：有几种状态 composing、has_menu、paging</p>\n<p>_accept_：控制接受的按键 minus、equal,、period、comma、bracketleft、bracketright</p>\n<p>_send_：控制动作 Page_Up、Page_Down、Escape(清空输入码)</p>\n<p><code># # 快捷键# - &#123; when: has_menu, accept: semicolon, send: 2 &#125; # &quot;:&quot; (分号)选择第 2 个候选词# - &#123; when: has_menu, accept: apostrophe, send: 3 &#125; # &quot;&#39;&quot; (引号)选择第 3 个候选词# - &#123; when: composing, accept: Shift+Tab, send: Shift+Left &#125; # &quot;Shift+Tab&quot; 键向左选拼音分词# - &#123; when: composing, accept: Control+a, send: Home &#125; # &quot;Control+a&quot; 光标移至首# - &#123; when: composing, accept: Control+e, send: End &#125; # &quot;Control+e&quot; 光标移至尾# - &#123; when: composing, accept: Control+g, send: Escape &#125; # &quot;Control+g&quot; 清码# - &#123; when: composing, accept: Return, send: Escape &#125; # &quot;Return&quot; 回车清码# - &#123; when: always, accept: Control+Shift+1, select: .next &#125; # 切换输入方案# - &#123; when: always, accept: Control+Shift+2, toggle: ascii_mode &#125; # 中/英文切换# - &#123; when: always, accept: Control+Shift+3, toggle: full_shape &#125; # 全角/半角切换# - &#123; when: always, accept: Control+Shift+4, toggle: simplification &#125; # 繁简体切换# - &#123; when: always, accept: Control+Shift+5, toggle: extended_charset &#125; # 通用/增广切换（显示生僻字）# - &#123; when: composing, accept: Control+b, send: Left &#125; # &quot;Control+b&quot; 移动光标# - &#123; when: composing, accept: Control+f, send: Right &#125; # &quot;Control+f&quot; 向右选择候选词# - &#123; when: composing, accept: Control+h, send: BackSpace &#125; # &quot;Control+h&quot; 删除输入码</code></p>\n<p><a href=\"https://gist.github.com/lotem/2316704\">https://gist.github.com/lotem/2316704</a></p>\n","excerpt":"","more":"<p>_when_：有几种状态 composing、has_menu、paging</p>\n<p>_accept_：控制接受的按键 minus、equal,、period、comma、bracketleft、bracketright</p>\n<p>_send_：控制动作 Page_Up、Page_Down、Escape(清空输入码)</p>\n<p><code># # 快捷键# - &#123; when: has_menu, accept: semicolon, send: 2 &#125; # &quot;:&quot; (分号)选择第 2 个候选词# - &#123; when: has_menu, accept: apostrophe, send: 3 &#125; # &quot;&#39;&quot; (引号)选择第 3 个候选词# - &#123; when: composing, accept: Shift+Tab, send: Shift+Left &#125; # &quot;Shift+Tab&quot; 键向左选拼音分词# - &#123; when: composing, accept: Control+a, send: Home &#125; # &quot;Control+a&quot; 光标移至首# - &#123; when: composing, accept: Control+e, send: End &#125; # &quot;Control+e&quot; 光标移至尾# - &#123; when: composing, accept: Control+g, send: Escape &#125; # &quot;Control+g&quot; 清码# - &#123; when: composing, accept: Return, send: Escape &#125; # &quot;Return&quot; 回车清码# - &#123; when: always, accept: Control+Shift+1, select: .next &#125; # 切换输入方案# - &#123; when: always, accept: Control+Shift+2, toggle: ascii_mode &#125; # 中/英文切换# - &#123; when: always, accept: Control+Shift+3, toggle: full_shape &#125; # 全角/半角切换# - &#123; when: always, accept: Control+Shift+4, toggle: simplification &#125; # 繁简体切换# - &#123; when: always, accept: Control+Shift+5, toggle: extended_charset &#125; # 通用/增广切换（显示生僻字）# - &#123; when: composing, accept: Control+b, send: Left &#125; # &quot;Control+b&quot; 移动光标# - &#123; when: composing, accept: Control+f, send: Right &#125; # &quot;Control+f&quot; 向右选择候选词# - &#123; when: composing, accept: Control+h, send: BackSpace &#125; # &quot;Control+h&quot; 删除输入码</code></p>\n<p><a href=\"https://gist.github.com/lotem/2316704\">https://gist.github.com/lotem/2316704</a></p>\n"},{"_content":"Wandb（全称为Weights and Biases）是一个专注于机器学习项目的工具，旨在帮助用户跟踪、可视化和协作。它提供了实时指标跟踪、超参数调整、模型可视化等功能，使机器学习工程师能够更好地管理和监控他们的实验，从而获得更多的见解和知识\n。Wandb支持与Jupyter、TensorFlow等工具的集成，能够自动记录模型训练过程中的超参数和输出指标，并进行可视化和比较，便于快速共享结果\n\n使用Wandb的基本步骤包括：首先，在W&B网站上创建一个免费账户\n\n；然后，安装Wandb库并登录\n\n；在代码中导入Wandb并初始化，定义要监视的变量，如超参数、loss和Metric\n\n；接着，记录训练日志（包括图片和文字）、保存模型，并在训练过程中获取权重直方图等\n\n。此外，Wandb还提供了丰富的用户管理和团队管理功能，方便团队协作\n\n总结来说，Wandb是一个强大的机器学习项目管理工具，通过其提供的功能，可以帮助研究人员和开发者更有效地进行实验设计、数据可视化和结果分析。通过简单的注册、安装和初始化过程，即可开始使用Wandb来提升机器学习项目的效率和质量。\n0c95d54f6822155600329ac8870848a84191a0ca","source":"_posts/工具教程/教程：Wandb.md","raw":"Wandb（全称为Weights and Biases）是一个专注于机器学习项目的工具，旨在帮助用户跟踪、可视化和协作。它提供了实时指标跟踪、超参数调整、模型可视化等功能，使机器学习工程师能够更好地管理和监控他们的实验，从而获得更多的见解和知识\n。Wandb支持与Jupyter、TensorFlow等工具的集成，能够自动记录模型训练过程中的超参数和输出指标，并进行可视化和比较，便于快速共享结果\n\n使用Wandb的基本步骤包括：首先，在W&B网站上创建一个免费账户\n\n；然后，安装Wandb库并登录\n\n；在代码中导入Wandb并初始化，定义要监视的变量，如超参数、loss和Metric\n\n；接着，记录训练日志（包括图片和文字）、保存模型，并在训练过程中获取权重直方图等\n\n。此外，Wandb还提供了丰富的用户管理和团队管理功能，方便团队协作\n\n总结来说，Wandb是一个强大的机器学习项目管理工具，通过其提供的功能，可以帮助研究人员和开发者更有效地进行实验设计、数据可视化和结果分析。通过简单的注册、安装和初始化过程，即可开始使用Wandb来提升机器学习项目的效率和质量。\n0c95d54f6822155600329ac8870848a84191a0ca","slug":"工具教程/教程：Wandb","published":1,"date":"2024-04-22T13:14:48.760Z","updated":"2024-03-21T08:00:53.196Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0c000ikgg45o5tfhy9","content":"<p>Wandb（全称为Weights and Biases）是一个专注于机器学习项目的工具，旨在帮助用户跟踪、可视化和协作。它提供了实时指标跟踪、超参数调整、模型可视化等功能，使机器学习工程师能够更好地管理和监控他们的实验，从而获得更多的见解和知识<br>。Wandb支持与Jupyter、TensorFlow等工具的集成，能够自动记录模型训练过程中的超参数和输出指标，并进行可视化和比较，便于快速共享结果</p>\n<p>使用Wandb的基本步骤包括：首先，在W&amp;B网站上创建一个免费账户</p>\n<p>；然后，安装Wandb库并登录</p>\n<p>；在代码中导入Wandb并初始化，定义要监视的变量，如超参数、loss和Metric</p>\n<p>；接着，记录训练日志（包括图片和文字）、保存模型，并在训练过程中获取权重直方图等</p>\n<p>。此外，Wandb还提供了丰富的用户管理和团队管理功能，方便团队协作</p>\n<p>总结来说，Wandb是一个强大的机器学习项目管理工具，通过其提供的功能，可以帮助研究人员和开发者更有效地进行实验设计、数据可视化和结果分析。通过简单的注册、安装和初始化过程，即可开始使用Wandb来提升机器学习项目的效率和质量。<br>0c95d54f6822155600329ac8870848a84191a0ca</p>\n","excerpt":"","more":"<p>Wandb（全称为Weights and Biases）是一个专注于机器学习项目的工具，旨在帮助用户跟踪、可视化和协作。它提供了实时指标跟踪、超参数调整、模型可视化等功能，使机器学习工程师能够更好地管理和监控他们的实验，从而获得更多的见解和知识<br>。Wandb支持与Jupyter、TensorFlow等工具的集成，能够自动记录模型训练过程中的超参数和输出指标，并进行可视化和比较，便于快速共享结果</p>\n<p>使用Wandb的基本步骤包括：首先，在W&amp;B网站上创建一个免费账户</p>\n<p>；然后，安装Wandb库并登录</p>\n<p>；在代码中导入Wandb并初始化，定义要监视的变量，如超参数、loss和Metric</p>\n<p>；接着，记录训练日志（包括图片和文字）、保存模型，并在训练过程中获取权重直方图等</p>\n<p>。此外，Wandb还提供了丰富的用户管理和团队管理功能，方便团队协作</p>\n<p>总结来说，Wandb是一个强大的机器学习项目管理工具，通过其提供的功能，可以帮助研究人员和开发者更有效地进行实验设计、数据可视化和结果分析。通过简单的注册、安装和初始化过程，即可开始使用Wandb来提升机器学习项目的效率和质量。<br>0c95d54f6822155600329ac8870848a84191a0ca</p>\n"},{"_content":"[Markdown数学公式语法 - 简书 (jianshu.com)](https://www.jianshu.com/p/383e8149136c)\n\n# 一、简单分类\n\n### 1. 行内公式\n\n将公式插入到本行内，符号：`$公式内容$`，如：`$xyz$`  \n![xyz](https://math.jianshu.com/math?formula=xyz)\n\n### 2. 行间公式\n\n将公式插入到新的一行内，并且居中，符号：`$公式内容$`，如：`$$xyz$$`  \n![xyz](https://math.jianshu.com/math?formula=xyz)\n\n# 二、上标、下标与组合\n\n### 1. 上标符号，符号：`^`，如：`$x^4$` ![x^4](https://math.jianshu.com/math?formula=x%5E4)\n\n### 2. 下标符号，符号：`_`，如：`$x_1$` ![x_1](https://math.jianshu.com/math?formula=x_1)\n\n### 3. 组合符号，符号：`{}`，如：![<sup>{16}_{8}O</sup>{2+}_{2}](https://math.jianshu.com/math?formula=%3Csup%3E%7B16%7D_%7B8%7DO%3C%2Fsup%3E%7B2%2B%7D_%7B2%7D)\n\n默认情况下，上、下标符号仅仅对下一个组起作用。一个组即单个字符或者使用{}（大括号） 包裹起来的内容。如果使用`$10^10$`表示的是![10^10](https://math.jianshu.com/math?formula=10%5E10),而`$10^{10}$` 才可以表示为![10^{10}](https://math.jianshu.com/math?formula=10%5E%7B10%7D)。同时，大括号还能消除二义性，如：`$x^5^6$` 将得到一个错误，必须使用大括号来界定^的结合性，如:`${x^5}^6$`表示的![{x^5}^6](https://math.jianshu.com/math?formula=%7Bx%5E5%7D%5E6)：或者用`$x^{5^6}$`表示的![x^{5^6}](https://math.jianshu.com/math?formula=x%5E%7B5%5E6%7D)。\n\n# 三、括号\n\n### 1.小括号与方括号\n\n用原始的( ) ，[ ] 即可，如`(2+3)[4+4]`可表示：![(2+3)[4+4]](https://math.jianshu.com/math?formula=(2%2B3)%5B4%2B4%5D)。  \n使用\\left(或\\right)使符号大小与邻近的公式相适应（该语句适用于所有括号类型），如\\left(\\frac{x}{y}\\right)可表示![\\left(\\frac{x}{y}\\right)](https://math.jianshu.com/math?formula=%5Cleft(%5Cfrac%7Bx%7D%7By%7D%5Cright))\n\n### 2. 大括号\n\n由于大括号{} 被用于分组，因此需要使用{和}表示大括号，也可以使用\\lbrace 和\\rbrace来表示。如{ab}或\\lbrace ab\\rbrace表示:![\\{ab\\}](https://math.jianshu.com/math?formula=%5C%7Bab%5C%7D)\n\n### 3. 尖括号\n\n区分于小于号和大于号，使用\\langle 和\\rangle 表示左尖括号和右尖括号。如\\langle x \\rangle表示：![\\langle x \\rangle](https://math.jianshu.com/math?formula=%5Clangle%20x%20%5Crangle)\n\n# 三、取整\n\n### 1. 上取整\n\n使用\\lceil 和 \\rceil 表示。 如，\\lceil x \\rceil表示为：![\\lceil x \\rceil](https://math.jianshu.com/math?formula=%5Clceil%20x%20%5Crceil)\n\n### 2. 下取整\n\n使用\\lfloor 和 \\rfloor 表示。如，\\lfloor x \\rfloor表示为:![\\lfloor x \\rfloor](https://math.jianshu.com/math?formula=%5Clfloor%20x%20%5Crfloor)\n\n# 四、求和\\积分\\连乘\n\n### 1.求和\n\n`\\sum` 用来表示求和符号，其下标表示求和下限，上标表示上限。如:  \n`$\\sum_{r=1}^n$`表示：![\\sum_{r=1}^n](https://math.jianshu.com/math?formula=%5Csum_%7Br%3D1%7D%5En)\n\n### 2. 积分\n\n`\\int` 用来表示积分符号，同样地，其上下标表示积分的上下限。如，`$\\int_{r=1}^\\infty$`表示:![\\int_{r=1}^\\infty](https://math.jianshu.com/math?formula=%5Cint_%7Br%3D1%7D%5E%5Cinfty)  \n多重积分同样使用`\\int` ，通过 i 的数量表示积分导数：  \n如：  \n`$\\iint$` 表示为：![\\iint](https://math.jianshu.com/math?formula=%5Ciint)  \n`$\\iiint$` 表示为：![\\iiint](https://math.jianshu.com/math?formula=%5Ciiint)\n\n### 3. 连乘\n\n`$\\prod {a+b}$` 表示：![\\prod {a+b}](https://math.jianshu.com/math?formula=%5Cprod%20%7Ba%2Bb%7D)  \n`$\\prod_{i=1}^{K}$` 表示：![\\prod_{i=1}^{K}](https://math.jianshu.com/math?formula=%5Cprod_%7Bi%3D1%7D%5E%7BK%7D)  \n`$$\\prod_{i=1}^{K}$$`表示（注意是行间公式）：![\\prod_{i=1}^{K}](https://math.jianshu.com/math?formula=%5Cprod_%7Bi%3D1%7D%5E%7BK%7D)\n\n### 4. 其他\n\n与此类似的符号还有，  \n`$\\prod$` ：![\\prod](https://math.jianshu.com/math?formula=%5Cprod)  \n`$\\bigcup$`：![\\bigcup](https://math.jianshu.com/math?formula=%5Cbigcup)  \n`$\\bigcap$` ：![\\bigcap](https://math.jianshu.com/math?formula=%5Cbigcap)  \n`$arg\\,\\max_{c_k}$`：![arg\\,\\max_{c_k}](https://math.jianshu.com/math?formula=arg%5C%2C%5Cmax_%7Bc_k%7D)  \n`$arg\\,\\min_{c_k}$`：![arg,\\min_{c_k}](https://math.jianshu.com/math?formula=arg%2C%5Cmin_%7Bc_k%7D)  \n`$\\mathop {argmin}_{c_k}$`：![\\mathop {argmin}_{c_k}](https://math.jianshu.com/math?formula=%5Cmathop%20%7Bargmin%7D_%7Bc_k%7D)  \n`$\\mathop {argmax}_{c_k}$`：![\\mathop {argmax}_{c_k}](https://math.jianshu.com/math?formula=%5Cmathop%20%7Bargmax%7D_%7Bc_k%7D)  \n`$\\max_{c_k}$`：![\\max_{c_k}](https://math.jianshu.com/math?formula=%5Cmax_%7Bc_k%7D)  \n`$\\min_{c_k}$`：![\\min_{c_k}](https://math.jianshu.com/math?formula=%5Cmin_%7Bc_k%7D)\n\n# 五、分式与根式\n\n### 1. 分式\n\n第一种，使用`\\frac ab`，表示为:![\\frac ab](https://math.jianshu.com/math?formula=%5Cfrac%20ab) ，`\\frac`作用于其后的两个组a ，b ，结果为。如果你的分子或分母不是单个字符，请使用{…}来分组，比如`$\\frac {a+c+1}{b+c+2}$`表示:![\\frac {a+c+1}{b+c+2}](https://math.jianshu.com/math?formula=%5Cfrac%20%7Ba%2Bc%2B1%7D%7Bb%2Bc%2B2%7D)  \n第二种，使用\\over来分隔一个组的前后两部分，如`${a+1\\over b+1}$`：![{a+1\\over b+1}](https://math.jianshu.com/math?formula=%7Ba%2B1%5Cover%20b%2B1%7D)\n\n### 2. 连分数\n\n书写连分数表达式时，请使用`\\cfrac`代替`\\frac`或者`\\over`两者效果对比如下：  \n`\\frac` 表示如下：\n\n```ruby\n $$x=a_0 + \\frac {1^2}{a_1 + \\frac {2^2}{a_2 + \\frac {3^2}{a_3 + \\frac {4^2}{a_4 + ...}}}}$$\n```\n\n显示如下：  \n![x=a_0 + \\frac {1^2}{a_1 + \\frac {2^2}{a_2 + \\frac {3^2}{a_3 + \\frac {4^2}{a_4 + ...}}}}](https://math.jianshu.com/math?formula=x%3Da_0%20%2B%20%5Cfrac%20%7B1%5E2%7D%7Ba_1%20%2B%20%5Cfrac%20%7B2%5E2%7D%7Ba_2%20%2B%20%5Cfrac%20%7B3%5E2%7D%7Ba_3%20%2B%20%5Cfrac%20%7B4%5E2%7D%7Ba_4%20%2B%20...%7D%7D%7D%7D)  \n`\\cfrac`表示如下：\n\n```ruby\n$$x=a_0 + \\cfrac {1^2}{a_1 + \\cfrac {2^2}{a_2 + \\cfrac {3^2}{a_3 + \\cfrac {4^2}{a_4 + ...}}}}$$\n```\n\n显示如下：  \n![x=a_0 + \\cfrac {1^2}{a_1 + \\cfrac {2^2}{a_2 + \\cfrac {3^2}{a_3 + \\cfrac {4^2}{a_4 + ...}}}}](https://math.jianshu.com/math?formula=x%3Da_0%20%2B%20%5Ccfrac%20%7B1%5E2%7D%7Ba_1%20%2B%20%5Ccfrac%20%7B2%5E2%7D%7Ba_2%20%2B%20%5Ccfrac%20%7B3%5E2%7D%7Ba_3%20%2B%20%5Ccfrac%20%7B4%5E2%7D%7Ba_4%20%2B%20...%7D%7D%7D%7D)\n\n### 3.根式\n\n根式使用`\\sqrt` 来表示。  \n如开4次方：`$\\sqrt[4]{\\frac xy}$` 可表示：![\\sqrt[4]{\\frac xy}](https://math.jianshu.com/math?formula=%5Csqrt%5B4%5D%7B%5Cfrac%20xy%7D)  \n开平方：`$\\sqrt {a+b}$`可表示：![\\sqrt {a+b}](https://math.jianshu.com/math?formula=%5Csqrt%20%7Ba%2Bb%7D)\n\n# 六、多行表达式\n\n### 1. 分类表达式\n\n定义函数的时候经常需要分情况给出表达式，使用\\begin{cases}…\\end{cases} 。其中：  \n使用`\\\\` 来分类，  \n使用`&`指示需要对齐的位置，  \n使用`\\ +space`表示空格。  \n如：\n\n```ruby\n$$\nf(n)\n\\begin{cases}\n\\cfrac n2, &if\\ n\\ is\\ even\\\\\n3n + 1, &if\\  n\\ is\\ odd\n\\end{cases}\n$$\n```\n\n表示:  \n![f(n) \\begin{cases} \\cfrac n2, &if\\ n\\ is\\ even\\\\ 3n + 1, &if\\ n\\ is\\ odd \\end{cases}](https://math.jianshu.com/math?formula=f(n)%20%5Cbegin%7Bcases%7D%20%5Ccfrac%20n2%2C%20%26if%5C%20n%5C%20is%5C%20even%5C%5C%203n%20%2B%201%2C%20%26if%5C%20n%5C%20is%5C%20odd%20%5Cend%7Bcases%7D)  \n以及:\n\n```ruby\n$$\nL(Y,f(X)) =\n\\begin{cases}\n0, & \\text{Y = f(X)}  \\\\\n1, & \\text{Y $\\neq$ f(X)}\n\\end{cases}\n$$\n```\n\n表示:  \n![L(Y,f(X)) = \\begin{cases} 0, & \\text{Y = f(X)} \\\\ 1, & \\text{Y $\\neq$ f(X)} \\end{cases}](https://math.jianshu.com/math?formula=L(Y%2Cf(X))%20%3D%20%5Cbegin%7Bcases%7D%200%2C%20%26%20%5Ctext%7BY%20%3D%20f(X)%7D%20%5C%5C%201%2C%20%26%20%5Ctext%7BY%20%24%5Cneq%24%20f(X)%7D%20%5Cend%7Bcases%7D)\n\n如果想分类之间的垂直间隔变大，可以使用`\\\\[2ex]`代替`\\\\`来分隔不同的情况。`(3ex,4ex` 也可以用，`1ex`相当于原始距离）。如下所示：\n\n```ruby\n$$\nL(Y,f(X)) =\n\\begin{cases}\n0, & \\text{Y = f(X)} \\\\[5ex]\n1, & \\text{Y $\\neq$ f(X)}\n\\end{cases}\n$$\n```\n\n表示：  \n![L(Y,f(X)) = \\begin{cases} 0, & \\text{Y = f(X)} \\\\[5ex] 1, & \\text{Y $\\neq$ f(X)} \\end{cases}](https://math.jianshu.com/math?formula=L(Y%2Cf(X))%20%3D%20%5Cbegin%7Bcases%7D%200%2C%20%26%20%5Ctext%7BY%20%3D%20f(X)%7D%20%5C%5C%5B5ex%5D%201%2C%20%26%20%5Ctext%7BY%20%24%5Cneq%24%20f(X)%7D%20%5Cend%7Bcases%7D)\n\n### 2. 多行表达式\n\n有时候需要将一行公式分多行进行显示。\n\n```cpp\n$$\n\\begin{aligned}\n\\sqrt{37} & = \\sqrt{\\frac{73^2-1}{12^2}} \\\\\n & = \\sqrt{\\frac{73^2}{12^2}\\cdot\\frac{73^2-1}{73^2}} \\\\ \n & = \\sqrt{\\frac{73^2}{12^2}}\\sqrt{\\frac{73^2-1}{73^2}} \\\\\n & = \\frac{73}{12}\\sqrt{1 - \\frac{1}{73^2}} \\\\ \n & \\approx \\frac{73}{12}\\left(1 - \\frac{1}{2\\cdot73^2}\\right)\n\\end{aligned}\n$$\n```\n\n表示:  \n![\\begin{aligned} \\sqrt{37} & = \\sqrt{\\frac{73^2-1}{12^2}} \\\\ & = \\sqrt{\\frac{73^2}{12^2}\\cdot\\frac{73^2-1}{73^2}} \\\\ & = \\sqrt{\\frac{73^2}{12^2}}\\sqrt{\\frac{73^2-1}{73^2}} \\\\ & = \\frac{73}{12}\\sqrt{1 - \\frac{1}{73^2}} \\\\ & \\approx \\frac{73}{12}\\left(1 - \\frac{1}{2\\cdot73^2}\\right) \\end{aligned}](https://math.jianshu.com/math?formula=%5Cbegin%7Baligned%7D%20%5Csqrt%7B37%7D%20%26%20%3D%20%5Csqrt%7B%5Cfrac%7B73%5E2-1%7D%7B12%5E2%7D%7D%20%5C%5C%20%26%20%3D%20%5Csqrt%7B%5Cfrac%7B73%5E2%7D%7B12%5E2%7D%5Ccdot%5Cfrac%7B73%5E2-1%7D%7B73%5E2%7D%7D%20%5C%5C%20%26%20%3D%20%5Csqrt%7B%5Cfrac%7B73%5E2%7D%7B12%5E2%7D%7D%5Csqrt%7B%5Cfrac%7B73%5E2-1%7D%7B73%5E2%7D%7D%20%5C%5C%20%26%20%3D%20%5Cfrac%7B73%7D%7B12%7D%5Csqrt%7B1%20-%20%5Cfrac%7B1%7D%7B73%5E2%7D%7D%20%5C%5C%20%26%20%5Capprox%20%5Cfrac%7B73%7D%7B12%7D%5Cleft(1%20-%20%5Cfrac%7B1%7D%7B2%5Ccdot73%5E2%7D%5Cright)%20%5Cend%7Baligned%7D)\n\n```ruby\n$$\n\\begin{aligned}\na&=b+c-d \\\\\n&=e-f \\\\\n&=i \\\\\n\\end{aligned}\n$$\n```\n\n表示:  \n![\\begin{aligned} a&=b+c-d \\\\ &=e-f \\\\ &=i \\\\ \\end{aligned}](https://math.jianshu.com/math?formula=%5Cbegin%7Baligned%7D%20a%26%3Db%2Bc-d%20%5C%5C%20%26%3De-f%20%5C%5C%20%26%3Di%20%5C%5C%20%5Cend%7Baligned%7D)\n\n其中`begin{equation}` 表示开始方程，`end{equation}`表示方程结束；`begin{split}` 表示开始多行公式，`end{split}` 表示结束；公式中用`\\\\` 表示回车到下一行，`&` 表示对齐的位置。\n\n# 七、方程组\n\n使用\\begin{array}...\\end{array} 与\\left \\与\\right 配合表示方程组,如:\n\n```ruby\n$$\n\\left \\{ \n\\begin{array}{c}\na_1x+b_1y+c_1z=d_1 \\\\ \na_2x+b_2y+c_2z=d_2 \\\\ \na_3x+b_3y+c_3z=d_3\n\\end{array}\n\\right.\n$$\n```\n\n表示：  \n![\\left \\{ \\begin{array}{c} a_1x+b_1y+c_1z=d_1 \\\\ a_2x+b_2y+c_2z=d_2 \\\\ a_3x+b_3y+c_3z=d_3 \\end{array} \\right.](https://math.jianshu.com/math?formula=%5Cleft%20%5C%7B%20%5Cbegin%7Barray%7D%7Bc%7D%20a_1x%2Bb_1y%2Bc_1z%3Dd_1%20%5C%5C%20a_2x%2Bb_2y%2Bc_2z%3Dd_2%20%5C%5C%20a_3x%2Bb_3y%2Bc_3z%3Dd_3%20%5Cend%7Barray%7D%20%5Cright.)\n\n注意：通常MathJax通过内部策略自己管理公式内部的空间，因此`a…b` 与`a…….b`（.表示空格）都会显示为`ab`。可以通过在`ab`间加入`\\`,增加些许间隙，`\\;`增加较宽的间隙，`\\quad` 与`\\qquad` 会增加更大的间隙。\n\n# 八、特殊函数与符号\n\n### 1. 三角函数\n\n`$\\sin x$` : ![\\sin x](https://math.jianshu.com/math?formula=%5Csin%20x)  \n`$\\arctan x$` : ![\\arctan x](https://math.jianshu.com/math?formula=%5Carctan%20x)\n\n### 2.比较运算符\n\n小于`(\\lt )`：![(\\lt )](https://math.jianshu.com/math?formula=(%5Clt%20))  \n大于`(\\gt )`：![(\\gt](https://math.jianshu.com/math?formula=(%5Cgt)  \n小于等于`(\\le )`：![(\\le )](https://math.jianshu.com/math?formula=(%5Cle%20))  \n大于等于`(\\ge )`：![(\\ge )](https://math.jianshu.com/math?formula=(%5Cge%20))  \n不等于`(\\ne )` :![(\\ne )](https://math.jianshu.com/math?formula=(%5Cne%20))  \n可以在这些运算符前面加上`\\not` ，如`\\not\\lt` : ![\\not\\lt](https://math.jianshu.com/math?formula=%5Cnot%5Clt)\n\n### 3.集合关系与运算\n\n并集`(\\cup)`: ![(\\cup)](https://math.jianshu.com/math?formula=(%5Ccup))  \n交集`(\\cap)`: ![(\\cap)](https://math.jianshu.com/math?formula=(%5Ccap))  \n差集`(\\setminus)`:![(\\setminus)](https://math.jianshu.com/math?formula=(%5Csetminus))  \n子集`(\\subset)`: ![(\\subset)](https://math.jianshu.com/math?formula=(%5Csubset))  \n子集`(\\subseteq)`: ![(\\subseteq)](https://math.jianshu.com/math?formula=(%5Csubseteq))  \n非子集`(\\subsetneq)`: ![(\\subsetneq)](https://math.jianshu.com/math?formula=(%5Csubsetneq))  \n父集`(\\supset)`: ![(\\supset)](https://math.jianshu.com/math?formula=(%5Csupset))  \n属于`(\\in)`: ![(\\in)](https://math.jianshu.com/math?formula=(%5Cin))  \n不属于`(\\notin)`:![`(\\notin)](https://math.jianshu.com/math?formula=%60(%5Cnotin))  \n空集`(\\emptyset)`: ![(\\emptyset)](https://math.jianshu.com/math?formula=(%5Cemptyset))  \n空`(\\varnothing)`: ![(\\varnothing)](https://math.jianshu.com/math?formula=(%5Cvarnothing))\n\n### 4. 排列\n\n`\\binom{n+1}{2k}` : ![\\binom{n+1}{2k}](https://math.jianshu.com/math?formula=%5Cbinom%7Bn%2B1%7D%7B2k%7D)  \n`{n+1 \\choose 2k}` : ![{n+1 \\choose 2k}](https://math.jianshu.com/math?formula=%7Bn%2B1%20%5Cchoose%202k%7D)\n\n### 5. 箭头\n\n`(\\to)`:![(\\to)](https://math.jianshu.com/math?formula=(%5Cto))  \n`(\\rightarrow)`: ![(\\rightarrow)](https://math.jianshu.com/math?formula=(%5Crightarrow))  \n`(\\leftarrow)`: ![(\\leftarrow)](https://math.jianshu.com/math?formula=(%5Cleftarrow))  \n`(\\Rightarrow)`:![`(\\Rightarrow)](https://math.jianshu.com/math?formula=%60(%5CRightarrow))  \n`(\\Leftarrow)`: ![(\\Leftarrow)](https://math.jianshu.com/math?formula=(%5CLeftarrow))  \n`(\\mapsto)`: ![\\mapsto)](https://math.jianshu.com/math?formula=%5Cmapsto))\n\n### 6. 逻辑运算符\n\n`(\\land)`: ![(\\land)](https://math.jianshu.com/math?formula=(%5Cland))  \n`(\\lor)`: ![(\\lor)](https://math.jianshu.com/math?formula=(%5Clor))  \n`(\\lnot)`: ![(\\lnot)](https://math.jianshu.com/math?formula=(%5Clnot))  \n`(\\forall)`: ![(\\forall)](https://math.jianshu.com/math?formula=(%5Cforall))  \n`(\\exists)`: ![(\\exists)](https://math.jianshu.com/math?formula=(%5Cexists))  \n`(\\top)`: ![(\\top)](https://math.jianshu.com/math?formula=(%5Ctop))  \n`(\\bot)`: ![(\\bot)](https://math.jianshu.com/math?formula=(%5Cbot))  \n`(\\vdash)`: ![(\\vdash)](https://math.jianshu.com/math?formula=(%5Cvdash))  \n`(\\vDash)`:![(\\vDash)](https://math.jianshu.com/math?formula=(%5CvDash))\n\n### 7.操作符\n\n`(\\star)`: ![`(\\star)](https://math.jianshu.com/math?formula=%60(%5Cstar))  \n`(\\ast)`: ![(\\ast)](https://math.jianshu.com/math?formula=(%5Cast))  \n`(\\oplus)`: ![(\\oplus)](https://math.jianshu.com/math?formula=(%5Coplus))  \n`(\\circ)`: ![(\\circ)](https://math.jianshu.com/math?formula=(%5Ccirc))  \n`(\\bullet)`: ![(\\bullet)](https://math.jianshu.com/math?formula=(%5Cbullet))\n\n### 8.等于\n\n`(\\approx)`:![(\\approx)](https://math.jianshu.com/math?formula=(%5Capprox))  \n`(\\sim)`: ![(\\sim)](https://math.jianshu.com/math?formula=(%5Csim))  \n`(\\equiv)`: ![(\\equiv)](https://math.jianshu.com/math?formula=(%5Cequiv))  \n`(\\prec)`: ![(\\prec)](https://math.jianshu.com/math?formula=(%5Cprec))\n\n### 9.范围\n\n`(\\infty)`:![(\\infty)](https://math.jianshu.com/math?formula=(%5Cinfty))  \n`(\\aleph_o)`:![(\\aleph_o)](https://math.jianshu.com/math?formula=(%5Caleph_o))  \n`(\\nabla)`: ![(\\nabla)](https://math.jianshu.com/math?formula=(%5Cnabla))  \n`(\\Im)`: ![(\\Im)](https://math.jianshu.com/math?formula=(%5CIm))  \n`(\\Re)`: ![(\\Re)](https://math.jianshu.com/math?formula=(%5CRe))\n\n### 10. 模运算\n\n`(\\pmod)`: ![`(\\pmod)](https://math.jianshu.com/math?formula=%60(%5Cpmod))  \n如a \\equiv b \\pmod n 表示为: ![a \\equiv b \\pmod n](https://math.jianshu.com/math?formula=a%20%5Cequiv%20b%20%5Cpmod%20n)\n\n### 11. 点\n\n`(\\ldots)`: ![(\\ldots)](https://math.jianshu.com/math?formula=(%5Cldots))  \n`(\\cdots)`: ![(\\cdots)](https://math.jianshu.com/math?formula=(%5Ccdots))  \n`(\\cdot)`: ![(\\cdot)](https://math.jianshu.com/math?formula=(%5Ccdot))  \n其区别是点的位置不同，`\\ldots` 位置稍低，`\\cdots` 位置居中。\n\n```ruby\n$$\n\\begin{cases}\na_1+a_2+\\ldots+a_n \\\\ \na_1+a_2+\\cdots+a_n \\\\\n\\end{cases}\n$$\n```\n\n表示(注意两部分点的位置)：  \n![\\begin{cases} a_1+a_2+\\ldots+a_n \\\\ a_1+a_2+\\cdots+a_n \\\\ \\end{cases}](https://math.jianshu.com/math?formula=%5Cbegin%7Bcases%7D%20a_1%2Ba_2%2B%5Cldots%2Ba_n%20%5C%5C%20a_1%2Ba_2%2B%5Ccdots%2Ba_n%20%5C%5C%20%5Cend%7Bcases%7D)\n\n### 12.顶部符号\n\n对于单字符，`\\hat x`：![\\hat x](https://math.jianshu.com/math?formula=%5Chat%20x)  \n多字符可以使用`\\widehat {xy}`：![\\widehat {xy}](https://math.jianshu.com/math?formula=%5Cwidehat%20%7Bxy%7D)  \n类似的还有`\\overline x`: ![\\overline x](https://math.jianshu.com/math?formula=%5Coverline%20x)  \n矢量`\\vec x`:![\\vec x](https://math.jianshu.com/math?formula=%5Cvec%20x)  \n向量`\\overrightarrow {xy}`: ![\\overrightarrow {xy}](https://math.jianshu.com/math?formula=%5Coverrightarrow%20%7Bxy%7D)  \n`\\dot x` : ![\\dot x](https://math.jianshu.com/math?formula=%5Cdot%20x)  \n`\\ddot x`: ![\\ddot x](https://math.jianshu.com/math?formula=%5Cddot%20x)  \n`\\dot {\\dot x}`: ![\\dot {\\dot x}](https://math.jianshu.com/math?formula=%5Cdot%20%7B%5Cdot%20x%7D)\n\n# 九、表格\n\n使用`\\begin{array}{列样式}…\\end{array}`这样的形式来创建表格，列样式可以是`clr` 表示居中，左，右对齐，还可以使用`|`表示一条竖线。表格中各行使用\\ 分隔，各列使用& 分隔。使用`\\hline` 在本行前加入一条直线。 例如:\n\n```ruby\n$$\n\\begin{array}{c|lcr}\nn & \\text{Left} & \\text{Center} & \\text{Right} \\\\\n\\hline\n1 & 0.24 & 1 & 125 \\\\\n2 & -1 & 189 & -8 \\\\\n3 & -20 & 2000 & 1+10i \\\\\n\\end{array}\n$$\n```\n\n得到：  \n![\\begin{array}{c|lcr} n & \\text{Left} & \\text{Center} & \\text{Right} \\\\ \\hline 1 & 0.24 & 1 & 125 \\\\ 2 & -1 & 189 & -8 \\\\ 3 & -20 & 2000 & 1+10i \\\\ \\end{array}](https://math.jianshu.com/math?formula=%5Cbegin%7Barray%7D%7Bc%7Clcr%7D%20n%20%26%20%5Ctext%7BLeft%7D%20%26%20%5Ctext%7BCenter%7D%20%26%20%5Ctext%7BRight%7D%20%5C%5C%20%5Chline%201%20%26%200.24%20%26%201%20%26%20125%20%5C%5C%202%20%26%20-1%20%26%20189%20%26%20-8%20%5C%5C%203%20%26%20-20%20%26%202000%20%26%201%2B10i%20%5C%5C%20%5Cend%7Barray%7D)\n\n# 十、汉字、字体与格式\n\n1. 汉字形式，符号：`\\mbox{}`，如：![V_{\\mbox{初始}}](https://math.jianshu.com/math?formula=V_%7B%5Cmbox%7B%E5%88%9D%E5%A7%8B%7D%7D)\n2. 字体控制，符号：`\\displaystyle`，如：![\\displaystyle \\frac{x+y}{y+z}](https://math.jianshu.com/math?formula=%5Cdisplaystyle%20%5Cfrac%7Bx%2By%7D%7By%2Bz%7D)\n3. 下划线符号，符号：`\\underline`，如：![\\underline{x+y}](https://math.jianshu.com/math?formula=%5Cunderline%7Bx%2By%7D)\n4. 标签，符号`\\tag{数字}`，如：![\\tag{11}](https://math.jianshu.com/math?formula=%5Ctag%7B11%7D)\n5. 上大括号，符号：`\\overbrace{算式}`，如：![\\overbrace{a+b+c+d}^{2.0}](https://math.jianshu.com/math?formula=%5Coverbrace%7Ba%2Bb%2Bc%2Bd%7D%5E%7B2.0%7D)\n6. 下大括号，符号：`\\underbrace{算式}`，如：![a+\\underbrace{b+c}_{1.0}+d](https://math.jianshu.com/math?formula=a%2B%5Cunderbrace%7Bb%2Bc%7D_%7B1.0%7D%2Bd)\n7. 上位符号，符号：`\\stacrel{上位符号}{基位符号}`，如：![\\vec{x}\\stackrel{\\mathrm{def}}{=}{x_1,\\dots,x_n}](https://math.jianshu.com/math?formula=%5Cvec%7Bx%7D%5Cstackrel%7B%5Cmathrm%7Bdef%7D%7D%7B%3D%7D%7Bx_1%2C%5Cdots%2Cx_n%7D)\n\n# 十一、占位符\n\n1. 两个quad空格，符号：`\\qquad`，如：![x \\qquad y](https://math.jianshu.com/math?formula=x%20%5Cqquad%20y)\n2. quad空格，符号：`\\quad`，如：![x \\quad y](https://math.jianshu.com/math?formula=x%20%5Cquad%20y)\n3. 大空格，符号`\\`，如：![x \\ y](https://math.jianshu.com/math?formula=x%20%5C%20y)\n4. 中空格，符号`\\:`，如：![x : y](https://math.jianshu.com/math?formula=x%20%3A%20y)\n5. 小空格，符号`\\,`，如：![x , y](https://math.jianshu.com/math?formula=x%20%2C%20y)\n6. 没有空格，符号``，如：![xy](https://math.jianshu.com/math?formula=xy)\n7. 紧贴，符号`\\!`，如：![x ! y](https://math.jianshu.com/math?formula=x%20!%20y)\n\n# 十二、定界符与组合\n\n1. 括号，符号：`（）\\big(\\big) \\Big(\\Big) \\bigg(\\bigg) \\Bigg(\\Bigg)`，如：![（）\\big(\\big) \\Big(\\Big) \\bigg(\\bigg) \\Bigg(\\Bigg)](https://math.jianshu.com/math?formula=%EF%BC%88%EF%BC%89%5Cbig(%5Cbig)%20%5CBig(%5CBig)%20%5Cbigg(%5Cbigg)%20%5CBigg(%5CBigg))\n2. 中括号，符号：`[]`，如：![[x+y]](https://math.jianshu.com/math?formula=%5Bx%2By%5D)\n3. 大括号，符号：`\\{ \\}`，如：![{x+y}](https://math.jianshu.com/math?formula=%7Bx%2By%7D)\n4. 自适应括号，符号：`\\left \\right`，如：`$\\left(x\\right)$`，![\\left(x\\right)](https://math.jianshu.com/math?formula=%5Cleft(x%5Cright))\n5. 组合公式，符号：`{上位公式 \\choose 下位公式}`，如：![{n+1 \\choose k}={n \\choose k}+{n \\choose k-1}](https://math.jianshu.com/math?formula=%7Bn%2B1%20%5Cchoose%20k%7D%3D%7Bn%20%5Cchoose%20k%7D%2B%7Bn%20%5Cchoose%20k-1%7D)\n6. 组合公式，符号：`{上位公式 \\atop 下位公式}`，如：![\\sum_{k_0,k_1,\\ldots>0 \\atop k_0+k_1+\\cdots=n}A_{k_0}A_{k_1}\\cdots](https://math.jianshu.com/math?formula=%5Csum_%7Bk_0%2Ck_1%2C%5Cldots%3E0%20%5Catop%20k_0%2Bk_1%2B%5Ccdots%3Dn%7DA_%7Bk_0%7DA_%7Bk_1%7D%5Ccdots)\n\n# 十三、四则运算\n\n1. 加法运算，符号：`+`，如：![x+y=z](https://math.jianshu.com/math?formula=x%2By%3Dz)\n2. 减法运算，符号：`-`，如：![x-y=z](https://math.jianshu.com/math?formula=x-y%3Dz)\n3. 加减运算，符号：`\\pm`，如：![x \\pm y=z](https://math.jianshu.com/math?formula=x%20%5Cpm%20y%3Dz)\n4. 减甲运算，符号：`\\mp`，如：![x \\mp y=z](https://math.jianshu.com/math?formula=x%20%5Cmp%20y%3Dz)\n5. 乘法运算，符号：`\\times`，如：![x \\times y=z](https://math.jianshu.com/math?formula=x%20%5Ctimes%20y%3Dz)\n6. 点乘运算，符号：`\\cdot`，如：![x \\cdot y=z](https://math.jianshu.com/math?formula=x%20%5Ccdot%20y%3Dz)\n7. 星乘运算，符号：`\\ast`，如：![x \\ast y=z](https://math.jianshu.com/math?formula=x%20%5Cast%20y%3Dz)\n8. 除法运算，符号：`\\div`，如：![x \\div y=z](https://math.jianshu.com/math?formula=x%20%5Cdiv%20y%3Dz)\n9. 斜法运算，符号：`/`，如：![x/y=z](https://math.jianshu.com/math?formula=x%2Fy%3Dz)\n10. 分式表示，符号：`\\frac{分子}{分母}`，如：![\\frac{x+y}{y+z}](https://math.jianshu.com/math?formula=%5Cfrac%7Bx%2By%7D%7By%2Bz%7D)\n11. 分式表示，符号：`{分子} \\voer {分母}`，如：![{x+y} \\over {y+z}](https://math.jianshu.com/math?formula=%7Bx%2By%7D%20%5Cover%20%7By%2Bz%7D)\n12. 绝对值表示，符号：`||`，如：![|x+y|](https://math.jianshu.com/math?formula=%7Cx%2By%7C)\n\n# 十四、高级运算\n\n1. 平均数运算，符号：`\\overline{算式}`，如：![\\overline{xyz}](https://math.jianshu.com/math?formula=%5Coverline%7Bxyz%7D)\n2. 开二次方运算，符号：`\\sqrt`，如：![\\sqrt x](https://math.jianshu.com/math?formula=%5Csqrt%20x)\n3. 开方运算，符号：`\\sqrt[开方数]{被开方数}`，如：![\\sqrt[3]{x+y}](https://math.jianshu.com/math?formula=%5Csqrt%5B3%5D%7Bx%2By%7D)\n4. 对数运算，符号：`\\log`，如：![\\log(x)](https://math.jianshu.com/math?formula=%5Clog(x))\n5. 极限运算，符号：`\\lim`，如：![\\lim^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}}](https://math.jianshu.com/math?formula=%5Clim%5E%7Bx%20%5Cto%20%5Cinfty%7D_%7By%20%5Cto%200%7D%7B%5Cfrac%7Bx%7D%7By%7D%7D)\n6. 极限运算，符号：`\\displaystyle \\lim`，如：![\\displaystyle \\lim^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}}](https://math.jianshu.com/math?formula=%5Cdisplaystyle%20%5Clim%5E%7Bx%20%5Cto%20%5Cinfty%7D_%7By%20%5Cto%200%7D%7B%5Cfrac%7Bx%7D%7By%7D%7D)\n7. 求和运算，符号：`\\sum`，如：![\\sum^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}}](https://math.jianshu.com/math?formula=%5Csum%5E%7Bx%20%5Cto%20%5Cinfty%7D_%7By%20%5Cto%200%7D%7B%5Cfrac%7Bx%7D%7By%7D%7D)\n8. 求和运算，符号：`\\displaystyle \\sum`，如：![\\displaystyle \\sum^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}}](https://math.jianshu.com/math?formula=%5Cdisplaystyle%20%5Csum%5E%7Bx%20%5Cto%20%5Cinfty%7D_%7By%20%5Cto%200%7D%7B%5Cfrac%7Bx%7D%7By%7D%7D)\n9. 积分运算，符号：`\\int`，如：![\\int^{\\infty}_{0}{xdx}](https://math.jianshu.com/math?formula=%5Cint%5E%7B%5Cinfty%7D_%7B0%7D%7Bxdx%7D)\n10. 积分运算，符号：`\\displaystyle \\int`，如：![\\displaystyle \\int^{\\infty}_{0}{xdx}](https://math.jianshu.com/math?formula=%5Cdisplaystyle%20%5Cint%5E%7B%5Cinfty%7D_%7B0%7D%7Bxdx%7D)\n11. 微分运算，符号：`\\partial`，如：![\\frac{\\partial x}{\\partial y}](https://math.jianshu.com/math?formula=%5Cfrac%7B%5Cpartial%20x%7D%7B%5Cpartial%20y%7D)\n12. 矩阵表示，符号：`\\begin{matrix} \\end{matrix}`，如：![\\left[ \\begin{matrix} 1 &2 &\\cdots &4\\5 &6 &\\cdots &8\\\\vdots &\\vdots &\\ddots &\\vdots\\13 &14 &\\cdots &16\\end{matrix} \\right]](https://math.jianshu.com/math?formula=%5Cleft%5B%20%5Cbegin%7Bmatrix%7D%201%20%262%20%26%5Ccdots%20%264%5C5%20%266%20%26%5Ccdots%20%268%5C%5Cvdots%20%26%5Cvdots%20%26%5Cddots%20%26%5Cvdots%5C13%20%2614%20%26%5Ccdots%20%2616%5Cend%7Bmatrix%7D%20%5Cright%5D)\n\n# 十五、 逻辑运算\n\n1. 等于运算，符号：`=`，如：![x+y=z](https://math.jianshu.com/math?formula=x%2By%3Dz)\n2. 大于运算，符号：`>`，如：![x+y>z](https://math.jianshu.com/math?formula=x%2By%3Ez)\n3. 小于运算，符号：`<`，如：![x+y<z](https://math.jianshu.com/math?formula=x%2By%3Cz)\n4. 大于等于运算，符号：`\\geq`，如：![x+y \\geq z](https://math.jianshu.com/math?formula=x%2By%20%5Cgeq%20z)\n5. 小于等于运算，符号：`\\leq`，如：![x+y \\leq z](https://math.jianshu.com/math?formula=x%2By%20%5Cleq%20z)\n6. 不等于运算，符号：`\\neq`，如：![x+y \\neq z](https://math.jianshu.com/math?formula=x%2By%20%5Cneq%20z)\n7. 不大于等于运算，符号：`\\ngeq`，如：![x+y \\ngeq z](https://math.jianshu.com/math?formula=x%2By%20%5Cngeq%20z)\n8. 不大于等于运算，符号：`\\not\\geq`，如：![x+y \\not\\geq z](https://math.jianshu.com/math?formula=x%2By%20%5Cnot%5Cgeq%20z)\n9. 不小于等于运算，符号：`\\nleq`，如：![x+y \\nleq z](https://math.jianshu.com/math?formula=x%2By%20%5Cnleq%20z)\n10. 不小于等于运算，符号：`\\not\\leq`，如：![x+y \\not\\leq z](https://math.jianshu.com/math?formula=x%2By%20%5Cnot%5Cleq%20z)\n11. 约等于运算，符号：`\\approx`，如：![x+y \\approx z](https://math.jianshu.com/math?formula=x%2By%20%5Capprox%20z)\n12. 恒定等于运算，符号：`\\equiv`，如：![x+y \\equiv z](https://math.jianshu.com/math?formula=x%2By%20%5Cequiv%20z)\n\n# 十六、集合运算\n\n1. 属于运算，符号：`\\in`，如：![x \\in y](https://math.jianshu.com/math?formula=x%20%5Cin%20y)\n2. 不属于运算，符号：`\\notin`，如：![x \\notin y](https://math.jianshu.com/math?formula=x%20%5Cnotin%20y)\n3. 不属于运算，符号：`\\not\\in`，如：![x \\not\\in y](https://math.jianshu.com/math?formula=x%20%5Cnot%5Cin%20y)\n4. 子集运算，符号：`\\subset`，如：![x \\subset y](https://math.jianshu.com/math?formula=x%20%5Csubset%20y)\n5. 子集运算，符号：`\\supset`，如：![x \\supset y](https://math.jianshu.com/math?formula=x%20%5Csupset%20y)\n6. 真子集运算，符号：`\\subseteq`，如：![x \\subseteq y](https://math.jianshu.com/math?formula=x%20%5Csubseteq%20y)\n7. 非真子集运算，符号：`\\subsetneq`，如：![x \\subsetneq y](https://math.jianshu.com/math?formula=x%20%5Csubsetneq%20y)\n8. 真子集运算，符号：`\\supseteq`，如：![x \\supseteq y](https://math.jianshu.com/math?formula=x%20%5Csupseteq%20y)\n9. 非真子集运算，符号：`\\supsetneq`，如：![x \\supsetneq y](https://math.jianshu.com/math?formula=x%20%5Csupsetneq%20y)\n10. 非子集运算，符号：`\\not\\subset`，如：![x \\not\\subset y](https://math.jianshu.com/math?formula=x%20%5Cnot%5Csubset%20y)\n11. 非子集运算，符号：`\\not\\supset`，如：![x \\not\\supset y](https://math.jianshu.com/math?formula=x%20%5Cnot%5Csupset%20y)\n12. 并集运算，符号：`\\cup`，如：![x \\cup y](https://math.jianshu.com/math?formula=x%20%5Ccup%20y)\n13. 交集运算，符号：`\\cap`，如：![x \\cap y](https://math.jianshu.com/math?formula=x%20%5Ccap%20y)\n14. 差集运算，符号：`\\setminus`，如：![x \\setminus y](https://math.jianshu.com/math?formula=x%20%5Csetminus%20y)\n15. 同或运算，符号：`\\bigodot`，如：![x \\bigodot y](https://math.jianshu.com/math?formula=x%20%5Cbigodot%20y)\n16. 同与运算，符号：`\\bigotimes`，如：![x \\bigotimes y](https://math.jianshu.com/math?formula=x%20%5Cbigotimes%20y)\n17. 实数集合，符号：`\\mathbb{R}`，如：`\\mathbb{R}`\n18. 自然数集合，符号：`\\mathbb{Z}`，如：`\\mathbb{Z}`\n19. 空集，符号：`\\emptyset`，如：![\\emptyset](https://math.jianshu.com/math?formula=%5Cemptyset)\n\n# 十七、数学符号\n\n1. 无穷，符号：`\\infty`，如：![\\infty](https://math.jianshu.com/math?formula=%5Cinfty)\n2. 虚数，符号：`\\imath`，如：![\\imath](https://math.jianshu.com/math?formula=%5Cimath)\n3. 虚数，符号：`\\jmath`，如：![\\jmath](https://math.jianshu.com/math?formula=%5Cjmath)\n4. 数学符号，符号`\\hat{a}`，如：![\\hat{a}](https://math.jianshu.com/math?formula=%5Chat%7Ba%7D)\n5. 数学符号，符号`\\check{a}`，如：![\\check{a}](https://math.jianshu.com/math?formula=%5Ccheck%7Ba%7D)\n6. 数学符号，符号`\\breve{a}`，如：![\\breve{a}](https://math.jianshu.com/math?formula=%5Cbreve%7Ba%7D)\n7. 数学符号，符号`\\tilde{a}`，如：![\\tilde{a}](https://math.jianshu.com/math?formula=%5Ctilde%7Ba%7D)\n8. 数学符号，符号`\\bar{a}`，如：![\\bar{a}](https://math.jianshu.com/math?formula=%5Cbar%7Ba%7D)\n9. 矢量符号，符号`\\vec{a}`，如：![\\vec{a}](https://math.jianshu.com/math?formula=%5Cvec%7Ba%7D)\n10. 数学符号，符号`\\acute{a}`，如：![\\acute{a}](https://math.jianshu.com/math?formula=%5Cacute%7Ba%7D)\n11. 数学符号，符号`\\grave{a}`，如：![\\grave{a}](https://math.jianshu.com/math?formula=%5Cgrave%7Ba%7D)\n12. 数学符号，符号`\\mathring{a}`，如：![\\mathring{a}](https://math.jianshu.com/math?formula=%5Cmathring%7Ba%7D)\n13. 一阶导数符号，符号`\\dot{a}`，如：![\\dot{a}](https://math.jianshu.com/math?formula=%5Cdot%7Ba%7D)\n14. 二阶导数符号，符号`\\ddot{a}`，如：![\\ddot{a}](https://math.jianshu.com/math?formula=%5Cddot%7Ba%7D)\n15. 上箭头，符号：`\\uparrow`，如：![\\uparrow](https://math.jianshu.com/math?formula=%5Cuparrow)\n16. 上箭头，符号：`\\Uparrow`，如：![\\Uparrow](https://math.jianshu.com/math?formula=%5CUparrow)\n17. 下箭头，符号：`\\downarrow`，如：![\\downarrow](https://math.jianshu.com/math?formula=%5Cdownarrow)\n18. 下箭头，符号：`\\Downarrow`，如：![\\Downarrow](https://math.jianshu.com/math?formula=%5CDownarrow)\n19. 左箭头，符号：`\\leftarrow`，如：![\\leftarrow](https://math.jianshu.com/math?formula=%5Cleftarrow)\n20. 左箭头，符号：`\\Leftarrow`，如：![\\Leftarrow](https://math.jianshu.com/math?formula=%5CLeftarrow)\n21. 右箭头，符号：`\\rightarrow`，如：![\\rightarrow](https://math.jianshu.com/math?formula=%5Crightarrow)\n22. 右箭头，符号：`\\Rightarrow`，如：![\\Rightarrow](https://math.jianshu.com/math?formula=%5CRightarrow)\n23. 底端对齐的省略号，符号：`\\ldots`，如：![1,2,\\ldots,n](https://math.jianshu.com/math?formula=1%2C2%2C%5Cldots%2Cn)\n24. 中线对齐的省略号，符号：`\\cdots`，如：![x_1^2 + x_2^2 + \\cdots + x_n^2](https://math.jianshu.com/math?formula=x_1%5E2%20%2B%20x_2%5E2%20%2B%20%5Ccdots%20%2B%20x_n%5E2)\n25. 竖直对齐的省略号，符号：`\\vdots`，如：![\\vdots](https://math.jianshu.com/math?formula=%5Cvdots)\n26. 斜对齐的省略号，符号：`\\ddots`，如：![\\ddots](https://math.jianshu.com/math?formula=%5Cddots)\n\n# 十八、矩阵\n\n使用`\\begin{matrix}…\\end{matrix}`这样的形式来表示矩阵，在`\\begin` 与`\\end`之间加入矩阵中的元素即可。矩阵的行之间使用`\\\\`分隔，列之间使用`&`分隔，例如:\n\n```ruby\n$$\n\\begin{matrix}\n1 & x & x^2 \\\\\n1 & y & y^2 \\\\\n1 & z & z^2 \\\\\n\\end{matrix}\n$$\n```\n\n得到：  \n![\\begin{matrix} 1 & x & x^2 \\\\ 1 & y & y^2 \\\\ 1 & z & z^2 \\\\ \\end{matrix}](https://math.jianshu.com/math?formula=%5Cbegin%7Bmatrix%7D%201%20%26%20x%20%26%20x%5E2%20%5C%5C%201%20%26%20y%20%26%20y%5E2%20%5C%5C%201%20%26%20z%20%26%20z%5E2%20%5C%5C%20%5Cend%7Bmatrix%7D)\n\n### 1. 括号\n\n如果要对矩阵加括号，可以像上文中提到的一样，使用`\\left`与`\\right` 配合表示括号符号。也可以使用特殊的matrix 。即替换`\\begin{matrix}…\\end{matrix} 中matrix 为pmatrix ，bmatrix ，Bmatrix ，vmatrix , Vmatrix` 。  \n`pmatrix$\\begin{pmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{pmatrix}$`:pmatrix![\\begin{pmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{pmatrix}](https://math.jianshu.com/math?formula=%5Cbegin%7Bpmatrix%7D1%20%26%202%20%5C%5C%203%20%26%204%5C%5C%20%5Cend%7Bpmatrix%7D)  \n`bmatrix$\\begin{bmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{bmatrix}$` :bmatrix![\\begin{bmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{bmatrix}](https://math.jianshu.com/math?formula=%5Cbegin%7Bbmatrix%7D1%20%26%202%20%5C%5C%203%20%26%204%5C%5C%20%5Cend%7Bbmatrix%7D)  \n`Bmatrix$\\begin{Bmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{Bmatrix}$` :Bmatrix![\\begin{Bmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{Bmatrix}](https://math.jianshu.com/math?formula=%5Cbegin%7BBmatrix%7D1%20%26%202%20%5C%5C%203%20%26%204%5C%5C%20%5Cend%7BBmatrix%7D)  \n`vmatrix$\\begin{vmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{vmatrix}$` :vmatrix![\\begin{vmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{vmatrix}](https://math.jianshu.com/math?formula=%5Cbegin%7Bvmatrix%7D1%20%26%202%20%5C%5C%203%20%26%204%5C%5C%20%5Cend%7Bvmatrix%7D)  \n`Vmatrix$\\begin{Vmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{Vmatrix}$` :Vmatrix![\\begin{Vmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{Vmatrix}](https://math.jianshu.com/math?formula=%5Cbegin%7BVmatrix%7D1%20%26%202%20%5C%5C%203%20%26%204%5C%5C%20%5Cend%7BVmatrix%7D)  \n元素省略:  \n可以使用\\cdots ：⋯，\\ddots：⋱ ，\\vdots：⋮ 来省略矩阵中的元素，如：\n\n```ruby\n$$\n\\begin{pmatrix}\n1&a_1&a_1^2&\\cdots&a_1^n\\\\\n1&a_2&a_2^2&\\cdots&a_2^n\\\\\n\\vdots&\\vdots&\\vdots&\\ddots&\\vdots\\\\\n1&a_m&a_m^2&\\cdots&a_m^n\\\\\n\\end{pmatrix}\n$$\n\n```\n\n表示：  \n![\\begin{pmatrix} 1&a_1&a_1^2&\\cdots&a_1^n\\\\ 1&a_2&a_2^2&\\cdots&a_2^n\\\\ \\vdots&\\vdots&\\vdots&\\ddots&\\vdots\\\\ 1&a_m&a_m^2&\\cdots&a_m^n\\\\ \\end{pmatrix}](https://math.jianshu.com/math?formula=%5Cbegin%7Bpmatrix%7D%201%26a_1%26a_1%5E2%26%5Ccdots%26a_1%5En%5C%5C%201%26a_2%26a_2%5E2%26%5Ccdots%26a_2%5En%5C%5C%20%5Cvdots%26%5Cvdots%26%5Cvdots%26%5Cddots%26%5Cvdots%5C%5C%201%26a_m%26a_m%5E2%26%5Ccdots%26a_m%5En%5C%5C%20%5Cend%7Bpmatrix%7D)\n\n### 2. 增广矩阵\n\n增广矩阵需要使用前面的表格中使用到的`\\begin{array} ... \\end{array}`来实现。\n\n```swift\n$$\n\\left[  \\begin{array}  {c c | c} %这里的c表示数组中元素对其方式：c居中、r右对齐、l左对齐，竖线表示2、3列间插入竖线\n1 & 2 & 3 \\\\\n\\hline %插入横线，如果去掉\\hline就是增广矩阵\n4 & 5 & 6\n\\end{array}  \\right]\n$$\n\n```\n\n显示为：  \n![\\left[ \\begin{array} {c c | c} 1 & 2 & 3 \\\\ \\hline 4 & 5 & 6 \\end{array} \\right]](https://math.jianshu.com/math?formula=%5Cleft%5B%20%5Cbegin%7Barray%7D%20%7Bc%20c%20%7C%20c%7D%201%20%26%202%20%26%203%20%5C%5C%20%5Chline%204%20%26%205%20%26%206%20%5Cend%7Barray%7D%20%5Cright%5D)\n\n# 二十、公式标记与引用\n\n使用`\\tag{yourtag}`来标记公式，如`$$a=x^2-y^3\\tag{1}$$`显示为：  \n![a=x^2-y^3\\tag{1}](https://math.jianshu.com/math?formula=a%3Dx%5E2-y%5E3%5Ctag%7B1%7D)\n\n# 二十一、字体\n\n### 1.黑板粗体字\n\n此字体经常用来表示代表实数、整数、有理数、复数的大写字母。  \n`$\\mathbb ABCDEF$`：![\\mathbb ABCDEF](https://math.jianshu.com/math?formula=%5Cmathbb%20ABCDEF)  \n`$\\Bbb ABCDEF$`：![\\Bbb ABCDEF](https://math.jianshu.com/math?formula=%5CBbb%20ABCDEF)\n\n### 3.黑体字\n\n`$\\mathbf ABCDEFGHIJKLMNOPQRSTUVWXYZ$`:![\\mathbf ABCDEFGHIJKLMNOPQRSTUVWXYZ](https://math.jianshu.com/math?formula=%5Cmathbf%20ABCDEFGHIJKLMNOPQRSTUVWXYZ)  \n`$\\mathbf abcdefghijklmnopqrstuvwxyz$`:![\\mathbf abcdefghijklmnopqrstuvwxyz](https://math.jianshu.com/math?formula=%5Cmathbf%20abcdefghijklmnopqrstuvwxyz)\n\n### 3.打印机字体\n\n`$\\mathtt ABCDEFGHIJKLMNOPQRSTUVWXYZ$`:![\\mathtt ABCDEFGHIJKLMNOPQRSTUVWXYZ](https://math.jianshu.com/math?formula=%5Cmathtt%20ABCDEFGHIJKLMNOPQRSTUVWXYZ)\n\n# 二十二、希腊字母\n\n| 字母  | 实现              | 字母  | 实现            |\n| --- | --------------- | --- | ------------- |\n| A   | `A`             | α   | `\\alhpa`      |\n| B   | `B`             | β   | `\\beta`       |\n| Γ   | `\\Gamma`        | γ   | `\\gamma`      |\n| Δ   | `\\Delta`        | δ   | `\\delta`      |\n| E   | `E`             | ϵ   | `\\epsilon`    |\n| Z   | `Z`             | ζ   | `\\zeta`       |\n| H   | `H`             | η   | `\\eta`        |\n| Θ   | `\\Theta`        | θ   | `\\theta`      |\n| I   | `I`             | ι   | `\\iota`       |\n| K   | `K`             | κ   | `\\kappa`      |\n| Λ   | `\\Lambda`       | λ   | `\\lambda`     |\n| M   | `M`             | μ   | `\\mu`         |\n| N   | `N`             | ν   | `\\nu`         |\n| Ξ   | `\\Xi`           | ξ   | `\\xi`         |\n| O   | `O`             | ο   | `\\omicron`    |\n| Π   | `\\Pi`           | π   | `\\pi`         |\n| P   | `P`             | ρ   | `\\rho`        |\n| Σ   | `\\Sigma`        | σ   | `\\sigma`      |\n| T   | `T`             | τ   | `\\tau`        |\n| Υ   | `\\Upsilon`      | υ   | `\\upsilon`    |\n| Φ   | `\\Phi`          | ϕ   | `\\phi`        |\n| X   | `X`             | χ   | `\\chi`        |\n| Ψ   | `\\Psi`          | ψ   | `\\psi`        |\n| Ω   | `\\v`            | ω   | `\\omega`      |\n| ε   | `$\\varepsilon$` | ϑ   | `$\\vartheta$` |\n| ϖ   | `$\\varpi$`      | ϱ   | `$\\varrho$`   |\n| ς   | `$\\varsigma$`   | φ   | `$\\varphi$`   |\n\n[https://blog.csdn.net/weixin_43159628/article/details/88237139](https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fweixin_43159628%2Farticle%2Fdetails%2F88237139)  \n[https://www.jianshu.com/p/08cbe54a5f33](https://www.jianshu.com/p/08cbe54a5f33)\n\n  \n  \n作者：无剑_君  \n链接：https://www.jianshu.com/p/383e8149136c  \n来源：简书  \n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","source":"_posts/工具教程/教程：MD 数学公式语法.md","raw":"[Markdown数学公式语法 - 简书 (jianshu.com)](https://www.jianshu.com/p/383e8149136c)\n\n# 一、简单分类\n\n### 1. 行内公式\n\n将公式插入到本行内，符号：`$公式内容$`，如：`$xyz$`  \n![xyz](https://math.jianshu.com/math?formula=xyz)\n\n### 2. 行间公式\n\n将公式插入到新的一行内，并且居中，符号：`$公式内容$`，如：`$$xyz$$`  \n![xyz](https://math.jianshu.com/math?formula=xyz)\n\n# 二、上标、下标与组合\n\n### 1. 上标符号，符号：`^`，如：`$x^4$` ![x^4](https://math.jianshu.com/math?formula=x%5E4)\n\n### 2. 下标符号，符号：`_`，如：`$x_1$` ![x_1](https://math.jianshu.com/math?formula=x_1)\n\n### 3. 组合符号，符号：`{}`，如：![<sup>{16}_{8}O</sup>{2+}_{2}](https://math.jianshu.com/math?formula=%3Csup%3E%7B16%7D_%7B8%7DO%3C%2Fsup%3E%7B2%2B%7D_%7B2%7D)\n\n默认情况下，上、下标符号仅仅对下一个组起作用。一个组即单个字符或者使用{}（大括号） 包裹起来的内容。如果使用`$10^10$`表示的是![10^10](https://math.jianshu.com/math?formula=10%5E10),而`$10^{10}$` 才可以表示为![10^{10}](https://math.jianshu.com/math?formula=10%5E%7B10%7D)。同时，大括号还能消除二义性，如：`$x^5^6$` 将得到一个错误，必须使用大括号来界定^的结合性，如:`${x^5}^6$`表示的![{x^5}^6](https://math.jianshu.com/math?formula=%7Bx%5E5%7D%5E6)：或者用`$x^{5^6}$`表示的![x^{5^6}](https://math.jianshu.com/math?formula=x%5E%7B5%5E6%7D)。\n\n# 三、括号\n\n### 1.小括号与方括号\n\n用原始的( ) ，[ ] 即可，如`(2+3)[4+4]`可表示：![(2+3)[4+4]](https://math.jianshu.com/math?formula=(2%2B3)%5B4%2B4%5D)。  \n使用\\left(或\\right)使符号大小与邻近的公式相适应（该语句适用于所有括号类型），如\\left(\\frac{x}{y}\\right)可表示![\\left(\\frac{x}{y}\\right)](https://math.jianshu.com/math?formula=%5Cleft(%5Cfrac%7Bx%7D%7By%7D%5Cright))\n\n### 2. 大括号\n\n由于大括号{} 被用于分组，因此需要使用{和}表示大括号，也可以使用\\lbrace 和\\rbrace来表示。如{ab}或\\lbrace ab\\rbrace表示:![\\{ab\\}](https://math.jianshu.com/math?formula=%5C%7Bab%5C%7D)\n\n### 3. 尖括号\n\n区分于小于号和大于号，使用\\langle 和\\rangle 表示左尖括号和右尖括号。如\\langle x \\rangle表示：![\\langle x \\rangle](https://math.jianshu.com/math?formula=%5Clangle%20x%20%5Crangle)\n\n# 三、取整\n\n### 1. 上取整\n\n使用\\lceil 和 \\rceil 表示。 如，\\lceil x \\rceil表示为：![\\lceil x \\rceil](https://math.jianshu.com/math?formula=%5Clceil%20x%20%5Crceil)\n\n### 2. 下取整\n\n使用\\lfloor 和 \\rfloor 表示。如，\\lfloor x \\rfloor表示为:![\\lfloor x \\rfloor](https://math.jianshu.com/math?formula=%5Clfloor%20x%20%5Crfloor)\n\n# 四、求和\\积分\\连乘\n\n### 1.求和\n\n`\\sum` 用来表示求和符号，其下标表示求和下限，上标表示上限。如:  \n`$\\sum_{r=1}^n$`表示：![\\sum_{r=1}^n](https://math.jianshu.com/math?formula=%5Csum_%7Br%3D1%7D%5En)\n\n### 2. 积分\n\n`\\int` 用来表示积分符号，同样地，其上下标表示积分的上下限。如，`$\\int_{r=1}^\\infty$`表示:![\\int_{r=1}^\\infty](https://math.jianshu.com/math?formula=%5Cint_%7Br%3D1%7D%5E%5Cinfty)  \n多重积分同样使用`\\int` ，通过 i 的数量表示积分导数：  \n如：  \n`$\\iint$` 表示为：![\\iint](https://math.jianshu.com/math?formula=%5Ciint)  \n`$\\iiint$` 表示为：![\\iiint](https://math.jianshu.com/math?formula=%5Ciiint)\n\n### 3. 连乘\n\n`$\\prod {a+b}$` 表示：![\\prod {a+b}](https://math.jianshu.com/math?formula=%5Cprod%20%7Ba%2Bb%7D)  \n`$\\prod_{i=1}^{K}$` 表示：![\\prod_{i=1}^{K}](https://math.jianshu.com/math?formula=%5Cprod_%7Bi%3D1%7D%5E%7BK%7D)  \n`$$\\prod_{i=1}^{K}$$`表示（注意是行间公式）：![\\prod_{i=1}^{K}](https://math.jianshu.com/math?formula=%5Cprod_%7Bi%3D1%7D%5E%7BK%7D)\n\n### 4. 其他\n\n与此类似的符号还有，  \n`$\\prod$` ：![\\prod](https://math.jianshu.com/math?formula=%5Cprod)  \n`$\\bigcup$`：![\\bigcup](https://math.jianshu.com/math?formula=%5Cbigcup)  \n`$\\bigcap$` ：![\\bigcap](https://math.jianshu.com/math?formula=%5Cbigcap)  \n`$arg\\,\\max_{c_k}$`：![arg\\,\\max_{c_k}](https://math.jianshu.com/math?formula=arg%5C%2C%5Cmax_%7Bc_k%7D)  \n`$arg\\,\\min_{c_k}$`：![arg,\\min_{c_k}](https://math.jianshu.com/math?formula=arg%2C%5Cmin_%7Bc_k%7D)  \n`$\\mathop {argmin}_{c_k}$`：![\\mathop {argmin}_{c_k}](https://math.jianshu.com/math?formula=%5Cmathop%20%7Bargmin%7D_%7Bc_k%7D)  \n`$\\mathop {argmax}_{c_k}$`：![\\mathop {argmax}_{c_k}](https://math.jianshu.com/math?formula=%5Cmathop%20%7Bargmax%7D_%7Bc_k%7D)  \n`$\\max_{c_k}$`：![\\max_{c_k}](https://math.jianshu.com/math?formula=%5Cmax_%7Bc_k%7D)  \n`$\\min_{c_k}$`：![\\min_{c_k}](https://math.jianshu.com/math?formula=%5Cmin_%7Bc_k%7D)\n\n# 五、分式与根式\n\n### 1. 分式\n\n第一种，使用`\\frac ab`，表示为:![\\frac ab](https://math.jianshu.com/math?formula=%5Cfrac%20ab) ，`\\frac`作用于其后的两个组a ，b ，结果为。如果你的分子或分母不是单个字符，请使用{…}来分组，比如`$\\frac {a+c+1}{b+c+2}$`表示:![\\frac {a+c+1}{b+c+2}](https://math.jianshu.com/math?formula=%5Cfrac%20%7Ba%2Bc%2B1%7D%7Bb%2Bc%2B2%7D)  \n第二种，使用\\over来分隔一个组的前后两部分，如`${a+1\\over b+1}$`：![{a+1\\over b+1}](https://math.jianshu.com/math?formula=%7Ba%2B1%5Cover%20b%2B1%7D)\n\n### 2. 连分数\n\n书写连分数表达式时，请使用`\\cfrac`代替`\\frac`或者`\\over`两者效果对比如下：  \n`\\frac` 表示如下：\n\n```ruby\n $$x=a_0 + \\frac {1^2}{a_1 + \\frac {2^2}{a_2 + \\frac {3^2}{a_3 + \\frac {4^2}{a_4 + ...}}}}$$\n```\n\n显示如下：  \n![x=a_0 + \\frac {1^2}{a_1 + \\frac {2^2}{a_2 + \\frac {3^2}{a_3 + \\frac {4^2}{a_4 + ...}}}}](https://math.jianshu.com/math?formula=x%3Da_0%20%2B%20%5Cfrac%20%7B1%5E2%7D%7Ba_1%20%2B%20%5Cfrac%20%7B2%5E2%7D%7Ba_2%20%2B%20%5Cfrac%20%7B3%5E2%7D%7Ba_3%20%2B%20%5Cfrac%20%7B4%5E2%7D%7Ba_4%20%2B%20...%7D%7D%7D%7D)  \n`\\cfrac`表示如下：\n\n```ruby\n$$x=a_0 + \\cfrac {1^2}{a_1 + \\cfrac {2^2}{a_2 + \\cfrac {3^2}{a_3 + \\cfrac {4^2}{a_4 + ...}}}}$$\n```\n\n显示如下：  \n![x=a_0 + \\cfrac {1^2}{a_1 + \\cfrac {2^2}{a_2 + \\cfrac {3^2}{a_3 + \\cfrac {4^2}{a_4 + ...}}}}](https://math.jianshu.com/math?formula=x%3Da_0%20%2B%20%5Ccfrac%20%7B1%5E2%7D%7Ba_1%20%2B%20%5Ccfrac%20%7B2%5E2%7D%7Ba_2%20%2B%20%5Ccfrac%20%7B3%5E2%7D%7Ba_3%20%2B%20%5Ccfrac%20%7B4%5E2%7D%7Ba_4%20%2B%20...%7D%7D%7D%7D)\n\n### 3.根式\n\n根式使用`\\sqrt` 来表示。  \n如开4次方：`$\\sqrt[4]{\\frac xy}$` 可表示：![\\sqrt[4]{\\frac xy}](https://math.jianshu.com/math?formula=%5Csqrt%5B4%5D%7B%5Cfrac%20xy%7D)  \n开平方：`$\\sqrt {a+b}$`可表示：![\\sqrt {a+b}](https://math.jianshu.com/math?formula=%5Csqrt%20%7Ba%2Bb%7D)\n\n# 六、多行表达式\n\n### 1. 分类表达式\n\n定义函数的时候经常需要分情况给出表达式，使用\\begin{cases}…\\end{cases} 。其中：  \n使用`\\\\` 来分类，  \n使用`&`指示需要对齐的位置，  \n使用`\\ +space`表示空格。  \n如：\n\n```ruby\n$$\nf(n)\n\\begin{cases}\n\\cfrac n2, &if\\ n\\ is\\ even\\\\\n3n + 1, &if\\  n\\ is\\ odd\n\\end{cases}\n$$\n```\n\n表示:  \n![f(n) \\begin{cases} \\cfrac n2, &if\\ n\\ is\\ even\\\\ 3n + 1, &if\\ n\\ is\\ odd \\end{cases}](https://math.jianshu.com/math?formula=f(n)%20%5Cbegin%7Bcases%7D%20%5Ccfrac%20n2%2C%20%26if%5C%20n%5C%20is%5C%20even%5C%5C%203n%20%2B%201%2C%20%26if%5C%20n%5C%20is%5C%20odd%20%5Cend%7Bcases%7D)  \n以及:\n\n```ruby\n$$\nL(Y,f(X)) =\n\\begin{cases}\n0, & \\text{Y = f(X)}  \\\\\n1, & \\text{Y $\\neq$ f(X)}\n\\end{cases}\n$$\n```\n\n表示:  \n![L(Y,f(X)) = \\begin{cases} 0, & \\text{Y = f(X)} \\\\ 1, & \\text{Y $\\neq$ f(X)} \\end{cases}](https://math.jianshu.com/math?formula=L(Y%2Cf(X))%20%3D%20%5Cbegin%7Bcases%7D%200%2C%20%26%20%5Ctext%7BY%20%3D%20f(X)%7D%20%5C%5C%201%2C%20%26%20%5Ctext%7BY%20%24%5Cneq%24%20f(X)%7D%20%5Cend%7Bcases%7D)\n\n如果想分类之间的垂直间隔变大，可以使用`\\\\[2ex]`代替`\\\\`来分隔不同的情况。`(3ex,4ex` 也可以用，`1ex`相当于原始距离）。如下所示：\n\n```ruby\n$$\nL(Y,f(X)) =\n\\begin{cases}\n0, & \\text{Y = f(X)} \\\\[5ex]\n1, & \\text{Y $\\neq$ f(X)}\n\\end{cases}\n$$\n```\n\n表示：  \n![L(Y,f(X)) = \\begin{cases} 0, & \\text{Y = f(X)} \\\\[5ex] 1, & \\text{Y $\\neq$ f(X)} \\end{cases}](https://math.jianshu.com/math?formula=L(Y%2Cf(X))%20%3D%20%5Cbegin%7Bcases%7D%200%2C%20%26%20%5Ctext%7BY%20%3D%20f(X)%7D%20%5C%5C%5B5ex%5D%201%2C%20%26%20%5Ctext%7BY%20%24%5Cneq%24%20f(X)%7D%20%5Cend%7Bcases%7D)\n\n### 2. 多行表达式\n\n有时候需要将一行公式分多行进行显示。\n\n```cpp\n$$\n\\begin{aligned}\n\\sqrt{37} & = \\sqrt{\\frac{73^2-1}{12^2}} \\\\\n & = \\sqrt{\\frac{73^2}{12^2}\\cdot\\frac{73^2-1}{73^2}} \\\\ \n & = \\sqrt{\\frac{73^2}{12^2}}\\sqrt{\\frac{73^2-1}{73^2}} \\\\\n & = \\frac{73}{12}\\sqrt{1 - \\frac{1}{73^2}} \\\\ \n & \\approx \\frac{73}{12}\\left(1 - \\frac{1}{2\\cdot73^2}\\right)\n\\end{aligned}\n$$\n```\n\n表示:  \n![\\begin{aligned} \\sqrt{37} & = \\sqrt{\\frac{73^2-1}{12^2}} \\\\ & = \\sqrt{\\frac{73^2}{12^2}\\cdot\\frac{73^2-1}{73^2}} \\\\ & = \\sqrt{\\frac{73^2}{12^2}}\\sqrt{\\frac{73^2-1}{73^2}} \\\\ & = \\frac{73}{12}\\sqrt{1 - \\frac{1}{73^2}} \\\\ & \\approx \\frac{73}{12}\\left(1 - \\frac{1}{2\\cdot73^2}\\right) \\end{aligned}](https://math.jianshu.com/math?formula=%5Cbegin%7Baligned%7D%20%5Csqrt%7B37%7D%20%26%20%3D%20%5Csqrt%7B%5Cfrac%7B73%5E2-1%7D%7B12%5E2%7D%7D%20%5C%5C%20%26%20%3D%20%5Csqrt%7B%5Cfrac%7B73%5E2%7D%7B12%5E2%7D%5Ccdot%5Cfrac%7B73%5E2-1%7D%7B73%5E2%7D%7D%20%5C%5C%20%26%20%3D%20%5Csqrt%7B%5Cfrac%7B73%5E2%7D%7B12%5E2%7D%7D%5Csqrt%7B%5Cfrac%7B73%5E2-1%7D%7B73%5E2%7D%7D%20%5C%5C%20%26%20%3D%20%5Cfrac%7B73%7D%7B12%7D%5Csqrt%7B1%20-%20%5Cfrac%7B1%7D%7B73%5E2%7D%7D%20%5C%5C%20%26%20%5Capprox%20%5Cfrac%7B73%7D%7B12%7D%5Cleft(1%20-%20%5Cfrac%7B1%7D%7B2%5Ccdot73%5E2%7D%5Cright)%20%5Cend%7Baligned%7D)\n\n```ruby\n$$\n\\begin{aligned}\na&=b+c-d \\\\\n&=e-f \\\\\n&=i \\\\\n\\end{aligned}\n$$\n```\n\n表示:  \n![\\begin{aligned} a&=b+c-d \\\\ &=e-f \\\\ &=i \\\\ \\end{aligned}](https://math.jianshu.com/math?formula=%5Cbegin%7Baligned%7D%20a%26%3Db%2Bc-d%20%5C%5C%20%26%3De-f%20%5C%5C%20%26%3Di%20%5C%5C%20%5Cend%7Baligned%7D)\n\n其中`begin{equation}` 表示开始方程，`end{equation}`表示方程结束；`begin{split}` 表示开始多行公式，`end{split}` 表示结束；公式中用`\\\\` 表示回车到下一行，`&` 表示对齐的位置。\n\n# 七、方程组\n\n使用\\begin{array}...\\end{array} 与\\left \\与\\right 配合表示方程组,如:\n\n```ruby\n$$\n\\left \\{ \n\\begin{array}{c}\na_1x+b_1y+c_1z=d_1 \\\\ \na_2x+b_2y+c_2z=d_2 \\\\ \na_3x+b_3y+c_3z=d_3\n\\end{array}\n\\right.\n$$\n```\n\n表示：  \n![\\left \\{ \\begin{array}{c} a_1x+b_1y+c_1z=d_1 \\\\ a_2x+b_2y+c_2z=d_2 \\\\ a_3x+b_3y+c_3z=d_3 \\end{array} \\right.](https://math.jianshu.com/math?formula=%5Cleft%20%5C%7B%20%5Cbegin%7Barray%7D%7Bc%7D%20a_1x%2Bb_1y%2Bc_1z%3Dd_1%20%5C%5C%20a_2x%2Bb_2y%2Bc_2z%3Dd_2%20%5C%5C%20a_3x%2Bb_3y%2Bc_3z%3Dd_3%20%5Cend%7Barray%7D%20%5Cright.)\n\n注意：通常MathJax通过内部策略自己管理公式内部的空间，因此`a…b` 与`a…….b`（.表示空格）都会显示为`ab`。可以通过在`ab`间加入`\\`,增加些许间隙，`\\;`增加较宽的间隙，`\\quad` 与`\\qquad` 会增加更大的间隙。\n\n# 八、特殊函数与符号\n\n### 1. 三角函数\n\n`$\\sin x$` : ![\\sin x](https://math.jianshu.com/math?formula=%5Csin%20x)  \n`$\\arctan x$` : ![\\arctan x](https://math.jianshu.com/math?formula=%5Carctan%20x)\n\n### 2.比较运算符\n\n小于`(\\lt )`：![(\\lt )](https://math.jianshu.com/math?formula=(%5Clt%20))  \n大于`(\\gt )`：![(\\gt](https://math.jianshu.com/math?formula=(%5Cgt)  \n小于等于`(\\le )`：![(\\le )](https://math.jianshu.com/math?formula=(%5Cle%20))  \n大于等于`(\\ge )`：![(\\ge )](https://math.jianshu.com/math?formula=(%5Cge%20))  \n不等于`(\\ne )` :![(\\ne )](https://math.jianshu.com/math?formula=(%5Cne%20))  \n可以在这些运算符前面加上`\\not` ，如`\\not\\lt` : ![\\not\\lt](https://math.jianshu.com/math?formula=%5Cnot%5Clt)\n\n### 3.集合关系与运算\n\n并集`(\\cup)`: ![(\\cup)](https://math.jianshu.com/math?formula=(%5Ccup))  \n交集`(\\cap)`: ![(\\cap)](https://math.jianshu.com/math?formula=(%5Ccap))  \n差集`(\\setminus)`:![(\\setminus)](https://math.jianshu.com/math?formula=(%5Csetminus))  \n子集`(\\subset)`: ![(\\subset)](https://math.jianshu.com/math?formula=(%5Csubset))  \n子集`(\\subseteq)`: ![(\\subseteq)](https://math.jianshu.com/math?formula=(%5Csubseteq))  \n非子集`(\\subsetneq)`: ![(\\subsetneq)](https://math.jianshu.com/math?formula=(%5Csubsetneq))  \n父集`(\\supset)`: ![(\\supset)](https://math.jianshu.com/math?formula=(%5Csupset))  \n属于`(\\in)`: ![(\\in)](https://math.jianshu.com/math?formula=(%5Cin))  \n不属于`(\\notin)`:![`(\\notin)](https://math.jianshu.com/math?formula=%60(%5Cnotin))  \n空集`(\\emptyset)`: ![(\\emptyset)](https://math.jianshu.com/math?formula=(%5Cemptyset))  \n空`(\\varnothing)`: ![(\\varnothing)](https://math.jianshu.com/math?formula=(%5Cvarnothing))\n\n### 4. 排列\n\n`\\binom{n+1}{2k}` : ![\\binom{n+1}{2k}](https://math.jianshu.com/math?formula=%5Cbinom%7Bn%2B1%7D%7B2k%7D)  \n`{n+1 \\choose 2k}` : ![{n+1 \\choose 2k}](https://math.jianshu.com/math?formula=%7Bn%2B1%20%5Cchoose%202k%7D)\n\n### 5. 箭头\n\n`(\\to)`:![(\\to)](https://math.jianshu.com/math?formula=(%5Cto))  \n`(\\rightarrow)`: ![(\\rightarrow)](https://math.jianshu.com/math?formula=(%5Crightarrow))  \n`(\\leftarrow)`: ![(\\leftarrow)](https://math.jianshu.com/math?formula=(%5Cleftarrow))  \n`(\\Rightarrow)`:![`(\\Rightarrow)](https://math.jianshu.com/math?formula=%60(%5CRightarrow))  \n`(\\Leftarrow)`: ![(\\Leftarrow)](https://math.jianshu.com/math?formula=(%5CLeftarrow))  \n`(\\mapsto)`: ![\\mapsto)](https://math.jianshu.com/math?formula=%5Cmapsto))\n\n### 6. 逻辑运算符\n\n`(\\land)`: ![(\\land)](https://math.jianshu.com/math?formula=(%5Cland))  \n`(\\lor)`: ![(\\lor)](https://math.jianshu.com/math?formula=(%5Clor))  \n`(\\lnot)`: ![(\\lnot)](https://math.jianshu.com/math?formula=(%5Clnot))  \n`(\\forall)`: ![(\\forall)](https://math.jianshu.com/math?formula=(%5Cforall))  \n`(\\exists)`: ![(\\exists)](https://math.jianshu.com/math?formula=(%5Cexists))  \n`(\\top)`: ![(\\top)](https://math.jianshu.com/math?formula=(%5Ctop))  \n`(\\bot)`: ![(\\bot)](https://math.jianshu.com/math?formula=(%5Cbot))  \n`(\\vdash)`: ![(\\vdash)](https://math.jianshu.com/math?formula=(%5Cvdash))  \n`(\\vDash)`:![(\\vDash)](https://math.jianshu.com/math?formula=(%5CvDash))\n\n### 7.操作符\n\n`(\\star)`: ![`(\\star)](https://math.jianshu.com/math?formula=%60(%5Cstar))  \n`(\\ast)`: ![(\\ast)](https://math.jianshu.com/math?formula=(%5Cast))  \n`(\\oplus)`: ![(\\oplus)](https://math.jianshu.com/math?formula=(%5Coplus))  \n`(\\circ)`: ![(\\circ)](https://math.jianshu.com/math?formula=(%5Ccirc))  \n`(\\bullet)`: ![(\\bullet)](https://math.jianshu.com/math?formula=(%5Cbullet))\n\n### 8.等于\n\n`(\\approx)`:![(\\approx)](https://math.jianshu.com/math?formula=(%5Capprox))  \n`(\\sim)`: ![(\\sim)](https://math.jianshu.com/math?formula=(%5Csim))  \n`(\\equiv)`: ![(\\equiv)](https://math.jianshu.com/math?formula=(%5Cequiv))  \n`(\\prec)`: ![(\\prec)](https://math.jianshu.com/math?formula=(%5Cprec))\n\n### 9.范围\n\n`(\\infty)`:![(\\infty)](https://math.jianshu.com/math?formula=(%5Cinfty))  \n`(\\aleph_o)`:![(\\aleph_o)](https://math.jianshu.com/math?formula=(%5Caleph_o))  \n`(\\nabla)`: ![(\\nabla)](https://math.jianshu.com/math?formula=(%5Cnabla))  \n`(\\Im)`: ![(\\Im)](https://math.jianshu.com/math?formula=(%5CIm))  \n`(\\Re)`: ![(\\Re)](https://math.jianshu.com/math?formula=(%5CRe))\n\n### 10. 模运算\n\n`(\\pmod)`: ![`(\\pmod)](https://math.jianshu.com/math?formula=%60(%5Cpmod))  \n如a \\equiv b \\pmod n 表示为: ![a \\equiv b \\pmod n](https://math.jianshu.com/math?formula=a%20%5Cequiv%20b%20%5Cpmod%20n)\n\n### 11. 点\n\n`(\\ldots)`: ![(\\ldots)](https://math.jianshu.com/math?formula=(%5Cldots))  \n`(\\cdots)`: ![(\\cdots)](https://math.jianshu.com/math?formula=(%5Ccdots))  \n`(\\cdot)`: ![(\\cdot)](https://math.jianshu.com/math?formula=(%5Ccdot))  \n其区别是点的位置不同，`\\ldots` 位置稍低，`\\cdots` 位置居中。\n\n```ruby\n$$\n\\begin{cases}\na_1+a_2+\\ldots+a_n \\\\ \na_1+a_2+\\cdots+a_n \\\\\n\\end{cases}\n$$\n```\n\n表示(注意两部分点的位置)：  \n![\\begin{cases} a_1+a_2+\\ldots+a_n \\\\ a_1+a_2+\\cdots+a_n \\\\ \\end{cases}](https://math.jianshu.com/math?formula=%5Cbegin%7Bcases%7D%20a_1%2Ba_2%2B%5Cldots%2Ba_n%20%5C%5C%20a_1%2Ba_2%2B%5Ccdots%2Ba_n%20%5C%5C%20%5Cend%7Bcases%7D)\n\n### 12.顶部符号\n\n对于单字符，`\\hat x`：![\\hat x](https://math.jianshu.com/math?formula=%5Chat%20x)  \n多字符可以使用`\\widehat {xy}`：![\\widehat {xy}](https://math.jianshu.com/math?formula=%5Cwidehat%20%7Bxy%7D)  \n类似的还有`\\overline x`: ![\\overline x](https://math.jianshu.com/math?formula=%5Coverline%20x)  \n矢量`\\vec x`:![\\vec x](https://math.jianshu.com/math?formula=%5Cvec%20x)  \n向量`\\overrightarrow {xy}`: ![\\overrightarrow {xy}](https://math.jianshu.com/math?formula=%5Coverrightarrow%20%7Bxy%7D)  \n`\\dot x` : ![\\dot x](https://math.jianshu.com/math?formula=%5Cdot%20x)  \n`\\ddot x`: ![\\ddot x](https://math.jianshu.com/math?formula=%5Cddot%20x)  \n`\\dot {\\dot x}`: ![\\dot {\\dot x}](https://math.jianshu.com/math?formula=%5Cdot%20%7B%5Cdot%20x%7D)\n\n# 九、表格\n\n使用`\\begin{array}{列样式}…\\end{array}`这样的形式来创建表格，列样式可以是`clr` 表示居中，左，右对齐，还可以使用`|`表示一条竖线。表格中各行使用\\ 分隔，各列使用& 分隔。使用`\\hline` 在本行前加入一条直线。 例如:\n\n```ruby\n$$\n\\begin{array}{c|lcr}\nn & \\text{Left} & \\text{Center} & \\text{Right} \\\\\n\\hline\n1 & 0.24 & 1 & 125 \\\\\n2 & -1 & 189 & -8 \\\\\n3 & -20 & 2000 & 1+10i \\\\\n\\end{array}\n$$\n```\n\n得到：  \n![\\begin{array}{c|lcr} n & \\text{Left} & \\text{Center} & \\text{Right} \\\\ \\hline 1 & 0.24 & 1 & 125 \\\\ 2 & -1 & 189 & -8 \\\\ 3 & -20 & 2000 & 1+10i \\\\ \\end{array}](https://math.jianshu.com/math?formula=%5Cbegin%7Barray%7D%7Bc%7Clcr%7D%20n%20%26%20%5Ctext%7BLeft%7D%20%26%20%5Ctext%7BCenter%7D%20%26%20%5Ctext%7BRight%7D%20%5C%5C%20%5Chline%201%20%26%200.24%20%26%201%20%26%20125%20%5C%5C%202%20%26%20-1%20%26%20189%20%26%20-8%20%5C%5C%203%20%26%20-20%20%26%202000%20%26%201%2B10i%20%5C%5C%20%5Cend%7Barray%7D)\n\n# 十、汉字、字体与格式\n\n1. 汉字形式，符号：`\\mbox{}`，如：![V_{\\mbox{初始}}](https://math.jianshu.com/math?formula=V_%7B%5Cmbox%7B%E5%88%9D%E5%A7%8B%7D%7D)\n2. 字体控制，符号：`\\displaystyle`，如：![\\displaystyle \\frac{x+y}{y+z}](https://math.jianshu.com/math?formula=%5Cdisplaystyle%20%5Cfrac%7Bx%2By%7D%7By%2Bz%7D)\n3. 下划线符号，符号：`\\underline`，如：![\\underline{x+y}](https://math.jianshu.com/math?formula=%5Cunderline%7Bx%2By%7D)\n4. 标签，符号`\\tag{数字}`，如：![\\tag{11}](https://math.jianshu.com/math?formula=%5Ctag%7B11%7D)\n5. 上大括号，符号：`\\overbrace{算式}`，如：![\\overbrace{a+b+c+d}^{2.0}](https://math.jianshu.com/math?formula=%5Coverbrace%7Ba%2Bb%2Bc%2Bd%7D%5E%7B2.0%7D)\n6. 下大括号，符号：`\\underbrace{算式}`，如：![a+\\underbrace{b+c}_{1.0}+d](https://math.jianshu.com/math?formula=a%2B%5Cunderbrace%7Bb%2Bc%7D_%7B1.0%7D%2Bd)\n7. 上位符号，符号：`\\stacrel{上位符号}{基位符号}`，如：![\\vec{x}\\stackrel{\\mathrm{def}}{=}{x_1,\\dots,x_n}](https://math.jianshu.com/math?formula=%5Cvec%7Bx%7D%5Cstackrel%7B%5Cmathrm%7Bdef%7D%7D%7B%3D%7D%7Bx_1%2C%5Cdots%2Cx_n%7D)\n\n# 十一、占位符\n\n1. 两个quad空格，符号：`\\qquad`，如：![x \\qquad y](https://math.jianshu.com/math?formula=x%20%5Cqquad%20y)\n2. quad空格，符号：`\\quad`，如：![x \\quad y](https://math.jianshu.com/math?formula=x%20%5Cquad%20y)\n3. 大空格，符号`\\`，如：![x \\ y](https://math.jianshu.com/math?formula=x%20%5C%20y)\n4. 中空格，符号`\\:`，如：![x : y](https://math.jianshu.com/math?formula=x%20%3A%20y)\n5. 小空格，符号`\\,`，如：![x , y](https://math.jianshu.com/math?formula=x%20%2C%20y)\n6. 没有空格，符号``，如：![xy](https://math.jianshu.com/math?formula=xy)\n7. 紧贴，符号`\\!`，如：![x ! y](https://math.jianshu.com/math?formula=x%20!%20y)\n\n# 十二、定界符与组合\n\n1. 括号，符号：`（）\\big(\\big) \\Big(\\Big) \\bigg(\\bigg) \\Bigg(\\Bigg)`，如：![（）\\big(\\big) \\Big(\\Big) \\bigg(\\bigg) \\Bigg(\\Bigg)](https://math.jianshu.com/math?formula=%EF%BC%88%EF%BC%89%5Cbig(%5Cbig)%20%5CBig(%5CBig)%20%5Cbigg(%5Cbigg)%20%5CBigg(%5CBigg))\n2. 中括号，符号：`[]`，如：![[x+y]](https://math.jianshu.com/math?formula=%5Bx%2By%5D)\n3. 大括号，符号：`\\{ \\}`，如：![{x+y}](https://math.jianshu.com/math?formula=%7Bx%2By%7D)\n4. 自适应括号，符号：`\\left \\right`，如：`$\\left(x\\right)$`，![\\left(x\\right)](https://math.jianshu.com/math?formula=%5Cleft(x%5Cright))\n5. 组合公式，符号：`{上位公式 \\choose 下位公式}`，如：![{n+1 \\choose k}={n \\choose k}+{n \\choose k-1}](https://math.jianshu.com/math?formula=%7Bn%2B1%20%5Cchoose%20k%7D%3D%7Bn%20%5Cchoose%20k%7D%2B%7Bn%20%5Cchoose%20k-1%7D)\n6. 组合公式，符号：`{上位公式 \\atop 下位公式}`，如：![\\sum_{k_0,k_1,\\ldots>0 \\atop k_0+k_1+\\cdots=n}A_{k_0}A_{k_1}\\cdots](https://math.jianshu.com/math?formula=%5Csum_%7Bk_0%2Ck_1%2C%5Cldots%3E0%20%5Catop%20k_0%2Bk_1%2B%5Ccdots%3Dn%7DA_%7Bk_0%7DA_%7Bk_1%7D%5Ccdots)\n\n# 十三、四则运算\n\n1. 加法运算，符号：`+`，如：![x+y=z](https://math.jianshu.com/math?formula=x%2By%3Dz)\n2. 减法运算，符号：`-`，如：![x-y=z](https://math.jianshu.com/math?formula=x-y%3Dz)\n3. 加减运算，符号：`\\pm`，如：![x \\pm y=z](https://math.jianshu.com/math?formula=x%20%5Cpm%20y%3Dz)\n4. 减甲运算，符号：`\\mp`，如：![x \\mp y=z](https://math.jianshu.com/math?formula=x%20%5Cmp%20y%3Dz)\n5. 乘法运算，符号：`\\times`，如：![x \\times y=z](https://math.jianshu.com/math?formula=x%20%5Ctimes%20y%3Dz)\n6. 点乘运算，符号：`\\cdot`，如：![x \\cdot y=z](https://math.jianshu.com/math?formula=x%20%5Ccdot%20y%3Dz)\n7. 星乘运算，符号：`\\ast`，如：![x \\ast y=z](https://math.jianshu.com/math?formula=x%20%5Cast%20y%3Dz)\n8. 除法运算，符号：`\\div`，如：![x \\div y=z](https://math.jianshu.com/math?formula=x%20%5Cdiv%20y%3Dz)\n9. 斜法运算，符号：`/`，如：![x/y=z](https://math.jianshu.com/math?formula=x%2Fy%3Dz)\n10. 分式表示，符号：`\\frac{分子}{分母}`，如：![\\frac{x+y}{y+z}](https://math.jianshu.com/math?formula=%5Cfrac%7Bx%2By%7D%7By%2Bz%7D)\n11. 分式表示，符号：`{分子} \\voer {分母}`，如：![{x+y} \\over {y+z}](https://math.jianshu.com/math?formula=%7Bx%2By%7D%20%5Cover%20%7By%2Bz%7D)\n12. 绝对值表示，符号：`||`，如：![|x+y|](https://math.jianshu.com/math?formula=%7Cx%2By%7C)\n\n# 十四、高级运算\n\n1. 平均数运算，符号：`\\overline{算式}`，如：![\\overline{xyz}](https://math.jianshu.com/math?formula=%5Coverline%7Bxyz%7D)\n2. 开二次方运算，符号：`\\sqrt`，如：![\\sqrt x](https://math.jianshu.com/math?formula=%5Csqrt%20x)\n3. 开方运算，符号：`\\sqrt[开方数]{被开方数}`，如：![\\sqrt[3]{x+y}](https://math.jianshu.com/math?formula=%5Csqrt%5B3%5D%7Bx%2By%7D)\n4. 对数运算，符号：`\\log`，如：![\\log(x)](https://math.jianshu.com/math?formula=%5Clog(x))\n5. 极限运算，符号：`\\lim`，如：![\\lim^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}}](https://math.jianshu.com/math?formula=%5Clim%5E%7Bx%20%5Cto%20%5Cinfty%7D_%7By%20%5Cto%200%7D%7B%5Cfrac%7Bx%7D%7By%7D%7D)\n6. 极限运算，符号：`\\displaystyle \\lim`，如：![\\displaystyle \\lim^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}}](https://math.jianshu.com/math?formula=%5Cdisplaystyle%20%5Clim%5E%7Bx%20%5Cto%20%5Cinfty%7D_%7By%20%5Cto%200%7D%7B%5Cfrac%7Bx%7D%7By%7D%7D)\n7. 求和运算，符号：`\\sum`，如：![\\sum^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}}](https://math.jianshu.com/math?formula=%5Csum%5E%7Bx%20%5Cto%20%5Cinfty%7D_%7By%20%5Cto%200%7D%7B%5Cfrac%7Bx%7D%7By%7D%7D)\n8. 求和运算，符号：`\\displaystyle \\sum`，如：![\\displaystyle \\sum^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}}](https://math.jianshu.com/math?formula=%5Cdisplaystyle%20%5Csum%5E%7Bx%20%5Cto%20%5Cinfty%7D_%7By%20%5Cto%200%7D%7B%5Cfrac%7Bx%7D%7By%7D%7D)\n9. 积分运算，符号：`\\int`，如：![\\int^{\\infty}_{0}{xdx}](https://math.jianshu.com/math?formula=%5Cint%5E%7B%5Cinfty%7D_%7B0%7D%7Bxdx%7D)\n10. 积分运算，符号：`\\displaystyle \\int`，如：![\\displaystyle \\int^{\\infty}_{0}{xdx}](https://math.jianshu.com/math?formula=%5Cdisplaystyle%20%5Cint%5E%7B%5Cinfty%7D_%7B0%7D%7Bxdx%7D)\n11. 微分运算，符号：`\\partial`，如：![\\frac{\\partial x}{\\partial y}](https://math.jianshu.com/math?formula=%5Cfrac%7B%5Cpartial%20x%7D%7B%5Cpartial%20y%7D)\n12. 矩阵表示，符号：`\\begin{matrix} \\end{matrix}`，如：![\\left[ \\begin{matrix} 1 &2 &\\cdots &4\\5 &6 &\\cdots &8\\\\vdots &\\vdots &\\ddots &\\vdots\\13 &14 &\\cdots &16\\end{matrix} \\right]](https://math.jianshu.com/math?formula=%5Cleft%5B%20%5Cbegin%7Bmatrix%7D%201%20%262%20%26%5Ccdots%20%264%5C5%20%266%20%26%5Ccdots%20%268%5C%5Cvdots%20%26%5Cvdots%20%26%5Cddots%20%26%5Cvdots%5C13%20%2614%20%26%5Ccdots%20%2616%5Cend%7Bmatrix%7D%20%5Cright%5D)\n\n# 十五、 逻辑运算\n\n1. 等于运算，符号：`=`，如：![x+y=z](https://math.jianshu.com/math?formula=x%2By%3Dz)\n2. 大于运算，符号：`>`，如：![x+y>z](https://math.jianshu.com/math?formula=x%2By%3Ez)\n3. 小于运算，符号：`<`，如：![x+y<z](https://math.jianshu.com/math?formula=x%2By%3Cz)\n4. 大于等于运算，符号：`\\geq`，如：![x+y \\geq z](https://math.jianshu.com/math?formula=x%2By%20%5Cgeq%20z)\n5. 小于等于运算，符号：`\\leq`，如：![x+y \\leq z](https://math.jianshu.com/math?formula=x%2By%20%5Cleq%20z)\n6. 不等于运算，符号：`\\neq`，如：![x+y \\neq z](https://math.jianshu.com/math?formula=x%2By%20%5Cneq%20z)\n7. 不大于等于运算，符号：`\\ngeq`，如：![x+y \\ngeq z](https://math.jianshu.com/math?formula=x%2By%20%5Cngeq%20z)\n8. 不大于等于运算，符号：`\\not\\geq`，如：![x+y \\not\\geq z](https://math.jianshu.com/math?formula=x%2By%20%5Cnot%5Cgeq%20z)\n9. 不小于等于运算，符号：`\\nleq`，如：![x+y \\nleq z](https://math.jianshu.com/math?formula=x%2By%20%5Cnleq%20z)\n10. 不小于等于运算，符号：`\\not\\leq`，如：![x+y \\not\\leq z](https://math.jianshu.com/math?formula=x%2By%20%5Cnot%5Cleq%20z)\n11. 约等于运算，符号：`\\approx`，如：![x+y \\approx z](https://math.jianshu.com/math?formula=x%2By%20%5Capprox%20z)\n12. 恒定等于运算，符号：`\\equiv`，如：![x+y \\equiv z](https://math.jianshu.com/math?formula=x%2By%20%5Cequiv%20z)\n\n# 十六、集合运算\n\n1. 属于运算，符号：`\\in`，如：![x \\in y](https://math.jianshu.com/math?formula=x%20%5Cin%20y)\n2. 不属于运算，符号：`\\notin`，如：![x \\notin y](https://math.jianshu.com/math?formula=x%20%5Cnotin%20y)\n3. 不属于运算，符号：`\\not\\in`，如：![x \\not\\in y](https://math.jianshu.com/math?formula=x%20%5Cnot%5Cin%20y)\n4. 子集运算，符号：`\\subset`，如：![x \\subset y](https://math.jianshu.com/math?formula=x%20%5Csubset%20y)\n5. 子集运算，符号：`\\supset`，如：![x \\supset y](https://math.jianshu.com/math?formula=x%20%5Csupset%20y)\n6. 真子集运算，符号：`\\subseteq`，如：![x \\subseteq y](https://math.jianshu.com/math?formula=x%20%5Csubseteq%20y)\n7. 非真子集运算，符号：`\\subsetneq`，如：![x \\subsetneq y](https://math.jianshu.com/math?formula=x%20%5Csubsetneq%20y)\n8. 真子集运算，符号：`\\supseteq`，如：![x \\supseteq y](https://math.jianshu.com/math?formula=x%20%5Csupseteq%20y)\n9. 非真子集运算，符号：`\\supsetneq`，如：![x \\supsetneq y](https://math.jianshu.com/math?formula=x%20%5Csupsetneq%20y)\n10. 非子集运算，符号：`\\not\\subset`，如：![x \\not\\subset y](https://math.jianshu.com/math?formula=x%20%5Cnot%5Csubset%20y)\n11. 非子集运算，符号：`\\not\\supset`，如：![x \\not\\supset y](https://math.jianshu.com/math?formula=x%20%5Cnot%5Csupset%20y)\n12. 并集运算，符号：`\\cup`，如：![x \\cup y](https://math.jianshu.com/math?formula=x%20%5Ccup%20y)\n13. 交集运算，符号：`\\cap`，如：![x \\cap y](https://math.jianshu.com/math?formula=x%20%5Ccap%20y)\n14. 差集运算，符号：`\\setminus`，如：![x \\setminus y](https://math.jianshu.com/math?formula=x%20%5Csetminus%20y)\n15. 同或运算，符号：`\\bigodot`，如：![x \\bigodot y](https://math.jianshu.com/math?formula=x%20%5Cbigodot%20y)\n16. 同与运算，符号：`\\bigotimes`，如：![x \\bigotimes y](https://math.jianshu.com/math?formula=x%20%5Cbigotimes%20y)\n17. 实数集合，符号：`\\mathbb{R}`，如：`\\mathbb{R}`\n18. 自然数集合，符号：`\\mathbb{Z}`，如：`\\mathbb{Z}`\n19. 空集，符号：`\\emptyset`，如：![\\emptyset](https://math.jianshu.com/math?formula=%5Cemptyset)\n\n# 十七、数学符号\n\n1. 无穷，符号：`\\infty`，如：![\\infty](https://math.jianshu.com/math?formula=%5Cinfty)\n2. 虚数，符号：`\\imath`，如：![\\imath](https://math.jianshu.com/math?formula=%5Cimath)\n3. 虚数，符号：`\\jmath`，如：![\\jmath](https://math.jianshu.com/math?formula=%5Cjmath)\n4. 数学符号，符号`\\hat{a}`，如：![\\hat{a}](https://math.jianshu.com/math?formula=%5Chat%7Ba%7D)\n5. 数学符号，符号`\\check{a}`，如：![\\check{a}](https://math.jianshu.com/math?formula=%5Ccheck%7Ba%7D)\n6. 数学符号，符号`\\breve{a}`，如：![\\breve{a}](https://math.jianshu.com/math?formula=%5Cbreve%7Ba%7D)\n7. 数学符号，符号`\\tilde{a}`，如：![\\tilde{a}](https://math.jianshu.com/math?formula=%5Ctilde%7Ba%7D)\n8. 数学符号，符号`\\bar{a}`，如：![\\bar{a}](https://math.jianshu.com/math?formula=%5Cbar%7Ba%7D)\n9. 矢量符号，符号`\\vec{a}`，如：![\\vec{a}](https://math.jianshu.com/math?formula=%5Cvec%7Ba%7D)\n10. 数学符号，符号`\\acute{a}`，如：![\\acute{a}](https://math.jianshu.com/math?formula=%5Cacute%7Ba%7D)\n11. 数学符号，符号`\\grave{a}`，如：![\\grave{a}](https://math.jianshu.com/math?formula=%5Cgrave%7Ba%7D)\n12. 数学符号，符号`\\mathring{a}`，如：![\\mathring{a}](https://math.jianshu.com/math?formula=%5Cmathring%7Ba%7D)\n13. 一阶导数符号，符号`\\dot{a}`，如：![\\dot{a}](https://math.jianshu.com/math?formula=%5Cdot%7Ba%7D)\n14. 二阶导数符号，符号`\\ddot{a}`，如：![\\ddot{a}](https://math.jianshu.com/math?formula=%5Cddot%7Ba%7D)\n15. 上箭头，符号：`\\uparrow`，如：![\\uparrow](https://math.jianshu.com/math?formula=%5Cuparrow)\n16. 上箭头，符号：`\\Uparrow`，如：![\\Uparrow](https://math.jianshu.com/math?formula=%5CUparrow)\n17. 下箭头，符号：`\\downarrow`，如：![\\downarrow](https://math.jianshu.com/math?formula=%5Cdownarrow)\n18. 下箭头，符号：`\\Downarrow`，如：![\\Downarrow](https://math.jianshu.com/math?formula=%5CDownarrow)\n19. 左箭头，符号：`\\leftarrow`，如：![\\leftarrow](https://math.jianshu.com/math?formula=%5Cleftarrow)\n20. 左箭头，符号：`\\Leftarrow`，如：![\\Leftarrow](https://math.jianshu.com/math?formula=%5CLeftarrow)\n21. 右箭头，符号：`\\rightarrow`，如：![\\rightarrow](https://math.jianshu.com/math?formula=%5Crightarrow)\n22. 右箭头，符号：`\\Rightarrow`，如：![\\Rightarrow](https://math.jianshu.com/math?formula=%5CRightarrow)\n23. 底端对齐的省略号，符号：`\\ldots`，如：![1,2,\\ldots,n](https://math.jianshu.com/math?formula=1%2C2%2C%5Cldots%2Cn)\n24. 中线对齐的省略号，符号：`\\cdots`，如：![x_1^2 + x_2^2 + \\cdots + x_n^2](https://math.jianshu.com/math?formula=x_1%5E2%20%2B%20x_2%5E2%20%2B%20%5Ccdots%20%2B%20x_n%5E2)\n25. 竖直对齐的省略号，符号：`\\vdots`，如：![\\vdots](https://math.jianshu.com/math?formula=%5Cvdots)\n26. 斜对齐的省略号，符号：`\\ddots`，如：![\\ddots](https://math.jianshu.com/math?formula=%5Cddots)\n\n# 十八、矩阵\n\n使用`\\begin{matrix}…\\end{matrix}`这样的形式来表示矩阵，在`\\begin` 与`\\end`之间加入矩阵中的元素即可。矩阵的行之间使用`\\\\`分隔，列之间使用`&`分隔，例如:\n\n```ruby\n$$\n\\begin{matrix}\n1 & x & x^2 \\\\\n1 & y & y^2 \\\\\n1 & z & z^2 \\\\\n\\end{matrix}\n$$\n```\n\n得到：  \n![\\begin{matrix} 1 & x & x^2 \\\\ 1 & y & y^2 \\\\ 1 & z & z^2 \\\\ \\end{matrix}](https://math.jianshu.com/math?formula=%5Cbegin%7Bmatrix%7D%201%20%26%20x%20%26%20x%5E2%20%5C%5C%201%20%26%20y%20%26%20y%5E2%20%5C%5C%201%20%26%20z%20%26%20z%5E2%20%5C%5C%20%5Cend%7Bmatrix%7D)\n\n### 1. 括号\n\n如果要对矩阵加括号，可以像上文中提到的一样，使用`\\left`与`\\right` 配合表示括号符号。也可以使用特殊的matrix 。即替换`\\begin{matrix}…\\end{matrix} 中matrix 为pmatrix ，bmatrix ，Bmatrix ，vmatrix , Vmatrix` 。  \n`pmatrix$\\begin{pmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{pmatrix}$`:pmatrix![\\begin{pmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{pmatrix}](https://math.jianshu.com/math?formula=%5Cbegin%7Bpmatrix%7D1%20%26%202%20%5C%5C%203%20%26%204%5C%5C%20%5Cend%7Bpmatrix%7D)  \n`bmatrix$\\begin{bmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{bmatrix}$` :bmatrix![\\begin{bmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{bmatrix}](https://math.jianshu.com/math?formula=%5Cbegin%7Bbmatrix%7D1%20%26%202%20%5C%5C%203%20%26%204%5C%5C%20%5Cend%7Bbmatrix%7D)  \n`Bmatrix$\\begin{Bmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{Bmatrix}$` :Bmatrix![\\begin{Bmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{Bmatrix}](https://math.jianshu.com/math?formula=%5Cbegin%7BBmatrix%7D1%20%26%202%20%5C%5C%203%20%26%204%5C%5C%20%5Cend%7BBmatrix%7D)  \n`vmatrix$\\begin{vmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{vmatrix}$` :vmatrix![\\begin{vmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{vmatrix}](https://math.jianshu.com/math?formula=%5Cbegin%7Bvmatrix%7D1%20%26%202%20%5C%5C%203%20%26%204%5C%5C%20%5Cend%7Bvmatrix%7D)  \n`Vmatrix$\\begin{Vmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{Vmatrix}$` :Vmatrix![\\begin{Vmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{Vmatrix}](https://math.jianshu.com/math?formula=%5Cbegin%7BVmatrix%7D1%20%26%202%20%5C%5C%203%20%26%204%5C%5C%20%5Cend%7BVmatrix%7D)  \n元素省略:  \n可以使用\\cdots ：⋯，\\ddots：⋱ ，\\vdots：⋮ 来省略矩阵中的元素，如：\n\n```ruby\n$$\n\\begin{pmatrix}\n1&a_1&a_1^2&\\cdots&a_1^n\\\\\n1&a_2&a_2^2&\\cdots&a_2^n\\\\\n\\vdots&\\vdots&\\vdots&\\ddots&\\vdots\\\\\n1&a_m&a_m^2&\\cdots&a_m^n\\\\\n\\end{pmatrix}\n$$\n\n```\n\n表示：  \n![\\begin{pmatrix} 1&a_1&a_1^2&\\cdots&a_1^n\\\\ 1&a_2&a_2^2&\\cdots&a_2^n\\\\ \\vdots&\\vdots&\\vdots&\\ddots&\\vdots\\\\ 1&a_m&a_m^2&\\cdots&a_m^n\\\\ \\end{pmatrix}](https://math.jianshu.com/math?formula=%5Cbegin%7Bpmatrix%7D%201%26a_1%26a_1%5E2%26%5Ccdots%26a_1%5En%5C%5C%201%26a_2%26a_2%5E2%26%5Ccdots%26a_2%5En%5C%5C%20%5Cvdots%26%5Cvdots%26%5Cvdots%26%5Cddots%26%5Cvdots%5C%5C%201%26a_m%26a_m%5E2%26%5Ccdots%26a_m%5En%5C%5C%20%5Cend%7Bpmatrix%7D)\n\n### 2. 增广矩阵\n\n增广矩阵需要使用前面的表格中使用到的`\\begin{array} ... \\end{array}`来实现。\n\n```swift\n$$\n\\left[  \\begin{array}  {c c | c} %这里的c表示数组中元素对其方式：c居中、r右对齐、l左对齐，竖线表示2、3列间插入竖线\n1 & 2 & 3 \\\\\n\\hline %插入横线，如果去掉\\hline就是增广矩阵\n4 & 5 & 6\n\\end{array}  \\right]\n$$\n\n```\n\n显示为：  \n![\\left[ \\begin{array} {c c | c} 1 & 2 & 3 \\\\ \\hline 4 & 5 & 6 \\end{array} \\right]](https://math.jianshu.com/math?formula=%5Cleft%5B%20%5Cbegin%7Barray%7D%20%7Bc%20c%20%7C%20c%7D%201%20%26%202%20%26%203%20%5C%5C%20%5Chline%204%20%26%205%20%26%206%20%5Cend%7Barray%7D%20%5Cright%5D)\n\n# 二十、公式标记与引用\n\n使用`\\tag{yourtag}`来标记公式，如`$$a=x^2-y^3\\tag{1}$$`显示为：  \n![a=x^2-y^3\\tag{1}](https://math.jianshu.com/math?formula=a%3Dx%5E2-y%5E3%5Ctag%7B1%7D)\n\n# 二十一、字体\n\n### 1.黑板粗体字\n\n此字体经常用来表示代表实数、整数、有理数、复数的大写字母。  \n`$\\mathbb ABCDEF$`：![\\mathbb ABCDEF](https://math.jianshu.com/math?formula=%5Cmathbb%20ABCDEF)  \n`$\\Bbb ABCDEF$`：![\\Bbb ABCDEF](https://math.jianshu.com/math?formula=%5CBbb%20ABCDEF)\n\n### 3.黑体字\n\n`$\\mathbf ABCDEFGHIJKLMNOPQRSTUVWXYZ$`:![\\mathbf ABCDEFGHIJKLMNOPQRSTUVWXYZ](https://math.jianshu.com/math?formula=%5Cmathbf%20ABCDEFGHIJKLMNOPQRSTUVWXYZ)  \n`$\\mathbf abcdefghijklmnopqrstuvwxyz$`:![\\mathbf abcdefghijklmnopqrstuvwxyz](https://math.jianshu.com/math?formula=%5Cmathbf%20abcdefghijklmnopqrstuvwxyz)\n\n### 3.打印机字体\n\n`$\\mathtt ABCDEFGHIJKLMNOPQRSTUVWXYZ$`:![\\mathtt ABCDEFGHIJKLMNOPQRSTUVWXYZ](https://math.jianshu.com/math?formula=%5Cmathtt%20ABCDEFGHIJKLMNOPQRSTUVWXYZ)\n\n# 二十二、希腊字母\n\n| 字母  | 实现              | 字母  | 实现            |\n| --- | --------------- | --- | ------------- |\n| A   | `A`             | α   | `\\alhpa`      |\n| B   | `B`             | β   | `\\beta`       |\n| Γ   | `\\Gamma`        | γ   | `\\gamma`      |\n| Δ   | `\\Delta`        | δ   | `\\delta`      |\n| E   | `E`             | ϵ   | `\\epsilon`    |\n| Z   | `Z`             | ζ   | `\\zeta`       |\n| H   | `H`             | η   | `\\eta`        |\n| Θ   | `\\Theta`        | θ   | `\\theta`      |\n| I   | `I`             | ι   | `\\iota`       |\n| K   | `K`             | κ   | `\\kappa`      |\n| Λ   | `\\Lambda`       | λ   | `\\lambda`     |\n| M   | `M`             | μ   | `\\mu`         |\n| N   | `N`             | ν   | `\\nu`         |\n| Ξ   | `\\Xi`           | ξ   | `\\xi`         |\n| O   | `O`             | ο   | `\\omicron`    |\n| Π   | `\\Pi`           | π   | `\\pi`         |\n| P   | `P`             | ρ   | `\\rho`        |\n| Σ   | `\\Sigma`        | σ   | `\\sigma`      |\n| T   | `T`             | τ   | `\\tau`        |\n| Υ   | `\\Upsilon`      | υ   | `\\upsilon`    |\n| Φ   | `\\Phi`          | ϕ   | `\\phi`        |\n| X   | `X`             | χ   | `\\chi`        |\n| Ψ   | `\\Psi`          | ψ   | `\\psi`        |\n| Ω   | `\\v`            | ω   | `\\omega`      |\n| ε   | `$\\varepsilon$` | ϑ   | `$\\vartheta$` |\n| ϖ   | `$\\varpi$`      | ϱ   | `$\\varrho$`   |\n| ς   | `$\\varsigma$`   | φ   | `$\\varphi$`   |\n\n[https://blog.csdn.net/weixin_43159628/article/details/88237139](https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fweixin_43159628%2Farticle%2Fdetails%2F88237139)  \n[https://www.jianshu.com/p/08cbe54a5f33](https://www.jianshu.com/p/08cbe54a5f33)\n\n  \n  \n作者：无剑_君  \n链接：https://www.jianshu.com/p/383e8149136c  \n来源：简书  \n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","slug":"工具教程/教程：MD 数学公式语法","published":1,"date":"2024-04-22T13:14:48.756Z","updated":"2024-04-12T09:49:47.435Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0c000jkgg40at6f7hj","content":"<p><a href=\"https://www.jianshu.com/p/383e8149136c\">Markdown数学公式语法 - 简书 (jianshu.com)</a></p>\n<h1 id=\"一、简单分类\"><a href=\"#一、简单分类\" class=\"headerlink\" title=\"一、简单分类\"></a>一、简单分类</h1><h3 id=\"1-行内公式\"><a href=\"#1-行内公式\" class=\"headerlink\" title=\"1. 行内公式\"></a>1. 行内公式</h3><p>将公式插入到本行内，符号：<code>$公式内容$</code>，如：<code>$xyz$</code><br><img src=\"https://math.jianshu.com/math?formula=xyz\" alt=\"xyz\"></p>\n<h3 id=\"2-行间公式\"><a href=\"#2-行间公式\" class=\"headerlink\" title=\"2. 行间公式\"></a>2. 行间公式</h3><p>将公式插入到新的一行内，并且居中，符号：<code>$公式内容$</code>，如：<code>$$xyz$$</code><br><img src=\"https://math.jianshu.com/math?formula=xyz\" alt=\"xyz\"></p>\n<h1 id=\"二、上标、下标与组合\"><a href=\"#二、上标、下标与组合\" class=\"headerlink\" title=\"二、上标、下标与组合\"></a>二、上标、下标与组合</h1><h3 id=\"1-上标符号，符号：-，如：-x-4\"><a href=\"#1-上标符号，符号：-，如：-x-4\" class=\"headerlink\" title=\"1. 上标符号，符号：^，如：$x^4$ \"></a>1. 上标符号，符号：<code>^</code>，如：<code>$x^4$</code> <img src=\"https://math.jianshu.com/math?formula=x%5E4\" alt=\"x^4\"></h3><h3 id=\"2-下标符号，符号：-，如：-x-1\"><a href=\"#2-下标符号，符号：-，如：-x-1\" class=\"headerlink\" title=\"2. 下标符号，符号：_，如：$x_1$ \"></a>2. 下标符号，符号：<code>_</code>，如：<code>$x_1$</code> <img src=\"https://math.jianshu.com/math?formula=x_1\" alt=\"x_1\"></h3><h3 id=\"3-组合符号，符号：-，如：\"><a href=\"#3-组合符号，符号：-，如：\" class=\"headerlink\" title=\"3. 组合符号，符号：{}，如：\"></a>3. 组合符号，符号：<code>&#123;&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%3Csup%3E%7B16%7D_%7B8%7DO%3C/sup%3E%7B2+%7D_%7B2%7D\" alt=\"&lt;sup&gt;{16}_{8}O&lt;/sup&gt;{2+}_{2}\"></h3><p>默认情况下，上、下标符号仅仅对下一个组起作用。一个组即单个字符或者使用{}（大括号） 包裹起来的内容。如果使用<code>$10^10$</code>表示的是<img src=\"https://math.jianshu.com/math?formula=10%5E10\" alt=\"10^10\">,而<code>$10^&#123;10&#125;$</code> 才可以表示为<img src=\"https://math.jianshu.com/math?formula=10%5E%7B10%7D\" alt=\"10^{10}\">。同时，大括号还能消除二义性，如：<code>$x^5^6$</code> 将得到一个错误，必须使用大括号来界定^的结合性，如:<code>$&#123;x^5&#125;^6$</code>表示的<img src=\"https://math.jianshu.com/math?formula=%7Bx%5E5%7D%5E6\" alt=\"{x^5}^6\">：或者用<code>$x^&#123;5^6&#125;$</code>表示的<img src=\"https://math.jianshu.com/math?formula=x%5E%7B5%5E6%7D\" alt=\"x^{5^6}\">。</p>\n<h1 id=\"三、括号\"><a href=\"#三、括号\" class=\"headerlink\" title=\"三、括号\"></a>三、括号</h1><h3 id=\"1-小括号与方括号\"><a href=\"#1-小括号与方括号\" class=\"headerlink\" title=\"1.小括号与方括号\"></a>1.小括号与方括号</h3><p>用原始的( ) ，[ ] 即可，如<code>(2+3)[4+4]</code>可表示：<img src=\"https://math.jianshu.com/math?formula=(2+3)%5B4+4%5D\" alt=\"(2+3)[4+4]\">。<br>使用\\left(或\\right)使符号大小与邻近的公式相适应（该语句适用于所有括号类型），如\\left(\\frac{x}{y}\\right)可表示<img src=\"https://math.jianshu.com/math?formula=%5Cleft(%5Cfrac%7Bx%7D%7By%7D%5Cright)\" alt=\"\\left(\\frac{x}{y}\\right)\"></p>\n<h3 id=\"2-大括号\"><a href=\"#2-大括号\" class=\"headerlink\" title=\"2. 大括号\"></a>2. 大括号</h3><p>由于大括号{} 被用于分组，因此需要使用{和}表示大括号，也可以使用\\lbrace 和\\rbrace来表示。如{ab}或\\lbrace ab\\rbrace表示:<img src=\"https://math.jianshu.com/math?formula=%5C%7Bab%5C%7D\" alt=\"\\{ab\\}\"></p>\n<h3 id=\"3-尖括号\"><a href=\"#3-尖括号\" class=\"headerlink\" title=\"3. 尖括号\"></a>3. 尖括号</h3><p>区分于小于号和大于号，使用\\langle 和\\rangle 表示左尖括号和右尖括号。如\\langle x \\rangle表示：<img src=\"https://math.jianshu.com/math?formula=%5Clangle%20x%20%5Crangle\" alt=\"\\langle x \\rangle\"></p>\n<h1 id=\"三、取整\"><a href=\"#三、取整\" class=\"headerlink\" title=\"三、取整\"></a>三、取整</h1><h3 id=\"1-上取整\"><a href=\"#1-上取整\" class=\"headerlink\" title=\"1. 上取整\"></a>1. 上取整</h3><p>使用\\lceil 和 \\rceil 表示。 如，\\lceil x \\rceil表示为：<img src=\"https://math.jianshu.com/math?formula=%5Clceil%20x%20%5Crceil\" alt=\"\\lceil x \\rceil\"></p>\n<h3 id=\"2-下取整\"><a href=\"#2-下取整\" class=\"headerlink\" title=\"2. 下取整\"></a>2. 下取整</h3><p>使用\\lfloor 和 \\rfloor 表示。如，\\lfloor x \\rfloor表示为:<img src=\"https://math.jianshu.com/math?formula=%5Clfloor%20x%20%5Crfloor\" alt=\"\\lfloor x \\rfloor\"></p>\n<h1 id=\"四、求和-积分-连乘\"><a href=\"#四、求和-积分-连乘\" class=\"headerlink\" title=\"四、求和\\积分\\连乘\"></a>四、求和\\积分\\连乘</h1><h3 id=\"1-求和\"><a href=\"#1-求和\" class=\"headerlink\" title=\"1.求和\"></a>1.求和</h3><p><code>\\sum</code> 用来表示求和符号，其下标表示求和下限，上标表示上限。如:<br><code>$\\sum_&#123;r=1&#125;^n$</code>表示：<img src=\"https://math.jianshu.com/math?formula=%5Csum_%7Br=1%7D%5En\" alt=\"\\sum_{r=1}^n\"></p>\n<h3 id=\"2-积分\"><a href=\"#2-积分\" class=\"headerlink\" title=\"2. 积分\"></a>2. 积分</h3><p><code>\\int</code> 用来表示积分符号，同样地，其上下标表示积分的上下限。如，<code>$\\int_&#123;r=1&#125;^\\infty$</code>表示:<img src=\"https://math.jianshu.com/math?formula=%5Cint_%7Br=1%7D%5E%5Cinfty\" alt=\"\\int_{r=1}^\\infty\"><br>多重积分同样使用<code>\\int</code> ，通过 i 的数量表示积分导数：<br>如：<br><code>$\\iint$</code> 表示为：<img src=\"https://math.jianshu.com/math?formula=%5Ciint\" alt=\"\\iint\"><br><code>$\\iiint$</code> 表示为：<img src=\"https://math.jianshu.com/math?formula=%5Ciiint\" alt=\"\\iiint\"></p>\n<h3 id=\"3-连乘\"><a href=\"#3-连乘\" class=\"headerlink\" title=\"3. 连乘\"></a>3. 连乘</h3><p><code>$\\prod &#123;a+b&#125;$</code> 表示：<img src=\"https://math.jianshu.com/math?formula=%5Cprod%20%7Ba+b%7D\" alt=\"\\prod {a+b}\"><br><code>$\\prod_&#123;i=1&#125;^&#123;K&#125;$</code> 表示：<img src=\"https://math.jianshu.com/math?formula=%5Cprod_%7Bi=1%7D%5E%7BK%7D\" alt=\"\\prod_{i=1}^{K}\"><br><code>$$\\prod_&#123;i=1&#125;^&#123;K&#125;$$</code>表示（注意是行间公式）：<img src=\"https://math.jianshu.com/math?formula=%5Cprod_%7Bi=1%7D%5E%7BK%7D\" alt=\"\\prod_{i=1}^{K}\"></p>\n<h3 id=\"4-其他\"><a href=\"#4-其他\" class=\"headerlink\" title=\"4. 其他\"></a>4. 其他</h3><p>与此类似的符号还有，<br><code>$\\prod$</code> ：<img src=\"https://math.jianshu.com/math?formula=%5Cprod\" alt=\"\\prod\"><br><code>$\\bigcup$</code>：<img src=\"https://math.jianshu.com/math?formula=%5Cbigcup\" alt=\"\\bigcup\"><br><code>$\\bigcap$</code> ：<img src=\"https://math.jianshu.com/math?formula=%5Cbigcap\" alt=\"\\bigcap\"><br><code>$arg\\,\\max_&#123;c_k&#125;$</code>：<img src=\"https://math.jianshu.com/math?formula=arg%5C,%5Cmax_%7Bc_k%7D\" alt=\"arg\\,\\max_{c_k}\"><br><code>$arg\\,\\min_&#123;c_k&#125;$</code>：<img src=\"https://math.jianshu.com/math?formula=arg,%5Cmin_%7Bc_k%7D\" alt=\"arg,\\min_{c_k}\"><br><code>$\\mathop &#123;argmin&#125;_&#123;c_k&#125;$</code>：<img src=\"https://math.jianshu.com/math?formula=%5Cmathop%20%7Bargmin%7D_%7Bc_k%7D\" alt=\"\\mathop {argmin}_{c_k}\"><br><code>$\\mathop &#123;argmax&#125;_&#123;c_k&#125;$</code>：<img src=\"https://math.jianshu.com/math?formula=%5Cmathop%20%7Bargmax%7D_%7Bc_k%7D\" alt=\"\\mathop {argmax}_{c_k}\"><br><code>$\\max_&#123;c_k&#125;$</code>：<img src=\"https://math.jianshu.com/math?formula=%5Cmax_%7Bc_k%7D\" alt=\"\\max_{c_k}\"><br><code>$\\min_&#123;c_k&#125;$</code>：<img src=\"https://math.jianshu.com/math?formula=%5Cmin_%7Bc_k%7D\" alt=\"\\min_{c_k}\"></p>\n<h1 id=\"五、分式与根式\"><a href=\"#五、分式与根式\" class=\"headerlink\" title=\"五、分式与根式\"></a>五、分式与根式</h1><h3 id=\"1-分式\"><a href=\"#1-分式\" class=\"headerlink\" title=\"1. 分式\"></a>1. 分式</h3><p>第一种，使用<code>\\frac ab</code>，表示为:<img src=\"https://math.jianshu.com/math?formula=%5Cfrac%20ab\" alt=\"\\frac ab\"> ，<code>\\frac</code>作用于其后的两个组a ，b ，结果为。如果你的分子或分母不是单个字符，请使用{…}来分组，比如<code>$\\frac &#123;a+c+1&#125;&#123;b+c+2&#125;$</code>表示:<img src=\"https://math.jianshu.com/math?formula=%5Cfrac%20%7Ba+c+1%7D%7Bb+c+2%7D\" alt=\"\\frac {a+c+1}{b+c+2}\"><br>第二种，使用\\over来分隔一个组的前后两部分，如<code>$&#123;a+1\\over b+1&#125;$</code>：<img src=\"https://math.jianshu.com/math?formula=%7Ba+1%5Cover%20b+1%7D\" alt=\"{a+1\\over b+1}\"></p>\n<h3 id=\"2-连分数\"><a href=\"#2-连分数\" class=\"headerlink\" title=\"2. 连分数\"></a>2. 连分数</h3><p>书写连分数表达式时，请使用<code>\\cfrac</code>代替<code>\\frac</code>或者<code>\\over</code>两者效果对比如下：<br><code>\\frac</code> 表示如下：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$$</span>x=a_0 + \\frac &#123;<span class=\"number\">1</span>^<span class=\"number\">2</span>&#125;&#123;a_1 + \\frac &#123;<span class=\"number\">2</span>^<span class=\"number\">2</span>&#125;&#123;a_2 + \\frac &#123;<span class=\"number\">3</span>^<span class=\"number\">2</span>&#125;&#123;a_3 + \\frac &#123;<span class=\"number\">4</span>^<span class=\"number\">2</span>&#125;&#123;a_4 + ...&#125;&#125;&#125;&#125;<span class=\"variable\">$$</span></span><br></pre></td></tr></table></figure>\n\n<p>显示如下：<br><img src=\"https://math.jianshu.com/math?formula=x=a_0%20+%20%5Cfrac%20%7B1%5E2%7D%7Ba_1%20+%20%5Cfrac%20%7B2%5E2%7D%7Ba_2%20+%20%5Cfrac%20%7B3%5E2%7D%7Ba_3%20+%20%5Cfrac%20%7B4%5E2%7D%7Ba_4%20+%20...%7D%7D%7D%7D\" alt=\"x=a_0 + \\frac {1^2}{a_1 + \\frac {2^2}{a_2 + \\frac {3^2}{a_3 + \\frac {4^2}{a_4 + ...}}}}\"><br><code>\\cfrac</code>表示如下：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$$</span>x=a_0 + \\cfrac &#123;<span class=\"number\">1</span>^<span class=\"number\">2</span>&#125;&#123;a_1 + \\cfrac &#123;<span class=\"number\">2</span>^<span class=\"number\">2</span>&#125;&#123;a_2 + \\cfrac &#123;<span class=\"number\">3</span>^<span class=\"number\">2</span>&#125;&#123;a_3 + \\cfrac &#123;<span class=\"number\">4</span>^<span class=\"number\">2</span>&#125;&#123;a_4 + ...&#125;&#125;&#125;&#125;<span class=\"variable\">$$</span></span><br></pre></td></tr></table></figure>\n\n<p>显示如下：<br><img src=\"https://math.jianshu.com/math?formula=x=a_0%20+%20%5Ccfrac%20%7B1%5E2%7D%7Ba_1%20+%20%5Ccfrac%20%7B2%5E2%7D%7Ba_2%20+%20%5Ccfrac%20%7B3%5E2%7D%7Ba_3%20+%20%5Ccfrac%20%7B4%5E2%7D%7Ba_4%20+%20...%7D%7D%7D%7D\" alt=\"x=a_0 + \\cfrac {1^2}{a_1 + \\cfrac {2^2}{a_2 + \\cfrac {3^2}{a_3 + \\cfrac {4^2}{a_4 + ...}}}}\"></p>\n<h3 id=\"3-根式\"><a href=\"#3-根式\" class=\"headerlink\" title=\"3.根式\"></a>3.根式</h3><p>根式使用<code>\\sqrt</code> 来表示。<br>如开4次方：<code>$\\sqrt[4]&#123;\\frac xy&#125;$</code> 可表示：<img src=\"https://math.jianshu.com/math?formula=%5Csqrt%5B4%5D%7B%5Cfrac%20xy%7D\" alt=\"\\sqrt[4]{\\frac xy}\"><br>开平方：<code>$\\sqrt &#123;a+b&#125;$</code>可表示：<img src=\"https://math.jianshu.com/math?formula=%5Csqrt%20%7Ba+b%7D\" alt=\"\\sqrt {a+b}\"></p>\n<h1 id=\"六、多行表达式\"><a href=\"#六、多行表达式\" class=\"headerlink\" title=\"六、多行表达式\"></a>六、多行表达式</h1><h3 id=\"1-分类表达式\"><a href=\"#1-分类表达式\" class=\"headerlink\" title=\"1. 分类表达式\"></a>1. 分类表达式</h3><p>定义函数的时候经常需要分情况给出表达式，使用\\begin{cases}…\\end{cases} 。其中：<br>使用<code>\\\\</code> 来分类，<br>使用<code>&amp;</code>指示需要对齐的位置，<br>使用<code>\\ +space</code>表示空格。<br>如：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$$</span></span><br><span class=\"line\">f(n)</span><br><span class=\"line\">\\<span class=\"keyword\">begin</span>&#123;cases&#125;</span><br><span class=\"line\">\\cfrac n2, &amp;<span class=\"keyword\">if</span>\\ n\\ is\\ even\\\\</span><br><span class=\"line\">3n + <span class=\"number\">1</span>, &amp;<span class=\"keyword\">if</span>\\  n\\ is\\ odd</span><br><span class=\"line\">\\<span class=\"keyword\">end</span>&#123;cases&#125;</span><br><span class=\"line\"><span class=\"variable\">$$</span></span><br></pre></td></tr></table></figure>\n\n<p>表示:<br><img src=\"https://math.jianshu.com/math?formula=f(n)%20%5Cbegin%7Bcases%7D%20%5Ccfrac%20n2,%20&if%5C%20n%5C%20is%5C%20even%5C%5C%203n%20+%201,%20&if%5C%20n%5C%20is%5C%20odd%20%5Cend%7Bcases%7D\" alt=\"f(n) \\begin{cases} \\cfrac n2, &amp;if\\ n\\ is\\ even\\\\ 3n + 1, &amp;if\\ n\\ is\\ odd \\end{cases}\"><br>以及:</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$$</span></span><br><span class=\"line\">L(Y,f(X)) =</span><br><span class=\"line\">\\<span class=\"keyword\">begin</span>&#123;cases&#125;</span><br><span class=\"line\"><span class=\"number\">0</span>, &amp; \\text&#123;Y = f(X)&#125;  \\\\</span><br><span class=\"line\"><span class=\"number\">1</span>, &amp; \\text&#123;Y <span class=\"variable\">$\\</span>neq<span class=\"variable\">$ </span>f(X)&#125;</span><br><span class=\"line\">\\<span class=\"keyword\">end</span>&#123;cases&#125;</span><br><span class=\"line\"><span class=\"variable\">$$</span></span><br></pre></td></tr></table></figure>\n\n<p>表示:<br><img src=\"https://math.jianshu.com/math?formula=L(Y,f(X))%20=%20%5Cbegin%7Bcases%7D%200,%20&%20%5Ctext%7BY%20=%20f(X)%7D%20%5C%5C%201,%20&%20%5Ctext%7BY%20$%5Cneq$%20f(X)%7D%20%5Cend%7Bcases%7D\" alt=\"L(Y,f(X)) = \\begin{cases} 0, &amp; \\text{Y = f(X)} \\\\ 1, &amp; \\text{Y $\\neq$ f(X)} \\end{cases}\"></p>\n<p>如果想分类之间的垂直间隔变大，可以使用<code>\\\\[2ex]</code>代替<code>\\\\</code>来分隔不同的情况。<code>(3ex,4ex</code> 也可以用，<code>1ex</code>相当于原始距离）。如下所示：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$$</span></span><br><span class=\"line\">L(Y,f(X)) =</span><br><span class=\"line\">\\<span class=\"keyword\">begin</span>&#123;cases&#125;</span><br><span class=\"line\"><span class=\"number\">0</span>, &amp; \\text&#123;Y = f(X)&#125; \\\\[5ex]</span><br><span class=\"line\"><span class=\"number\">1</span>, &amp; \\text&#123;Y <span class=\"variable\">$\\</span>neq<span class=\"variable\">$ </span>f(X)&#125;</span><br><span class=\"line\">\\<span class=\"keyword\">end</span>&#123;cases&#125;</span><br><span class=\"line\"><span class=\"variable\">$$</span></span><br></pre></td></tr></table></figure>\n\n<p>表示：<br><img src=\"https://math.jianshu.com/math?formula=L(Y,f(X))%20=%20%5Cbegin%7Bcases%7D%200,%20&%20%5Ctext%7BY%20=%20f(X)%7D%20%5C%5C%5B5ex%5D%201,%20&%20%5Ctext%7BY%20$%5Cneq$%20f(X)%7D%20%5Cend%7Bcases%7D\" alt=\"L(Y,f(X)) = \\begin{cases} 0, &amp; \\text{Y = f(X)} \\[5ex] 1, &amp; \\text{Y $\\neq$ f(X)} \\end{cases}\"></p>\n<h3 id=\"2-多行表达式\"><a href=\"#2-多行表达式\" class=\"headerlink\" title=\"2. 多行表达式\"></a>2. 多行表达式</h3><p>有时候需要将一行公式分多行进行显示。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$$</span><br><span class=\"line\">\\begin&#123;aligned&#125;</span><br><span class=\"line\">\\sqrt&#123;<span class=\"number\">37</span>&#125; &amp; = \\sqrt&#123;\\frac&#123;<span class=\"number\">73</span>^<span class=\"number\">2</span><span class=\"number\">-1</span>&#125;&#123;<span class=\"number\">12</span>^<span class=\"number\">2</span>&#125;&#125; \\\\</span><br><span class=\"line\"> &amp; = \\sqrt&#123;\\frac&#123;<span class=\"number\">73</span>^<span class=\"number\">2</span>&#125;&#123;<span class=\"number\">12</span>^<span class=\"number\">2</span>&#125;\\cdot\\frac&#123;<span class=\"number\">73</span>^<span class=\"number\">2</span><span class=\"number\">-1</span>&#125;&#123;<span class=\"number\">73</span>^<span class=\"number\">2</span>&#125;&#125; \\\\ </span><br><span class=\"line\"> &amp; = \\sqrt&#123;\\frac&#123;<span class=\"number\">73</span>^<span class=\"number\">2</span>&#125;&#123;<span class=\"number\">12</span>^<span class=\"number\">2</span>&#125;&#125;\\sqrt&#123;\\frac&#123;<span class=\"number\">73</span>^<span class=\"number\">2</span><span class=\"number\">-1</span>&#125;&#123;<span class=\"number\">73</span>^<span class=\"number\">2</span>&#125;&#125; \\\\</span><br><span class=\"line\"> &amp; = \\frac&#123;<span class=\"number\">73</span>&#125;&#123;<span class=\"number\">12</span>&#125;\\sqrt&#123;<span class=\"number\">1</span> - \\frac&#123;<span class=\"number\">1</span>&#125;&#123;<span class=\"number\">73</span>^<span class=\"number\">2</span>&#125;&#125; \\\\ </span><br><span class=\"line\"> &amp; \\approx \\frac&#123;<span class=\"number\">73</span>&#125;&#123;<span class=\"number\">12</span>&#125;\\<span class=\"built_in\">left</span>(<span class=\"number\">1</span> - \\frac&#123;<span class=\"number\">1</span>&#125;&#123;<span class=\"number\">2</span>\\cdot73^<span class=\"number\">2</span>&#125;\\right)</span><br><span class=\"line\">\\end&#123;aligned&#125;</span><br><span class=\"line\">$$</span><br></pre></td></tr></table></figure>\n\n<p>表示:<br><img src=\"https://math.jianshu.com/math?formula=%5Cbegin%7Baligned%7D%20%5Csqrt%7B37%7D%20&%20=%20%5Csqrt%7B%5Cfrac%7B73%5E2-1%7D%7B12%5E2%7D%7D%20%5C%5C%20&%20=%20%5Csqrt%7B%5Cfrac%7B73%5E2%7D%7B12%5E2%7D%5Ccdot%5Cfrac%7B73%5E2-1%7D%7B73%5E2%7D%7D%20%5C%5C%20&%20=%20%5Csqrt%7B%5Cfrac%7B73%5E2%7D%7B12%5E2%7D%7D%5Csqrt%7B%5Cfrac%7B73%5E2-1%7D%7B73%5E2%7D%7D%20%5C%5C%20&%20=%20%5Cfrac%7B73%7D%7B12%7D%5Csqrt%7B1%20-%20%5Cfrac%7B1%7D%7B73%5E2%7D%7D%20%5C%5C%20&%20%5Capprox%20%5Cfrac%7B73%7D%7B12%7D%5Cleft(1%20-%20%5Cfrac%7B1%7D%7B2%5Ccdot73%5E2%7D%5Cright)%20%5Cend%7Baligned%7D\" alt=\"\\begin{aligned} \\sqrt{37} &amp; = \\sqrt{\\frac{73^2-1}{12^2}} \\\\ &amp; = \\sqrt{\\frac{73^2}{12^2}\\cdot\\frac{73^2-1}{73^2}} \\\\ &amp; = \\sqrt{\\frac{73^2}{12^2}}\\sqrt{\\frac{73^2-1}{73^2}} \\\\ &amp; = \\frac{73}{12}\\sqrt{1 - \\frac{1}{73^2}} \\\\ &amp; \\approx \\frac{73}{12}\\left(1 - \\frac{1}{2\\cdot73^2}\\right) \\end{aligned}\"></p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$$</span></span><br><span class=\"line\">\\<span class=\"keyword\">begin</span>&#123;aligned&#125;</span><br><span class=\"line\">a&amp;=b+c-d \\\\</span><br><span class=\"line\">&amp;=e-f \\\\</span><br><span class=\"line\">&amp;=i \\\\</span><br><span class=\"line\">\\<span class=\"keyword\">end</span>&#123;aligned&#125;</span><br><span class=\"line\"><span class=\"variable\">$$</span></span><br></pre></td></tr></table></figure>\n\n<p>表示:<br><img src=\"https://math.jianshu.com/math?formula=%5Cbegin%7Baligned%7D%20a&=b+c-d%20%5C%5C%20&=e-f%20%5C%5C%20&=i%20%5C%5C%20%5Cend%7Baligned%7D\" alt=\"\\begin{aligned} a&amp;=b+c-d \\\\ &amp;=e-f \\\\ &amp;=i \\\\ \\end{aligned}\"></p>\n<p>其中<code>begin&#123;equation&#125;</code> 表示开始方程，<code>end&#123;equation&#125;</code>表示方程结束；<code>begin&#123;split&#125;</code> 表示开始多行公式，<code>end&#123;split&#125;</code> 表示结束；公式中用<code>\\\\</code> 表示回车到下一行，<code>&amp;</code> 表示对齐的位置。</p>\n<h1 id=\"七、方程组\"><a href=\"#七、方程组\" class=\"headerlink\" title=\"七、方程组\"></a>七、方程组</h1><p>使用\\begin{array}…\\end{array} 与\\left \\与\\right 配合表示方程组,如:</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$$</span></span><br><span class=\"line\">\\left \\&#123; </span><br><span class=\"line\">\\<span class=\"keyword\">begin</span>&#123;array&#125;&#123;c&#125;</span><br><span class=\"line\">a_1x+b_1y+c_1z=d_1 \\\\ </span><br><span class=\"line\">a_2x+b_2y+c_2z=d_2 \\\\ </span><br><span class=\"line\">a_3x+b_3y+c_3z=d_3</span><br><span class=\"line\">\\<span class=\"keyword\">end</span>&#123;array&#125;</span><br><span class=\"line\">\\right.</span><br><span class=\"line\"><span class=\"variable\">$$</span></span><br></pre></td></tr></table></figure>\n\n<p>表示：<br><img src=\"https://math.jianshu.com/math?formula=%5Cleft%20%5C%7B%20%5Cbegin%7Barray%7D%7Bc%7D%20a_1x+b_1y+c_1z=d_1%20%5C%5C%20a_2x+b_2y+c_2z=d_2%20%5C%5C%20a_3x+b_3y+c_3z=d_3%20%5Cend%7Barray%7D%20%5Cright.\" alt=\"\\left \\{ \\begin{array}{c} a_1x+b_1y+c_1z=d_1 \\\\ a_2x+b_2y+c_2z=d_2 \\\\ a_3x+b_3y+c_3z=d_3 \\end{array} \\right.\"></p>\n<p>注意：通常MathJax通过内部策略自己管理公式内部的空间，因此<code>a…b</code> 与<code>a…….b</code>（.表示空格）都会显示为<code>ab</code>。可以通过在<code>ab</code>间加入<code>\\</code>,增加些许间隙，<code>\\;</code>增加较宽的间隙，<code>\\quad</code> 与<code>\\qquad</code> 会增加更大的间隙。</p>\n<h1 id=\"八、特殊函数与符号\"><a href=\"#八、特殊函数与符号\" class=\"headerlink\" title=\"八、特殊函数与符号\"></a>八、特殊函数与符号</h1><h3 id=\"1-三角函数\"><a href=\"#1-三角函数\" class=\"headerlink\" title=\"1. 三角函数\"></a>1. 三角函数</h3><p><code>$\\sin x$</code> : <img src=\"https://math.jianshu.com/math?formula=%5Csin%20x\" alt=\"\\sin x\"><br><code>$\\arctan x$</code> : <img src=\"https://math.jianshu.com/math?formula=%5Carctan%20x\" alt=\"\\arctan x\"></p>\n<h3 id=\"2-比较运算符\"><a href=\"#2-比较运算符\" class=\"headerlink\" title=\"2.比较运算符\"></a>2.比较运算符</h3><p>小于<code>(\\lt )</code>：<img src=\"https://math.jianshu.com/math?formula=(%5Clt%20)\" alt=\"(\\lt )\"><br>大于<code>(\\gt )</code>：<img src=\"https://math.jianshu.com/math?formula=(%5Cgt\" alt=\"(\\gt\"><br>小于等于<code>(\\le )</code>：<img src=\"https://math.jianshu.com/math?formula=(%5Cle%20)\" alt=\"(\\le )\"><br>大于等于<code>(\\ge )</code>：<img src=\"https://math.jianshu.com/math?formula=(%5Cge%20)\" alt=\"(\\ge )\"><br>不等于<code>(\\ne )</code> :<img src=\"https://math.jianshu.com/math?formula=(%5Cne%20)\" alt=\"(\\ne )\"><br>可以在这些运算符前面加上<code>\\not</code> ，如<code>\\not\\lt</code> : <img src=\"https://math.jianshu.com/math?formula=%5Cnot%5Clt\" alt=\"\\not\\lt\"></p>\n<h3 id=\"3-集合关系与运算\"><a href=\"#3-集合关系与运算\" class=\"headerlink\" title=\"3.集合关系与运算\"></a>3.集合关系与运算</h3><p>并集<code>(\\cup)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Ccup)\" alt=\"(\\cup)\"><br>交集<code>(\\cap)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Ccap)\" alt=\"(\\cap)\"><br>差集<code>(\\setminus)</code>:<img src=\"https://math.jianshu.com/math?formula=(%5Csetminus)\" alt=\"(\\setminus)\"><br>子集<code>(\\subset)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Csubset)\" alt=\"(\\subset)\"><br>子集<code>(\\subseteq)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Csubseteq)\" alt=\"(\\subseteq)\"><br>非子集<code>(\\subsetneq)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Csubsetneq)\" alt=\"(\\subsetneq)\"><br>父集<code>(\\supset)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Csupset)\" alt=\"(\\supset)\"><br>属于<code>(\\in)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Cin)\" alt=\"(\\in)\"><br>不属于<code>(\\notin)</code>:![<code>(\\notin)](https://math.jianshu.com/math?formula=%60(%5Cnotin))   空集</code>(\\emptyset)<code>: ![(\\emptyset)](https://math.jianshu.com/math?formula=(%5Cemptyset))   空</code>(\\varnothing)&#96;: <img src=\"https://math.jianshu.com/math?formula=(%5Cvarnothing)\" alt=\"(\\varnothing)\"></p>\n<h3 id=\"4-排列\"><a href=\"#4-排列\" class=\"headerlink\" title=\"4. 排列\"></a>4. 排列</h3><p><code>\\binom&#123;n+1&#125;&#123;2k&#125;</code> : <img src=\"https://math.jianshu.com/math?formula=%5Cbinom%7Bn+1%7D%7B2k%7D\" alt=\"\\binom{n+1}{2k}\"><br><code>&#123;n+1 \\choose 2k&#125;</code> : <img src=\"https://math.jianshu.com/math?formula=%7Bn+1%20%5Cchoose%202k%7D\" alt=\"{n+1 \\choose 2k}\"></p>\n<h3 id=\"5-箭头\"><a href=\"#5-箭头\" class=\"headerlink\" title=\"5. 箭头\"></a>5. 箭头</h3><p><code>(\\to)</code>:<img src=\"https://math.jianshu.com/math?formula=(%5Cto)\" alt=\"(\\to)\"><br><code>(\\rightarrow)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Crightarrow)\" alt=\"(\\rightarrow)\"><br><code>(\\leftarrow)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Cleftarrow)\" alt=\"(\\leftarrow)\"><br><code>(\\Rightarrow)</code>:![<code>(\\Rightarrow)](https://math.jianshu.com/math?formula=%60(%5CRightarrow))   </code>(\\Leftarrow)<code>: ![(\\Leftarrow)](https://math.jianshu.com/math?formula=(%5CLeftarrow))   </code>(\\mapsto)&#96;: <img src=\"https://math.jianshu.com/math?formula=%5Cmapsto\" alt=\"\\mapsto)\">)</p>\n<h3 id=\"6-逻辑运算符\"><a href=\"#6-逻辑运算符\" class=\"headerlink\" title=\"6. 逻辑运算符\"></a>6. 逻辑运算符</h3><p><code>(\\land)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Cland)\" alt=\"(\\land)\"><br><code>(\\lor)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Clor)\" alt=\"(\\lor)\"><br><code>(\\lnot)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Clnot)\" alt=\"(\\lnot)\"><br><code>(\\forall)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Cforall)\" alt=\"(\\forall)\"><br><code>(\\exists)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Cexists)\" alt=\"(\\exists)\"><br><code>(\\top)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Ctop)\" alt=\"(\\top)\"><br><code>(\\bot)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Cbot)\" alt=\"(\\bot)\"><br><code>(\\vdash)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Cvdash)\" alt=\"(\\vdash)\"><br><code>(\\vDash)</code>:<img src=\"https://math.jianshu.com/math?formula=(%5CvDash)\" alt=\"(\\vDash)\"></p>\n<h3 id=\"7-操作符\"><a href=\"#7-操作符\" class=\"headerlink\" title=\"7.操作符\"></a>7.操作符</h3><p><code>(\\star)</code>: ![<code>(\\star)](https://math.jianshu.com/math?formula=%60(%5Cstar))   </code>(\\ast)<code>: ![(\\ast)](https://math.jianshu.com/math?formula=(%5Cast))   </code>(\\oplus)<code>: ![(\\oplus)](https://math.jianshu.com/math?formula=(%5Coplus))   </code>(\\circ)<code>: ![(\\circ)](https://math.jianshu.com/math?formula=(%5Ccirc))   </code>(\\bullet)&#96;: <img src=\"https://math.jianshu.com/math?formula=(%5Cbullet)\" alt=\"(\\bullet)\"></p>\n<h3 id=\"8-等于\"><a href=\"#8-等于\" class=\"headerlink\" title=\"8.等于\"></a>8.等于</h3><p><code>(\\approx)</code>:<img src=\"https://math.jianshu.com/math?formula=(%5Capprox)\" alt=\"(\\approx)\"><br><code>(\\sim)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Csim)\" alt=\"(\\sim)\"><br><code>(\\equiv)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Cequiv)\" alt=\"(\\equiv)\"><br><code>(\\prec)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Cprec)\" alt=\"(\\prec)\"></p>\n<h3 id=\"9-范围\"><a href=\"#9-范围\" class=\"headerlink\" title=\"9.范围\"></a>9.范围</h3><p><code>(\\infty)</code>:<img src=\"https://math.jianshu.com/math?formula=(%5Cinfty)\" alt=\"(\\infty)\"><br><code>(\\aleph_o)</code>:<img src=\"https://math.jianshu.com/math?formula=(%5Caleph_o)\" alt=\"(\\aleph_o)\"><br><code>(\\nabla)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Cnabla)\" alt=\"(\\nabla)\"><br><code>(\\Im)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5CIm)\" alt=\"(\\Im)\"><br><code>(\\Re)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5CRe)\" alt=\"(\\Re)\"></p>\n<h3 id=\"10-模运算\"><a href=\"#10-模运算\" class=\"headerlink\" title=\"10. 模运算\"></a>10. 模运算</h3><p><code>(\\pmod)</code>: ![&#96;(\\pmod)](<a href=\"https://math.jianshu.com/math?formula=%60(%5Cpmod)\">https://math.jianshu.com/math?formula=%60(%5Cpmod)</a>)<br>如a \\equiv b \\pmod n 表示为: <img src=\"https://math.jianshu.com/math?formula=a%20%5Cequiv%20b%20%5Cpmod%20n\" alt=\"a \\equiv b \\pmod n\"></p>\n<h3 id=\"11-点\"><a href=\"#11-点\" class=\"headerlink\" title=\"11. 点\"></a>11. 点</h3><p><code>(\\ldots)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Cldots)\" alt=\"(\\ldots)\"><br><code>(\\cdots)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Ccdots)\" alt=\"(\\cdots)\"><br><code>(\\cdot)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Ccdot)\" alt=\"(\\cdot)\"><br>其区别是点的位置不同，<code>\\ldots</code> 位置稍低，<code>\\cdots</code> 位置居中。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$$</span></span><br><span class=\"line\">\\<span class=\"keyword\">begin</span>&#123;cases&#125;</span><br><span class=\"line\">a_1+a_2+\\ldots+a_n \\\\ </span><br><span class=\"line\">a_1+a_2+\\cdots+a_n \\\\</span><br><span class=\"line\">\\<span class=\"keyword\">end</span>&#123;cases&#125;</span><br><span class=\"line\"><span class=\"variable\">$$</span></span><br></pre></td></tr></table></figure>\n\n<p>表示(注意两部分点的位置)：<br><img src=\"https://math.jianshu.com/math?formula=%5Cbegin%7Bcases%7D%20a_1+a_2+%5Cldots+a_n%20%5C%5C%20a_1+a_2+%5Ccdots+a_n%20%5C%5C%20%5Cend%7Bcases%7D\" alt=\"\\begin{cases} a_1+a_2+\\ldots+a_n \\\\ a_1+a_2+\\cdots+a_n \\\\ \\end{cases}\"></p>\n<h3 id=\"12-顶部符号\"><a href=\"#12-顶部符号\" class=\"headerlink\" title=\"12.顶部符号\"></a>12.顶部符号</h3><p>对于单字符，<code>\\hat x</code>：<img src=\"https://math.jianshu.com/math?formula=%5Chat%20x\" alt=\"\\hat x\"><br>多字符可以使用<code>\\widehat &#123;xy&#125;</code>：<img src=\"https://math.jianshu.com/math?formula=%5Cwidehat%20%7Bxy%7D\" alt=\"\\widehat {xy}\"><br>类似的还有<code>\\overline x</code>: <img src=\"https://math.jianshu.com/math?formula=%5Coverline%20x\" alt=\"\\overline x\"><br>矢量<code>\\vec x</code>:<img src=\"https://math.jianshu.com/math?formula=%5Cvec%20x\" alt=\"\\vec x\"><br>向量<code>\\overrightarrow &#123;xy&#125;</code>: <img src=\"https://math.jianshu.com/math?formula=%5Coverrightarrow%20%7Bxy%7D\" alt=\"\\overrightarrow {xy}\"><br><code>\\dot x</code> : <img src=\"https://math.jianshu.com/math?formula=%5Cdot%20x\" alt=\"\\dot x\"><br><code>\\ddot x</code>: <img src=\"https://math.jianshu.com/math?formula=%5Cddot%20x\" alt=\"\\ddot x\"><br><code>\\dot &#123;\\dot x&#125;</code>: <img src=\"https://math.jianshu.com/math?formula=%5Cdot%20%7B%5Cdot%20x%7D\" alt=\"\\dot {\\dot x}\"></p>\n<h1 id=\"九、表格\"><a href=\"#九、表格\" class=\"headerlink\" title=\"九、表格\"></a>九、表格</h1><p>使用<code>\\begin&#123;array&#125;&#123;列样式&#125;…\\end&#123;array&#125;</code>这样的形式来创建表格，列样式可以是<code>clr</code> 表示居中，左，右对齐，还可以使用<code>|</code>表示一条竖线。表格中各行使用\\ 分隔，各列使用&amp; 分隔。使用<code>\\hline</code> 在本行前加入一条直线。 例如:</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$$</span></span><br><span class=\"line\">\\<span class=\"keyword\">begin</span>&#123;array&#125;&#123;c|<span class=\"params\">lcr&#125;</span></span><br><span class=\"line\"><span class=\"params\">n &amp; \\text&#123;Left&#125; &amp; \\text&#123;Center&#125; &amp; \\text&#123;Right&#125; \\\\</span></span><br><span class=\"line\"><span class=\"params\">\\hline</span></span><br><span class=\"line\"><span class=\"params\">1 &amp; 0.24 &amp; 1 &amp; 125 \\\\</span></span><br><span class=\"line\"><span class=\"params\">2 &amp; -1 &amp; 189 &amp; -8 \\\\</span></span><br><span class=\"line\"><span class=\"params\">3 &amp; -20 &amp; 2000 &amp; 1+10i \\\\</span></span><br><span class=\"line\"><span class=\"params\">\\<span class=\"keyword\">end</span>&#123;array&#125;</span></span><br><span class=\"line\"><span class=\"params\">$$</span></span><br></pre></td></tr></table></figure>\n\n<p>得到：<br><img src=\"https://math.jianshu.com/math?formula=%5Cbegin%7Barray%7D%7Bc%7Clcr%7D%20n%20&%20%5Ctext%7BLeft%7D%20&%20%5Ctext%7BCenter%7D%20&%20%5Ctext%7BRight%7D%20%5C%5C%20%5Chline%201%20&%200.24%20&%201%20&%20125%20%5C%5C%202%20&%20-1%20&%20189%20&%20-8%20%5C%5C%203%20&%20-20%20&%202000%20&%201+10i%20%5C%5C%20%5Cend%7Barray%7D\" alt=\"\\begin{array}{c|lcr} n &amp; \\text{Left} &amp; \\text{Center} &amp; \\text{Right} \\\\ \\hline 1 &amp; 0.24 &amp; 1 &amp; 125 \\\\ 2 &amp; -1 &amp; 189 &amp; -8 \\\\ 3 &amp; -20 &amp; 2000 &amp; 1+10i \\\\ \\end{array}\"></p>\n<h1 id=\"十、汉字、字体与格式\"><a href=\"#十、汉字、字体与格式\" class=\"headerlink\" title=\"十、汉字、字体与格式\"></a>十、汉字、字体与格式</h1><ol>\n<li>汉字形式，符号：<code>\\mbox&#123;&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=V_%7B%5Cmbox%7B%E5%88%9D%E5%A7%8B%7D%7D\" alt=\"V_{\\mbox{初始}}\"></li>\n<li>字体控制，符号：<code>\\displaystyle</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cdisplaystyle%20%5Cfrac%7Bx+y%7D%7By+z%7D\" alt=\"\\displaystyle \\frac{x+y}{y+z}\"></li>\n<li>下划线符号，符号：<code>\\underline</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cunderline%7Bx+y%7D\" alt=\"\\underline{x+y}\"></li>\n<li>标签，符号<code>\\tag&#123;数字&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Ctag%7B11%7D\" alt=\"\\tag{11}\"></li>\n<li>上大括号，符号：<code>\\overbrace&#123;算式&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Coverbrace%7Ba+b+c+d%7D%5E%7B2.0%7D\" alt=\"\\overbrace{a+b+c+d}^{2.0}\"></li>\n<li>下大括号，符号：<code>\\underbrace&#123;算式&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=a+%5Cunderbrace%7Bb+c%7D_%7B1.0%7D+d\" alt=\"a+\\underbrace{b+c}_{1.0}+d\"></li>\n<li>上位符号，符号：<code>\\stacrel&#123;上位符号&#125;&#123;基位符号&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cvec%7Bx%7D%5Cstackrel%7B%5Cmathrm%7Bdef%7D%7D%7B=%7D%7Bx_1,%5Cdots,x_n%7D\" alt=\"\\vec{x}\\stackrel{\\mathrm{def}}{=}{x_1,\\dots,x_n}\"></li>\n</ol>\n<h1 id=\"十一、占位符\"><a href=\"#十一、占位符\" class=\"headerlink\" title=\"十一、占位符\"></a>十一、占位符</h1><ol>\n<li>两个quad空格，符号：<code>\\qquad</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Cqquad%20y\" alt=\"x \\qquad y\"></li>\n<li>quad空格，符号：<code>\\quad</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Cquad%20y\" alt=\"x \\quad y\"></li>\n<li>大空格，符号<code>\\</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5C%20y\" alt=\"x \\ y\"></li>\n<li>中空格，符号<code>\\:</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20:%20y\" alt=\"x : y\"></li>\n<li>小空格，符号<code>\\,</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20,%20y\" alt=\"x , y\"></li>\n<li>没有空格，符号&#96;&#96;，如：<img src=\"https://math.jianshu.com/math?formula=xy\" alt=\"xy\"></li>\n<li>紧贴，符号<code>\\!</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20!%20y\" alt=\"x ! y\"></li>\n</ol>\n<h1 id=\"十二、定界符与组合\"><a href=\"#十二、定界符与组合\" class=\"headerlink\" title=\"十二、定界符与组合\"></a>十二、定界符与组合</h1><ol>\n<li>括号，符号：<code>（）\\big(\\big) \\Big(\\Big) \\bigg(\\bigg) \\Bigg(\\Bigg)</code>，如：<img src=\"https://math.jianshu.com/math?formula=%EF%BC%88%EF%BC%89%5Cbig(%5Cbig)%20%5CBig(%5CBig)%20%5Cbigg(%5Cbigg)%20%5CBigg(%5CBigg)\" alt=\"（）\\big(\\big) \\Big(\\Big) \\bigg(\\bigg) \\Bigg(\\Bigg)\"></li>\n<li>中括号，符号：<code>[]</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Bx+y%5D\" alt=\"[x+y]\"></li>\n<li>大括号，符号：<code>\\&#123; \\&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%7Bx+y%7D\" alt=\"{x+y}\"></li>\n<li>自适应括号，符号：<code>\\left \\right</code>，如：<code>$\\left(x\\right)$</code>，<img src=\"https://math.jianshu.com/math?formula=%5Cleft(x%5Cright)\" alt=\"\\left(x\\right)\"></li>\n<li>组合公式，符号：<code>&#123;上位公式 \\choose 下位公式&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%7Bn+1%20%5Cchoose%20k%7D=%7Bn%20%5Cchoose%20k%7D+%7Bn%20%5Cchoose%20k-1%7D\" alt=\"{n+1 \\choose k}={n \\choose k}+{n \\choose k-1}\"></li>\n<li>组合公式，符号：<code>&#123;上位公式 \\atop 下位公式&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Csum_%7Bk_0,k_1,%5Cldots%3E0%20%5Catop%20k_0+k_1+%5Ccdots=n%7DA_%7Bk_0%7DA_%7Bk_1%7D%5Ccdots\" alt=\"\\sum_{k_0,k_1,\\ldots&gt;0 \\atop k_0+k_1+\\cdots=n}A_{k_0}A_{k_1}\\cdots\"></li>\n</ol>\n<h1 id=\"十三、四则运算\"><a href=\"#十三、四则运算\" class=\"headerlink\" title=\"十三、四则运算\"></a>十三、四则运算</h1><ol>\n<li>加法运算，符号：<code>+</code>，如：<img src=\"https://math.jianshu.com/math?formula=x+y=z\" alt=\"x+y=z\"></li>\n<li>减法运算，符号：<code>-</code>，如：<img src=\"https://math.jianshu.com/math?formula=x-y=z\" alt=\"x-y=z\"></li>\n<li>加减运算，符号：<code>\\pm</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Cpm%20y=z\" alt=\"x \\pm y=z\"></li>\n<li>减甲运算，符号：<code>\\mp</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Cmp%20y=z\" alt=\"x \\mp y=z\"></li>\n<li>乘法运算，符号：<code>\\times</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Ctimes%20y=z\" alt=\"x \\times y=z\"></li>\n<li>点乘运算，符号：<code>\\cdot</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Ccdot%20y=z\" alt=\"x \\cdot y=z\"></li>\n<li>星乘运算，符号：<code>\\ast</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Cast%20y=z\" alt=\"x \\ast y=z\"></li>\n<li>除法运算，符号：<code>\\div</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Cdiv%20y=z\" alt=\"x \\div y=z\"></li>\n<li>斜法运算，符号：<code>/</code>，如：<img src=\"https://math.jianshu.com/math?formula=x/y=z\" alt=\"x/y=z\"></li>\n<li>分式表示，符号：<code>\\frac&#123;分子&#125;&#123;分母&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cfrac%7Bx+y%7D%7By+z%7D\" alt=\"\\frac{x+y}{y+z}\"></li>\n<li>分式表示，符号：<code>&#123;分子&#125; \\voer &#123;分母&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%7Bx+y%7D%20%5Cover%20%7By+z%7D\" alt=\"{x+y} \\over {y+z}\"></li>\n<li>绝对值表示，符号：<code>||</code>，如：<img src=\"https://math.jianshu.com/math?formula=%7Cx+y%7C\" alt=\"|x+y|\"></li>\n</ol>\n<h1 id=\"十四、高级运算\"><a href=\"#十四、高级运算\" class=\"headerlink\" title=\"十四、高级运算\"></a>十四、高级运算</h1><ol>\n<li>平均数运算，符号：<code>\\overline&#123;算式&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Coverline%7Bxyz%7D\" alt=\"\\overline{xyz}\"></li>\n<li>开二次方运算，符号：<code>\\sqrt</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Csqrt%20x\" alt=\"\\sqrt x\"></li>\n<li>开方运算，符号：<code>\\sqrt[开方数]&#123;被开方数&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Csqrt%5B3%5D%7Bx+y%7D\" alt=\"\\sqrt[3]{x+y}\"></li>\n<li>对数运算，符号：<code>\\log</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Clog(x)\" alt=\"\\log(x)\"></li>\n<li>极限运算，符号：<code>\\lim</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Clim%5E%7Bx%20%5Cto%20%5Cinfty%7D_%7By%20%5Cto%200%7D%7B%5Cfrac%7Bx%7D%7By%7D%7D\" alt=\"\\lim^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}}\"></li>\n<li>极限运算，符号：<code>\\displaystyle \\lim</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cdisplaystyle%20%5Clim%5E%7Bx%20%5Cto%20%5Cinfty%7D_%7By%20%5Cto%200%7D%7B%5Cfrac%7Bx%7D%7By%7D%7D\" alt=\"\\displaystyle \\lim^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}}\"></li>\n<li>求和运算，符号：<code>\\sum</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Csum%5E%7Bx%20%5Cto%20%5Cinfty%7D_%7By%20%5Cto%200%7D%7B%5Cfrac%7Bx%7D%7By%7D%7D\" alt=\"\\sum^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}}\"></li>\n<li>求和运算，符号：<code>\\displaystyle \\sum</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cdisplaystyle%20%5Csum%5E%7Bx%20%5Cto%20%5Cinfty%7D_%7By%20%5Cto%200%7D%7B%5Cfrac%7Bx%7D%7By%7D%7D\" alt=\"\\displaystyle \\sum^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}}\"></li>\n<li>积分运算，符号：<code>\\int</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cint%5E%7B%5Cinfty%7D_%7B0%7D%7Bxdx%7D\" alt=\"\\int^{\\infty}_{0}{xdx}\"></li>\n<li>积分运算，符号：<code>\\displaystyle \\int</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cdisplaystyle%20%5Cint%5E%7B%5Cinfty%7D_%7B0%7D%7Bxdx%7D\" alt=\"\\displaystyle \\int^{\\infty}_{0}{xdx}\"></li>\n<li>微分运算，符号：<code>\\partial</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cfrac%7B%5Cpartial%20x%7D%7B%5Cpartial%20y%7D\" alt=\"\\frac{\\partial x}{\\partial y}\"></li>\n<li>矩阵表示，符号：<code>\\begin&#123;matrix&#125; \\end&#123;matrix&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cleft%5B%20%5Cbegin%7Bmatrix%7D%201%20&2%20&%5Ccdots%20&4%5C5%20&6%20&%5Ccdots%20&8%5C%5Cvdots%20&%5Cvdots%20&%5Cddots%20&%5Cvdots%5C13%20&14%20&%5Ccdots%20&16%5Cend%7Bmatrix%7D%20%5Cright%5D\" alt=\"\\left[ \\begin{matrix} 1 &amp;2 &amp;\\cdots &amp;4\\5 &amp;6 &amp;\\cdots &amp;8\\\\vdots &amp;\\vdots &amp;\\ddots &amp;\\vdots\\13 &amp;14 &amp;\\cdots &amp;16\\end{matrix} \\right]\"></li>\n</ol>\n<h1 id=\"十五、-逻辑运算\"><a href=\"#十五、-逻辑运算\" class=\"headerlink\" title=\"十五、 逻辑运算\"></a>十五、 逻辑运算</h1><ol>\n<li>等于运算，符号：<code>=</code>，如：<img src=\"https://math.jianshu.com/math?formula=x+y=z\" alt=\"x+y=z\"></li>\n<li>大于运算，符号：<code>&gt;</code>，如：<img src=\"https://math.jianshu.com/math?formula=x+y%3Ez\" alt=\"x+y&gt;z\"></li>\n<li>小于运算，符号：<code>&lt;</code>，如：<img src=\"https://math.jianshu.com/math?formula=x+y%3Cz\" alt=\"x+y&lt;z\"></li>\n<li>大于等于运算，符号：<code>\\geq</code>，如：<img src=\"https://math.jianshu.com/math?formula=x+y%20%5Cgeq%20z\" alt=\"x+y \\geq z\"></li>\n<li>小于等于运算，符号：<code>\\leq</code>，如：<img src=\"https://math.jianshu.com/math?formula=x+y%20%5Cleq%20z\" alt=\"x+y \\leq z\"></li>\n<li>不等于运算，符号：<code>\\neq</code>，如：<img src=\"https://math.jianshu.com/math?formula=x+y%20%5Cneq%20z\" alt=\"x+y \\neq z\"></li>\n<li>不大于等于运算，符号：<code>\\ngeq</code>，如：<img src=\"https://math.jianshu.com/math?formula=x+y%20%5Cngeq%20z\" alt=\"x+y \\ngeq z\"></li>\n<li>不大于等于运算，符号：<code>\\not\\geq</code>，如：<img src=\"https://math.jianshu.com/math?formula=x+y%20%5Cnot%5Cgeq%20z\" alt=\"x+y \\not\\geq z\"></li>\n<li>不小于等于运算，符号：<code>\\nleq</code>，如：<img src=\"https://math.jianshu.com/math?formula=x+y%20%5Cnleq%20z\" alt=\"x+y \\nleq z\"></li>\n<li>不小于等于运算，符号：<code>\\not\\leq</code>，如：<img src=\"https://math.jianshu.com/math?formula=x+y%20%5Cnot%5Cleq%20z\" alt=\"x+y \\not\\leq z\"></li>\n<li>约等于运算，符号：<code>\\approx</code>，如：<img src=\"https://math.jianshu.com/math?formula=x+y%20%5Capprox%20z\" alt=\"x+y \\approx z\"></li>\n<li>恒定等于运算，符号：<code>\\equiv</code>，如：<img src=\"https://math.jianshu.com/math?formula=x+y%20%5Cequiv%20z\" alt=\"x+y \\equiv z\"></li>\n</ol>\n<h1 id=\"十六、集合运算\"><a href=\"#十六、集合运算\" class=\"headerlink\" title=\"十六、集合运算\"></a>十六、集合运算</h1><ol>\n<li>属于运算，符号：<code>\\in</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Cin%20y\" alt=\"x \\in y\"></li>\n<li>不属于运算，符号：<code>\\notin</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Cnotin%20y\" alt=\"x \\notin y\"></li>\n<li>不属于运算，符号：<code>\\not\\in</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Cnot%5Cin%20y\" alt=\"x \\not\\in y\"></li>\n<li>子集运算，符号：<code>\\subset</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Csubset%20y\" alt=\"x \\subset y\"></li>\n<li>子集运算，符号：<code>\\supset</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Csupset%20y\" alt=\"x \\supset y\"></li>\n<li>真子集运算，符号：<code>\\subseteq</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Csubseteq%20y\" alt=\"x \\subseteq y\"></li>\n<li>非真子集运算，符号：<code>\\subsetneq</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Csubsetneq%20y\" alt=\"x \\subsetneq y\"></li>\n<li>真子集运算，符号：<code>\\supseteq</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Csupseteq%20y\" alt=\"x \\supseteq y\"></li>\n<li>非真子集运算，符号：<code>\\supsetneq</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Csupsetneq%20y\" alt=\"x \\supsetneq y\"></li>\n<li>非子集运算，符号：<code>\\not\\subset</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Cnot%5Csubset%20y\" alt=\"x \\not\\subset y\"></li>\n<li>非子集运算，符号：<code>\\not\\supset</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Cnot%5Csupset%20y\" alt=\"x \\not\\supset y\"></li>\n<li>并集运算，符号：<code>\\cup</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Ccup%20y\" alt=\"x \\cup y\"></li>\n<li>交集运算，符号：<code>\\cap</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Ccap%20y\" alt=\"x \\cap y\"></li>\n<li>差集运算，符号：<code>\\setminus</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Csetminus%20y\" alt=\"x \\setminus y\"></li>\n<li>同或运算，符号：<code>\\bigodot</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Cbigodot%20y\" alt=\"x \\bigodot y\"></li>\n<li>同与运算，符号：<code>\\bigotimes</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Cbigotimes%20y\" alt=\"x \\bigotimes y\"></li>\n<li>实数集合，符号：<code>\\mathbb&#123;R&#125;</code>，如：<code>\\mathbb&#123;R&#125;</code></li>\n<li>自然数集合，符号：<code>\\mathbb&#123;Z&#125;</code>，如：<code>\\mathbb&#123;Z&#125;</code></li>\n<li>空集，符号：<code>\\emptyset</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cemptyset\" alt=\"\\emptyset\"></li>\n</ol>\n<h1 id=\"十七、数学符号\"><a href=\"#十七、数学符号\" class=\"headerlink\" title=\"十七、数学符号\"></a>十七、数学符号</h1><ol>\n<li>无穷，符号：<code>\\infty</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cinfty\" alt=\"\\infty\"></li>\n<li>虚数，符号：<code>\\imath</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cimath\" alt=\"\\imath\"></li>\n<li>虚数，符号：<code>\\jmath</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cjmath\" alt=\"\\jmath\"></li>\n<li>数学符号，符号<code>\\hat&#123;a&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Chat%7Ba%7D\" alt=\"\\hat{a}\"></li>\n<li>数学符号，符号<code>\\check&#123;a&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Ccheck%7Ba%7D\" alt=\"\\check{a}\"></li>\n<li>数学符号，符号<code>\\breve&#123;a&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cbreve%7Ba%7D\" alt=\"\\breve{a}\"></li>\n<li>数学符号，符号<code>\\tilde&#123;a&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Ctilde%7Ba%7D\" alt=\"\\tilde{a}\"></li>\n<li>数学符号，符号<code>\\bar&#123;a&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cbar%7Ba%7D\" alt=\"\\bar{a}\"></li>\n<li>矢量符号，符号<code>\\vec&#123;a&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cvec%7Ba%7D\" alt=\"\\vec{a}\"></li>\n<li>数学符号，符号<code>\\acute&#123;a&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cacute%7Ba%7D\" alt=\"\\acute{a}\"></li>\n<li>数学符号，符号<code>\\grave&#123;a&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cgrave%7Ba%7D\" alt=\"\\grave{a}\"></li>\n<li>数学符号，符号<code>\\mathring&#123;a&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cmathring%7Ba%7D\" alt=\"\\mathring{a}\"></li>\n<li>一阶导数符号，符号<code>\\dot&#123;a&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cdot%7Ba%7D\" alt=\"\\dot{a}\"></li>\n<li>二阶导数符号，符号<code>\\ddot&#123;a&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cddot%7Ba%7D\" alt=\"\\ddot{a}\"></li>\n<li>上箭头，符号：<code>\\uparrow</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cuparrow\" alt=\"\\uparrow\"></li>\n<li>上箭头，符号：<code>\\Uparrow</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5CUparrow\" alt=\"\\Uparrow\"></li>\n<li>下箭头，符号：<code>\\downarrow</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cdownarrow\" alt=\"\\downarrow\"></li>\n<li>下箭头，符号：<code>\\Downarrow</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5CDownarrow\" alt=\"\\Downarrow\"></li>\n<li>左箭头，符号：<code>\\leftarrow</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cleftarrow\" alt=\"\\leftarrow\"></li>\n<li>左箭头，符号：<code>\\Leftarrow</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5CLeftarrow\" alt=\"\\Leftarrow\"></li>\n<li>右箭头，符号：<code>\\rightarrow</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Crightarrow\" alt=\"\\rightarrow\"></li>\n<li>右箭头，符号：<code>\\Rightarrow</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5CRightarrow\" alt=\"\\Rightarrow\"></li>\n<li>底端对齐的省略号，符号：<code>\\ldots</code>，如：<img src=\"https://math.jianshu.com/math?formula=1,2,%5Cldots,n\" alt=\"1,2,\\ldots,n\"></li>\n<li>中线对齐的省略号，符号：<code>\\cdots</code>，如：<img src=\"https://math.jianshu.com/math?formula=x_1%5E2%20+%20x_2%5E2%20+%20%5Ccdots%20+%20x_n%5E2\" alt=\"x_1^2 + x_2^2 + \\cdots + x_n^2\"></li>\n<li>竖直对齐的省略号，符号：<code>\\vdots</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cvdots\" alt=\"\\vdots\"></li>\n<li>斜对齐的省略号，符号：<code>\\ddots</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cddots\" alt=\"\\ddots\"></li>\n</ol>\n<h1 id=\"十八、矩阵\"><a href=\"#十八、矩阵\" class=\"headerlink\" title=\"十八、矩阵\"></a>十八、矩阵</h1><p>使用<code>\\begin&#123;matrix&#125;…\\end&#123;matrix&#125;</code>这样的形式来表示矩阵，在<code>\\begin</code> 与<code>\\end</code>之间加入矩阵中的元素即可。矩阵的行之间使用<code>\\\\</code>分隔，列之间使用<code>&amp;</code>分隔，例如:</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$$</span></span><br><span class=\"line\">\\<span class=\"keyword\">begin</span>&#123;matrix&#125;</span><br><span class=\"line\"><span class=\"number\">1</span> &amp; x &amp; x^<span class=\"number\">2</span> \\\\</span><br><span class=\"line\"><span class=\"number\">1</span> &amp; y &amp; y^<span class=\"number\">2</span> \\\\</span><br><span class=\"line\"><span class=\"number\">1</span> &amp; z &amp; z^<span class=\"number\">2</span> \\\\</span><br><span class=\"line\">\\<span class=\"keyword\">end</span>&#123;matrix&#125;</span><br><span class=\"line\"><span class=\"variable\">$$</span></span><br></pre></td></tr></table></figure>\n\n<p>得到：<br><img src=\"https://math.jianshu.com/math?formula=%5Cbegin%7Bmatrix%7D%201%20&%20x%20&%20x%5E2%20%5C%5C%201%20&%20y%20&%20y%5E2%20%5C%5C%201%20&%20z%20&%20z%5E2%20%5C%5C%20%5Cend%7Bmatrix%7D\" alt=\"\\begin{matrix} 1 &amp; x &amp; x^2 \\\\ 1 &amp; y &amp; y^2 \\\\ 1 &amp; z &amp; z^2 \\\\ \\end{matrix}\"></p>\n<h3 id=\"1-括号\"><a href=\"#1-括号\" class=\"headerlink\" title=\"1. 括号\"></a>1. 括号</h3><p>如果要对矩阵加括号，可以像上文中提到的一样，使用<code>\\left</code>与<code>\\right</code> 配合表示括号符号。也可以使用特殊的matrix 。即替换<code>\\begin&#123;matrix&#125;…\\end&#123;matrix&#125; 中matrix 为pmatrix ，bmatrix ，Bmatrix ，vmatrix , Vmatrix</code> 。<br><code>pmatrix$\\begin&#123;pmatrix&#125;1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end&#123;pmatrix&#125;$</code>:pmatrix<img src=\"https://math.jianshu.com/math?formula=%5Cbegin%7Bpmatrix%7D1%20&%202%20%5C%5C%203%20&%204%5C%5C%20%5Cend%7Bpmatrix%7D\" alt=\"\\begin{pmatrix}1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end{pmatrix}\"><br><code>bmatrix$\\begin&#123;bmatrix&#125;1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end&#123;bmatrix&#125;$</code> :bmatrix<img src=\"https://math.jianshu.com/math?formula=%5Cbegin%7Bbmatrix%7D1%20&%202%20%5C%5C%203%20&%204%5C%5C%20%5Cend%7Bbmatrix%7D\" alt=\"\\begin{bmatrix}1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end{bmatrix}\"><br><code>Bmatrix$\\begin&#123;Bmatrix&#125;1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end&#123;Bmatrix&#125;$</code> :Bmatrix<img src=\"https://math.jianshu.com/math?formula=%5Cbegin%7BBmatrix%7D1%20&%202%20%5C%5C%203%20&%204%5C%5C%20%5Cend%7BBmatrix%7D\" alt=\"\\begin{Bmatrix}1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end{Bmatrix}\"><br><code>vmatrix$\\begin&#123;vmatrix&#125;1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end&#123;vmatrix&#125;$</code> :vmatrix<img src=\"https://math.jianshu.com/math?formula=%5Cbegin%7Bvmatrix%7D1%20&%202%20%5C%5C%203%20&%204%5C%5C%20%5Cend%7Bvmatrix%7D\" alt=\"\\begin{vmatrix}1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end{vmatrix}\"><br><code>Vmatrix$\\begin&#123;Vmatrix&#125;1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end&#123;Vmatrix&#125;$</code> :Vmatrix<img src=\"https://math.jianshu.com/math?formula=%5Cbegin%7BVmatrix%7D1%20&%202%20%5C%5C%203%20&%204%5C%5C%20%5Cend%7BVmatrix%7D\" alt=\"\\begin{Vmatrix}1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end{Vmatrix}\"><br>元素省略:<br>可以使用\\cdots ：⋯，\\ddots：⋱ ，\\vdots：⋮ 来省略矩阵中的元素，如：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$$</span></span><br><span class=\"line\">\\<span class=\"keyword\">begin</span>&#123;pmatrix&#125;</span><br><span class=\"line\"><span class=\"number\">1</span>&amp;a_1&amp;a_1^<span class=\"number\">2</span>&amp;\\cdots&amp;a_1^n\\\\</span><br><span class=\"line\"><span class=\"number\">1</span>&amp;a_2&amp;a_2^<span class=\"number\">2</span>&amp;\\cdots&amp;a_2^n\\\\</span><br><span class=\"line\">\\vdots&amp;\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\</span><br><span class=\"line\"><span class=\"number\">1</span>&amp;a_m&amp;a_m^<span class=\"number\">2</span>&amp;\\cdots&amp;a_m^n\\\\</span><br><span class=\"line\">\\<span class=\"keyword\">end</span>&#123;pmatrix&#125;</span><br><span class=\"line\"><span class=\"variable\">$$</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>表示：<br><img src=\"https://math.jianshu.com/math?formula=%5Cbegin%7Bpmatrix%7D%201&a_1&a_1%5E2&%5Ccdots&a_1%5En%5C%5C%201&a_2&a_2%5E2&%5Ccdots&a_2%5En%5C%5C%20%5Cvdots&%5Cvdots&%5Cvdots&%5Cddots&%5Cvdots%5C%5C%201&a_m&a_m%5E2&%5Ccdots&a_m%5En%5C%5C%20%5Cend%7Bpmatrix%7D\" alt=\"\\begin{pmatrix} 1&amp;a_1&amp;a_1^2&amp;\\cdots&amp;a_1^n\\\\ 1&amp;a_2&amp;a_2^2&amp;\\cdots&amp;a_2^n\\\\ \\vdots&amp;\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\ 1&amp;a_m&amp;a_m^2&amp;\\cdots&amp;a_m^n\\\\ \\end{pmatrix}\"></p>\n<h3 id=\"2-增广矩阵\"><a href=\"#2-增广矩阵\" class=\"headerlink\" title=\"2. 增广矩阵\"></a>2. 增广矩阵</h3><p>增广矩阵需要使用前面的表格中使用到的<code>\\begin&#123;array&#125; ... \\end&#123;array&#125;</code>来实现。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$$</span><br><span class=\"line\">\\left[  \\begin&#123;array&#125;  &#123;c c <span class=\"operator\">|</span> c&#125; <span class=\"operator\">%</span>这里的c表示数组中元素对其方式：c居中<span class=\"operator\">、</span>r右对齐<span class=\"operator\">、</span>l左对齐，竖线表示<span class=\"number\">2</span><span class=\"operator\">、</span><span class=\"number\">3</span>列间插入竖线</span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"operator\">&amp;</span> <span class=\"number\">2</span> <span class=\"operator\">&amp;</span> <span class=\"number\">3</span> \\\\</span><br><span class=\"line\">\\hline <span class=\"operator\">%</span>插入横线，如果去掉\\hline就是增广矩阵</span><br><span class=\"line\"><span class=\"number\">4</span> <span class=\"operator\">&amp;</span> <span class=\"number\">5</span> <span class=\"operator\">&amp;</span> <span class=\"number\">6</span></span><br><span class=\"line\">\\end&#123;array&#125;  \\right]</span><br><span class=\"line\">$$</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>显示为：<br><img src=\"https://math.jianshu.com/math?formula=%5Cleft%5B%20%5Cbegin%7Barray%7D%20%7Bc%20c%20%7C%20c%7D%201%20&%202%20&%203%20%5C%5C%20%5Chline%204%20&%205%20&%206%20%5Cend%7Barray%7D%20%5Cright%5D\" alt=\"\\left[ \\begin{array} {c c | c} 1 &amp; 2 &amp; 3 \\\\ \\hline 4 &amp; 5 &amp; 6 \\end{array} \\right]\"></p>\n<h1 id=\"二十、公式标记与引用\"><a href=\"#二十、公式标记与引用\" class=\"headerlink\" title=\"二十、公式标记与引用\"></a>二十、公式标记与引用</h1><p>使用<code>\\tag&#123;yourtag&#125;</code>来标记公式，如<code>$$a=x^2-y^3\\tag&#123;1&#125;$$</code>显示为：<br><img src=\"https://math.jianshu.com/math?formula=a=x%5E2-y%5E3%5Ctag%7B1%7D\" alt=\"a=x^2-y^3\\tag{1}\"></p>\n<h1 id=\"二十一、字体\"><a href=\"#二十一、字体\" class=\"headerlink\" title=\"二十一、字体\"></a>二十一、字体</h1><h3 id=\"1-黑板粗体字\"><a href=\"#1-黑板粗体字\" class=\"headerlink\" title=\"1.黑板粗体字\"></a>1.黑板粗体字</h3><p>此字体经常用来表示代表实数、整数、有理数、复数的大写字母。<br><code>$\\mathbb ABCDEF$</code>：<img src=\"https://math.jianshu.com/math?formula=%5Cmathbb%20ABCDEF\" alt=\"\\mathbb ABCDEF\"><br><code>$\\Bbb ABCDEF$</code>：<img src=\"https://math.jianshu.com/math?formula=%5CBbb%20ABCDEF\" alt=\"\\Bbb ABCDEF\"></p>\n<h3 id=\"3-黑体字\"><a href=\"#3-黑体字\" class=\"headerlink\" title=\"3.黑体字\"></a>3.黑体字</h3><p><code>$\\mathbf ABCDEFGHIJKLMNOPQRSTUVWXYZ$</code>:<img src=\"https://math.jianshu.com/math?formula=%5Cmathbf%20ABCDEFGHIJKLMNOPQRSTUVWXYZ\" alt=\"\\mathbf ABCDEFGHIJKLMNOPQRSTUVWXYZ\"><br><code>$\\mathbf abcdefghijklmnopqrstuvwxyz$</code>:<img src=\"https://math.jianshu.com/math?formula=%5Cmathbf%20abcdefghijklmnopqrstuvwxyz\" alt=\"\\mathbf abcdefghijklmnopqrstuvwxyz\"></p>\n<h3 id=\"3-打印机字体\"><a href=\"#3-打印机字体\" class=\"headerlink\" title=\"3.打印机字体\"></a>3.打印机字体</h3><p><code>$\\mathtt ABCDEFGHIJKLMNOPQRSTUVWXYZ$</code>:<img src=\"https://math.jianshu.com/math?formula=%5Cmathtt%20ABCDEFGHIJKLMNOPQRSTUVWXYZ\" alt=\"\\mathtt ABCDEFGHIJKLMNOPQRSTUVWXYZ\"></p>\n<h1 id=\"二十二、希腊字母\"><a href=\"#二十二、希腊字母\" class=\"headerlink\" title=\"二十二、希腊字母\"></a>二十二、希腊字母</h1><table>\n<thead>\n<tr>\n<th>字母</th>\n<th>实现</th>\n<th>字母</th>\n<th>实现</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>A</td>\n<td><code>A</code></td>\n<td>α</td>\n<td><code>\\alhpa</code></td>\n</tr>\n<tr>\n<td>B</td>\n<td><code>B</code></td>\n<td>β</td>\n<td><code>\\beta</code></td>\n</tr>\n<tr>\n<td>Γ</td>\n<td><code>\\Gamma</code></td>\n<td>γ</td>\n<td><code>\\gamma</code></td>\n</tr>\n<tr>\n<td>Δ</td>\n<td><code>\\Delta</code></td>\n<td>δ</td>\n<td><code>\\delta</code></td>\n</tr>\n<tr>\n<td>E</td>\n<td><code>E</code></td>\n<td>ϵ</td>\n<td><code>\\epsilon</code></td>\n</tr>\n<tr>\n<td>Z</td>\n<td><code>Z</code></td>\n<td>ζ</td>\n<td><code>\\zeta</code></td>\n</tr>\n<tr>\n<td>H</td>\n<td><code>H</code></td>\n<td>η</td>\n<td><code>\\eta</code></td>\n</tr>\n<tr>\n<td>Θ</td>\n<td><code>\\Theta</code></td>\n<td>θ</td>\n<td><code>\\theta</code></td>\n</tr>\n<tr>\n<td>I</td>\n<td><code>I</code></td>\n<td>ι</td>\n<td><code>\\iota</code></td>\n</tr>\n<tr>\n<td>K</td>\n<td><code>K</code></td>\n<td>κ</td>\n<td><code>\\kappa</code></td>\n</tr>\n<tr>\n<td>Λ</td>\n<td><code>\\Lambda</code></td>\n<td>λ</td>\n<td><code>\\lambda</code></td>\n</tr>\n<tr>\n<td>M</td>\n<td><code>M</code></td>\n<td>μ</td>\n<td><code>\\mu</code></td>\n</tr>\n<tr>\n<td>N</td>\n<td><code>N</code></td>\n<td>ν</td>\n<td><code>\\nu</code></td>\n</tr>\n<tr>\n<td>Ξ</td>\n<td><code>\\Xi</code></td>\n<td>ξ</td>\n<td><code>\\xi</code></td>\n</tr>\n<tr>\n<td>O</td>\n<td><code>O</code></td>\n<td>ο</td>\n<td><code>\\omicron</code></td>\n</tr>\n<tr>\n<td>Π</td>\n<td><code>\\Pi</code></td>\n<td>π</td>\n<td><code>\\pi</code></td>\n</tr>\n<tr>\n<td>P</td>\n<td><code>P</code></td>\n<td>ρ</td>\n<td><code>\\rho</code></td>\n</tr>\n<tr>\n<td>Σ</td>\n<td><code>\\Sigma</code></td>\n<td>σ</td>\n<td><code>\\sigma</code></td>\n</tr>\n<tr>\n<td>T</td>\n<td><code>T</code></td>\n<td>τ</td>\n<td><code>\\tau</code></td>\n</tr>\n<tr>\n<td>Υ</td>\n<td><code>\\Upsilon</code></td>\n<td>υ</td>\n<td><code>\\upsilon</code></td>\n</tr>\n<tr>\n<td>Φ</td>\n<td><code>\\Phi</code></td>\n<td>ϕ</td>\n<td><code>\\phi</code></td>\n</tr>\n<tr>\n<td>X</td>\n<td><code>X</code></td>\n<td>χ</td>\n<td><code>\\chi</code></td>\n</tr>\n<tr>\n<td>Ψ</td>\n<td><code>\\Psi</code></td>\n<td>ψ</td>\n<td><code>\\psi</code></td>\n</tr>\n<tr>\n<td>Ω</td>\n<td><code>\\v</code></td>\n<td>ω</td>\n<td><code>\\omega</code></td>\n</tr>\n<tr>\n<td>ε</td>\n<td><code>$\\varepsilon$</code></td>\n<td>ϑ</td>\n<td><code>$\\vartheta$</code></td>\n</tr>\n<tr>\n<td>ϖ</td>\n<td><code>$\\varpi$</code></td>\n<td>ϱ</td>\n<td><code>$\\varrho$</code></td>\n</tr>\n<tr>\n<td>ς</td>\n<td><code>$\\varsigma$</code></td>\n<td>φ</td>\n<td><code>$\\varphi$</code></td>\n</tr>\n</tbody></table>\n<p><a href=\"https://links.jianshu.com/go?to=https://blog.csdn.net/weixin_43159628/article/details/88237139\">https://blog.csdn.net/weixin_43159628&#x2F;article&#x2F;details&#x2F;88237139</a><br><a href=\"https://www.jianshu.com/p/08cbe54a5f33\">https://www.jianshu.com/p/08cbe54a5f33</a></p>\n<p>作者：无剑_君<br>链接：<a href=\"https://www.jianshu.com/p/383e8149136c\">https://www.jianshu.com/p/383e8149136c</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n","excerpt":"","more":"<p><a href=\"https://www.jianshu.com/p/383e8149136c\">Markdown数学公式语法 - 简书 (jianshu.com)</a></p>\n<h1 id=\"一、简单分类\"><a href=\"#一、简单分类\" class=\"headerlink\" title=\"一、简单分类\"></a>一、简单分类</h1><h3 id=\"1-行内公式\"><a href=\"#1-行内公式\" class=\"headerlink\" title=\"1. 行内公式\"></a>1. 行内公式</h3><p>将公式插入到本行内，符号：<code>$公式内容$</code>，如：<code>$xyz$</code><br><img src=\"https://math.jianshu.com/math?formula=xyz\" alt=\"xyz\"></p>\n<h3 id=\"2-行间公式\"><a href=\"#2-行间公式\" class=\"headerlink\" title=\"2. 行间公式\"></a>2. 行间公式</h3><p>将公式插入到新的一行内，并且居中，符号：<code>$公式内容$</code>，如：<code>$$xyz$$</code><br><img src=\"https://math.jianshu.com/math?formula=xyz\" alt=\"xyz\"></p>\n<h1 id=\"二、上标、下标与组合\"><a href=\"#二、上标、下标与组合\" class=\"headerlink\" title=\"二、上标、下标与组合\"></a>二、上标、下标与组合</h1><h3 id=\"1-上标符号，符号：-，如：-x-4\"><a href=\"#1-上标符号，符号：-，如：-x-4\" class=\"headerlink\" title=\"1. 上标符号，符号：^，如：$x^4$ \"></a>1. 上标符号，符号：<code>^</code>，如：<code>$x^4$</code> <img src=\"https://math.jianshu.com/math?formula=x%5E4\" alt=\"x^4\"></h3><h3 id=\"2-下标符号，符号：-，如：-x-1\"><a href=\"#2-下标符号，符号：-，如：-x-1\" class=\"headerlink\" title=\"2. 下标符号，符号：_，如：$x_1$ \"></a>2. 下标符号，符号：<code>_</code>，如：<code>$x_1$</code> <img src=\"https://math.jianshu.com/math?formula=x_1\" alt=\"x_1\"></h3><h3 id=\"3-组合符号，符号：-，如：\"><a href=\"#3-组合符号，符号：-，如：\" class=\"headerlink\" title=\"3. 组合符号，符号：{}，如：\"></a>3. 组合符号，符号：<code>&#123;&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%3Csup%3E%7B16%7D_%7B8%7DO%3C/sup%3E%7B2+%7D_%7B2%7D\" alt=\"&lt;sup&gt;{16}_{8}O&lt;/sup&gt;{2+}_{2}\"></h3><p>默认情况下，上、下标符号仅仅对下一个组起作用。一个组即单个字符或者使用{}（大括号） 包裹起来的内容。如果使用<code>$10^10$</code>表示的是<img src=\"https://math.jianshu.com/math?formula=10%5E10\" alt=\"10^10\">,而<code>$10^&#123;10&#125;$</code> 才可以表示为<img src=\"https://math.jianshu.com/math?formula=10%5E%7B10%7D\" alt=\"10^{10}\">。同时，大括号还能消除二义性，如：<code>$x^5^6$</code> 将得到一个错误，必须使用大括号来界定^的结合性，如:<code>$&#123;x^5&#125;^6$</code>表示的<img src=\"https://math.jianshu.com/math?formula=%7Bx%5E5%7D%5E6\" alt=\"{x^5}^6\">：或者用<code>$x^&#123;5^6&#125;$</code>表示的<img src=\"https://math.jianshu.com/math?formula=x%5E%7B5%5E6%7D\" alt=\"x^{5^6}\">。</p>\n<h1 id=\"三、括号\"><a href=\"#三、括号\" class=\"headerlink\" title=\"三、括号\"></a>三、括号</h1><h3 id=\"1-小括号与方括号\"><a href=\"#1-小括号与方括号\" class=\"headerlink\" title=\"1.小括号与方括号\"></a>1.小括号与方括号</h3><p>用原始的( ) ，[ ] 即可，如<code>(2+3)[4+4]</code>可表示：<img src=\"https://math.jianshu.com/math?formula=(2+3)%5B4+4%5D\" alt=\"(2+3)[4+4]\">。<br>使用\\left(或\\right)使符号大小与邻近的公式相适应（该语句适用于所有括号类型），如\\left(\\frac{x}{y}\\right)可表示<img src=\"https://math.jianshu.com/math?formula=%5Cleft(%5Cfrac%7Bx%7D%7By%7D%5Cright)\" alt=\"\\left(\\frac{x}{y}\\right)\"></p>\n<h3 id=\"2-大括号\"><a href=\"#2-大括号\" class=\"headerlink\" title=\"2. 大括号\"></a>2. 大括号</h3><p>由于大括号{} 被用于分组，因此需要使用{和}表示大括号，也可以使用\\lbrace 和\\rbrace来表示。如{ab}或\\lbrace ab\\rbrace表示:<img src=\"https://math.jianshu.com/math?formula=%5C%7Bab%5C%7D\" alt=\"\\{ab\\}\"></p>\n<h3 id=\"3-尖括号\"><a href=\"#3-尖括号\" class=\"headerlink\" title=\"3. 尖括号\"></a>3. 尖括号</h3><p>区分于小于号和大于号，使用\\langle 和\\rangle 表示左尖括号和右尖括号。如\\langle x \\rangle表示：<img src=\"https://math.jianshu.com/math?formula=%5Clangle%20x%20%5Crangle\" alt=\"\\langle x \\rangle\"></p>\n<h1 id=\"三、取整\"><a href=\"#三、取整\" class=\"headerlink\" title=\"三、取整\"></a>三、取整</h1><h3 id=\"1-上取整\"><a href=\"#1-上取整\" class=\"headerlink\" title=\"1. 上取整\"></a>1. 上取整</h3><p>使用\\lceil 和 \\rceil 表示。 如，\\lceil x \\rceil表示为：<img src=\"https://math.jianshu.com/math?formula=%5Clceil%20x%20%5Crceil\" alt=\"\\lceil x \\rceil\"></p>\n<h3 id=\"2-下取整\"><a href=\"#2-下取整\" class=\"headerlink\" title=\"2. 下取整\"></a>2. 下取整</h3><p>使用\\lfloor 和 \\rfloor 表示。如，\\lfloor x \\rfloor表示为:<img src=\"https://math.jianshu.com/math?formula=%5Clfloor%20x%20%5Crfloor\" alt=\"\\lfloor x \\rfloor\"></p>\n<h1 id=\"四、求和-积分-连乘\"><a href=\"#四、求和-积分-连乘\" class=\"headerlink\" title=\"四、求和\\积分\\连乘\"></a>四、求和\\积分\\连乘</h1><h3 id=\"1-求和\"><a href=\"#1-求和\" class=\"headerlink\" title=\"1.求和\"></a>1.求和</h3><p><code>\\sum</code> 用来表示求和符号，其下标表示求和下限，上标表示上限。如:<br><code>$\\sum_&#123;r=1&#125;^n$</code>表示：<img src=\"https://math.jianshu.com/math?formula=%5Csum_%7Br=1%7D%5En\" alt=\"\\sum_{r=1}^n\"></p>\n<h3 id=\"2-积分\"><a href=\"#2-积分\" class=\"headerlink\" title=\"2. 积分\"></a>2. 积分</h3><p><code>\\int</code> 用来表示积分符号，同样地，其上下标表示积分的上下限。如，<code>$\\int_&#123;r=1&#125;^\\infty$</code>表示:<img src=\"https://math.jianshu.com/math?formula=%5Cint_%7Br=1%7D%5E%5Cinfty\" alt=\"\\int_{r=1}^\\infty\"><br>多重积分同样使用<code>\\int</code> ，通过 i 的数量表示积分导数：<br>如：<br><code>$\\iint$</code> 表示为：<img src=\"https://math.jianshu.com/math?formula=%5Ciint\" alt=\"\\iint\"><br><code>$\\iiint$</code> 表示为：<img src=\"https://math.jianshu.com/math?formula=%5Ciiint\" alt=\"\\iiint\"></p>\n<h3 id=\"3-连乘\"><a href=\"#3-连乘\" class=\"headerlink\" title=\"3. 连乘\"></a>3. 连乘</h3><p><code>$\\prod &#123;a+b&#125;$</code> 表示：<img src=\"https://math.jianshu.com/math?formula=%5Cprod%20%7Ba+b%7D\" alt=\"\\prod {a+b}\"><br><code>$\\prod_&#123;i=1&#125;^&#123;K&#125;$</code> 表示：<img src=\"https://math.jianshu.com/math?formula=%5Cprod_%7Bi=1%7D%5E%7BK%7D\" alt=\"\\prod_{i=1}^{K}\"><br><code>$$\\prod_&#123;i=1&#125;^&#123;K&#125;$$</code>表示（注意是行间公式）：<img src=\"https://math.jianshu.com/math?formula=%5Cprod_%7Bi=1%7D%5E%7BK%7D\" alt=\"\\prod_{i=1}^{K}\"></p>\n<h3 id=\"4-其他\"><a href=\"#4-其他\" class=\"headerlink\" title=\"4. 其他\"></a>4. 其他</h3><p>与此类似的符号还有，<br><code>$\\prod$</code> ：<img src=\"https://math.jianshu.com/math?formula=%5Cprod\" alt=\"\\prod\"><br><code>$\\bigcup$</code>：<img src=\"https://math.jianshu.com/math?formula=%5Cbigcup\" alt=\"\\bigcup\"><br><code>$\\bigcap$</code> ：<img src=\"https://math.jianshu.com/math?formula=%5Cbigcap\" alt=\"\\bigcap\"><br><code>$arg\\,\\max_&#123;c_k&#125;$</code>：<img src=\"https://math.jianshu.com/math?formula=arg%5C,%5Cmax_%7Bc_k%7D\" alt=\"arg\\,\\max_{c_k}\"><br><code>$arg\\,\\min_&#123;c_k&#125;$</code>：<img src=\"https://math.jianshu.com/math?formula=arg,%5Cmin_%7Bc_k%7D\" alt=\"arg,\\min_{c_k}\"><br><code>$\\mathop &#123;argmin&#125;_&#123;c_k&#125;$</code>：<img src=\"https://math.jianshu.com/math?formula=%5Cmathop%20%7Bargmin%7D_%7Bc_k%7D\" alt=\"\\mathop {argmin}_{c_k}\"><br><code>$\\mathop &#123;argmax&#125;_&#123;c_k&#125;$</code>：<img src=\"https://math.jianshu.com/math?formula=%5Cmathop%20%7Bargmax%7D_%7Bc_k%7D\" alt=\"\\mathop {argmax}_{c_k}\"><br><code>$\\max_&#123;c_k&#125;$</code>：<img src=\"https://math.jianshu.com/math?formula=%5Cmax_%7Bc_k%7D\" alt=\"\\max_{c_k}\"><br><code>$\\min_&#123;c_k&#125;$</code>：<img src=\"https://math.jianshu.com/math?formula=%5Cmin_%7Bc_k%7D\" alt=\"\\min_{c_k}\"></p>\n<h1 id=\"五、分式与根式\"><a href=\"#五、分式与根式\" class=\"headerlink\" title=\"五、分式与根式\"></a>五、分式与根式</h1><h3 id=\"1-分式\"><a href=\"#1-分式\" class=\"headerlink\" title=\"1. 分式\"></a>1. 分式</h3><p>第一种，使用<code>\\frac ab</code>，表示为:<img src=\"https://math.jianshu.com/math?formula=%5Cfrac%20ab\" alt=\"\\frac ab\"> ，<code>\\frac</code>作用于其后的两个组a ，b ，结果为。如果你的分子或分母不是单个字符，请使用{…}来分组，比如<code>$\\frac &#123;a+c+1&#125;&#123;b+c+2&#125;$</code>表示:<img src=\"https://math.jianshu.com/math?formula=%5Cfrac%20%7Ba+c+1%7D%7Bb+c+2%7D\" alt=\"\\frac {a+c+1}{b+c+2}\"><br>第二种，使用\\over来分隔一个组的前后两部分，如<code>$&#123;a+1\\over b+1&#125;$</code>：<img src=\"https://math.jianshu.com/math?formula=%7Ba+1%5Cover%20b+1%7D\" alt=\"{a+1\\over b+1}\"></p>\n<h3 id=\"2-连分数\"><a href=\"#2-连分数\" class=\"headerlink\" title=\"2. 连分数\"></a>2. 连分数</h3><p>书写连分数表达式时，请使用<code>\\cfrac</code>代替<code>\\frac</code>或者<code>\\over</code>两者效果对比如下：<br><code>\\frac</code> 表示如下：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$$</span>x=a_0 + \\frac &#123;<span class=\"number\">1</span>^<span class=\"number\">2</span>&#125;&#123;a_1 + \\frac &#123;<span class=\"number\">2</span>^<span class=\"number\">2</span>&#125;&#123;a_2 + \\frac &#123;<span class=\"number\">3</span>^<span class=\"number\">2</span>&#125;&#123;a_3 + \\frac &#123;<span class=\"number\">4</span>^<span class=\"number\">2</span>&#125;&#123;a_4 + ...&#125;&#125;&#125;&#125;<span class=\"variable\">$$</span></span><br></pre></td></tr></table></figure>\n\n<p>显示如下：<br><img src=\"https://math.jianshu.com/math?formula=x=a_0%20+%20%5Cfrac%20%7B1%5E2%7D%7Ba_1%20+%20%5Cfrac%20%7B2%5E2%7D%7Ba_2%20+%20%5Cfrac%20%7B3%5E2%7D%7Ba_3%20+%20%5Cfrac%20%7B4%5E2%7D%7Ba_4%20+%20...%7D%7D%7D%7D\" alt=\"x=a_0 + \\frac {1^2}{a_1 + \\frac {2^2}{a_2 + \\frac {3^2}{a_3 + \\frac {4^2}{a_4 + ...}}}}\"><br><code>\\cfrac</code>表示如下：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$$</span>x=a_0 + \\cfrac &#123;<span class=\"number\">1</span>^<span class=\"number\">2</span>&#125;&#123;a_1 + \\cfrac &#123;<span class=\"number\">2</span>^<span class=\"number\">2</span>&#125;&#123;a_2 + \\cfrac &#123;<span class=\"number\">3</span>^<span class=\"number\">2</span>&#125;&#123;a_3 + \\cfrac &#123;<span class=\"number\">4</span>^<span class=\"number\">2</span>&#125;&#123;a_4 + ...&#125;&#125;&#125;&#125;<span class=\"variable\">$$</span></span><br></pre></td></tr></table></figure>\n\n<p>显示如下：<br><img src=\"https://math.jianshu.com/math?formula=x=a_0%20+%20%5Ccfrac%20%7B1%5E2%7D%7Ba_1%20+%20%5Ccfrac%20%7B2%5E2%7D%7Ba_2%20+%20%5Ccfrac%20%7B3%5E2%7D%7Ba_3%20+%20%5Ccfrac%20%7B4%5E2%7D%7Ba_4%20+%20...%7D%7D%7D%7D\" alt=\"x=a_0 + \\cfrac {1^2}{a_1 + \\cfrac {2^2}{a_2 + \\cfrac {3^2}{a_3 + \\cfrac {4^2}{a_4 + ...}}}}\"></p>\n<h3 id=\"3-根式\"><a href=\"#3-根式\" class=\"headerlink\" title=\"3.根式\"></a>3.根式</h3><p>根式使用<code>\\sqrt</code> 来表示。<br>如开4次方：<code>$\\sqrt[4]&#123;\\frac xy&#125;$</code> 可表示：<img src=\"https://math.jianshu.com/math?formula=%5Csqrt%5B4%5D%7B%5Cfrac%20xy%7D\" alt=\"\\sqrt[4]{\\frac xy}\"><br>开平方：<code>$\\sqrt &#123;a+b&#125;$</code>可表示：<img src=\"https://math.jianshu.com/math?formula=%5Csqrt%20%7Ba+b%7D\" alt=\"\\sqrt {a+b}\"></p>\n<h1 id=\"六、多行表达式\"><a href=\"#六、多行表达式\" class=\"headerlink\" title=\"六、多行表达式\"></a>六、多行表达式</h1><h3 id=\"1-分类表达式\"><a href=\"#1-分类表达式\" class=\"headerlink\" title=\"1. 分类表达式\"></a>1. 分类表达式</h3><p>定义函数的时候经常需要分情况给出表达式，使用\\begin{cases}…\\end{cases} 。其中：<br>使用<code>\\\\</code> 来分类，<br>使用<code>&amp;</code>指示需要对齐的位置，<br>使用<code>\\ +space</code>表示空格。<br>如：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$$</span></span><br><span class=\"line\">f(n)</span><br><span class=\"line\">\\<span class=\"keyword\">begin</span>&#123;cases&#125;</span><br><span class=\"line\">\\cfrac n2, &amp;<span class=\"keyword\">if</span>\\ n\\ is\\ even\\\\</span><br><span class=\"line\">3n + <span class=\"number\">1</span>, &amp;<span class=\"keyword\">if</span>\\  n\\ is\\ odd</span><br><span class=\"line\">\\<span class=\"keyword\">end</span>&#123;cases&#125;</span><br><span class=\"line\"><span class=\"variable\">$$</span></span><br></pre></td></tr></table></figure>\n\n<p>表示:<br><img src=\"https://math.jianshu.com/math?formula=f(n)%20%5Cbegin%7Bcases%7D%20%5Ccfrac%20n2,%20&if%5C%20n%5C%20is%5C%20even%5C%5C%203n%20+%201,%20&if%5C%20n%5C%20is%5C%20odd%20%5Cend%7Bcases%7D\" alt=\"f(n) \\begin{cases} \\cfrac n2, &amp;if\\ n\\ is\\ even\\\\ 3n + 1, &amp;if\\ n\\ is\\ odd \\end{cases}\"><br>以及:</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$$</span></span><br><span class=\"line\">L(Y,f(X)) =</span><br><span class=\"line\">\\<span class=\"keyword\">begin</span>&#123;cases&#125;</span><br><span class=\"line\"><span class=\"number\">0</span>, &amp; \\text&#123;Y = f(X)&#125;  \\\\</span><br><span class=\"line\"><span class=\"number\">1</span>, &amp; \\text&#123;Y <span class=\"variable\">$\\</span>neq<span class=\"variable\">$ </span>f(X)&#125;</span><br><span class=\"line\">\\<span class=\"keyword\">end</span>&#123;cases&#125;</span><br><span class=\"line\"><span class=\"variable\">$$</span></span><br></pre></td></tr></table></figure>\n\n<p>表示:<br><img src=\"https://math.jianshu.com/math?formula=L(Y,f(X))%20=%20%5Cbegin%7Bcases%7D%200,%20&%20%5Ctext%7BY%20=%20f(X)%7D%20%5C%5C%201,%20&%20%5Ctext%7BY%20$%5Cneq$%20f(X)%7D%20%5Cend%7Bcases%7D\" alt=\"L(Y,f(X)) = \\begin{cases} 0, &amp; \\text{Y = f(X)} \\\\ 1, &amp; \\text{Y $\\neq$ f(X)} \\end{cases}\"></p>\n<p>如果想分类之间的垂直间隔变大，可以使用<code>\\\\[2ex]</code>代替<code>\\\\</code>来分隔不同的情况。<code>(3ex,4ex</code> 也可以用，<code>1ex</code>相当于原始距离）。如下所示：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$$</span></span><br><span class=\"line\">L(Y,f(X)) =</span><br><span class=\"line\">\\<span class=\"keyword\">begin</span>&#123;cases&#125;</span><br><span class=\"line\"><span class=\"number\">0</span>, &amp; \\text&#123;Y = f(X)&#125; \\\\[5ex]</span><br><span class=\"line\"><span class=\"number\">1</span>, &amp; \\text&#123;Y <span class=\"variable\">$\\</span>neq<span class=\"variable\">$ </span>f(X)&#125;</span><br><span class=\"line\">\\<span class=\"keyword\">end</span>&#123;cases&#125;</span><br><span class=\"line\"><span class=\"variable\">$$</span></span><br></pre></td></tr></table></figure>\n\n<p>表示：<br><img src=\"https://math.jianshu.com/math?formula=L(Y,f(X))%20=%20%5Cbegin%7Bcases%7D%200,%20&%20%5Ctext%7BY%20=%20f(X)%7D%20%5C%5C%5B5ex%5D%201,%20&%20%5Ctext%7BY%20$%5Cneq$%20f(X)%7D%20%5Cend%7Bcases%7D\" alt=\"L(Y,f(X)) = \\begin{cases} 0, &amp; \\text{Y = f(X)} \\[5ex] 1, &amp; \\text{Y $\\neq$ f(X)} \\end{cases}\"></p>\n<h3 id=\"2-多行表达式\"><a href=\"#2-多行表达式\" class=\"headerlink\" title=\"2. 多行表达式\"></a>2. 多行表达式</h3><p>有时候需要将一行公式分多行进行显示。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$$</span><br><span class=\"line\">\\begin&#123;aligned&#125;</span><br><span class=\"line\">\\sqrt&#123;<span class=\"number\">37</span>&#125; &amp; = \\sqrt&#123;\\frac&#123;<span class=\"number\">73</span>^<span class=\"number\">2</span><span class=\"number\">-1</span>&#125;&#123;<span class=\"number\">12</span>^<span class=\"number\">2</span>&#125;&#125; \\\\</span><br><span class=\"line\"> &amp; = \\sqrt&#123;\\frac&#123;<span class=\"number\">73</span>^<span class=\"number\">2</span>&#125;&#123;<span class=\"number\">12</span>^<span class=\"number\">2</span>&#125;\\cdot\\frac&#123;<span class=\"number\">73</span>^<span class=\"number\">2</span><span class=\"number\">-1</span>&#125;&#123;<span class=\"number\">73</span>^<span class=\"number\">2</span>&#125;&#125; \\\\ </span><br><span class=\"line\"> &amp; = \\sqrt&#123;\\frac&#123;<span class=\"number\">73</span>^<span class=\"number\">2</span>&#125;&#123;<span class=\"number\">12</span>^<span class=\"number\">2</span>&#125;&#125;\\sqrt&#123;\\frac&#123;<span class=\"number\">73</span>^<span class=\"number\">2</span><span class=\"number\">-1</span>&#125;&#123;<span class=\"number\">73</span>^<span class=\"number\">2</span>&#125;&#125; \\\\</span><br><span class=\"line\"> &amp; = \\frac&#123;<span class=\"number\">73</span>&#125;&#123;<span class=\"number\">12</span>&#125;\\sqrt&#123;<span class=\"number\">1</span> - \\frac&#123;<span class=\"number\">1</span>&#125;&#123;<span class=\"number\">73</span>^<span class=\"number\">2</span>&#125;&#125; \\\\ </span><br><span class=\"line\"> &amp; \\approx \\frac&#123;<span class=\"number\">73</span>&#125;&#123;<span class=\"number\">12</span>&#125;\\<span class=\"built_in\">left</span>(<span class=\"number\">1</span> - \\frac&#123;<span class=\"number\">1</span>&#125;&#123;<span class=\"number\">2</span>\\cdot73^<span class=\"number\">2</span>&#125;\\right)</span><br><span class=\"line\">\\end&#123;aligned&#125;</span><br><span class=\"line\">$$</span><br></pre></td></tr></table></figure>\n\n<p>表示:<br><img src=\"https://math.jianshu.com/math?formula=%5Cbegin%7Baligned%7D%20%5Csqrt%7B37%7D%20&%20=%20%5Csqrt%7B%5Cfrac%7B73%5E2-1%7D%7B12%5E2%7D%7D%20%5C%5C%20&%20=%20%5Csqrt%7B%5Cfrac%7B73%5E2%7D%7B12%5E2%7D%5Ccdot%5Cfrac%7B73%5E2-1%7D%7B73%5E2%7D%7D%20%5C%5C%20&%20=%20%5Csqrt%7B%5Cfrac%7B73%5E2%7D%7B12%5E2%7D%7D%5Csqrt%7B%5Cfrac%7B73%5E2-1%7D%7B73%5E2%7D%7D%20%5C%5C%20&%20=%20%5Cfrac%7B73%7D%7B12%7D%5Csqrt%7B1%20-%20%5Cfrac%7B1%7D%7B73%5E2%7D%7D%20%5C%5C%20&%20%5Capprox%20%5Cfrac%7B73%7D%7B12%7D%5Cleft(1%20-%20%5Cfrac%7B1%7D%7B2%5Ccdot73%5E2%7D%5Cright)%20%5Cend%7Baligned%7D\" alt=\"\\begin{aligned} \\sqrt{37} &amp; = \\sqrt{\\frac{73^2-1}{12^2}} \\\\ &amp; = \\sqrt{\\frac{73^2}{12^2}\\cdot\\frac{73^2-1}{73^2}} \\\\ &amp; = \\sqrt{\\frac{73^2}{12^2}}\\sqrt{\\frac{73^2-1}{73^2}} \\\\ &amp; = \\frac{73}{12}\\sqrt{1 - \\frac{1}{73^2}} \\\\ &amp; \\approx \\frac{73}{12}\\left(1 - \\frac{1}{2\\cdot73^2}\\right) \\end{aligned}\"></p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$$</span></span><br><span class=\"line\">\\<span class=\"keyword\">begin</span>&#123;aligned&#125;</span><br><span class=\"line\">a&amp;=b+c-d \\\\</span><br><span class=\"line\">&amp;=e-f \\\\</span><br><span class=\"line\">&amp;=i \\\\</span><br><span class=\"line\">\\<span class=\"keyword\">end</span>&#123;aligned&#125;</span><br><span class=\"line\"><span class=\"variable\">$$</span></span><br></pre></td></tr></table></figure>\n\n<p>表示:<br><img src=\"https://math.jianshu.com/math?formula=%5Cbegin%7Baligned%7D%20a&=b+c-d%20%5C%5C%20&=e-f%20%5C%5C%20&=i%20%5C%5C%20%5Cend%7Baligned%7D\" alt=\"\\begin{aligned} a&amp;=b+c-d \\\\ &amp;=e-f \\\\ &amp;=i \\\\ \\end{aligned}\"></p>\n<p>其中<code>begin&#123;equation&#125;</code> 表示开始方程，<code>end&#123;equation&#125;</code>表示方程结束；<code>begin&#123;split&#125;</code> 表示开始多行公式，<code>end&#123;split&#125;</code> 表示结束；公式中用<code>\\\\</code> 表示回车到下一行，<code>&amp;</code> 表示对齐的位置。</p>\n<h1 id=\"七、方程组\"><a href=\"#七、方程组\" class=\"headerlink\" title=\"七、方程组\"></a>七、方程组</h1><p>使用\\begin{array}…\\end{array} 与\\left \\与\\right 配合表示方程组,如:</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$$</span></span><br><span class=\"line\">\\left \\&#123; </span><br><span class=\"line\">\\<span class=\"keyword\">begin</span>&#123;array&#125;&#123;c&#125;</span><br><span class=\"line\">a_1x+b_1y+c_1z=d_1 \\\\ </span><br><span class=\"line\">a_2x+b_2y+c_2z=d_2 \\\\ </span><br><span class=\"line\">a_3x+b_3y+c_3z=d_3</span><br><span class=\"line\">\\<span class=\"keyword\">end</span>&#123;array&#125;</span><br><span class=\"line\">\\right.</span><br><span class=\"line\"><span class=\"variable\">$$</span></span><br></pre></td></tr></table></figure>\n\n<p>表示：<br><img src=\"https://math.jianshu.com/math?formula=%5Cleft%20%5C%7B%20%5Cbegin%7Barray%7D%7Bc%7D%20a_1x+b_1y+c_1z=d_1%20%5C%5C%20a_2x+b_2y+c_2z=d_2%20%5C%5C%20a_3x+b_3y+c_3z=d_3%20%5Cend%7Barray%7D%20%5Cright.\" alt=\"\\left \\{ \\begin{array}{c} a_1x+b_1y+c_1z=d_1 \\\\ a_2x+b_2y+c_2z=d_2 \\\\ a_3x+b_3y+c_3z=d_3 \\end{array} \\right.\"></p>\n<p>注意：通常MathJax通过内部策略自己管理公式内部的空间，因此<code>a…b</code> 与<code>a…….b</code>（.表示空格）都会显示为<code>ab</code>。可以通过在<code>ab</code>间加入<code>\\</code>,增加些许间隙，<code>\\;</code>增加较宽的间隙，<code>\\quad</code> 与<code>\\qquad</code> 会增加更大的间隙。</p>\n<h1 id=\"八、特殊函数与符号\"><a href=\"#八、特殊函数与符号\" class=\"headerlink\" title=\"八、特殊函数与符号\"></a>八、特殊函数与符号</h1><h3 id=\"1-三角函数\"><a href=\"#1-三角函数\" class=\"headerlink\" title=\"1. 三角函数\"></a>1. 三角函数</h3><p><code>$\\sin x$</code> : <img src=\"https://math.jianshu.com/math?formula=%5Csin%20x\" alt=\"\\sin x\"><br><code>$\\arctan x$</code> : <img src=\"https://math.jianshu.com/math?formula=%5Carctan%20x\" alt=\"\\arctan x\"></p>\n<h3 id=\"2-比较运算符\"><a href=\"#2-比较运算符\" class=\"headerlink\" title=\"2.比较运算符\"></a>2.比较运算符</h3><p>小于<code>(\\lt )</code>：<img src=\"https://math.jianshu.com/math?formula=(%5Clt%20)\" alt=\"(\\lt )\"><br>大于<code>(\\gt )</code>：<img src=\"https://math.jianshu.com/math?formula=(%5Cgt\" alt=\"(\\gt\"><br>小于等于<code>(\\le )</code>：<img src=\"https://math.jianshu.com/math?formula=(%5Cle%20)\" alt=\"(\\le )\"><br>大于等于<code>(\\ge )</code>：<img src=\"https://math.jianshu.com/math?formula=(%5Cge%20)\" alt=\"(\\ge )\"><br>不等于<code>(\\ne )</code> :<img src=\"https://math.jianshu.com/math?formula=(%5Cne%20)\" alt=\"(\\ne )\"><br>可以在这些运算符前面加上<code>\\not</code> ，如<code>\\not\\lt</code> : <img src=\"https://math.jianshu.com/math?formula=%5Cnot%5Clt\" alt=\"\\not\\lt\"></p>\n<h3 id=\"3-集合关系与运算\"><a href=\"#3-集合关系与运算\" class=\"headerlink\" title=\"3.集合关系与运算\"></a>3.集合关系与运算</h3><p>并集<code>(\\cup)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Ccup)\" alt=\"(\\cup)\"><br>交集<code>(\\cap)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Ccap)\" alt=\"(\\cap)\"><br>差集<code>(\\setminus)</code>:<img src=\"https://math.jianshu.com/math?formula=(%5Csetminus)\" alt=\"(\\setminus)\"><br>子集<code>(\\subset)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Csubset)\" alt=\"(\\subset)\"><br>子集<code>(\\subseteq)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Csubseteq)\" alt=\"(\\subseteq)\"><br>非子集<code>(\\subsetneq)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Csubsetneq)\" alt=\"(\\subsetneq)\"><br>父集<code>(\\supset)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Csupset)\" alt=\"(\\supset)\"><br>属于<code>(\\in)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Cin)\" alt=\"(\\in)\"><br>不属于<code>(\\notin)</code>:![<code>(\\notin)](https://math.jianshu.com/math?formula=%60(%5Cnotin))   空集</code>(\\emptyset)<code>: ![(\\emptyset)](https://math.jianshu.com/math?formula=(%5Cemptyset))   空</code>(\\varnothing)&#96;: <img src=\"https://math.jianshu.com/math?formula=(%5Cvarnothing)\" alt=\"(\\varnothing)\"></p>\n<h3 id=\"4-排列\"><a href=\"#4-排列\" class=\"headerlink\" title=\"4. 排列\"></a>4. 排列</h3><p><code>\\binom&#123;n+1&#125;&#123;2k&#125;</code> : <img src=\"https://math.jianshu.com/math?formula=%5Cbinom%7Bn+1%7D%7B2k%7D\" alt=\"\\binom{n+1}{2k}\"><br><code>&#123;n+1 \\choose 2k&#125;</code> : <img src=\"https://math.jianshu.com/math?formula=%7Bn+1%20%5Cchoose%202k%7D\" alt=\"{n+1 \\choose 2k}\"></p>\n<h3 id=\"5-箭头\"><a href=\"#5-箭头\" class=\"headerlink\" title=\"5. 箭头\"></a>5. 箭头</h3><p><code>(\\to)</code>:<img src=\"https://math.jianshu.com/math?formula=(%5Cto)\" alt=\"(\\to)\"><br><code>(\\rightarrow)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Crightarrow)\" alt=\"(\\rightarrow)\"><br><code>(\\leftarrow)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Cleftarrow)\" alt=\"(\\leftarrow)\"><br><code>(\\Rightarrow)</code>:![<code>(\\Rightarrow)](https://math.jianshu.com/math?formula=%60(%5CRightarrow))   </code>(\\Leftarrow)<code>: ![(\\Leftarrow)](https://math.jianshu.com/math?formula=(%5CLeftarrow))   </code>(\\mapsto)&#96;: <img src=\"https://math.jianshu.com/math?formula=%5Cmapsto\" alt=\"\\mapsto)\">)</p>\n<h3 id=\"6-逻辑运算符\"><a href=\"#6-逻辑运算符\" class=\"headerlink\" title=\"6. 逻辑运算符\"></a>6. 逻辑运算符</h3><p><code>(\\land)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Cland)\" alt=\"(\\land)\"><br><code>(\\lor)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Clor)\" alt=\"(\\lor)\"><br><code>(\\lnot)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Clnot)\" alt=\"(\\lnot)\"><br><code>(\\forall)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Cforall)\" alt=\"(\\forall)\"><br><code>(\\exists)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Cexists)\" alt=\"(\\exists)\"><br><code>(\\top)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Ctop)\" alt=\"(\\top)\"><br><code>(\\bot)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Cbot)\" alt=\"(\\bot)\"><br><code>(\\vdash)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Cvdash)\" alt=\"(\\vdash)\"><br><code>(\\vDash)</code>:<img src=\"https://math.jianshu.com/math?formula=(%5CvDash)\" alt=\"(\\vDash)\"></p>\n<h3 id=\"7-操作符\"><a href=\"#7-操作符\" class=\"headerlink\" title=\"7.操作符\"></a>7.操作符</h3><p><code>(\\star)</code>: ![<code>(\\star)](https://math.jianshu.com/math?formula=%60(%5Cstar))   </code>(\\ast)<code>: ![(\\ast)](https://math.jianshu.com/math?formula=(%5Cast))   </code>(\\oplus)<code>: ![(\\oplus)](https://math.jianshu.com/math?formula=(%5Coplus))   </code>(\\circ)<code>: ![(\\circ)](https://math.jianshu.com/math?formula=(%5Ccirc))   </code>(\\bullet)&#96;: <img src=\"https://math.jianshu.com/math?formula=(%5Cbullet)\" alt=\"(\\bullet)\"></p>\n<h3 id=\"8-等于\"><a href=\"#8-等于\" class=\"headerlink\" title=\"8.等于\"></a>8.等于</h3><p><code>(\\approx)</code>:<img src=\"https://math.jianshu.com/math?formula=(%5Capprox)\" alt=\"(\\approx)\"><br><code>(\\sim)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Csim)\" alt=\"(\\sim)\"><br><code>(\\equiv)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Cequiv)\" alt=\"(\\equiv)\"><br><code>(\\prec)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Cprec)\" alt=\"(\\prec)\"></p>\n<h3 id=\"9-范围\"><a href=\"#9-范围\" class=\"headerlink\" title=\"9.范围\"></a>9.范围</h3><p><code>(\\infty)</code>:<img src=\"https://math.jianshu.com/math?formula=(%5Cinfty)\" alt=\"(\\infty)\"><br><code>(\\aleph_o)</code>:<img src=\"https://math.jianshu.com/math?formula=(%5Caleph_o)\" alt=\"(\\aleph_o)\"><br><code>(\\nabla)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Cnabla)\" alt=\"(\\nabla)\"><br><code>(\\Im)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5CIm)\" alt=\"(\\Im)\"><br><code>(\\Re)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5CRe)\" alt=\"(\\Re)\"></p>\n<h3 id=\"10-模运算\"><a href=\"#10-模运算\" class=\"headerlink\" title=\"10. 模运算\"></a>10. 模运算</h3><p><code>(\\pmod)</code>: ![&#96;(\\pmod)](<a href=\"https://math.jianshu.com/math?formula=%60(%5Cpmod)\">https://math.jianshu.com/math?formula=%60(%5Cpmod)</a>)<br>如a \\equiv b \\pmod n 表示为: <img src=\"https://math.jianshu.com/math?formula=a%20%5Cequiv%20b%20%5Cpmod%20n\" alt=\"a \\equiv b \\pmod n\"></p>\n<h3 id=\"11-点\"><a href=\"#11-点\" class=\"headerlink\" title=\"11. 点\"></a>11. 点</h3><p><code>(\\ldots)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Cldots)\" alt=\"(\\ldots)\"><br><code>(\\cdots)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Ccdots)\" alt=\"(\\cdots)\"><br><code>(\\cdot)</code>: <img src=\"https://math.jianshu.com/math?formula=(%5Ccdot)\" alt=\"(\\cdot)\"><br>其区别是点的位置不同，<code>\\ldots</code> 位置稍低，<code>\\cdots</code> 位置居中。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$$</span></span><br><span class=\"line\">\\<span class=\"keyword\">begin</span>&#123;cases&#125;</span><br><span class=\"line\">a_1+a_2+\\ldots+a_n \\\\ </span><br><span class=\"line\">a_1+a_2+\\cdots+a_n \\\\</span><br><span class=\"line\">\\<span class=\"keyword\">end</span>&#123;cases&#125;</span><br><span class=\"line\"><span class=\"variable\">$$</span></span><br></pre></td></tr></table></figure>\n\n<p>表示(注意两部分点的位置)：<br><img src=\"https://math.jianshu.com/math?formula=%5Cbegin%7Bcases%7D%20a_1+a_2+%5Cldots+a_n%20%5C%5C%20a_1+a_2+%5Ccdots+a_n%20%5C%5C%20%5Cend%7Bcases%7D\" alt=\"\\begin{cases} a_1+a_2+\\ldots+a_n \\\\ a_1+a_2+\\cdots+a_n \\\\ \\end{cases}\"></p>\n<h3 id=\"12-顶部符号\"><a href=\"#12-顶部符号\" class=\"headerlink\" title=\"12.顶部符号\"></a>12.顶部符号</h3><p>对于单字符，<code>\\hat x</code>：<img src=\"https://math.jianshu.com/math?formula=%5Chat%20x\" alt=\"\\hat x\"><br>多字符可以使用<code>\\widehat &#123;xy&#125;</code>：<img src=\"https://math.jianshu.com/math?formula=%5Cwidehat%20%7Bxy%7D\" alt=\"\\widehat {xy}\"><br>类似的还有<code>\\overline x</code>: <img src=\"https://math.jianshu.com/math?formula=%5Coverline%20x\" alt=\"\\overline x\"><br>矢量<code>\\vec x</code>:<img src=\"https://math.jianshu.com/math?formula=%5Cvec%20x\" alt=\"\\vec x\"><br>向量<code>\\overrightarrow &#123;xy&#125;</code>: <img src=\"https://math.jianshu.com/math?formula=%5Coverrightarrow%20%7Bxy%7D\" alt=\"\\overrightarrow {xy}\"><br><code>\\dot x</code> : <img src=\"https://math.jianshu.com/math?formula=%5Cdot%20x\" alt=\"\\dot x\"><br><code>\\ddot x</code>: <img src=\"https://math.jianshu.com/math?formula=%5Cddot%20x\" alt=\"\\ddot x\"><br><code>\\dot &#123;\\dot x&#125;</code>: <img src=\"https://math.jianshu.com/math?formula=%5Cdot%20%7B%5Cdot%20x%7D\" alt=\"\\dot {\\dot x}\"></p>\n<h1 id=\"九、表格\"><a href=\"#九、表格\" class=\"headerlink\" title=\"九、表格\"></a>九、表格</h1><p>使用<code>\\begin&#123;array&#125;&#123;列样式&#125;…\\end&#123;array&#125;</code>这样的形式来创建表格，列样式可以是<code>clr</code> 表示居中，左，右对齐，还可以使用<code>|</code>表示一条竖线。表格中各行使用\\ 分隔，各列使用&amp; 分隔。使用<code>\\hline</code> 在本行前加入一条直线。 例如:</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$$</span></span><br><span class=\"line\">\\<span class=\"keyword\">begin</span>&#123;array&#125;&#123;c|<span class=\"params\">lcr&#125;</span></span><br><span class=\"line\"><span class=\"params\">n &amp; \\text&#123;Left&#125; &amp; \\text&#123;Center&#125; &amp; \\text&#123;Right&#125; \\\\</span></span><br><span class=\"line\"><span class=\"params\">\\hline</span></span><br><span class=\"line\"><span class=\"params\">1 &amp; 0.24 &amp; 1 &amp; 125 \\\\</span></span><br><span class=\"line\"><span class=\"params\">2 &amp; -1 &amp; 189 &amp; -8 \\\\</span></span><br><span class=\"line\"><span class=\"params\">3 &amp; -20 &amp; 2000 &amp; 1+10i \\\\</span></span><br><span class=\"line\"><span class=\"params\">\\<span class=\"keyword\">end</span>&#123;array&#125;</span></span><br><span class=\"line\"><span class=\"params\">$$</span></span><br></pre></td></tr></table></figure>\n\n<p>得到：<br><img src=\"https://math.jianshu.com/math?formula=%5Cbegin%7Barray%7D%7Bc%7Clcr%7D%20n%20&%20%5Ctext%7BLeft%7D%20&%20%5Ctext%7BCenter%7D%20&%20%5Ctext%7BRight%7D%20%5C%5C%20%5Chline%201%20&%200.24%20&%201%20&%20125%20%5C%5C%202%20&%20-1%20&%20189%20&%20-8%20%5C%5C%203%20&%20-20%20&%202000%20&%201+10i%20%5C%5C%20%5Cend%7Barray%7D\" alt=\"\\begin{array}{c|lcr} n &amp; \\text{Left} &amp; \\text{Center} &amp; \\text{Right} \\\\ \\hline 1 &amp; 0.24 &amp; 1 &amp; 125 \\\\ 2 &amp; -1 &amp; 189 &amp; -8 \\\\ 3 &amp; -20 &amp; 2000 &amp; 1+10i \\\\ \\end{array}\"></p>\n<h1 id=\"十、汉字、字体与格式\"><a href=\"#十、汉字、字体与格式\" class=\"headerlink\" title=\"十、汉字、字体与格式\"></a>十、汉字、字体与格式</h1><ol>\n<li>汉字形式，符号：<code>\\mbox&#123;&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=V_%7B%5Cmbox%7B%E5%88%9D%E5%A7%8B%7D%7D\" alt=\"V_{\\mbox{初始}}\"></li>\n<li>字体控制，符号：<code>\\displaystyle</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cdisplaystyle%20%5Cfrac%7Bx+y%7D%7By+z%7D\" alt=\"\\displaystyle \\frac{x+y}{y+z}\"></li>\n<li>下划线符号，符号：<code>\\underline</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cunderline%7Bx+y%7D\" alt=\"\\underline{x+y}\"></li>\n<li>标签，符号<code>\\tag&#123;数字&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Ctag%7B11%7D\" alt=\"\\tag{11}\"></li>\n<li>上大括号，符号：<code>\\overbrace&#123;算式&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Coverbrace%7Ba+b+c+d%7D%5E%7B2.0%7D\" alt=\"\\overbrace{a+b+c+d}^{2.0}\"></li>\n<li>下大括号，符号：<code>\\underbrace&#123;算式&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=a+%5Cunderbrace%7Bb+c%7D_%7B1.0%7D+d\" alt=\"a+\\underbrace{b+c}_{1.0}+d\"></li>\n<li>上位符号，符号：<code>\\stacrel&#123;上位符号&#125;&#123;基位符号&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cvec%7Bx%7D%5Cstackrel%7B%5Cmathrm%7Bdef%7D%7D%7B=%7D%7Bx_1,%5Cdots,x_n%7D\" alt=\"\\vec{x}\\stackrel{\\mathrm{def}}{=}{x_1,\\dots,x_n}\"></li>\n</ol>\n<h1 id=\"十一、占位符\"><a href=\"#十一、占位符\" class=\"headerlink\" title=\"十一、占位符\"></a>十一、占位符</h1><ol>\n<li>两个quad空格，符号：<code>\\qquad</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Cqquad%20y\" alt=\"x \\qquad y\"></li>\n<li>quad空格，符号：<code>\\quad</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Cquad%20y\" alt=\"x \\quad y\"></li>\n<li>大空格，符号<code>\\</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5C%20y\" alt=\"x \\ y\"></li>\n<li>中空格，符号<code>\\:</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20:%20y\" alt=\"x : y\"></li>\n<li>小空格，符号<code>\\,</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20,%20y\" alt=\"x , y\"></li>\n<li>没有空格，符号&#96;&#96;，如：<img src=\"https://math.jianshu.com/math?formula=xy\" alt=\"xy\"></li>\n<li>紧贴，符号<code>\\!</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20!%20y\" alt=\"x ! y\"></li>\n</ol>\n<h1 id=\"十二、定界符与组合\"><a href=\"#十二、定界符与组合\" class=\"headerlink\" title=\"十二、定界符与组合\"></a>十二、定界符与组合</h1><ol>\n<li>括号，符号：<code>（）\\big(\\big) \\Big(\\Big) \\bigg(\\bigg) \\Bigg(\\Bigg)</code>，如：<img src=\"https://math.jianshu.com/math?formula=%EF%BC%88%EF%BC%89%5Cbig(%5Cbig)%20%5CBig(%5CBig)%20%5Cbigg(%5Cbigg)%20%5CBigg(%5CBigg)\" alt=\"（）\\big(\\big) \\Big(\\Big) \\bigg(\\bigg) \\Bigg(\\Bigg)\"></li>\n<li>中括号，符号：<code>[]</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Bx+y%5D\" alt=\"[x+y]\"></li>\n<li>大括号，符号：<code>\\&#123; \\&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%7Bx+y%7D\" alt=\"{x+y}\"></li>\n<li>自适应括号，符号：<code>\\left \\right</code>，如：<code>$\\left(x\\right)$</code>，<img src=\"https://math.jianshu.com/math?formula=%5Cleft(x%5Cright)\" alt=\"\\left(x\\right)\"></li>\n<li>组合公式，符号：<code>&#123;上位公式 \\choose 下位公式&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%7Bn+1%20%5Cchoose%20k%7D=%7Bn%20%5Cchoose%20k%7D+%7Bn%20%5Cchoose%20k-1%7D\" alt=\"{n+1 \\choose k}={n \\choose k}+{n \\choose k-1}\"></li>\n<li>组合公式，符号：<code>&#123;上位公式 \\atop 下位公式&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Csum_%7Bk_0,k_1,%5Cldots%3E0%20%5Catop%20k_0+k_1+%5Ccdots=n%7DA_%7Bk_0%7DA_%7Bk_1%7D%5Ccdots\" alt=\"\\sum_{k_0,k_1,\\ldots&gt;0 \\atop k_0+k_1+\\cdots=n}A_{k_0}A_{k_1}\\cdots\"></li>\n</ol>\n<h1 id=\"十三、四则运算\"><a href=\"#十三、四则运算\" class=\"headerlink\" title=\"十三、四则运算\"></a>十三、四则运算</h1><ol>\n<li>加法运算，符号：<code>+</code>，如：<img src=\"https://math.jianshu.com/math?formula=x+y=z\" alt=\"x+y=z\"></li>\n<li>减法运算，符号：<code>-</code>，如：<img src=\"https://math.jianshu.com/math?formula=x-y=z\" alt=\"x-y=z\"></li>\n<li>加减运算，符号：<code>\\pm</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Cpm%20y=z\" alt=\"x \\pm y=z\"></li>\n<li>减甲运算，符号：<code>\\mp</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Cmp%20y=z\" alt=\"x \\mp y=z\"></li>\n<li>乘法运算，符号：<code>\\times</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Ctimes%20y=z\" alt=\"x \\times y=z\"></li>\n<li>点乘运算，符号：<code>\\cdot</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Ccdot%20y=z\" alt=\"x \\cdot y=z\"></li>\n<li>星乘运算，符号：<code>\\ast</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Cast%20y=z\" alt=\"x \\ast y=z\"></li>\n<li>除法运算，符号：<code>\\div</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Cdiv%20y=z\" alt=\"x \\div y=z\"></li>\n<li>斜法运算，符号：<code>/</code>，如：<img src=\"https://math.jianshu.com/math?formula=x/y=z\" alt=\"x/y=z\"></li>\n<li>分式表示，符号：<code>\\frac&#123;分子&#125;&#123;分母&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cfrac%7Bx+y%7D%7By+z%7D\" alt=\"\\frac{x+y}{y+z}\"></li>\n<li>分式表示，符号：<code>&#123;分子&#125; \\voer &#123;分母&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%7Bx+y%7D%20%5Cover%20%7By+z%7D\" alt=\"{x+y} \\over {y+z}\"></li>\n<li>绝对值表示，符号：<code>||</code>，如：<img src=\"https://math.jianshu.com/math?formula=%7Cx+y%7C\" alt=\"|x+y|\"></li>\n</ol>\n<h1 id=\"十四、高级运算\"><a href=\"#十四、高级运算\" class=\"headerlink\" title=\"十四、高级运算\"></a>十四、高级运算</h1><ol>\n<li>平均数运算，符号：<code>\\overline&#123;算式&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Coverline%7Bxyz%7D\" alt=\"\\overline{xyz}\"></li>\n<li>开二次方运算，符号：<code>\\sqrt</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Csqrt%20x\" alt=\"\\sqrt x\"></li>\n<li>开方运算，符号：<code>\\sqrt[开方数]&#123;被开方数&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Csqrt%5B3%5D%7Bx+y%7D\" alt=\"\\sqrt[3]{x+y}\"></li>\n<li>对数运算，符号：<code>\\log</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Clog(x)\" alt=\"\\log(x)\"></li>\n<li>极限运算，符号：<code>\\lim</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Clim%5E%7Bx%20%5Cto%20%5Cinfty%7D_%7By%20%5Cto%200%7D%7B%5Cfrac%7Bx%7D%7By%7D%7D\" alt=\"\\lim^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}}\"></li>\n<li>极限运算，符号：<code>\\displaystyle \\lim</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cdisplaystyle%20%5Clim%5E%7Bx%20%5Cto%20%5Cinfty%7D_%7By%20%5Cto%200%7D%7B%5Cfrac%7Bx%7D%7By%7D%7D\" alt=\"\\displaystyle \\lim^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}}\"></li>\n<li>求和运算，符号：<code>\\sum</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Csum%5E%7Bx%20%5Cto%20%5Cinfty%7D_%7By%20%5Cto%200%7D%7B%5Cfrac%7Bx%7D%7By%7D%7D\" alt=\"\\sum^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}}\"></li>\n<li>求和运算，符号：<code>\\displaystyle \\sum</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cdisplaystyle%20%5Csum%5E%7Bx%20%5Cto%20%5Cinfty%7D_%7By%20%5Cto%200%7D%7B%5Cfrac%7Bx%7D%7By%7D%7D\" alt=\"\\displaystyle \\sum^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}}\"></li>\n<li>积分运算，符号：<code>\\int</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cint%5E%7B%5Cinfty%7D_%7B0%7D%7Bxdx%7D\" alt=\"\\int^{\\infty}_{0}{xdx}\"></li>\n<li>积分运算，符号：<code>\\displaystyle \\int</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cdisplaystyle%20%5Cint%5E%7B%5Cinfty%7D_%7B0%7D%7Bxdx%7D\" alt=\"\\displaystyle \\int^{\\infty}_{0}{xdx}\"></li>\n<li>微分运算，符号：<code>\\partial</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cfrac%7B%5Cpartial%20x%7D%7B%5Cpartial%20y%7D\" alt=\"\\frac{\\partial x}{\\partial y}\"></li>\n<li>矩阵表示，符号：<code>\\begin&#123;matrix&#125; \\end&#123;matrix&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cleft%5B%20%5Cbegin%7Bmatrix%7D%201%20&2%20&%5Ccdots%20&4%5C5%20&6%20&%5Ccdots%20&8%5C%5Cvdots%20&%5Cvdots%20&%5Cddots%20&%5Cvdots%5C13%20&14%20&%5Ccdots%20&16%5Cend%7Bmatrix%7D%20%5Cright%5D\" alt=\"\\left[ \\begin{matrix} 1 &amp;2 &amp;\\cdots &amp;4\\5 &amp;6 &amp;\\cdots &amp;8\\\\vdots &amp;\\vdots &amp;\\ddots &amp;\\vdots\\13 &amp;14 &amp;\\cdots &amp;16\\end{matrix} \\right]\"></li>\n</ol>\n<h1 id=\"十五、-逻辑运算\"><a href=\"#十五、-逻辑运算\" class=\"headerlink\" title=\"十五、 逻辑运算\"></a>十五、 逻辑运算</h1><ol>\n<li>等于运算，符号：<code>=</code>，如：<img src=\"https://math.jianshu.com/math?formula=x+y=z\" alt=\"x+y=z\"></li>\n<li>大于运算，符号：<code>&gt;</code>，如：<img src=\"https://math.jianshu.com/math?formula=x+y%3Ez\" alt=\"x+y&gt;z\"></li>\n<li>小于运算，符号：<code>&lt;</code>，如：<img src=\"https://math.jianshu.com/math?formula=x+y%3Cz\" alt=\"x+y&lt;z\"></li>\n<li>大于等于运算，符号：<code>\\geq</code>，如：<img src=\"https://math.jianshu.com/math?formula=x+y%20%5Cgeq%20z\" alt=\"x+y \\geq z\"></li>\n<li>小于等于运算，符号：<code>\\leq</code>，如：<img src=\"https://math.jianshu.com/math?formula=x+y%20%5Cleq%20z\" alt=\"x+y \\leq z\"></li>\n<li>不等于运算，符号：<code>\\neq</code>，如：<img src=\"https://math.jianshu.com/math?formula=x+y%20%5Cneq%20z\" alt=\"x+y \\neq z\"></li>\n<li>不大于等于运算，符号：<code>\\ngeq</code>，如：<img src=\"https://math.jianshu.com/math?formula=x+y%20%5Cngeq%20z\" alt=\"x+y \\ngeq z\"></li>\n<li>不大于等于运算，符号：<code>\\not\\geq</code>，如：<img src=\"https://math.jianshu.com/math?formula=x+y%20%5Cnot%5Cgeq%20z\" alt=\"x+y \\not\\geq z\"></li>\n<li>不小于等于运算，符号：<code>\\nleq</code>，如：<img src=\"https://math.jianshu.com/math?formula=x+y%20%5Cnleq%20z\" alt=\"x+y \\nleq z\"></li>\n<li>不小于等于运算，符号：<code>\\not\\leq</code>，如：<img src=\"https://math.jianshu.com/math?formula=x+y%20%5Cnot%5Cleq%20z\" alt=\"x+y \\not\\leq z\"></li>\n<li>约等于运算，符号：<code>\\approx</code>，如：<img src=\"https://math.jianshu.com/math?formula=x+y%20%5Capprox%20z\" alt=\"x+y \\approx z\"></li>\n<li>恒定等于运算，符号：<code>\\equiv</code>，如：<img src=\"https://math.jianshu.com/math?formula=x+y%20%5Cequiv%20z\" alt=\"x+y \\equiv z\"></li>\n</ol>\n<h1 id=\"十六、集合运算\"><a href=\"#十六、集合运算\" class=\"headerlink\" title=\"十六、集合运算\"></a>十六、集合运算</h1><ol>\n<li>属于运算，符号：<code>\\in</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Cin%20y\" alt=\"x \\in y\"></li>\n<li>不属于运算，符号：<code>\\notin</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Cnotin%20y\" alt=\"x \\notin y\"></li>\n<li>不属于运算，符号：<code>\\not\\in</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Cnot%5Cin%20y\" alt=\"x \\not\\in y\"></li>\n<li>子集运算，符号：<code>\\subset</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Csubset%20y\" alt=\"x \\subset y\"></li>\n<li>子集运算，符号：<code>\\supset</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Csupset%20y\" alt=\"x \\supset y\"></li>\n<li>真子集运算，符号：<code>\\subseteq</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Csubseteq%20y\" alt=\"x \\subseteq y\"></li>\n<li>非真子集运算，符号：<code>\\subsetneq</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Csubsetneq%20y\" alt=\"x \\subsetneq y\"></li>\n<li>真子集运算，符号：<code>\\supseteq</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Csupseteq%20y\" alt=\"x \\supseteq y\"></li>\n<li>非真子集运算，符号：<code>\\supsetneq</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Csupsetneq%20y\" alt=\"x \\supsetneq y\"></li>\n<li>非子集运算，符号：<code>\\not\\subset</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Cnot%5Csubset%20y\" alt=\"x \\not\\subset y\"></li>\n<li>非子集运算，符号：<code>\\not\\supset</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Cnot%5Csupset%20y\" alt=\"x \\not\\supset y\"></li>\n<li>并集运算，符号：<code>\\cup</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Ccup%20y\" alt=\"x \\cup y\"></li>\n<li>交集运算，符号：<code>\\cap</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Ccap%20y\" alt=\"x \\cap y\"></li>\n<li>差集运算，符号：<code>\\setminus</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Csetminus%20y\" alt=\"x \\setminus y\"></li>\n<li>同或运算，符号：<code>\\bigodot</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Cbigodot%20y\" alt=\"x \\bigodot y\"></li>\n<li>同与运算，符号：<code>\\bigotimes</code>，如：<img src=\"https://math.jianshu.com/math?formula=x%20%5Cbigotimes%20y\" alt=\"x \\bigotimes y\"></li>\n<li>实数集合，符号：<code>\\mathbb&#123;R&#125;</code>，如：<code>\\mathbb&#123;R&#125;</code></li>\n<li>自然数集合，符号：<code>\\mathbb&#123;Z&#125;</code>，如：<code>\\mathbb&#123;Z&#125;</code></li>\n<li>空集，符号：<code>\\emptyset</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cemptyset\" alt=\"\\emptyset\"></li>\n</ol>\n<h1 id=\"十七、数学符号\"><a href=\"#十七、数学符号\" class=\"headerlink\" title=\"十七、数学符号\"></a>十七、数学符号</h1><ol>\n<li>无穷，符号：<code>\\infty</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cinfty\" alt=\"\\infty\"></li>\n<li>虚数，符号：<code>\\imath</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cimath\" alt=\"\\imath\"></li>\n<li>虚数，符号：<code>\\jmath</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cjmath\" alt=\"\\jmath\"></li>\n<li>数学符号，符号<code>\\hat&#123;a&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Chat%7Ba%7D\" alt=\"\\hat{a}\"></li>\n<li>数学符号，符号<code>\\check&#123;a&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Ccheck%7Ba%7D\" alt=\"\\check{a}\"></li>\n<li>数学符号，符号<code>\\breve&#123;a&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cbreve%7Ba%7D\" alt=\"\\breve{a}\"></li>\n<li>数学符号，符号<code>\\tilde&#123;a&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Ctilde%7Ba%7D\" alt=\"\\tilde{a}\"></li>\n<li>数学符号，符号<code>\\bar&#123;a&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cbar%7Ba%7D\" alt=\"\\bar{a}\"></li>\n<li>矢量符号，符号<code>\\vec&#123;a&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cvec%7Ba%7D\" alt=\"\\vec{a}\"></li>\n<li>数学符号，符号<code>\\acute&#123;a&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cacute%7Ba%7D\" alt=\"\\acute{a}\"></li>\n<li>数学符号，符号<code>\\grave&#123;a&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cgrave%7Ba%7D\" alt=\"\\grave{a}\"></li>\n<li>数学符号，符号<code>\\mathring&#123;a&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cmathring%7Ba%7D\" alt=\"\\mathring{a}\"></li>\n<li>一阶导数符号，符号<code>\\dot&#123;a&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cdot%7Ba%7D\" alt=\"\\dot{a}\"></li>\n<li>二阶导数符号，符号<code>\\ddot&#123;a&#125;</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cddot%7Ba%7D\" alt=\"\\ddot{a}\"></li>\n<li>上箭头，符号：<code>\\uparrow</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cuparrow\" alt=\"\\uparrow\"></li>\n<li>上箭头，符号：<code>\\Uparrow</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5CUparrow\" alt=\"\\Uparrow\"></li>\n<li>下箭头，符号：<code>\\downarrow</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cdownarrow\" alt=\"\\downarrow\"></li>\n<li>下箭头，符号：<code>\\Downarrow</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5CDownarrow\" alt=\"\\Downarrow\"></li>\n<li>左箭头，符号：<code>\\leftarrow</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cleftarrow\" alt=\"\\leftarrow\"></li>\n<li>左箭头，符号：<code>\\Leftarrow</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5CLeftarrow\" alt=\"\\Leftarrow\"></li>\n<li>右箭头，符号：<code>\\rightarrow</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Crightarrow\" alt=\"\\rightarrow\"></li>\n<li>右箭头，符号：<code>\\Rightarrow</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5CRightarrow\" alt=\"\\Rightarrow\"></li>\n<li>底端对齐的省略号，符号：<code>\\ldots</code>，如：<img src=\"https://math.jianshu.com/math?formula=1,2,%5Cldots,n\" alt=\"1,2,\\ldots,n\"></li>\n<li>中线对齐的省略号，符号：<code>\\cdots</code>，如：<img src=\"https://math.jianshu.com/math?formula=x_1%5E2%20+%20x_2%5E2%20+%20%5Ccdots%20+%20x_n%5E2\" alt=\"x_1^2 + x_2^2 + \\cdots + x_n^2\"></li>\n<li>竖直对齐的省略号，符号：<code>\\vdots</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cvdots\" alt=\"\\vdots\"></li>\n<li>斜对齐的省略号，符号：<code>\\ddots</code>，如：<img src=\"https://math.jianshu.com/math?formula=%5Cddots\" alt=\"\\ddots\"></li>\n</ol>\n<h1 id=\"十八、矩阵\"><a href=\"#十八、矩阵\" class=\"headerlink\" title=\"十八、矩阵\"></a>十八、矩阵</h1><p>使用<code>\\begin&#123;matrix&#125;…\\end&#123;matrix&#125;</code>这样的形式来表示矩阵，在<code>\\begin</code> 与<code>\\end</code>之间加入矩阵中的元素即可。矩阵的行之间使用<code>\\\\</code>分隔，列之间使用<code>&amp;</code>分隔，例如:</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$$</span></span><br><span class=\"line\">\\<span class=\"keyword\">begin</span>&#123;matrix&#125;</span><br><span class=\"line\"><span class=\"number\">1</span> &amp; x &amp; x^<span class=\"number\">2</span> \\\\</span><br><span class=\"line\"><span class=\"number\">1</span> &amp; y &amp; y^<span class=\"number\">2</span> \\\\</span><br><span class=\"line\"><span class=\"number\">1</span> &amp; z &amp; z^<span class=\"number\">2</span> \\\\</span><br><span class=\"line\">\\<span class=\"keyword\">end</span>&#123;matrix&#125;</span><br><span class=\"line\"><span class=\"variable\">$$</span></span><br></pre></td></tr></table></figure>\n\n<p>得到：<br><img src=\"https://math.jianshu.com/math?formula=%5Cbegin%7Bmatrix%7D%201%20&%20x%20&%20x%5E2%20%5C%5C%201%20&%20y%20&%20y%5E2%20%5C%5C%201%20&%20z%20&%20z%5E2%20%5C%5C%20%5Cend%7Bmatrix%7D\" alt=\"\\begin{matrix} 1 &amp; x &amp; x^2 \\\\ 1 &amp; y &amp; y^2 \\\\ 1 &amp; z &amp; z^2 \\\\ \\end{matrix}\"></p>\n<h3 id=\"1-括号\"><a href=\"#1-括号\" class=\"headerlink\" title=\"1. 括号\"></a>1. 括号</h3><p>如果要对矩阵加括号，可以像上文中提到的一样，使用<code>\\left</code>与<code>\\right</code> 配合表示括号符号。也可以使用特殊的matrix 。即替换<code>\\begin&#123;matrix&#125;…\\end&#123;matrix&#125; 中matrix 为pmatrix ，bmatrix ，Bmatrix ，vmatrix , Vmatrix</code> 。<br><code>pmatrix$\\begin&#123;pmatrix&#125;1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end&#123;pmatrix&#125;$</code>:pmatrix<img src=\"https://math.jianshu.com/math?formula=%5Cbegin%7Bpmatrix%7D1%20&%202%20%5C%5C%203%20&%204%5C%5C%20%5Cend%7Bpmatrix%7D\" alt=\"\\begin{pmatrix}1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end{pmatrix}\"><br><code>bmatrix$\\begin&#123;bmatrix&#125;1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end&#123;bmatrix&#125;$</code> :bmatrix<img src=\"https://math.jianshu.com/math?formula=%5Cbegin%7Bbmatrix%7D1%20&%202%20%5C%5C%203%20&%204%5C%5C%20%5Cend%7Bbmatrix%7D\" alt=\"\\begin{bmatrix}1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end{bmatrix}\"><br><code>Bmatrix$\\begin&#123;Bmatrix&#125;1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end&#123;Bmatrix&#125;$</code> :Bmatrix<img src=\"https://math.jianshu.com/math?formula=%5Cbegin%7BBmatrix%7D1%20&%202%20%5C%5C%203%20&%204%5C%5C%20%5Cend%7BBmatrix%7D\" alt=\"\\begin{Bmatrix}1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end{Bmatrix}\"><br><code>vmatrix$\\begin&#123;vmatrix&#125;1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end&#123;vmatrix&#125;$</code> :vmatrix<img src=\"https://math.jianshu.com/math?formula=%5Cbegin%7Bvmatrix%7D1%20&%202%20%5C%5C%203%20&%204%5C%5C%20%5Cend%7Bvmatrix%7D\" alt=\"\\begin{vmatrix}1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end{vmatrix}\"><br><code>Vmatrix$\\begin&#123;Vmatrix&#125;1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end&#123;Vmatrix&#125;$</code> :Vmatrix<img src=\"https://math.jianshu.com/math?formula=%5Cbegin%7BVmatrix%7D1%20&%202%20%5C%5C%203%20&%204%5C%5C%20%5Cend%7BVmatrix%7D\" alt=\"\\begin{Vmatrix}1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end{Vmatrix}\"><br>元素省略:<br>可以使用\\cdots ：⋯，\\ddots：⋱ ，\\vdots：⋮ 来省略矩阵中的元素，如：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$$</span></span><br><span class=\"line\">\\<span class=\"keyword\">begin</span>&#123;pmatrix&#125;</span><br><span class=\"line\"><span class=\"number\">1</span>&amp;a_1&amp;a_1^<span class=\"number\">2</span>&amp;\\cdots&amp;a_1^n\\\\</span><br><span class=\"line\"><span class=\"number\">1</span>&amp;a_2&amp;a_2^<span class=\"number\">2</span>&amp;\\cdots&amp;a_2^n\\\\</span><br><span class=\"line\">\\vdots&amp;\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\</span><br><span class=\"line\"><span class=\"number\">1</span>&amp;a_m&amp;a_m^<span class=\"number\">2</span>&amp;\\cdots&amp;a_m^n\\\\</span><br><span class=\"line\">\\<span class=\"keyword\">end</span>&#123;pmatrix&#125;</span><br><span class=\"line\"><span class=\"variable\">$$</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>表示：<br><img src=\"https://math.jianshu.com/math?formula=%5Cbegin%7Bpmatrix%7D%201&a_1&a_1%5E2&%5Ccdots&a_1%5En%5C%5C%201&a_2&a_2%5E2&%5Ccdots&a_2%5En%5C%5C%20%5Cvdots&%5Cvdots&%5Cvdots&%5Cddots&%5Cvdots%5C%5C%201&a_m&a_m%5E2&%5Ccdots&a_m%5En%5C%5C%20%5Cend%7Bpmatrix%7D\" alt=\"\\begin{pmatrix} 1&amp;a_1&amp;a_1^2&amp;\\cdots&amp;a_1^n\\\\ 1&amp;a_2&amp;a_2^2&amp;\\cdots&amp;a_2^n\\\\ \\vdots&amp;\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\ 1&amp;a_m&amp;a_m^2&amp;\\cdots&amp;a_m^n\\\\ \\end{pmatrix}\"></p>\n<h3 id=\"2-增广矩阵\"><a href=\"#2-增广矩阵\" class=\"headerlink\" title=\"2. 增广矩阵\"></a>2. 增广矩阵</h3><p>增广矩阵需要使用前面的表格中使用到的<code>\\begin&#123;array&#125; ... \\end&#123;array&#125;</code>来实现。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$$</span><br><span class=\"line\">\\left[  \\begin&#123;array&#125;  &#123;c c <span class=\"operator\">|</span> c&#125; <span class=\"operator\">%</span>这里的c表示数组中元素对其方式：c居中<span class=\"operator\">、</span>r右对齐<span class=\"operator\">、</span>l左对齐，竖线表示<span class=\"number\">2</span><span class=\"operator\">、</span><span class=\"number\">3</span>列间插入竖线</span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"operator\">&amp;</span> <span class=\"number\">2</span> <span class=\"operator\">&amp;</span> <span class=\"number\">3</span> \\\\</span><br><span class=\"line\">\\hline <span class=\"operator\">%</span>插入横线，如果去掉\\hline就是增广矩阵</span><br><span class=\"line\"><span class=\"number\">4</span> <span class=\"operator\">&amp;</span> <span class=\"number\">5</span> <span class=\"operator\">&amp;</span> <span class=\"number\">6</span></span><br><span class=\"line\">\\end&#123;array&#125;  \\right]</span><br><span class=\"line\">$$</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>显示为：<br><img src=\"https://math.jianshu.com/math?formula=%5Cleft%5B%20%5Cbegin%7Barray%7D%20%7Bc%20c%20%7C%20c%7D%201%20&%202%20&%203%20%5C%5C%20%5Chline%204%20&%205%20&%206%20%5Cend%7Barray%7D%20%5Cright%5D\" alt=\"\\left[ \\begin{array} {c c | c} 1 &amp; 2 &amp; 3 \\\\ \\hline 4 &amp; 5 &amp; 6 \\end{array} \\right]\"></p>\n<h1 id=\"二十、公式标记与引用\"><a href=\"#二十、公式标记与引用\" class=\"headerlink\" title=\"二十、公式标记与引用\"></a>二十、公式标记与引用</h1><p>使用<code>\\tag&#123;yourtag&#125;</code>来标记公式，如<code>$$a=x^2-y^3\\tag&#123;1&#125;$$</code>显示为：<br><img src=\"https://math.jianshu.com/math?formula=a=x%5E2-y%5E3%5Ctag%7B1%7D\" alt=\"a=x^2-y^3\\tag{1}\"></p>\n<h1 id=\"二十一、字体\"><a href=\"#二十一、字体\" class=\"headerlink\" title=\"二十一、字体\"></a>二十一、字体</h1><h3 id=\"1-黑板粗体字\"><a href=\"#1-黑板粗体字\" class=\"headerlink\" title=\"1.黑板粗体字\"></a>1.黑板粗体字</h3><p>此字体经常用来表示代表实数、整数、有理数、复数的大写字母。<br><code>$\\mathbb ABCDEF$</code>：<img src=\"https://math.jianshu.com/math?formula=%5Cmathbb%20ABCDEF\" alt=\"\\mathbb ABCDEF\"><br><code>$\\Bbb ABCDEF$</code>：<img src=\"https://math.jianshu.com/math?formula=%5CBbb%20ABCDEF\" alt=\"\\Bbb ABCDEF\"></p>\n<h3 id=\"3-黑体字\"><a href=\"#3-黑体字\" class=\"headerlink\" title=\"3.黑体字\"></a>3.黑体字</h3><p><code>$\\mathbf ABCDEFGHIJKLMNOPQRSTUVWXYZ$</code>:<img src=\"https://math.jianshu.com/math?formula=%5Cmathbf%20ABCDEFGHIJKLMNOPQRSTUVWXYZ\" alt=\"\\mathbf ABCDEFGHIJKLMNOPQRSTUVWXYZ\"><br><code>$\\mathbf abcdefghijklmnopqrstuvwxyz$</code>:<img src=\"https://math.jianshu.com/math?formula=%5Cmathbf%20abcdefghijklmnopqrstuvwxyz\" alt=\"\\mathbf abcdefghijklmnopqrstuvwxyz\"></p>\n<h3 id=\"3-打印机字体\"><a href=\"#3-打印机字体\" class=\"headerlink\" title=\"3.打印机字体\"></a>3.打印机字体</h3><p><code>$\\mathtt ABCDEFGHIJKLMNOPQRSTUVWXYZ$</code>:<img src=\"https://math.jianshu.com/math?formula=%5Cmathtt%20ABCDEFGHIJKLMNOPQRSTUVWXYZ\" alt=\"\\mathtt ABCDEFGHIJKLMNOPQRSTUVWXYZ\"></p>\n<h1 id=\"二十二、希腊字母\"><a href=\"#二十二、希腊字母\" class=\"headerlink\" title=\"二十二、希腊字母\"></a>二十二、希腊字母</h1><table>\n<thead>\n<tr>\n<th>字母</th>\n<th>实现</th>\n<th>字母</th>\n<th>实现</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>A</td>\n<td><code>A</code></td>\n<td>α</td>\n<td><code>\\alhpa</code></td>\n</tr>\n<tr>\n<td>B</td>\n<td><code>B</code></td>\n<td>β</td>\n<td><code>\\beta</code></td>\n</tr>\n<tr>\n<td>Γ</td>\n<td><code>\\Gamma</code></td>\n<td>γ</td>\n<td><code>\\gamma</code></td>\n</tr>\n<tr>\n<td>Δ</td>\n<td><code>\\Delta</code></td>\n<td>δ</td>\n<td><code>\\delta</code></td>\n</tr>\n<tr>\n<td>E</td>\n<td><code>E</code></td>\n<td>ϵ</td>\n<td><code>\\epsilon</code></td>\n</tr>\n<tr>\n<td>Z</td>\n<td><code>Z</code></td>\n<td>ζ</td>\n<td><code>\\zeta</code></td>\n</tr>\n<tr>\n<td>H</td>\n<td><code>H</code></td>\n<td>η</td>\n<td><code>\\eta</code></td>\n</tr>\n<tr>\n<td>Θ</td>\n<td><code>\\Theta</code></td>\n<td>θ</td>\n<td><code>\\theta</code></td>\n</tr>\n<tr>\n<td>I</td>\n<td><code>I</code></td>\n<td>ι</td>\n<td><code>\\iota</code></td>\n</tr>\n<tr>\n<td>K</td>\n<td><code>K</code></td>\n<td>κ</td>\n<td><code>\\kappa</code></td>\n</tr>\n<tr>\n<td>Λ</td>\n<td><code>\\Lambda</code></td>\n<td>λ</td>\n<td><code>\\lambda</code></td>\n</tr>\n<tr>\n<td>M</td>\n<td><code>M</code></td>\n<td>μ</td>\n<td><code>\\mu</code></td>\n</tr>\n<tr>\n<td>N</td>\n<td><code>N</code></td>\n<td>ν</td>\n<td><code>\\nu</code></td>\n</tr>\n<tr>\n<td>Ξ</td>\n<td><code>\\Xi</code></td>\n<td>ξ</td>\n<td><code>\\xi</code></td>\n</tr>\n<tr>\n<td>O</td>\n<td><code>O</code></td>\n<td>ο</td>\n<td><code>\\omicron</code></td>\n</tr>\n<tr>\n<td>Π</td>\n<td><code>\\Pi</code></td>\n<td>π</td>\n<td><code>\\pi</code></td>\n</tr>\n<tr>\n<td>P</td>\n<td><code>P</code></td>\n<td>ρ</td>\n<td><code>\\rho</code></td>\n</tr>\n<tr>\n<td>Σ</td>\n<td><code>\\Sigma</code></td>\n<td>σ</td>\n<td><code>\\sigma</code></td>\n</tr>\n<tr>\n<td>T</td>\n<td><code>T</code></td>\n<td>τ</td>\n<td><code>\\tau</code></td>\n</tr>\n<tr>\n<td>Υ</td>\n<td><code>\\Upsilon</code></td>\n<td>υ</td>\n<td><code>\\upsilon</code></td>\n</tr>\n<tr>\n<td>Φ</td>\n<td><code>\\Phi</code></td>\n<td>ϕ</td>\n<td><code>\\phi</code></td>\n</tr>\n<tr>\n<td>X</td>\n<td><code>X</code></td>\n<td>χ</td>\n<td><code>\\chi</code></td>\n</tr>\n<tr>\n<td>Ψ</td>\n<td><code>\\Psi</code></td>\n<td>ψ</td>\n<td><code>\\psi</code></td>\n</tr>\n<tr>\n<td>Ω</td>\n<td><code>\\v</code></td>\n<td>ω</td>\n<td><code>\\omega</code></td>\n</tr>\n<tr>\n<td>ε</td>\n<td><code>$\\varepsilon$</code></td>\n<td>ϑ</td>\n<td><code>$\\vartheta$</code></td>\n</tr>\n<tr>\n<td>ϖ</td>\n<td><code>$\\varpi$</code></td>\n<td>ϱ</td>\n<td><code>$\\varrho$</code></td>\n</tr>\n<tr>\n<td>ς</td>\n<td><code>$\\varsigma$</code></td>\n<td>φ</td>\n<td><code>$\\varphi$</code></td>\n</tr>\n</tbody></table>\n<p><a href=\"https://links.jianshu.com/go?to=https://blog.csdn.net/weixin_43159628/article/details/88237139\">https://blog.csdn.net/weixin_43159628&#x2F;article&#x2F;details&#x2F;88237139</a><br><a href=\"https://www.jianshu.com/p/08cbe54a5f33\">https://www.jianshu.com/p/08cbe54a5f33</a></p>\n<p>作者：无剑_君<br>链接：<a href=\"https://www.jianshu.com/p/383e8149136c\">https://www.jianshu.com/p/383e8149136c</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n"},{"_content":"## 网络配置\n### 三种网络模式的区别\n#### 桥接模式\n![[Pasted image 20240329091944.png]]\n（图中的网卡虚拟交换机，实际上是物理主机的）\n指将虚拟机直接连接到物理网络中，使得虚拟机可以像局域网中的独立主机一样进行通信。\n\n在选择桥接模式时，如果需要使用一个分配的网络账号才能上网（比如公司或学校的网络），虚拟机将无法直接上网。原因在于，虚拟机此时被当作局域网中的另一台电脑，是一台独立主机，而宿主机的网卡则被虚拟化成了一个交换机。因此，虚拟机无法通过桥接模式直接使用分配的网络账号进行上网。\n#### NAT 模式\n![[Pasted image 20240329092608.png]]\nNAT（Network Address Translation）模式：用于共享主机的IP地址。\n\nNAT模式能够解决账号上网的问题。在NAT模式下，物理主机充当了代理服务器的角色。当虚拟机需要访问外部网络资源时，首先会向物理主机发送请求，然后物理主机会代替虚拟机去外部网络拉去请求，并将响应转发给虚拟机。\n\n在NAT模式下，虚拟机之间和虚拟机与物理主机之间的通信是受到限制的。因为NAT会将虚拟机的IP地址转换为物理主机的IP地址，所以虚拟机之间和虚拟机与物理主机之间的网络流量都必须经过NAT设备进行转发。\n\n> 当虚拟机使用NAT模式时，虚拟机会被分配一个私有IP地址，这个地址只在虚拟网络内部有效。而物理主机与外界通信时使用的是公网IP地址。为了将虚拟机与外界联通，需要进行网络地址转换（Network Address Translation, NAT），将虚拟机的私有IP地址转换成物理主机的公网IP地址。  \n> 当虚拟机与外界通信时，网络流量从虚拟机发出，经过虚拟网卡，进入到NAT设备中。NAT设备会检查目标IP地址，如果是外部网络地址则会直接发送到物理主机接口；如果是内部网络地址，则会将流量重新封装，使用主机的公网IP地址作为源地址，再发送给路由器或互联网上的其他设备。  \n> 同样的，当虚拟机之间或者虚拟机与物理主机之间通信时，网络流量也需要经过NAT设备。例如，当虚拟机A向虚拟机B发送数据时，数据先会发到NAT设备，被NAT设备重新封装后再发送给虚拟机B。因此，无论是虚拟机之间的通信还是虚拟机与物理主机之间的通信，都需要经过NAT设备进行转发。\n\n另外，虚拟机可以访问外部网络，但外部网络无法直接访问虚拟机，这也是NAT模式的特点之一。\n\n> 当虚拟机使用NAT模式时，它可以通过物理主机访问外部网络。这是因为虚拟网络地址被转换为物理网络地址，并且所有的网络通信都通过物理主机进行转发。  \n> 虚拟机发送的网络请求首先到达物理主机，然后物理主机将这些请求发送到外部网络。外部网络接收到请求后，将响应返回给物理主机，再由物理主机转发给相应的虚拟机。  \n> 然而，外部网络无法直接访问虚拟机。这是因为虚拟机的网络地址是由NAT模式进行转换的，它与物理主机存在不同的网络地址空间。外部网络只能识别并访问物理主机的网络地址，而无法直接访问虚拟机的网络地址。  \n> 这种限制提供了一层安全性，防止外部网络直接访问到虚拟机。虚拟机被保护在一个相对独立的网络环境中，只能通过物理主机来与外部网络进行通信。这有助于保护虚拟机免受潜在的网络攻击和威胁。\n#### 仅主机模式\n![[Pasted image 20240329102239.png]]\n\n当使用虚拟机进行测试、实验或隔离时，可以选择使用主机模式,这种模式适用于需要隔离、安全性要求较高或仅在单个主机上运行虚拟机的场景。在主机模式下，虚拟机与主机共享一个专用网络，而与外部网络相隔离。\n\n在主机模式下，虚拟机使用的是主机的物理网络接口，而不是虚拟化软件提供的虚拟网络接口。这意味着虚拟机可以通过主机来与外部网络通信，但外部网络无法直接访问虚拟机。\n\n为了实现虚拟机之间的通信，在物理主机上会虚拟出一个虚拟路由器。这个虚拟路由器会创建一个虚拟网卡（例如VMnet1），用于连接所有虚拟机。虚拟网卡负责控制虚拟机之间的信息传递，类似于一个路由器。你可以通过配置虚拟路由器的DHCP地址池，让新建立的虚拟机动态获取到同一网段的IP地址，从而实现虚拟机之间的互相通信。\n\n需要注意的是，虚拟网卡和主机的物理网卡是独立的，它们之间不能直接通信。虚拟网卡只用于虚拟机之间的通信，而主机的物理网卡用于虚拟机与外部网络的通信。\n\n主机模式提供了一种隔离虚拟机和外部网络的方式，可用于进行测试、安全实验等需要隔离环境的场景。但需要注意的是，在主机模式下，虚拟机无法直接与外部网络通信，这也是主机模式在某些场景下的限制之一。\n\n在仅主机模式下，虚拟机可以共享主机的计算资源，例如处理器、内存和存储空间。这允许您在单个物理主机上运行多个虚拟机，并高效地利用计算资源。\n\n\n### 虚拟机静态 ip 配置\n1. 查看宿主机 ip\n\t![[Pasted image 20240329141220.png]]\n2. 打开 Vmware 虚拟网络设置，依次点击”编辑“ – ”虚拟网络编辑器“\n\t![[Pasted image 20240329142244.png]]\n\t1. 这里选择 NAT 模式\n\t2. 为了能够使用静态IP，这里不要勾选”使用本地DHCP服务将IP分配给虚拟机“这个选项。\n\t3. 然后是配置子网 ip，子网 IP 与宿主机的 ip 一定不能处在同一地址范围里，否则就算虚拟机能上网，网络既慢，还不稳定。我主机的 ip 段是113.54.xxx.xxx，所以我配了113.54.10.xxx 来避开主机的 ip 段，反正 ip 的第三个数字在 0 到 254 并且不是 115 就行。\n\t4. 点”NAT设置”，查看虚拟机的网关。\n\t\t![[Pasted image 20240329142326.png]]\n\t\t配置网关 IP 以匹配子网 IP，同时添加端口转发规则。\n3. 进入虚拟机配置网络，vi /etc/sysconfig/network-scripts/ifcfg-name\n\t```text\n\tTYPE=Ethernet\n\tPROXY_METHOD=none\n\tBROWSER_ONLY=no\n\tBOOTPROTO=static\n\tDEFROUTE=yes\n\tIPU4_FAILURE_FATAL=n0\n\tIPU6INIT=yes\n\tIPU6_AUTOCONF=yes\n\tIPU6_DEFR0UTE=yes\n\tIPU6_FAILURE_FATAL=no\n\tIPU6_ADDR_GEN_MODE=stable-privacy\n\tNAME=ens33\n\tUU1D=2bd40a1c-8168-4ad1-97cf-b87fc6d2818e\n\tDEVICE=ens33\n\tONBOOT=yes\n\tGATEWAY=113.54.10.2\n\tIPADDR=113.54.10.23\n\tNETMASK=255.255.255.0\n\tDNS1=114.114.114.114\n\t```\n4. 重启网卡服务，执行 service network restart \n### 多网卡路由\n#### 需求\n配置如图网络：\n![[Pasted image 20240329152009.png]]\n此时，虚拟机的 192 网段之间可以互相 ping 通，但是虚拟机 A 的192 无法 ping 通虚拟机 B 的 113 网段。 \n\n#### 解决：配置路由\n \n安装工具\n```sh\nyum install net-tools iptables tcpdump\n```\n添加路由：将虚拟主机 B 的私有地址作为公网地址的网关。\n```\nroute add -host 113.54.10.22  gw 192.168.75.130\n```\n","source":"_posts/工具教程/配置：VMWare.md","raw":"## 网络配置\n### 三种网络模式的区别\n#### 桥接模式\n![[Pasted image 20240329091944.png]]\n（图中的网卡虚拟交换机，实际上是物理主机的）\n指将虚拟机直接连接到物理网络中，使得虚拟机可以像局域网中的独立主机一样进行通信。\n\n在选择桥接模式时，如果需要使用一个分配的网络账号才能上网（比如公司或学校的网络），虚拟机将无法直接上网。原因在于，虚拟机此时被当作局域网中的另一台电脑，是一台独立主机，而宿主机的网卡则被虚拟化成了一个交换机。因此，虚拟机无法通过桥接模式直接使用分配的网络账号进行上网。\n#### NAT 模式\n![[Pasted image 20240329092608.png]]\nNAT（Network Address Translation）模式：用于共享主机的IP地址。\n\nNAT模式能够解决账号上网的问题。在NAT模式下，物理主机充当了代理服务器的角色。当虚拟机需要访问外部网络资源时，首先会向物理主机发送请求，然后物理主机会代替虚拟机去外部网络拉去请求，并将响应转发给虚拟机。\n\n在NAT模式下，虚拟机之间和虚拟机与物理主机之间的通信是受到限制的。因为NAT会将虚拟机的IP地址转换为物理主机的IP地址，所以虚拟机之间和虚拟机与物理主机之间的网络流量都必须经过NAT设备进行转发。\n\n> 当虚拟机使用NAT模式时，虚拟机会被分配一个私有IP地址，这个地址只在虚拟网络内部有效。而物理主机与外界通信时使用的是公网IP地址。为了将虚拟机与外界联通，需要进行网络地址转换（Network Address Translation, NAT），将虚拟机的私有IP地址转换成物理主机的公网IP地址。  \n> 当虚拟机与外界通信时，网络流量从虚拟机发出，经过虚拟网卡，进入到NAT设备中。NAT设备会检查目标IP地址，如果是外部网络地址则会直接发送到物理主机接口；如果是内部网络地址，则会将流量重新封装，使用主机的公网IP地址作为源地址，再发送给路由器或互联网上的其他设备。  \n> 同样的，当虚拟机之间或者虚拟机与物理主机之间通信时，网络流量也需要经过NAT设备。例如，当虚拟机A向虚拟机B发送数据时，数据先会发到NAT设备，被NAT设备重新封装后再发送给虚拟机B。因此，无论是虚拟机之间的通信还是虚拟机与物理主机之间的通信，都需要经过NAT设备进行转发。\n\n另外，虚拟机可以访问外部网络，但外部网络无法直接访问虚拟机，这也是NAT模式的特点之一。\n\n> 当虚拟机使用NAT模式时，它可以通过物理主机访问外部网络。这是因为虚拟网络地址被转换为物理网络地址，并且所有的网络通信都通过物理主机进行转发。  \n> 虚拟机发送的网络请求首先到达物理主机，然后物理主机将这些请求发送到外部网络。外部网络接收到请求后，将响应返回给物理主机，再由物理主机转发给相应的虚拟机。  \n> 然而，外部网络无法直接访问虚拟机。这是因为虚拟机的网络地址是由NAT模式进行转换的，它与物理主机存在不同的网络地址空间。外部网络只能识别并访问物理主机的网络地址，而无法直接访问虚拟机的网络地址。  \n> 这种限制提供了一层安全性，防止外部网络直接访问到虚拟机。虚拟机被保护在一个相对独立的网络环境中，只能通过物理主机来与外部网络进行通信。这有助于保护虚拟机免受潜在的网络攻击和威胁。\n#### 仅主机模式\n![[Pasted image 20240329102239.png]]\n\n当使用虚拟机进行测试、实验或隔离时，可以选择使用主机模式,这种模式适用于需要隔离、安全性要求较高或仅在单个主机上运行虚拟机的场景。在主机模式下，虚拟机与主机共享一个专用网络，而与外部网络相隔离。\n\n在主机模式下，虚拟机使用的是主机的物理网络接口，而不是虚拟化软件提供的虚拟网络接口。这意味着虚拟机可以通过主机来与外部网络通信，但外部网络无法直接访问虚拟机。\n\n为了实现虚拟机之间的通信，在物理主机上会虚拟出一个虚拟路由器。这个虚拟路由器会创建一个虚拟网卡（例如VMnet1），用于连接所有虚拟机。虚拟网卡负责控制虚拟机之间的信息传递，类似于一个路由器。你可以通过配置虚拟路由器的DHCP地址池，让新建立的虚拟机动态获取到同一网段的IP地址，从而实现虚拟机之间的互相通信。\n\n需要注意的是，虚拟网卡和主机的物理网卡是独立的，它们之间不能直接通信。虚拟网卡只用于虚拟机之间的通信，而主机的物理网卡用于虚拟机与外部网络的通信。\n\n主机模式提供了一种隔离虚拟机和外部网络的方式，可用于进行测试、安全实验等需要隔离环境的场景。但需要注意的是，在主机模式下，虚拟机无法直接与外部网络通信，这也是主机模式在某些场景下的限制之一。\n\n在仅主机模式下，虚拟机可以共享主机的计算资源，例如处理器、内存和存储空间。这允许您在单个物理主机上运行多个虚拟机，并高效地利用计算资源。\n\n\n### 虚拟机静态 ip 配置\n1. 查看宿主机 ip\n\t![[Pasted image 20240329141220.png]]\n2. 打开 Vmware 虚拟网络设置，依次点击”编辑“ – ”虚拟网络编辑器“\n\t![[Pasted image 20240329142244.png]]\n\t1. 这里选择 NAT 模式\n\t2. 为了能够使用静态IP，这里不要勾选”使用本地DHCP服务将IP分配给虚拟机“这个选项。\n\t3. 然后是配置子网 ip，子网 IP 与宿主机的 ip 一定不能处在同一地址范围里，否则就算虚拟机能上网，网络既慢，还不稳定。我主机的 ip 段是113.54.xxx.xxx，所以我配了113.54.10.xxx 来避开主机的 ip 段，反正 ip 的第三个数字在 0 到 254 并且不是 115 就行。\n\t4. 点”NAT设置”，查看虚拟机的网关。\n\t\t![[Pasted image 20240329142326.png]]\n\t\t配置网关 IP 以匹配子网 IP，同时添加端口转发规则。\n3. 进入虚拟机配置网络，vi /etc/sysconfig/network-scripts/ifcfg-name\n\t```text\n\tTYPE=Ethernet\n\tPROXY_METHOD=none\n\tBROWSER_ONLY=no\n\tBOOTPROTO=static\n\tDEFROUTE=yes\n\tIPU4_FAILURE_FATAL=n0\n\tIPU6INIT=yes\n\tIPU6_AUTOCONF=yes\n\tIPU6_DEFR0UTE=yes\n\tIPU6_FAILURE_FATAL=no\n\tIPU6_ADDR_GEN_MODE=stable-privacy\n\tNAME=ens33\n\tUU1D=2bd40a1c-8168-4ad1-97cf-b87fc6d2818e\n\tDEVICE=ens33\n\tONBOOT=yes\n\tGATEWAY=113.54.10.2\n\tIPADDR=113.54.10.23\n\tNETMASK=255.255.255.0\n\tDNS1=114.114.114.114\n\t```\n4. 重启网卡服务，执行 service network restart \n### 多网卡路由\n#### 需求\n配置如图网络：\n![[Pasted image 20240329152009.png]]\n此时，虚拟机的 192 网段之间可以互相 ping 通，但是虚拟机 A 的192 无法 ping 通虚拟机 B 的 113 网段。 \n\n#### 解决：配置路由\n \n安装工具\n```sh\nyum install net-tools iptables tcpdump\n```\n添加路由：将虚拟主机 B 的私有地址作为公网地址的网关。\n```\nroute add -host 113.54.10.22  gw 192.168.75.130\n```\n","slug":"工具教程/配置：VMWare","published":1,"date":"2024-04-22T13:14:48.762Z","updated":"2024-03-30T04:43:33.895Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0c000kkgg4ghkr3ads","content":"<h2 id=\"网络配置\"><a href=\"#网络配置\" class=\"headerlink\" title=\"网络配置\"></a>网络配置</h2><h3 id=\"三种网络模式的区别\"><a href=\"#三种网络模式的区别\" class=\"headerlink\" title=\"三种网络模式的区别\"></a>三种网络模式的区别</h3><h4 id=\"桥接模式\"><a href=\"#桥接模式\" class=\"headerlink\" title=\"桥接模式\"></a>桥接模式</h4><p>![[Pasted image 20240329091944.png]]<br>（图中的网卡虚拟交换机，实际上是物理主机的）<br>指将虚拟机直接连接到物理网络中，使得虚拟机可以像局域网中的独立主机一样进行通信。</p>\n<p>在选择桥接模式时，如果需要使用一个分配的网络账号才能上网（比如公司或学校的网络），虚拟机将无法直接上网。原因在于，虚拟机此时被当作局域网中的另一台电脑，是一台独立主机，而宿主机的网卡则被虚拟化成了一个交换机。因此，虚拟机无法通过桥接模式直接使用分配的网络账号进行上网。</p>\n<h4 id=\"NAT-模式\"><a href=\"#NAT-模式\" class=\"headerlink\" title=\"NAT 模式\"></a>NAT 模式</h4><p>![[Pasted image 20240329092608.png]]<br>NAT（Network Address Translation）模式：用于共享主机的IP地址。</p>\n<p>NAT模式能够解决账号上网的问题。在NAT模式下，物理主机充当了代理服务器的角色。当虚拟机需要访问外部网络资源时，首先会向物理主机发送请求，然后物理主机会代替虚拟机去外部网络拉去请求，并将响应转发给虚拟机。</p>\n<p>在NAT模式下，虚拟机之间和虚拟机与物理主机之间的通信是受到限制的。因为NAT会将虚拟机的IP地址转换为物理主机的IP地址，所以虚拟机之间和虚拟机与物理主机之间的网络流量都必须经过NAT设备进行转发。</p>\n<blockquote>\n<p>当虚拟机使用NAT模式时，虚拟机会被分配一个私有IP地址，这个地址只在虚拟网络内部有效。而物理主机与外界通信时使用的是公网IP地址。为了将虚拟机与外界联通，需要进行网络地址转换（Network Address Translation, NAT），将虚拟机的私有IP地址转换成物理主机的公网IP地址。<br>当虚拟机与外界通信时，网络流量从虚拟机发出，经过虚拟网卡，进入到NAT设备中。NAT设备会检查目标IP地址，如果是外部网络地址则会直接发送到物理主机接口；如果是内部网络地址，则会将流量重新封装，使用主机的公网IP地址作为源地址，再发送给路由器或互联网上的其他设备。<br>同样的，当虚拟机之间或者虚拟机与物理主机之间通信时，网络流量也需要经过NAT设备。例如，当虚拟机A向虚拟机B发送数据时，数据先会发到NAT设备，被NAT设备重新封装后再发送给虚拟机B。因此，无论是虚拟机之间的通信还是虚拟机与物理主机之间的通信，都需要经过NAT设备进行转发。</p>\n</blockquote>\n<p>另外，虚拟机可以访问外部网络，但外部网络无法直接访问虚拟机，这也是NAT模式的特点之一。</p>\n<blockquote>\n<p>当虚拟机使用NAT模式时，它可以通过物理主机访问外部网络。这是因为虚拟网络地址被转换为物理网络地址，并且所有的网络通信都通过物理主机进行转发。<br>虚拟机发送的网络请求首先到达物理主机，然后物理主机将这些请求发送到外部网络。外部网络接收到请求后，将响应返回给物理主机，再由物理主机转发给相应的虚拟机。<br>然而，外部网络无法直接访问虚拟机。这是因为虚拟机的网络地址是由NAT模式进行转换的，它与物理主机存在不同的网络地址空间。外部网络只能识别并访问物理主机的网络地址，而无法直接访问虚拟机的网络地址。<br>这种限制提供了一层安全性，防止外部网络直接访问到虚拟机。虚拟机被保护在一个相对独立的网络环境中，只能通过物理主机来与外部网络进行通信。这有助于保护虚拟机免受潜在的网络攻击和威胁。</p>\n</blockquote>\n<h4 id=\"仅主机模式\"><a href=\"#仅主机模式\" class=\"headerlink\" title=\"仅主机模式\"></a>仅主机模式</h4><p>![[Pasted image 20240329102239.png]]</p>\n<p>当使用虚拟机进行测试、实验或隔离时，可以选择使用主机模式,这种模式适用于需要隔离、安全性要求较高或仅在单个主机上运行虚拟机的场景。在主机模式下，虚拟机与主机共享一个专用网络，而与外部网络相隔离。</p>\n<p>在主机模式下，虚拟机使用的是主机的物理网络接口，而不是虚拟化软件提供的虚拟网络接口。这意味着虚拟机可以通过主机来与外部网络通信，但外部网络无法直接访问虚拟机。</p>\n<p>为了实现虚拟机之间的通信，在物理主机上会虚拟出一个虚拟路由器。这个虚拟路由器会创建一个虚拟网卡（例如VMnet1），用于连接所有虚拟机。虚拟网卡负责控制虚拟机之间的信息传递，类似于一个路由器。你可以通过配置虚拟路由器的DHCP地址池，让新建立的虚拟机动态获取到同一网段的IP地址，从而实现虚拟机之间的互相通信。</p>\n<p>需要注意的是，虚拟网卡和主机的物理网卡是独立的，它们之间不能直接通信。虚拟网卡只用于虚拟机之间的通信，而主机的物理网卡用于虚拟机与外部网络的通信。</p>\n<p>主机模式提供了一种隔离虚拟机和外部网络的方式，可用于进行测试、安全实验等需要隔离环境的场景。但需要注意的是，在主机模式下，虚拟机无法直接与外部网络通信，这也是主机模式在某些场景下的限制之一。</p>\n<p>在仅主机模式下，虚拟机可以共享主机的计算资源，例如处理器、内存和存储空间。这允许您在单个物理主机上运行多个虚拟机，并高效地利用计算资源。</p>\n<h3 id=\"虚拟机静态-ip-配置\"><a href=\"#虚拟机静态-ip-配置\" class=\"headerlink\" title=\"虚拟机静态 ip 配置\"></a>虚拟机静态 ip 配置</h3><ol>\n<li>查看宿主机 ip<br> ![[Pasted image 20240329141220.png]]</li>\n<li>打开 Vmware 虚拟网络设置，依次点击”编辑“ – ”虚拟网络编辑器“<br> ![[Pasted image 20240329142244.png]]<ol>\n<li>这里选择 NAT 模式</li>\n<li>为了能够使用静态IP，这里不要勾选”使用本地DHCP服务将IP分配给虚拟机“这个选项。</li>\n<li>然后是配置子网 ip，子网 IP 与宿主机的 ip 一定不能处在同一地址范围里，否则就算虚拟机能上网，网络既慢，还不稳定。我主机的 ip 段是113.54.xxx.xxx，所以我配了113.54.10.xxx 来避开主机的 ip 段，反正 ip 的第三个数字在 0 到 254 并且不是 115 就行。</li>\n<li>点”NAT设置”，查看虚拟机的网关。<br> ![[Pasted image 20240329142326.png]]<br> 配置网关 IP 以匹配子网 IP，同时添加端口转发规则。</li>\n</ol>\n</li>\n<li>进入虚拟机配置网络，vi &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-name <figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TYPE=Ethernet</span><br><span class=\"line\">PROXY_METHOD=none</span><br><span class=\"line\">BROWSER_ONLY=no</span><br><span class=\"line\">BOOTPROTO=static</span><br><span class=\"line\">DEFROUTE=yes</span><br><span class=\"line\">IPU4_FAILURE_FATAL=n0</span><br><span class=\"line\">IPU6INIT=yes</span><br><span class=\"line\">IPU6_AUTOCONF=yes</span><br><span class=\"line\">IPU6_DEFR0UTE=yes</span><br><span class=\"line\">IPU6_FAILURE_FATAL=no</span><br><span class=\"line\">IPU6_ADDR_GEN_MODE=stable-privacy</span><br><span class=\"line\">NAME=ens33</span><br><span class=\"line\">UU1D=2bd40a1c-8168-4ad1-97cf-b87fc6d2818e</span><br><span class=\"line\">DEVICE=ens33</span><br><span class=\"line\">ONBOOT=yes</span><br><span class=\"line\">GATEWAY=113.54.10.2</span><br><span class=\"line\">IPADDR=113.54.10.23</span><br><span class=\"line\">NETMASK=255.255.255.0</span><br><span class=\"line\">DNS1=114.114.114.114</span><br></pre></td></tr></table></figure></li>\n<li>重启网卡服务，执行 service network restart</li>\n</ol>\n<h3 id=\"多网卡路由\"><a href=\"#多网卡路由\" class=\"headerlink\" title=\"多网卡路由\"></a>多网卡路由</h3><h4 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h4><p>配置如图网络：<br>![[Pasted image 20240329152009.png]]<br>此时，虚拟机的 192 网段之间可以互相 ping 通，但是虚拟机 A 的192 无法 ping 通虚拟机 B 的 113 网段。 </p>\n<h4 id=\"解决：配置路由\"><a href=\"#解决：配置路由\" class=\"headerlink\" title=\"解决：配置路由\"></a>解决：配置路由</h4><p>安装工具</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install net-tools iptables tcpdump</span><br></pre></td></tr></table></figure>\n<p>添加路由：将虚拟主机 B 的私有地址作为公网地址的网关。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">route add -host 113.54.10.22  gw 192.168.75.130</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<h2 id=\"网络配置\"><a href=\"#网络配置\" class=\"headerlink\" title=\"网络配置\"></a>网络配置</h2><h3 id=\"三种网络模式的区别\"><a href=\"#三种网络模式的区别\" class=\"headerlink\" title=\"三种网络模式的区别\"></a>三种网络模式的区别</h3><h4 id=\"桥接模式\"><a href=\"#桥接模式\" class=\"headerlink\" title=\"桥接模式\"></a>桥接模式</h4><p>![[Pasted image 20240329091944.png]]<br>（图中的网卡虚拟交换机，实际上是物理主机的）<br>指将虚拟机直接连接到物理网络中，使得虚拟机可以像局域网中的独立主机一样进行通信。</p>\n<p>在选择桥接模式时，如果需要使用一个分配的网络账号才能上网（比如公司或学校的网络），虚拟机将无法直接上网。原因在于，虚拟机此时被当作局域网中的另一台电脑，是一台独立主机，而宿主机的网卡则被虚拟化成了一个交换机。因此，虚拟机无法通过桥接模式直接使用分配的网络账号进行上网。</p>\n<h4 id=\"NAT-模式\"><a href=\"#NAT-模式\" class=\"headerlink\" title=\"NAT 模式\"></a>NAT 模式</h4><p>![[Pasted image 20240329092608.png]]<br>NAT（Network Address Translation）模式：用于共享主机的IP地址。</p>\n<p>NAT模式能够解决账号上网的问题。在NAT模式下，物理主机充当了代理服务器的角色。当虚拟机需要访问外部网络资源时，首先会向物理主机发送请求，然后物理主机会代替虚拟机去外部网络拉去请求，并将响应转发给虚拟机。</p>\n<p>在NAT模式下，虚拟机之间和虚拟机与物理主机之间的通信是受到限制的。因为NAT会将虚拟机的IP地址转换为物理主机的IP地址，所以虚拟机之间和虚拟机与物理主机之间的网络流量都必须经过NAT设备进行转发。</p>\n<blockquote>\n<p>当虚拟机使用NAT模式时，虚拟机会被分配一个私有IP地址，这个地址只在虚拟网络内部有效。而物理主机与外界通信时使用的是公网IP地址。为了将虚拟机与外界联通，需要进行网络地址转换（Network Address Translation, NAT），将虚拟机的私有IP地址转换成物理主机的公网IP地址。<br>当虚拟机与外界通信时，网络流量从虚拟机发出，经过虚拟网卡，进入到NAT设备中。NAT设备会检查目标IP地址，如果是外部网络地址则会直接发送到物理主机接口；如果是内部网络地址，则会将流量重新封装，使用主机的公网IP地址作为源地址，再发送给路由器或互联网上的其他设备。<br>同样的，当虚拟机之间或者虚拟机与物理主机之间通信时，网络流量也需要经过NAT设备。例如，当虚拟机A向虚拟机B发送数据时，数据先会发到NAT设备，被NAT设备重新封装后再发送给虚拟机B。因此，无论是虚拟机之间的通信还是虚拟机与物理主机之间的通信，都需要经过NAT设备进行转发。</p>\n</blockquote>\n<p>另外，虚拟机可以访问外部网络，但外部网络无法直接访问虚拟机，这也是NAT模式的特点之一。</p>\n<blockquote>\n<p>当虚拟机使用NAT模式时，它可以通过物理主机访问外部网络。这是因为虚拟网络地址被转换为物理网络地址，并且所有的网络通信都通过物理主机进行转发。<br>虚拟机发送的网络请求首先到达物理主机，然后物理主机将这些请求发送到外部网络。外部网络接收到请求后，将响应返回给物理主机，再由物理主机转发给相应的虚拟机。<br>然而，外部网络无法直接访问虚拟机。这是因为虚拟机的网络地址是由NAT模式进行转换的，它与物理主机存在不同的网络地址空间。外部网络只能识别并访问物理主机的网络地址，而无法直接访问虚拟机的网络地址。<br>这种限制提供了一层安全性，防止外部网络直接访问到虚拟机。虚拟机被保护在一个相对独立的网络环境中，只能通过物理主机来与外部网络进行通信。这有助于保护虚拟机免受潜在的网络攻击和威胁。</p>\n</blockquote>\n<h4 id=\"仅主机模式\"><a href=\"#仅主机模式\" class=\"headerlink\" title=\"仅主机模式\"></a>仅主机模式</h4><p>![[Pasted image 20240329102239.png]]</p>\n<p>当使用虚拟机进行测试、实验或隔离时，可以选择使用主机模式,这种模式适用于需要隔离、安全性要求较高或仅在单个主机上运行虚拟机的场景。在主机模式下，虚拟机与主机共享一个专用网络，而与外部网络相隔离。</p>\n<p>在主机模式下，虚拟机使用的是主机的物理网络接口，而不是虚拟化软件提供的虚拟网络接口。这意味着虚拟机可以通过主机来与外部网络通信，但外部网络无法直接访问虚拟机。</p>\n<p>为了实现虚拟机之间的通信，在物理主机上会虚拟出一个虚拟路由器。这个虚拟路由器会创建一个虚拟网卡（例如VMnet1），用于连接所有虚拟机。虚拟网卡负责控制虚拟机之间的信息传递，类似于一个路由器。你可以通过配置虚拟路由器的DHCP地址池，让新建立的虚拟机动态获取到同一网段的IP地址，从而实现虚拟机之间的互相通信。</p>\n<p>需要注意的是，虚拟网卡和主机的物理网卡是独立的，它们之间不能直接通信。虚拟网卡只用于虚拟机之间的通信，而主机的物理网卡用于虚拟机与外部网络的通信。</p>\n<p>主机模式提供了一种隔离虚拟机和外部网络的方式，可用于进行测试、安全实验等需要隔离环境的场景。但需要注意的是，在主机模式下，虚拟机无法直接与外部网络通信，这也是主机模式在某些场景下的限制之一。</p>\n<p>在仅主机模式下，虚拟机可以共享主机的计算资源，例如处理器、内存和存储空间。这允许您在单个物理主机上运行多个虚拟机，并高效地利用计算资源。</p>\n<h3 id=\"虚拟机静态-ip-配置\"><a href=\"#虚拟机静态-ip-配置\" class=\"headerlink\" title=\"虚拟机静态 ip 配置\"></a>虚拟机静态 ip 配置</h3><ol>\n<li>查看宿主机 ip<br> ![[Pasted image 20240329141220.png]]</li>\n<li>打开 Vmware 虚拟网络设置，依次点击”编辑“ – ”虚拟网络编辑器“<br> ![[Pasted image 20240329142244.png]]<ol>\n<li>这里选择 NAT 模式</li>\n<li>为了能够使用静态IP，这里不要勾选”使用本地DHCP服务将IP分配给虚拟机“这个选项。</li>\n<li>然后是配置子网 ip，子网 IP 与宿主机的 ip 一定不能处在同一地址范围里，否则就算虚拟机能上网，网络既慢，还不稳定。我主机的 ip 段是113.54.xxx.xxx，所以我配了113.54.10.xxx 来避开主机的 ip 段，反正 ip 的第三个数字在 0 到 254 并且不是 115 就行。</li>\n<li>点”NAT设置”，查看虚拟机的网关。<br> ![[Pasted image 20240329142326.png]]<br> 配置网关 IP 以匹配子网 IP，同时添加端口转发规则。</li>\n</ol>\n</li>\n<li>进入虚拟机配置网络，vi &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-name <figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TYPE=Ethernet</span><br><span class=\"line\">PROXY_METHOD=none</span><br><span class=\"line\">BROWSER_ONLY=no</span><br><span class=\"line\">BOOTPROTO=static</span><br><span class=\"line\">DEFROUTE=yes</span><br><span class=\"line\">IPU4_FAILURE_FATAL=n0</span><br><span class=\"line\">IPU6INIT=yes</span><br><span class=\"line\">IPU6_AUTOCONF=yes</span><br><span class=\"line\">IPU6_DEFR0UTE=yes</span><br><span class=\"line\">IPU6_FAILURE_FATAL=no</span><br><span class=\"line\">IPU6_ADDR_GEN_MODE=stable-privacy</span><br><span class=\"line\">NAME=ens33</span><br><span class=\"line\">UU1D=2bd40a1c-8168-4ad1-97cf-b87fc6d2818e</span><br><span class=\"line\">DEVICE=ens33</span><br><span class=\"line\">ONBOOT=yes</span><br><span class=\"line\">GATEWAY=113.54.10.2</span><br><span class=\"line\">IPADDR=113.54.10.23</span><br><span class=\"line\">NETMASK=255.255.255.0</span><br><span class=\"line\">DNS1=114.114.114.114</span><br></pre></td></tr></table></figure></li>\n<li>重启网卡服务，执行 service network restart</li>\n</ol>\n<h3 id=\"多网卡路由\"><a href=\"#多网卡路由\" class=\"headerlink\" title=\"多网卡路由\"></a>多网卡路由</h3><h4 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h4><p>配置如图网络：<br>![[Pasted image 20240329152009.png]]<br>此时，虚拟机的 192 网段之间可以互相 ping 通，但是虚拟机 A 的192 无法 ping 通虚拟机 B 的 113 网段。 </p>\n<h4 id=\"解决：配置路由\"><a href=\"#解决：配置路由\" class=\"headerlink\" title=\"解决：配置路由\"></a>解决：配置路由</h4><p>安装工具</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install net-tools iptables tcpdump</span><br></pre></td></tr></table></figure>\n<p>添加路由：将虚拟主机 B 的私有地址作为公网地址的网关。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">route add -host 113.54.10.22  gw 192.168.75.130</span><br></pre></td></tr></table></figure>\n"},{"_content":"\n# git 安装\n\n## Win 下载\nhttps://git-scm.com/download/\n## Linux\n```bash\napt-get install git\n```\n\n# git 配置\n\t注意： win 在 Git Bash 下； linux 在 /bin/bash 即可\n\n##### 生成公钥\n```bash\nssh-keygen -t rsa -C \"your_email@xxx.com\"\n```\n\n##### 获取公钥\n```bash\n# linux:\ncat ~/.ssh/id_rsa.pub\n#win: \nC:/user/.ssh/id_rsa.pub\n```\n\n##### 配置公钥\n复制公钥到 gitee｜githbu 网页个人设置中的公钥之中；保存。\n\n##### 终端环境配置\n```bash\nssh -T git@gitee.com\n\ngit config --global user.name yourname  # \"你码云的名字或昵称\"\n\ngit config --global user.email youremail@xxx.com # \"你码云的主邮箱\"\n\n```\n\n##### vscode 用一个远程库\n**初始化一个本次仓库**\nctrl+shift+p initialize repository: \n**远程链接**\n源代码管理库-》远程-》远程仓库-》粘贴.git 链接-》ok\n\n\n# git 使用\n##### 远程仓库管理\n\ngit remote -v:列出所有远程仓库的别名和地址\n\ngit remote show <远程仓库别名>:查看远程仓库的详细信息\n\ngit remote add <别名> <仓库地址>:添加一个新的远程仓库\n\ngit remote remove <别名>:删除一个远程仓库\n\ngit remote rename <原别名> <新别名>:重命名一个远程仓库\n\ngit remote set-url <别名> <新地址>:修改某个远程仓库的地址\n\ngit remote set-head <别名> <分支名>:修改远程仓库的默认分支\n\ngit remote -v update:更新所有远程仓库\n\ngit remote prune <别名>:移除远程上已删除的tracking分支\n\ngit remote get-url <别名>:查看远程仓库的原始克隆URL\n\n\n\n#### 查看跟踪远程分支\n\ngit branch -vv (当前分支：hash：远程跟踪分支：注释)\n\n#### 修改跟踪的远程分支\n\ngit branch --set-upstream-to=origin/remote-branch local-branch\n\n这将为本地分支 `local-branch` 设置远程跟踪分支为 `origin/remote-branch`。\n\n你也可以使用简化命令来设置远程跟踪分支：\n\ngit branch -u origin/remote-branch local-branch\n\n（这个命令用于现有本地分支，将其与远程分支相关联）\n\n#### 创建新分支\n\ngit branch  origin/serverfix\n\n\n\n#### 切换本地分支  \n\ngit checkout master \n\n  这里的master应该就是本地的分支\n\n\n\n此外：\n\ngit checkout -b master origin/master \n\n  表示切换的分支是新建的（本地只有main，没有master），分支名：master； 来源：orgin/master;\n\n\n确定要删除的分支，并运行以下命令来删除该分支（假设要删除的分支名为 branch-name）：\n\ngit branch -d branch-name\n\n如果分支上有未合并的更改，Git 会拒绝删除该分支，并显示一条警告消息。如果确实要强制删除分支，可以使用 -D 选项：\n\ngit branch -D branch-name\n\n\n\n#### 拉取\n\n源代码管理-》拉取\n\n或者 pull 就行\n\ngit pull [远程仓库名] [远程分支]\n\n\n\n\n#### 提交\n\n手动\n\n添加消息-》提交-》同步\n\n命令提交\n\n暂存：git add * \n\n\n## 提交：\n\n使用与当前分支关联的远程仓库和同名的远程分支：\n\ngit push \ngit push  xinka master\n\ngit push [<远程仓库名>] [<本地分支名>:]<远程分支名>\n\n强制将当前分支 覆盖掉origin 的 master 分支：\ngit push origin +current-branch:master\n\n\n\n\n（下面几个命令可以用来解决：refuse to merge unrelated histories）\n\n#### 获取分支最新提交hash\n\ngit log -1 main\n\n\n从远程仓库获取最新的提交和分支信息，但不会自动将这些更改合并到你的本地分支中：\n\ngit fetch <远程仓库名>\n\n使用其他命令（如git merge或git rebase）将这些更改合并到你的本地分支中。\n\n## git merge \n\ngit merge --strategy=ours <branch-to-merge>\n```\n这将执行合并操作，但将忽略其他分支（`<branch-to-merge>`）的更改，仅保留当前分支（主分支）的内容。任何冲突都会被自动解决为当前分支的更改。\n\ngit merge --strategy=theirs <branch-to-merge>\n```\n这将执行合并操作，但会忽略当前分支的更改，选择其他分支（`<branch-to-merge>`）的内容。冲突会被自动解决为其他分支的更改。\n\n\n# 放弃本地分支，重置到master分支的最新提交\n\n1. git fetch\n\n2. git reset --hard <dev-latest-commit-hash>\n\n或者\n\n2. git reset --hard origin/master\n\n\n\n另一种解释：放弃本地更改：\n\ngit reset --hard FETCH_HEAD，其中FETCH_HEAD表示上一次成功pull之后的commit点，然后git pull即可\n\n\n# 强制推送当前分支到远程分支\n\ngit push -f xinka master\n\n这样就丢掉了 master 原来的历史。这样可以快速建立分支之间的关系，但是原有分支的历史提交会丢失。需要根据实际情况权衡是否使用这种破坏性的重置方式。\n上面可能会出现：error: src refspec localagent does not match any ，此时，试试下面的操作。\n\ngit fetch\ngit push -f orign  HEAD:<远程分支名>\n\n\n\n# 补充\n\ngit pull 后 仓库  在本地的默认名称  就是  origin\n\n查看：git remote -v \n\n修改：git remote rename old new\n\n比如： git push origin master 表示将本地 推到 master\n\n永久修改默认名称：git config --global init.defaultBranch new_name;\n\n\n#  强制覆盖本地分支\n\n    git fetch --all\n\n    git reset --hard origin/master\n\n    git pull\n\n\n\n## 强制覆盖远程分支\n\ngit push [<远程仓库名>] [<本地分支名>:]<远程分支名>\n\n每次提交之后，必须点击：同步更改才能看到网页的变化。\n\n# 问题解决\n## connect reset 问题，直接通过命令行配置解决\ngit config --global http.sslBackend \"openssl\"\n\ngit config --global http.sslCAInfo \"C:\\Program Files\\Git\\mingw64\\ssl\\cert.pem\"\n\n\n\n\n## git remote\n\ngit remote [-v | --verbose]\n\n显示所有远程仓库的名称，以及它们的 URL。\n示例：git remote -v\ngit remote add [-t <branch>] [-m <master>] [-f] [--tags | --no-tags] [--mirror=<fetch|push>] <name> <url>\n\n添加一个新的远程仓库。\n示例：git remote add origin https://github.com/user/repo.git\ngit remote rename [--[no-]progress] <old> <new>\n\n重命名一个远程仓库。\n示例：git remote rename origin upstream\ngit remote remove <name>\n\n移除指定名称的远程仓库。\n示例：git remote remove origin\ngit remote set-head <name> (-a | --auto | -d | --delete | <branch>)\n\n设置指定远程仓库的 HEAD 引用。\n示例：git remote set-head origin master\ngit remote show [-n] <name>\n\n显示指定远程仓库的信息，包括分支和跟踪情况。\n示例：git remote show origin\ngit remote prune [-n | --dry-run] <name>\n\n移除没有对应本地分支的指定远程仓库分支的引用。\n示例：git remote prune origin\ngit remote update [-p | --prune] [(<group> | <remote>)...]\n\n更新指定的远程仓库的引用。\n示例：git remote update origin\ngit remote set-branches [--add] <name> <branch>...\n\n设置指定远程仓库应该跟踪的分支。\n示例：git remote set-branches origin main\ngit remote get-url [--push] [--all] <name>\n\n获取指定远程仓库的 URL。\n示例：git remote get-url origin\ngit remote set-url [--push] <name> <newurl> [<oldurl>]\n\n设置指定远程仓库的 URL。\n示例：git remote set-url origin https://github.com/user/new-repo.git\ngit remote set-url --add <name> <newurl>\n\n添加一个新的 URL 到指定远程仓库。\n示例：git remote set-url --add origin https://github.com/user/old-repo.git\ngit remote set-url --delete <name> <url>\n\n从指定远程仓库中删除指定的 URL。\n示例：git remote set-url --delete origin https://github.com/user/old-repo.git\n\n\n# 创建一个新的分支来保留你所做的提交\n\ngit switch -c <new-branch-name>  :这将在当前提交处创建一个新的分支，并切换到该分支，让你可以在该分支上继续工作\n\n如果放弃处于分离头指针状态下的更改，执行：git switch -  ：将切换回进入分离头指针状态之前所在的分支\n\n\n# 将一个本地仓库 提交到另一个本地仓库跟踪的远程分支\n\n确保你当前在本地分支 pv 上。可以使用以下命令检查当前所在的分支：\n\n\ngit branch\n确保 pv 分支前面有 * 标记。\n\n首先，将本地分支 pv 推送到远程的 private/master 分支。执行以下命令：\n\ngit push private pv:master\n这将把本地分支 pv 推送到远程仓库的 private/master 分支。\n\n接下来，切换到本地分支 pv 并合并远程的 public/master 分支。执行以下命令：\n\ngit checkout pv\ngit merge public/master\n这将切换到分支 pv 并将远程的 public/master 分支合并到本地分支。\n\n最后，将合并后的更改推送到远程的 public/master 分支。执行以下命令：\n\n\ngit push public pv:master\n这将把本地分支 pv 推送到远程仓库的 public/master 分支。\n\n\n","source":"_posts/工具教程/教程：git.md","raw":"\n# git 安装\n\n## Win 下载\nhttps://git-scm.com/download/\n## Linux\n```bash\napt-get install git\n```\n\n# git 配置\n\t注意： win 在 Git Bash 下； linux 在 /bin/bash 即可\n\n##### 生成公钥\n```bash\nssh-keygen -t rsa -C \"your_email@xxx.com\"\n```\n\n##### 获取公钥\n```bash\n# linux:\ncat ~/.ssh/id_rsa.pub\n#win: \nC:/user/.ssh/id_rsa.pub\n```\n\n##### 配置公钥\n复制公钥到 gitee｜githbu 网页个人设置中的公钥之中；保存。\n\n##### 终端环境配置\n```bash\nssh -T git@gitee.com\n\ngit config --global user.name yourname  # \"你码云的名字或昵称\"\n\ngit config --global user.email youremail@xxx.com # \"你码云的主邮箱\"\n\n```\n\n##### vscode 用一个远程库\n**初始化一个本次仓库**\nctrl+shift+p initialize repository: \n**远程链接**\n源代码管理库-》远程-》远程仓库-》粘贴.git 链接-》ok\n\n\n# git 使用\n##### 远程仓库管理\n\ngit remote -v:列出所有远程仓库的别名和地址\n\ngit remote show <远程仓库别名>:查看远程仓库的详细信息\n\ngit remote add <别名> <仓库地址>:添加一个新的远程仓库\n\ngit remote remove <别名>:删除一个远程仓库\n\ngit remote rename <原别名> <新别名>:重命名一个远程仓库\n\ngit remote set-url <别名> <新地址>:修改某个远程仓库的地址\n\ngit remote set-head <别名> <分支名>:修改远程仓库的默认分支\n\ngit remote -v update:更新所有远程仓库\n\ngit remote prune <别名>:移除远程上已删除的tracking分支\n\ngit remote get-url <别名>:查看远程仓库的原始克隆URL\n\n\n\n#### 查看跟踪远程分支\n\ngit branch -vv (当前分支：hash：远程跟踪分支：注释)\n\n#### 修改跟踪的远程分支\n\ngit branch --set-upstream-to=origin/remote-branch local-branch\n\n这将为本地分支 `local-branch` 设置远程跟踪分支为 `origin/remote-branch`。\n\n你也可以使用简化命令来设置远程跟踪分支：\n\ngit branch -u origin/remote-branch local-branch\n\n（这个命令用于现有本地分支，将其与远程分支相关联）\n\n#### 创建新分支\n\ngit branch  origin/serverfix\n\n\n\n#### 切换本地分支  \n\ngit checkout master \n\n  这里的master应该就是本地的分支\n\n\n\n此外：\n\ngit checkout -b master origin/master \n\n  表示切换的分支是新建的（本地只有main，没有master），分支名：master； 来源：orgin/master;\n\n\n确定要删除的分支，并运行以下命令来删除该分支（假设要删除的分支名为 branch-name）：\n\ngit branch -d branch-name\n\n如果分支上有未合并的更改，Git 会拒绝删除该分支，并显示一条警告消息。如果确实要强制删除分支，可以使用 -D 选项：\n\ngit branch -D branch-name\n\n\n\n#### 拉取\n\n源代码管理-》拉取\n\n或者 pull 就行\n\ngit pull [远程仓库名] [远程分支]\n\n\n\n\n#### 提交\n\n手动\n\n添加消息-》提交-》同步\n\n命令提交\n\n暂存：git add * \n\n\n## 提交：\n\n使用与当前分支关联的远程仓库和同名的远程分支：\n\ngit push \ngit push  xinka master\n\ngit push [<远程仓库名>] [<本地分支名>:]<远程分支名>\n\n强制将当前分支 覆盖掉origin 的 master 分支：\ngit push origin +current-branch:master\n\n\n\n\n（下面几个命令可以用来解决：refuse to merge unrelated histories）\n\n#### 获取分支最新提交hash\n\ngit log -1 main\n\n\n从远程仓库获取最新的提交和分支信息，但不会自动将这些更改合并到你的本地分支中：\n\ngit fetch <远程仓库名>\n\n使用其他命令（如git merge或git rebase）将这些更改合并到你的本地分支中。\n\n## git merge \n\ngit merge --strategy=ours <branch-to-merge>\n```\n这将执行合并操作，但将忽略其他分支（`<branch-to-merge>`）的更改，仅保留当前分支（主分支）的内容。任何冲突都会被自动解决为当前分支的更改。\n\ngit merge --strategy=theirs <branch-to-merge>\n```\n这将执行合并操作，但会忽略当前分支的更改，选择其他分支（`<branch-to-merge>`）的内容。冲突会被自动解决为其他分支的更改。\n\n\n# 放弃本地分支，重置到master分支的最新提交\n\n1. git fetch\n\n2. git reset --hard <dev-latest-commit-hash>\n\n或者\n\n2. git reset --hard origin/master\n\n\n\n另一种解释：放弃本地更改：\n\ngit reset --hard FETCH_HEAD，其中FETCH_HEAD表示上一次成功pull之后的commit点，然后git pull即可\n\n\n# 强制推送当前分支到远程分支\n\ngit push -f xinka master\n\n这样就丢掉了 master 原来的历史。这样可以快速建立分支之间的关系，但是原有分支的历史提交会丢失。需要根据实际情况权衡是否使用这种破坏性的重置方式。\n上面可能会出现：error: src refspec localagent does not match any ，此时，试试下面的操作。\n\ngit fetch\ngit push -f orign  HEAD:<远程分支名>\n\n\n\n# 补充\n\ngit pull 后 仓库  在本地的默认名称  就是  origin\n\n查看：git remote -v \n\n修改：git remote rename old new\n\n比如： git push origin master 表示将本地 推到 master\n\n永久修改默认名称：git config --global init.defaultBranch new_name;\n\n\n#  强制覆盖本地分支\n\n    git fetch --all\n\n    git reset --hard origin/master\n\n    git pull\n\n\n\n## 强制覆盖远程分支\n\ngit push [<远程仓库名>] [<本地分支名>:]<远程分支名>\n\n每次提交之后，必须点击：同步更改才能看到网页的变化。\n\n# 问题解决\n## connect reset 问题，直接通过命令行配置解决\ngit config --global http.sslBackend \"openssl\"\n\ngit config --global http.sslCAInfo \"C:\\Program Files\\Git\\mingw64\\ssl\\cert.pem\"\n\n\n\n\n## git remote\n\ngit remote [-v | --verbose]\n\n显示所有远程仓库的名称，以及它们的 URL。\n示例：git remote -v\ngit remote add [-t <branch>] [-m <master>] [-f] [--tags | --no-tags] [--mirror=<fetch|push>] <name> <url>\n\n添加一个新的远程仓库。\n示例：git remote add origin https://github.com/user/repo.git\ngit remote rename [--[no-]progress] <old> <new>\n\n重命名一个远程仓库。\n示例：git remote rename origin upstream\ngit remote remove <name>\n\n移除指定名称的远程仓库。\n示例：git remote remove origin\ngit remote set-head <name> (-a | --auto | -d | --delete | <branch>)\n\n设置指定远程仓库的 HEAD 引用。\n示例：git remote set-head origin master\ngit remote show [-n] <name>\n\n显示指定远程仓库的信息，包括分支和跟踪情况。\n示例：git remote show origin\ngit remote prune [-n | --dry-run] <name>\n\n移除没有对应本地分支的指定远程仓库分支的引用。\n示例：git remote prune origin\ngit remote update [-p | --prune] [(<group> | <remote>)...]\n\n更新指定的远程仓库的引用。\n示例：git remote update origin\ngit remote set-branches [--add] <name> <branch>...\n\n设置指定远程仓库应该跟踪的分支。\n示例：git remote set-branches origin main\ngit remote get-url [--push] [--all] <name>\n\n获取指定远程仓库的 URL。\n示例：git remote get-url origin\ngit remote set-url [--push] <name> <newurl> [<oldurl>]\n\n设置指定远程仓库的 URL。\n示例：git remote set-url origin https://github.com/user/new-repo.git\ngit remote set-url --add <name> <newurl>\n\n添加一个新的 URL 到指定远程仓库。\n示例：git remote set-url --add origin https://github.com/user/old-repo.git\ngit remote set-url --delete <name> <url>\n\n从指定远程仓库中删除指定的 URL。\n示例：git remote set-url --delete origin https://github.com/user/old-repo.git\n\n\n# 创建一个新的分支来保留你所做的提交\n\ngit switch -c <new-branch-name>  :这将在当前提交处创建一个新的分支，并切换到该分支，让你可以在该分支上继续工作\n\n如果放弃处于分离头指针状态下的更改，执行：git switch -  ：将切换回进入分离头指针状态之前所在的分支\n\n\n# 将一个本地仓库 提交到另一个本地仓库跟踪的远程分支\n\n确保你当前在本地分支 pv 上。可以使用以下命令检查当前所在的分支：\n\n\ngit branch\n确保 pv 分支前面有 * 标记。\n\n首先，将本地分支 pv 推送到远程的 private/master 分支。执行以下命令：\n\ngit push private pv:master\n这将把本地分支 pv 推送到远程仓库的 private/master 分支。\n\n接下来，切换到本地分支 pv 并合并远程的 public/master 分支。执行以下命令：\n\ngit checkout pv\ngit merge public/master\n这将切换到分支 pv 并将远程的 public/master 分支合并到本地分支。\n\n最后，将合并后的更改推送到远程的 public/master 分支。执行以下命令：\n\n\ngit push public pv:master\n这将把本地分支 pv 推送到远程仓库的 public/master 分支。\n\n\n","slug":"工具教程/教程：git","published":1,"date":"2024-04-22T13:14:48.760Z","updated":"2024-04-22T12:16:20.563Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0d000lkgg406sagp2a","content":"<h1 id=\"git-安装\"><a href=\"#git-安装\" class=\"headerlink\" title=\"git 安装\"></a>git 安装</h1><h2 id=\"Win-下载\"><a href=\"#Win-下载\" class=\"headerlink\" title=\"Win 下载\"></a>Win 下载</h2><p><a href=\"https://git-scm.com/download/\">https://git-scm.com/download/</a></p>\n<h2 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-get install git</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"git-配置\"><a href=\"#git-配置\" class=\"headerlink\" title=\"git 配置\"></a>git 配置</h1><pre><code>注意： win 在 Git Bash 下； linux 在 /bin/bash 即可\n</code></pre>\n<h5 id=\"生成公钥\"><a href=\"#生成公钥\" class=\"headerlink\" title=\"生成公钥\"></a>生成公钥</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C <span class=\"string\">&quot;your_email@xxx.com&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"获取公钥\"><a href=\"#获取公钥\" class=\"headerlink\" title=\"获取公钥\"></a>获取公钥</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># linux:</span></span><br><span class=\"line\"><span class=\"built_in\">cat</span> ~/.ssh/id_rsa.pub</span><br><span class=\"line\"><span class=\"comment\">#win: </span></span><br><span class=\"line\">C:/user/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"配置公钥\"><a href=\"#配置公钥\" class=\"headerlink\" title=\"配置公钥\"></a>配置公钥</h5><p>复制公钥到 gitee｜githbu 网页个人设置中的公钥之中；保存。</p>\n<h5 id=\"终端环境配置\"><a href=\"#终端环境配置\" class=\"headerlink\" title=\"终端环境配置\"></a>终端环境配置</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -T git@gitee.com</span><br><span class=\"line\"></span><br><span class=\"line\">git config --global user.name yourname  <span class=\"comment\"># &quot;你码云的名字或昵称&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">git config --global user.email youremail@xxx.com <span class=\"comment\"># &quot;你码云的主邮箱&quot;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"vscode-用一个远程库\"><a href=\"#vscode-用一个远程库\" class=\"headerlink\" title=\"vscode 用一个远程库\"></a>vscode 用一个远程库</h5><p><strong>初始化一个本次仓库</strong><br>ctrl+shift+p initialize repository:<br><strong>远程链接</strong><br>源代码管理库-》远程-》远程仓库-》粘贴.git 链接-》ok</p>\n<h1 id=\"git-使用\"><a href=\"#git-使用\" class=\"headerlink\" title=\"git 使用\"></a>git 使用</h1><h5 id=\"远程仓库管理\"><a href=\"#远程仓库管理\" class=\"headerlink\" title=\"远程仓库管理\"></a>远程仓库管理</h5><p>git remote -v:列出所有远程仓库的别名和地址</p>\n<p>git remote show &lt;远程仓库别名&gt;:查看远程仓库的详细信息</p>\n<p>git remote add &lt;别名&gt; &lt;仓库地址&gt;:添加一个新的远程仓库</p>\n<p>git remote remove &lt;别名&gt;:删除一个远程仓库</p>\n<p>git remote rename &lt;原别名&gt; &lt;新别名&gt;:重命名一个远程仓库</p>\n<p>git remote set-url &lt;别名&gt; &lt;新地址&gt;:修改某个远程仓库的地址</p>\n<p>git remote set-head &lt;别名&gt; &lt;分支名&gt;:修改远程仓库的默认分支</p>\n<p>git remote -v update:更新所有远程仓库</p>\n<p>git remote prune &lt;别名&gt;:移除远程上已删除的tracking分支</p>\n<p>git remote get-url &lt;别名&gt;:查看远程仓库的原始克隆URL</p>\n<h4 id=\"查看跟踪远程分支\"><a href=\"#查看跟踪远程分支\" class=\"headerlink\" title=\"查看跟踪远程分支\"></a>查看跟踪远程分支</h4><p>git branch -vv (当前分支：hash：远程跟踪分支：注释)</p>\n<h4 id=\"修改跟踪的远程分支\"><a href=\"#修改跟踪的远程分支\" class=\"headerlink\" title=\"修改跟踪的远程分支\"></a>修改跟踪的远程分支</h4><p>git branch –set-upstream-to&#x3D;origin&#x2F;remote-branch local-branch</p>\n<p>这将为本地分支 <code>local-branch</code> 设置远程跟踪分支为 <code>origin/remote-branch</code>。</p>\n<p>你也可以使用简化命令来设置远程跟踪分支：</p>\n<p>git branch -u origin&#x2F;remote-branch local-branch</p>\n<p>（这个命令用于现有本地分支，将其与远程分支相关联）</p>\n<h4 id=\"创建新分支\"><a href=\"#创建新分支\" class=\"headerlink\" title=\"创建新分支\"></a>创建新分支</h4><p>git branch  origin&#x2F;serverfix</p>\n<h4 id=\"切换本地分支\"><a href=\"#切换本地分支\" class=\"headerlink\" title=\"切换本地分支\"></a>切换本地分支</h4><p>git checkout master </p>\n<p>  这里的master应该就是本地的分支</p>\n<p>此外：</p>\n<p>git checkout -b master origin&#x2F;master </p>\n<p>  表示切换的分支是新建的（本地只有main，没有master），分支名：master； 来源：orgin&#x2F;master;</p>\n<p>确定要删除的分支，并运行以下命令来删除该分支（假设要删除的分支名为 branch-name）：</p>\n<p>git branch -d branch-name</p>\n<p>如果分支上有未合并的更改，Git 会拒绝删除该分支，并显示一条警告消息。如果确实要强制删除分支，可以使用 -D 选项：</p>\n<p>git branch -D branch-name</p>\n<h4 id=\"拉取\"><a href=\"#拉取\" class=\"headerlink\" title=\"拉取\"></a>拉取</h4><p>源代码管理-》拉取</p>\n<p>或者 pull 就行</p>\n<p>git pull [远程仓库名] [远程分支]</p>\n<h4 id=\"提交\"><a href=\"#提交\" class=\"headerlink\" title=\"提交\"></a>提交</h4><p>手动</p>\n<p>添加消息-》提交-》同步</p>\n<p>命令提交</p>\n<p>暂存：git add * </p>\n<h2 id=\"提交：\"><a href=\"#提交：\" class=\"headerlink\" title=\"提交：\"></a>提交：</h2><p>使用与当前分支关联的远程仓库和同名的远程分支：</p>\n<p>git push<br>git push  xinka master</p>\n<p>git push [&lt;远程仓库名&gt;] [&lt;本地分支名&gt;:]&lt;远程分支名&gt;</p>\n<p>强制将当前分支 覆盖掉origin 的 master 分支：<br>git push origin +current-branch:master</p>\n<p>（下面几个命令可以用来解决：refuse to merge unrelated histories）</p>\n<h4 id=\"获取分支最新提交hash\"><a href=\"#获取分支最新提交hash\" class=\"headerlink\" title=\"获取分支最新提交hash\"></a>获取分支最新提交hash</h4><p>git log -1 main</p>\n<p>从远程仓库获取最新的提交和分支信息，但不会自动将这些更改合并到你的本地分支中：</p>\n<p>git fetch &lt;远程仓库名&gt;</p>\n<p>使用其他命令（如git merge或git rebase）将这些更改合并到你的本地分支中。</p>\n<h2 id=\"git-merge\"><a href=\"#git-merge\" class=\"headerlink\" title=\"git merge\"></a>git merge</h2><p>git merge –strategy&#x3D;ours <branch-to-merge></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这将执行合并操作，但将忽略其他分支（`&lt;branch-to-merge&gt;`）的更改，仅保留当前分支（主分支）的内容。任何冲突都会被自动解决为当前分支的更改。</span><br><span class=\"line\"></span><br><span class=\"line\">git merge --strategy=theirs &lt;branch-to-merge&gt;</span><br></pre></td></tr></table></figure>\n<p>这将执行合并操作，但会忽略当前分支的更改，选择其他分支（<code>&lt;branch-to-merge&gt;</code>）的内容。冲突会被自动解决为其他分支的更改。</p>\n<h1 id=\"放弃本地分支，重置到master分支的最新提交\"><a href=\"#放弃本地分支，重置到master分支的最新提交\" class=\"headerlink\" title=\"放弃本地分支，重置到master分支的最新提交\"></a>放弃本地分支，重置到master分支的最新提交</h1><ol>\n<li><p>git fetch</p>\n</li>\n<li><p>git reset –hard <dev-latest-commit-hash></p>\n</li>\n</ol>\n<p>或者</p>\n<ol start=\"2\">\n<li>git reset –hard origin&#x2F;master</li>\n</ol>\n<p>另一种解释：放弃本地更改：</p>\n<p>git reset –hard FETCH_HEAD，其中FETCH_HEAD表示上一次成功pull之后的commit点，然后git pull即可</p>\n<h1 id=\"强制推送当前分支到远程分支\"><a href=\"#强制推送当前分支到远程分支\" class=\"headerlink\" title=\"强制推送当前分支到远程分支\"></a>强制推送当前分支到远程分支</h1><p>git push -f xinka master</p>\n<p>这样就丢掉了 master 原来的历史。这样可以快速建立分支之间的关系，但是原有分支的历史提交会丢失。需要根据实际情况权衡是否使用这种破坏性的重置方式。<br>上面可能会出现：error: src refspec localagent does not match any ，此时，试试下面的操作。</p>\n<p>git fetch<br>git push -f orign  HEAD:&lt;远程分支名&gt;</p>\n<h1 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h1><p>git pull 后 仓库  在本地的默认名称  就是  origin</p>\n<p>查看：git remote -v </p>\n<p>修改：git remote rename old new</p>\n<p>比如： git push origin master 表示将本地 推到 master</p>\n<p>永久修改默认名称：git config –global init.defaultBranch new_name;</p>\n<h1 id=\"强制覆盖本地分支\"><a href=\"#强制覆盖本地分支\" class=\"headerlink\" title=\"强制覆盖本地分支\"></a>强制覆盖本地分支</h1><pre><code>git fetch --all\n\ngit reset --hard origin/master\n\ngit pull\n</code></pre>\n<h2 id=\"强制覆盖远程分支\"><a href=\"#强制覆盖远程分支\" class=\"headerlink\" title=\"强制覆盖远程分支\"></a>强制覆盖远程分支</h2><p>git push [&lt;远程仓库名&gt;] [&lt;本地分支名&gt;:]&lt;远程分支名&gt;</p>\n<p>每次提交之后，必须点击：同步更改才能看到网页的变化。</p>\n<h1 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h1><h2 id=\"connect-reset-问题，直接通过命令行配置解决\"><a href=\"#connect-reset-问题，直接通过命令行配置解决\" class=\"headerlink\" title=\"connect reset 问题，直接通过命令行配置解决\"></a>connect reset 问题，直接通过命令行配置解决</h2><p>git config –global http.sslBackend “openssl”</p>\n<p>git config –global http.sslCAInfo “C:\\Program Files\\Git\\mingw64\\ssl\\cert.pem”</p>\n<h2 id=\"git-remote\"><a href=\"#git-remote\" class=\"headerlink\" title=\"git remote\"></a>git remote</h2><p>git remote [-v | –verbose]</p>\n<p>显示所有远程仓库的名称，以及它们的 URL。<br>示例：git remote -v<br>git remote add [-t <branch>] [-m <master>] [-f] [–tags | –no-tags] [–mirror&#x3D;&lt;fetch|push&gt;] <name> <url></p>\n<p>添加一个新的远程仓库。<br>示例：git remote add origin <a href=\"https://github.com/user/repo.git\">https://github.com/user/repo.git</a><br>git remote rename [–[no-]progress] <old> <new></p>\n<p>重命名一个远程仓库。<br>示例：git remote rename origin upstream<br>git remote remove <name></p>\n<p>移除指定名称的远程仓库。<br>示例：git remote remove origin<br>git remote set-head <name> (-a | –auto | -d | –delete | <branch>)</p>\n<p>设置指定远程仓库的 HEAD 引用。<br>示例：git remote set-head origin master<br>git remote show [-n] <name></p>\n<p>显示指定远程仓库的信息，包括分支和跟踪情况。<br>示例：git remote show origin<br>git remote prune [-n | –dry-run] <name></p>\n<p>移除没有对应本地分支的指定远程仓库分支的引用。<br>示例：git remote prune origin<br>git remote update [-p | –prune] [(<group> | <remote>)…]</p>\n<p>更新指定的远程仓库的引用。<br>示例：git remote update origin<br>git remote set-branches [–add] <name> <branch>…</p>\n<p>设置指定远程仓库应该跟踪的分支。<br>示例：git remote set-branches origin main<br>git remote get-url [–push] [–all] <name></p>\n<p>获取指定远程仓库的 URL。<br>示例：git remote get-url origin<br>git remote set-url [–push] <name> <newurl> [<oldurl>]</p>\n<p>设置指定远程仓库的 URL。<br>示例：git remote set-url origin <a href=\"https://github.com/user/new-repo.git\">https://github.com/user/new-repo.git</a><br>git remote set-url –add <name> <newurl></p>\n<p>添加一个新的 URL 到指定远程仓库。<br>示例：git remote set-url –add origin <a href=\"https://github.com/user/old-repo.git\">https://github.com/user/old-repo.git</a><br>git remote set-url –delete <name> <url></p>\n<p>从指定远程仓库中删除指定的 URL。<br>示例：git remote set-url –delete origin <a href=\"https://github.com/user/old-repo.git\">https://github.com/user/old-repo.git</a></p>\n<h1 id=\"创建一个新的分支来保留你所做的提交\"><a href=\"#创建一个新的分支来保留你所做的提交\" class=\"headerlink\" title=\"创建一个新的分支来保留你所做的提交\"></a>创建一个新的分支来保留你所做的提交</h1><p>git switch -c <new-branch-name>  :这将在当前提交处创建一个新的分支，并切换到该分支，让你可以在该分支上继续工作</p>\n<p>如果放弃处于分离头指针状态下的更改，执行：git switch -  ：将切换回进入分离头指针状态之前所在的分支</p>\n<h1 id=\"将一个本地仓库-提交到另一个本地仓库跟踪的远程分支\"><a href=\"#将一个本地仓库-提交到另一个本地仓库跟踪的远程分支\" class=\"headerlink\" title=\"将一个本地仓库 提交到另一个本地仓库跟踪的远程分支\"></a>将一个本地仓库 提交到另一个本地仓库跟踪的远程分支</h1><p>确保你当前在本地分支 pv 上。可以使用以下命令检查当前所在的分支：</p>\n<p>git branch<br>确保 pv 分支前面有 * 标记。</p>\n<p>首先，将本地分支 pv 推送到远程的 private&#x2F;master 分支。执行以下命令：</p>\n<p>git push private pv:master<br>这将把本地分支 pv 推送到远程仓库的 private&#x2F;master 分支。</p>\n<p>接下来，切换到本地分支 pv 并合并远程的 public&#x2F;master 分支。执行以下命令：</p>\n<p>git checkout pv<br>git merge public&#x2F;master<br>这将切换到分支 pv 并将远程的 public&#x2F;master 分支合并到本地分支。</p>\n<p>最后，将合并后的更改推送到远程的 public&#x2F;master 分支。执行以下命令：</p>\n<p>git push public pv:master<br>这将把本地分支 pv 推送到远程仓库的 public&#x2F;master 分支。</p>\n","excerpt":"","more":"<h1 id=\"git-安装\"><a href=\"#git-安装\" class=\"headerlink\" title=\"git 安装\"></a>git 安装</h1><h2 id=\"Win-下载\"><a href=\"#Win-下载\" class=\"headerlink\" title=\"Win 下载\"></a>Win 下载</h2><p><a href=\"https://git-scm.com/download/\">https://git-scm.com/download/</a></p>\n<h2 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-get install git</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"git-配置\"><a href=\"#git-配置\" class=\"headerlink\" title=\"git 配置\"></a>git 配置</h1><pre><code>注意： win 在 Git Bash 下； linux 在 /bin/bash 即可\n</code></pre>\n<h5 id=\"生成公钥\"><a href=\"#生成公钥\" class=\"headerlink\" title=\"生成公钥\"></a>生成公钥</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C <span class=\"string\">&quot;your_email@xxx.com&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"获取公钥\"><a href=\"#获取公钥\" class=\"headerlink\" title=\"获取公钥\"></a>获取公钥</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># linux:</span></span><br><span class=\"line\"><span class=\"built_in\">cat</span> ~/.ssh/id_rsa.pub</span><br><span class=\"line\"><span class=\"comment\">#win: </span></span><br><span class=\"line\">C:/user/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"配置公钥\"><a href=\"#配置公钥\" class=\"headerlink\" title=\"配置公钥\"></a>配置公钥</h5><p>复制公钥到 gitee｜githbu 网页个人设置中的公钥之中；保存。</p>\n<h5 id=\"终端环境配置\"><a href=\"#终端环境配置\" class=\"headerlink\" title=\"终端环境配置\"></a>终端环境配置</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -T git@gitee.com</span><br><span class=\"line\"></span><br><span class=\"line\">git config --global user.name yourname  <span class=\"comment\"># &quot;你码云的名字或昵称&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">git config --global user.email youremail@xxx.com <span class=\"comment\"># &quot;你码云的主邮箱&quot;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"vscode-用一个远程库\"><a href=\"#vscode-用一个远程库\" class=\"headerlink\" title=\"vscode 用一个远程库\"></a>vscode 用一个远程库</h5><p><strong>初始化一个本次仓库</strong><br>ctrl+shift+p initialize repository:<br><strong>远程链接</strong><br>源代码管理库-》远程-》远程仓库-》粘贴.git 链接-》ok</p>\n<h1 id=\"git-使用\"><a href=\"#git-使用\" class=\"headerlink\" title=\"git 使用\"></a>git 使用</h1><h5 id=\"远程仓库管理\"><a href=\"#远程仓库管理\" class=\"headerlink\" title=\"远程仓库管理\"></a>远程仓库管理</h5><p>git remote -v:列出所有远程仓库的别名和地址</p>\n<p>git remote show &lt;远程仓库别名&gt;:查看远程仓库的详细信息</p>\n<p>git remote add &lt;别名&gt; &lt;仓库地址&gt;:添加一个新的远程仓库</p>\n<p>git remote remove &lt;别名&gt;:删除一个远程仓库</p>\n<p>git remote rename &lt;原别名&gt; &lt;新别名&gt;:重命名一个远程仓库</p>\n<p>git remote set-url &lt;别名&gt; &lt;新地址&gt;:修改某个远程仓库的地址</p>\n<p>git remote set-head &lt;别名&gt; &lt;分支名&gt;:修改远程仓库的默认分支</p>\n<p>git remote -v update:更新所有远程仓库</p>\n<p>git remote prune &lt;别名&gt;:移除远程上已删除的tracking分支</p>\n<p>git remote get-url &lt;别名&gt;:查看远程仓库的原始克隆URL</p>\n<h4 id=\"查看跟踪远程分支\"><a href=\"#查看跟踪远程分支\" class=\"headerlink\" title=\"查看跟踪远程分支\"></a>查看跟踪远程分支</h4><p>git branch -vv (当前分支：hash：远程跟踪分支：注释)</p>\n<h4 id=\"修改跟踪的远程分支\"><a href=\"#修改跟踪的远程分支\" class=\"headerlink\" title=\"修改跟踪的远程分支\"></a>修改跟踪的远程分支</h4><p>git branch –set-upstream-to&#x3D;origin&#x2F;remote-branch local-branch</p>\n<p>这将为本地分支 <code>local-branch</code> 设置远程跟踪分支为 <code>origin/remote-branch</code>。</p>\n<p>你也可以使用简化命令来设置远程跟踪分支：</p>\n<p>git branch -u origin&#x2F;remote-branch local-branch</p>\n<p>（这个命令用于现有本地分支，将其与远程分支相关联）</p>\n<h4 id=\"创建新分支\"><a href=\"#创建新分支\" class=\"headerlink\" title=\"创建新分支\"></a>创建新分支</h4><p>git branch  origin&#x2F;serverfix</p>\n<h4 id=\"切换本地分支\"><a href=\"#切换本地分支\" class=\"headerlink\" title=\"切换本地分支\"></a>切换本地分支</h4><p>git checkout master </p>\n<p>  这里的master应该就是本地的分支</p>\n<p>此外：</p>\n<p>git checkout -b master origin&#x2F;master </p>\n<p>  表示切换的分支是新建的（本地只有main，没有master），分支名：master； 来源：orgin&#x2F;master;</p>\n<p>确定要删除的分支，并运行以下命令来删除该分支（假设要删除的分支名为 branch-name）：</p>\n<p>git branch -d branch-name</p>\n<p>如果分支上有未合并的更改，Git 会拒绝删除该分支，并显示一条警告消息。如果确实要强制删除分支，可以使用 -D 选项：</p>\n<p>git branch -D branch-name</p>\n<h4 id=\"拉取\"><a href=\"#拉取\" class=\"headerlink\" title=\"拉取\"></a>拉取</h4><p>源代码管理-》拉取</p>\n<p>或者 pull 就行</p>\n<p>git pull [远程仓库名] [远程分支]</p>\n<h4 id=\"提交\"><a href=\"#提交\" class=\"headerlink\" title=\"提交\"></a>提交</h4><p>手动</p>\n<p>添加消息-》提交-》同步</p>\n<p>命令提交</p>\n<p>暂存：git add * </p>\n<h2 id=\"提交：\"><a href=\"#提交：\" class=\"headerlink\" title=\"提交：\"></a>提交：</h2><p>使用与当前分支关联的远程仓库和同名的远程分支：</p>\n<p>git push<br>git push  xinka master</p>\n<p>git push [&lt;远程仓库名&gt;] [&lt;本地分支名&gt;:]&lt;远程分支名&gt;</p>\n<p>强制将当前分支 覆盖掉origin 的 master 分支：<br>git push origin +current-branch:master</p>\n<p>（下面几个命令可以用来解决：refuse to merge unrelated histories）</p>\n<h4 id=\"获取分支最新提交hash\"><a href=\"#获取分支最新提交hash\" class=\"headerlink\" title=\"获取分支最新提交hash\"></a>获取分支最新提交hash</h4><p>git log -1 main</p>\n<p>从远程仓库获取最新的提交和分支信息，但不会自动将这些更改合并到你的本地分支中：</p>\n<p>git fetch &lt;远程仓库名&gt;</p>\n<p>使用其他命令（如git merge或git rebase）将这些更改合并到你的本地分支中。</p>\n<h2 id=\"git-merge\"><a href=\"#git-merge\" class=\"headerlink\" title=\"git merge\"></a>git merge</h2><p>git merge –strategy&#x3D;ours <branch-to-merge></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这将执行合并操作，但将忽略其他分支（`&lt;branch-to-merge&gt;`）的更改，仅保留当前分支（主分支）的内容。任何冲突都会被自动解决为当前分支的更改。</span><br><span class=\"line\"></span><br><span class=\"line\">git merge --strategy=theirs &lt;branch-to-merge&gt;</span><br></pre></td></tr></table></figure>\n<p>这将执行合并操作，但会忽略当前分支的更改，选择其他分支（<code>&lt;branch-to-merge&gt;</code>）的内容。冲突会被自动解决为其他分支的更改。</p>\n<h1 id=\"放弃本地分支，重置到master分支的最新提交\"><a href=\"#放弃本地分支，重置到master分支的最新提交\" class=\"headerlink\" title=\"放弃本地分支，重置到master分支的最新提交\"></a>放弃本地分支，重置到master分支的最新提交</h1><ol>\n<li><p>git fetch</p>\n</li>\n<li><p>git reset –hard <dev-latest-commit-hash></p>\n</li>\n</ol>\n<p>或者</p>\n<ol start=\"2\">\n<li>git reset –hard origin&#x2F;master</li>\n</ol>\n<p>另一种解释：放弃本地更改：</p>\n<p>git reset –hard FETCH_HEAD，其中FETCH_HEAD表示上一次成功pull之后的commit点，然后git pull即可</p>\n<h1 id=\"强制推送当前分支到远程分支\"><a href=\"#强制推送当前分支到远程分支\" class=\"headerlink\" title=\"强制推送当前分支到远程分支\"></a>强制推送当前分支到远程分支</h1><p>git push -f xinka master</p>\n<p>这样就丢掉了 master 原来的历史。这样可以快速建立分支之间的关系，但是原有分支的历史提交会丢失。需要根据实际情况权衡是否使用这种破坏性的重置方式。<br>上面可能会出现：error: src refspec localagent does not match any ，此时，试试下面的操作。</p>\n<p>git fetch<br>git push -f orign  HEAD:&lt;远程分支名&gt;</p>\n<h1 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h1><p>git pull 后 仓库  在本地的默认名称  就是  origin</p>\n<p>查看：git remote -v </p>\n<p>修改：git remote rename old new</p>\n<p>比如： git push origin master 表示将本地 推到 master</p>\n<p>永久修改默认名称：git config –global init.defaultBranch new_name;</p>\n<h1 id=\"强制覆盖本地分支\"><a href=\"#强制覆盖本地分支\" class=\"headerlink\" title=\"强制覆盖本地分支\"></a>强制覆盖本地分支</h1><pre><code>git fetch --all\n\ngit reset --hard origin/master\n\ngit pull\n</code></pre>\n<h2 id=\"强制覆盖远程分支\"><a href=\"#强制覆盖远程分支\" class=\"headerlink\" title=\"强制覆盖远程分支\"></a>强制覆盖远程分支</h2><p>git push [&lt;远程仓库名&gt;] [&lt;本地分支名&gt;:]&lt;远程分支名&gt;</p>\n<p>每次提交之后，必须点击：同步更改才能看到网页的变化。</p>\n<h1 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h1><h2 id=\"connect-reset-问题，直接通过命令行配置解决\"><a href=\"#connect-reset-问题，直接通过命令行配置解决\" class=\"headerlink\" title=\"connect reset 问题，直接通过命令行配置解决\"></a>connect reset 问题，直接通过命令行配置解决</h2><p>git config –global http.sslBackend “openssl”</p>\n<p>git config –global http.sslCAInfo “C:\\Program Files\\Git\\mingw64\\ssl\\cert.pem”</p>\n<h2 id=\"git-remote\"><a href=\"#git-remote\" class=\"headerlink\" title=\"git remote\"></a>git remote</h2><p>git remote [-v | –verbose]</p>\n<p>显示所有远程仓库的名称，以及它们的 URL。<br>示例：git remote -v<br>git remote add [-t <branch>] [-m <master>] [-f] [–tags | –no-tags] [–mirror&#x3D;&lt;fetch|push&gt;] <name> <url></p>\n<p>添加一个新的远程仓库。<br>示例：git remote add origin <a href=\"https://github.com/user/repo.git\">https://github.com/user/repo.git</a><br>git remote rename [–[no-]progress] <old> <new></p>\n<p>重命名一个远程仓库。<br>示例：git remote rename origin upstream<br>git remote remove <name></p>\n<p>移除指定名称的远程仓库。<br>示例：git remote remove origin<br>git remote set-head <name> (-a | –auto | -d | –delete | <branch>)</p>\n<p>设置指定远程仓库的 HEAD 引用。<br>示例：git remote set-head origin master<br>git remote show [-n] <name></p>\n<p>显示指定远程仓库的信息，包括分支和跟踪情况。<br>示例：git remote show origin<br>git remote prune [-n | –dry-run] <name></p>\n<p>移除没有对应本地分支的指定远程仓库分支的引用。<br>示例：git remote prune origin<br>git remote update [-p | –prune] [(<group> | <remote>)…]</p>\n<p>更新指定的远程仓库的引用。<br>示例：git remote update origin<br>git remote set-branches [–add] <name> <branch>…</p>\n<p>设置指定远程仓库应该跟踪的分支。<br>示例：git remote set-branches origin main<br>git remote get-url [–push] [–all] <name></p>\n<p>获取指定远程仓库的 URL。<br>示例：git remote get-url origin<br>git remote set-url [–push] <name> <newurl> [<oldurl>]</p>\n<p>设置指定远程仓库的 URL。<br>示例：git remote set-url origin <a href=\"https://github.com/user/new-repo.git\">https://github.com/user/new-repo.git</a><br>git remote set-url –add <name> <newurl></p>\n<p>添加一个新的 URL 到指定远程仓库。<br>示例：git remote set-url –add origin <a href=\"https://github.com/user/old-repo.git\">https://github.com/user/old-repo.git</a><br>git remote set-url –delete <name> <url></p>\n<p>从指定远程仓库中删除指定的 URL。<br>示例：git remote set-url –delete origin <a href=\"https://github.com/user/old-repo.git\">https://github.com/user/old-repo.git</a></p>\n<h1 id=\"创建一个新的分支来保留你所做的提交\"><a href=\"#创建一个新的分支来保留你所做的提交\" class=\"headerlink\" title=\"创建一个新的分支来保留你所做的提交\"></a>创建一个新的分支来保留你所做的提交</h1><p>git switch -c <new-branch-name>  :这将在当前提交处创建一个新的分支，并切换到该分支，让你可以在该分支上继续工作</p>\n<p>如果放弃处于分离头指针状态下的更改，执行：git switch -  ：将切换回进入分离头指针状态之前所在的分支</p>\n<h1 id=\"将一个本地仓库-提交到另一个本地仓库跟踪的远程分支\"><a href=\"#将一个本地仓库-提交到另一个本地仓库跟踪的远程分支\" class=\"headerlink\" title=\"将一个本地仓库 提交到另一个本地仓库跟踪的远程分支\"></a>将一个本地仓库 提交到另一个本地仓库跟踪的远程分支</h1><p>确保你当前在本地分支 pv 上。可以使用以下命令检查当前所在的分支：</p>\n<p>git branch<br>确保 pv 分支前面有 * 标记。</p>\n<p>首先，将本地分支 pv 推送到远程的 private&#x2F;master 分支。执行以下命令：</p>\n<p>git push private pv:master<br>这将把本地分支 pv 推送到远程仓库的 private&#x2F;master 分支。</p>\n<p>接下来，切换到本地分支 pv 并合并远程的 public&#x2F;master 分支。执行以下命令：</p>\n<p>git checkout pv<br>git merge public&#x2F;master<br>这将切换到分支 pv 并将远程的 public&#x2F;master 分支合并到本地分支。</p>\n<p>最后，将合并后的更改推送到远程的 public&#x2F;master 分支。执行以下命令：</p>\n<p>git push public pv:master<br>这将把本地分支 pv 推送到远程仓库的 public&#x2F;master 分支。</p>\n"},{"_content":"[最新最全！吊打付费！这13款才是真正的电脑必装软件！_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV12z421o74i/?spm_id_from=333.1007.tianma.6-4-22.click&vd_source=59461060c1867e9bf731e467ae6f00b5)\n# vscode 配置\n```json\n    \"window.restoreWindows\": \"none\",\n\n    \"explorer.confirmDelete\": false,\n    \n    \"diffEditor.ignoreTrimWhitespace\": false,\n\n    \"files.eol\": \"\\n\"\n```\n\n[官方文档](https://code.visualstudio.com/docs/cpp/launch-json-reference)\n# win11 配置 node js \n[Node.js安装及环境配置之Windows 11篇_nodejs安装及环境配置 win11-CSDN博客](https://blog.csdn.net/liangfei8402/article/details/136099884)\n\n\n# C++\n[十六、windows11下VSCode配置C/C++编译环境_vscode c语言编译环境-CSDN博客](https://blog.csdn.net/qq_41742043/article/details/127750483)\n\nc_cpp_properties.json\n```json\n{\n    \"configurations\": [\n        {\n            \"name\": \"Win32\",\n            \"includePath\": [\n                \"${workspaceFolder}/**\"\n            ],\n            \"defines\": [\n                \"_DEBUG\",\n                \"UNICODE\",\n                \"_UNICODE\"\n            ],\n            \"windowsSdkVersion\": \"10.0.19041.0\",\n            \"compilerPath\": \"D:\\\\Program Files\\\\mingw64\\\\bin\\\\g++.exe\",\n            \"cStandard\": \"c17\",\n            \"cppStandard\": \"c++17\",\n            \"intelliSenseMode\": \"windows-msvc-x64\"\n        }\n    ],\n    \"version\": 4\n}\n```\n\n\nlaunch.json\n```json\n{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"name\": \"g++.exe build and debug active file\",\n            \"type\": \"cppdbg\",\n            \"request\": \"launch\",\n            \"program\": \"${fileDirname}\\\\${fileBasenameNoExtension}.exe\",\n            \"args\": [],\n            \"stopAtEntry\": false,\n            \"cwd\": \"${workspaceFolder}\",\n            \"environment\": [],\n            \"externalConsole\": true,\n            \"MIMode\": \"gdb\",\n            \"miDebuggerPath\": \"D:\\\\Program Files\\\\mingw64\\\\bin\\\\gdb.exe\",\t\t/**** 修改成自己bin目录下的gdb.exe，这里的路径和电脑里复制的文件目录有一点不一样，这里是两个反斜杠\\\\ ****/\n            \"setupCommands\": [\n                {\n                    \"description\": \"为 gdb 启用整齐打印\",\n                    \"text\": \"-enable-pretty-printing\",\n                    \"ignoreFailures\": true\n                }\n            ],\n            \"preLaunchTask\": \"task g++\"\n        }\n    ]\n}\n\n```\ntasks.json\n```json\n{\n    \"version\": \"2.0.0\",\n    \"tasks\": [\n        {\n        \"type\": \"shell\",\n        \"label\": \"task g++\",\n        \"command\": \"D:\\\\Program Files\\\\mingw64\\\\bin\\\\g++.exe\",\t/**** 修改成自己bin目录下的g++.exe，这里的路径和电脑里复制的文件目录有一点不一样，这里是两个反斜杠\\\\ ****/\n        \"args\": [\n            \"-g\",\n            \"${file}\",\n            \"-o\",\n            \"${fileDirname}\\\\${fileBasenameNoExtension}.exe\",\n            \"-I\",\n            \"D:\\\\Users\\fyn\\\\Pro_Cod\\\\leetcode\",      /**** 修改成自己放c/c++项目的文件夹，这里的路径和电脑里复制的文件目录有一点不一样，这里是两个反斜杠\\\\ ****/\n            \"-std=c++17\"\n        ],\n        \"options\": {\n            \"cwd\": \"D:\\\\Program Files\\\\mingw64\\\\bin\"\t/**** 修改成自己的bin目录，这里的路径和电脑里复制的文件目录有一点不一样，这里是两个反斜杠\\\\ ****/\n        },\n        \"problemMatcher\":[\n            \"$gcc\"\n        ],\n        \"group\": \"build\",\n        \n        }\n    ]\n}\n\n\n```\n\n### C++ 终端闪退的问题\n\nC/C++ Compile Run 并且选中 run in external terminal \n\n\n\n\n\n# 命令行\n```sh\n# 清空 DNS 缓冲\nipconfig /flushdns\n\n\n```\n","source":"_posts/工具教程/配置：Windows.md","raw":"[最新最全！吊打付费！这13款才是真正的电脑必装软件！_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV12z421o74i/?spm_id_from=333.1007.tianma.6-4-22.click&vd_source=59461060c1867e9bf731e467ae6f00b5)\n# vscode 配置\n```json\n    \"window.restoreWindows\": \"none\",\n\n    \"explorer.confirmDelete\": false,\n    \n    \"diffEditor.ignoreTrimWhitespace\": false,\n\n    \"files.eol\": \"\\n\"\n```\n\n[官方文档](https://code.visualstudio.com/docs/cpp/launch-json-reference)\n# win11 配置 node js \n[Node.js安装及环境配置之Windows 11篇_nodejs安装及环境配置 win11-CSDN博客](https://blog.csdn.net/liangfei8402/article/details/136099884)\n\n\n# C++\n[十六、windows11下VSCode配置C/C++编译环境_vscode c语言编译环境-CSDN博客](https://blog.csdn.net/qq_41742043/article/details/127750483)\n\nc_cpp_properties.json\n```json\n{\n    \"configurations\": [\n        {\n            \"name\": \"Win32\",\n            \"includePath\": [\n                \"${workspaceFolder}/**\"\n            ],\n            \"defines\": [\n                \"_DEBUG\",\n                \"UNICODE\",\n                \"_UNICODE\"\n            ],\n            \"windowsSdkVersion\": \"10.0.19041.0\",\n            \"compilerPath\": \"D:\\\\Program Files\\\\mingw64\\\\bin\\\\g++.exe\",\n            \"cStandard\": \"c17\",\n            \"cppStandard\": \"c++17\",\n            \"intelliSenseMode\": \"windows-msvc-x64\"\n        }\n    ],\n    \"version\": 4\n}\n```\n\n\nlaunch.json\n```json\n{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"name\": \"g++.exe build and debug active file\",\n            \"type\": \"cppdbg\",\n            \"request\": \"launch\",\n            \"program\": \"${fileDirname}\\\\${fileBasenameNoExtension}.exe\",\n            \"args\": [],\n            \"stopAtEntry\": false,\n            \"cwd\": \"${workspaceFolder}\",\n            \"environment\": [],\n            \"externalConsole\": true,\n            \"MIMode\": \"gdb\",\n            \"miDebuggerPath\": \"D:\\\\Program Files\\\\mingw64\\\\bin\\\\gdb.exe\",\t\t/**** 修改成自己bin目录下的gdb.exe，这里的路径和电脑里复制的文件目录有一点不一样，这里是两个反斜杠\\\\ ****/\n            \"setupCommands\": [\n                {\n                    \"description\": \"为 gdb 启用整齐打印\",\n                    \"text\": \"-enable-pretty-printing\",\n                    \"ignoreFailures\": true\n                }\n            ],\n            \"preLaunchTask\": \"task g++\"\n        }\n    ]\n}\n\n```\ntasks.json\n```json\n{\n    \"version\": \"2.0.0\",\n    \"tasks\": [\n        {\n        \"type\": \"shell\",\n        \"label\": \"task g++\",\n        \"command\": \"D:\\\\Program Files\\\\mingw64\\\\bin\\\\g++.exe\",\t/**** 修改成自己bin目录下的g++.exe，这里的路径和电脑里复制的文件目录有一点不一样，这里是两个反斜杠\\\\ ****/\n        \"args\": [\n            \"-g\",\n            \"${file}\",\n            \"-o\",\n            \"${fileDirname}\\\\${fileBasenameNoExtension}.exe\",\n            \"-I\",\n            \"D:\\\\Users\\fyn\\\\Pro_Cod\\\\leetcode\",      /**** 修改成自己放c/c++项目的文件夹，这里的路径和电脑里复制的文件目录有一点不一样，这里是两个反斜杠\\\\ ****/\n            \"-std=c++17\"\n        ],\n        \"options\": {\n            \"cwd\": \"D:\\\\Program Files\\\\mingw64\\\\bin\"\t/**** 修改成自己的bin目录，这里的路径和电脑里复制的文件目录有一点不一样，这里是两个反斜杠\\\\ ****/\n        },\n        \"problemMatcher\":[\n            \"$gcc\"\n        ],\n        \"group\": \"build\",\n        \n        }\n    ]\n}\n\n\n```\n\n### C++ 终端闪退的问题\n\nC/C++ Compile Run 并且选中 run in external terminal \n\n\n\n\n\n# 命令行\n```sh\n# 清空 DNS 缓冲\nipconfig /flushdns\n\n\n```\n","slug":"工具教程/配置：Windows","published":1,"date":"2024-04-22T13:14:48.764Z","updated":"2024-04-17T13:58:36.026Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0d000mkgg4hoje08op","content":"<p><a href=\"https://www.bilibili.com/video/BV12z421o74i/?spm_id_from=333.1007.tianma.6-4-22.click&vd_source=59461060c1867e9bf731e467ae6f00b5\">最新最全！吊打付费！这13款才是真正的电脑必装软件！_哔哩哔哩_bilibili</a></p>\n<h1 id=\"vscode-配置\"><a href=\"#vscode-配置\" class=\"headerlink\" title=\"vscode 配置\"></a>vscode 配置</h1><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"attr\">&quot;window.restoreWindows&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;none&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">&quot;explorer.confirmDelete&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">false</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"attr\">&quot;diffEditor.ignoreTrimWhitespace&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">false</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">&quot;files.eol&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;\\n&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://code.visualstudio.com/docs/cpp/launch-json-reference\">官方文档</a></p>\n<h1 id=\"win11-配置-node-js\"><a href=\"#win11-配置-node-js\" class=\"headerlink\" title=\"win11 配置 node js\"></a>win11 配置 node js</h1><p><a href=\"https://blog.csdn.net/liangfei8402/article/details/136099884\">Node.js安装及环境配置之Windows 11篇_nodejs安装及环境配置 win11-CSDN博客</a></p>\n<h1 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C++\"></a>C++</h1><p><a href=\"https://blog.csdn.net/qq_41742043/article/details/127750483\">十六、windows11下VSCode配置C&#x2F;C++编译环境_vscode c语言编译环境-CSDN博客</a></p>\n<p>c_cpp_properties.json</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;configurations&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Win32&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;includePath&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">                <span class=\"string\">&quot;$&#123;workspaceFolder&#125;/**&quot;</span></span><br><span class=\"line\">            <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;defines&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">                <span class=\"string\">&quot;_DEBUG&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"string\">&quot;UNICODE&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"string\">&quot;_UNICODE&quot;</span></span><br><span class=\"line\">            <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;windowsSdkVersion&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.0.19041.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;compilerPath&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;D:\\\\Program Files\\\\mingw64\\\\bin\\\\g++.exe&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;cStandard&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;c17&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;cppStandard&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;c++17&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;intelliSenseMode&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;windows-msvc-x64&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;version&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n<p>launch.json</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;version&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;0.2.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;configurations&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;g++.exe build and debug active file&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;cppdbg&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;request&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;launch&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;program&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;args&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;stopAtEntry&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">false</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;cwd&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;environment&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;externalConsole&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;MIMode&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;gdb&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;miDebuggerPath&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;D:\\\\Program Files\\\\mingw64\\\\bin\\\\gdb.exe&quot;</span><span class=\"punctuation\">,</span>\t\t<span class=\"comment\">/**** 修改成自己bin目录下的gdb.exe，这里的路径和电脑里复制的文件目录有一点不一样，这里是两个反斜杠\\\\ ****/</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;setupCommands&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">                <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;description&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;为 gdb 启用整齐打印&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;text&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;-enable-pretty-printing&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;ignoreFailures&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span></span><br><span class=\"line\">                <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">            <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;preLaunchTask&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;task g++&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>tasks.json</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;version&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;2.0.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;tasks&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;shell&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;label&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;task g++&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;command&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;D:\\\\Program Files\\\\mingw64\\\\bin\\\\g++.exe&quot;</span><span class=\"punctuation\">,</span>\t<span class=\"comment\">/**** 修改成自己bin目录下的g++.exe，这里的路径和电脑里复制的文件目录有一点不一样，这里是两个反斜杠\\\\ ****/</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;args&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">            <span class=\"string\">&quot;-g&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"string\">&quot;$&#123;file&#125;&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"string\">&quot;-o&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"string\">&quot;$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"string\">&quot;-I&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"string\">&quot;D:\\\\Users\\fyn\\\\Pro_Cod\\\\leetcode&quot;</span><span class=\"punctuation\">,</span>      <span class=\"comment\">/**** 修改成自己放c/c++项目的文件夹，这里的路径和电脑里复制的文件目录有一点不一样，这里是两个反斜杠\\\\ ****/</span></span><br><span class=\"line\">            <span class=\"string\">&quot;-std=c++17&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;options&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;cwd&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;D:\\\\Program Files\\\\mingw64\\\\bin&quot;</span>\t<span class=\"comment\">/**** 修改成自己的bin目录，这里的路径和电脑里复制的文件目录有一点不一样，这里是两个反斜杠\\\\ ****/</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;problemMatcher&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">[</span></span><br><span class=\"line\">            <span class=\"string\">&quot;$gcc&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;group&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;build&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"C-终端闪退的问题\"><a href=\"#C-终端闪退的问题\" class=\"headerlink\" title=\"C++ 终端闪退的问题\"></a>C++ 终端闪退的问题</h3><p>C&#x2F;C++ Compile Run 并且选中 run in external terminal </p>\n<h1 id=\"命令行\"><a href=\"#命令行\" class=\"headerlink\" title=\"命令行\"></a>命令行</h1><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 清空 DNS 缓冲</span></span><br><span class=\"line\">ipconfig /flushdns</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<p><a href=\"https://www.bilibili.com/video/BV12z421o74i/?spm_id_from=333.1007.tianma.6-4-22.click&vd_source=59461060c1867e9bf731e467ae6f00b5\">最新最全！吊打付费！这13款才是真正的电脑必装软件！_哔哩哔哩_bilibili</a></p>\n<h1 id=\"vscode-配置\"><a href=\"#vscode-配置\" class=\"headerlink\" title=\"vscode 配置\"></a>vscode 配置</h1><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"attr\">&quot;window.restoreWindows&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;none&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">&quot;explorer.confirmDelete&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">false</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"attr\">&quot;diffEditor.ignoreTrimWhitespace&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">false</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">&quot;files.eol&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;\\n&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://code.visualstudio.com/docs/cpp/launch-json-reference\">官方文档</a></p>\n<h1 id=\"win11-配置-node-js\"><a href=\"#win11-配置-node-js\" class=\"headerlink\" title=\"win11 配置 node js\"></a>win11 配置 node js</h1><p><a href=\"https://blog.csdn.net/liangfei8402/article/details/136099884\">Node.js安装及环境配置之Windows 11篇_nodejs安装及环境配置 win11-CSDN博客</a></p>\n<h1 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C++\"></a>C++</h1><p><a href=\"https://blog.csdn.net/qq_41742043/article/details/127750483\">十六、windows11下VSCode配置C&#x2F;C++编译环境_vscode c语言编译环境-CSDN博客</a></p>\n<p>c_cpp_properties.json</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;configurations&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Win32&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;includePath&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">                <span class=\"string\">&quot;$&#123;workspaceFolder&#125;/**&quot;</span></span><br><span class=\"line\">            <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;defines&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">                <span class=\"string\">&quot;_DEBUG&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"string\">&quot;UNICODE&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"string\">&quot;_UNICODE&quot;</span></span><br><span class=\"line\">            <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;windowsSdkVersion&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.0.19041.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;compilerPath&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;D:\\\\Program Files\\\\mingw64\\\\bin\\\\g++.exe&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;cStandard&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;c17&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;cppStandard&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;c++17&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;intelliSenseMode&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;windows-msvc-x64&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;version&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n<p>launch.json</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;version&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;0.2.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;configurations&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;g++.exe build and debug active file&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;cppdbg&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;request&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;launch&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;program&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;args&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;stopAtEntry&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">false</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;cwd&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;environment&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;externalConsole&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;MIMode&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;gdb&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;miDebuggerPath&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;D:\\\\Program Files\\\\mingw64\\\\bin\\\\gdb.exe&quot;</span><span class=\"punctuation\">,</span>\t\t<span class=\"comment\">/**** 修改成自己bin目录下的gdb.exe，这里的路径和电脑里复制的文件目录有一点不一样，这里是两个反斜杠\\\\ ****/</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;setupCommands&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">                <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;description&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;为 gdb 启用整齐打印&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;text&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;-enable-pretty-printing&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;ignoreFailures&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span></span><br><span class=\"line\">                <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">            <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;preLaunchTask&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;task g++&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>tasks.json</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;version&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;2.0.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;tasks&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;shell&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;label&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;task g++&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;command&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;D:\\\\Program Files\\\\mingw64\\\\bin\\\\g++.exe&quot;</span><span class=\"punctuation\">,</span>\t<span class=\"comment\">/**** 修改成自己bin目录下的g++.exe，这里的路径和电脑里复制的文件目录有一点不一样，这里是两个反斜杠\\\\ ****/</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;args&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">            <span class=\"string\">&quot;-g&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"string\">&quot;$&#123;file&#125;&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"string\">&quot;-o&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"string\">&quot;$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"string\">&quot;-I&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"string\">&quot;D:\\\\Users\\fyn\\\\Pro_Cod\\\\leetcode&quot;</span><span class=\"punctuation\">,</span>      <span class=\"comment\">/**** 修改成自己放c/c++项目的文件夹，这里的路径和电脑里复制的文件目录有一点不一样，这里是两个反斜杠\\\\ ****/</span></span><br><span class=\"line\">            <span class=\"string\">&quot;-std=c++17&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;options&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;cwd&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;D:\\\\Program Files\\\\mingw64\\\\bin&quot;</span>\t<span class=\"comment\">/**** 修改成自己的bin目录，这里的路径和电脑里复制的文件目录有一点不一样，这里是两个反斜杠\\\\ ****/</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;problemMatcher&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">[</span></span><br><span class=\"line\">            <span class=\"string\">&quot;$gcc&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;group&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;build&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"C-终端闪退的问题\"><a href=\"#C-终端闪退的问题\" class=\"headerlink\" title=\"C++ 终端闪退的问题\"></a>C++ 终端闪退的问题</h3><p>C&#x2F;C++ Compile Run 并且选中 run in external terminal </p>\n<h1 id=\"命令行\"><a href=\"#命令行\" class=\"headerlink\" title=\"命令行\"></a>命令行</h1><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 清空 DNS 缓冲</span></span><br><span class=\"line\">ipconfig /flushdns</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n"},{"_content":"认为神经网络将会成为未来最具  \n潜力的模型，并指出该领域的进一步研究和发展依赖于规范数据集的建立和多种方法的结合运用\n\n\n介绍当前存在的分类以及它们的瓶颈","source":"_posts/日程安排/IDL.md","raw":"认为神经网络将会成为未来最具  \n潜力的模型，并指出该领域的进一步研究和发展依赖于规范数据集的建立和多种方法的结合运用\n\n\n介绍当前存在的分类以及它们的瓶颈","slug":"日程安排/IDL","published":1,"date":"2024-04-22T13:14:49.057Z","updated":"2024-03-06T08:44:25.084Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0d000nkgg4fsxlcdse","content":"<p>认为神经网络将会成为未来最具<br>潜力的模型，并指出该领域的进一步研究和发展依赖于规范数据集的建立和多种方法的结合运用</p>\n<p>介绍当前存在的分类以及它们的瓶颈</p>\n","excerpt":"","more":"<p>认为神经网络将会成为未来最具<br>潜力的模型，并指出该领域的进一步研究和发展依赖于规范数据集的建立和多种方法的结合运用</p>\n<p>介绍当前存在的分类以及它们的瓶颈</p>\n"},{"_content":"# Linux 安装盘安装\n## 准备工作\n1. 准备一个空 U 盘，作为后续安装盘。\n2. 下载 rufus  U 盘 格式化软件，分区类型：选择GPT，目标系统类型UEFI（非SM） [下载地址](https://rufus.ie/zh/#google_vignette) \n3. 下载 Ubuntu iso 镜像 [Ubuntu22.04.4](https://ubuntu.com/download/server/thank-you?version=22.04.4&architecture=amd64)\n4. 使用 rufus 对安装盘进行制作，配置如下\n\t![[Pasted image 20240406101639.png]]\n\t磁盘分区方式：MBR和GPT，MBR的主分区只能划分最多4个，GPT的分区数量没有限制，这里选择 GPT。\n## 开始安装\n1. 开启服务器主机，进入系统 BIOS（Del键、F2键、F10键或者ESC键，依据主板型号，或者在开机界面一般会显示具体按键）\n2. 选择 UEFI  U 盘作为启动盘。保存并重启系统。\n\t- Secure Boot设置：Security —> Secure Boot —> Disabled\n\t- Boot Option设置：Boot —> Boot Option #1 —> 将 UEFI USB Key: **** 选择至第一位\n\t- 保存BIOS设置：Exit—>Save Changes and Reset\n3. 大部分默认设置。\n\t1. 网络 IP 使用默认？\n\t2. 安装源：http://mirrors.aliyun.com/ubuntu\n\t3. 磁盘分区：[参考](https://blog.csdn.net/2301_79810514/article/details/137122218)\n\t\t1. SWAP 分区：Linux 的虚拟内存，建议将交换分区的大小设置为物理内存的1.5倍到2倍。\n\t\t2. /boot 分区：引导分区，建议 300-500M ；\n\t\t\t【关于是否要分/boot分区的问题：如果你的主板bios里设置的是UEFI+GPT分区表模式，那么给ubuntu分区的时候不用设置这个/boot分区，设置下面第3步的efi系统分区即可； 但如果你用的是legacy+MBR分区表那就正常设置/boot分区，这个很重要，特别是装双系统或多系统时，避免破坏到其他系统的引导文件】\n\t\t3. EFI引导分区，类型为逻辑分区，，默认ext4。 推荐分 512 ~ 1024M，注意：放在空间起始位置。\n\t\t4. /var 分区（可选）：log 的日志文件存放，如果不分则默认在 / 下。如果 linux 用于服务器和经常做日志分析，建议划分。最少 300-500M，一般 2-3 G。\n\t\t5. 根分区（/）：存储操作系统文件、应用程序和用户数据。建议较大，15G+；\n\t\t6. home 分区：存放个人的文件，建议最大；（/ 和 /home 之间类似 C 和 D 盘的关系）\n# Linux 系统配置\n#### root 账户设置密码\n当前普通用户界面下输入命令，然后按提示两次输入密码即可。\n\n```sh\nsudo passwd root\n```\n\n#### 新增用户并且增加用户权限\n1. `useradd`：用于创建新用户账号。\n    ```\n    sudo useradd username\n    ```\n    其中，`username` 是要创建的新用户的用户名。该命令会创建一个新的用户账号，并分配一个默认的用户ID和组ID。\n    \n2. `passwd`：用于设置用户的密码。\n    ```\n    sudo passwd username\n    ```\n    其中，`username` 是要设置密码的用户的用户名。该命令会提示你输入新的密码，并要求确认密码。\n    \n3. `usermod`：用于修改用户的属性，包括用户权限。\n    ```\n    sudo usermod -aG groupname username\n    ```\n    其中，`groupname` 是要将用户添加到的用户组的组名，`username` 是要修改权限的用户的用户名。该命令会将指定用户添加到指定用户组中，从而增加用户的权限。\n    注意：在执行 `usermod` 命令时，使用 `-aG` 选项是为了将用户添加到用户组而不覆盖用户原有的用户组。\n    \n4. 重新登录：在完成上述步骤后，建议重新登录用户账号，以使用户权限的更改生效。\n\n\n#### 源配置\n###### 1. 首先备份官方自带的软件源\n\n`cp /etc/apt/sources.list /etc/apt/sources.list.bak`\n\n###### 2.然后编辑修改为清华源\n\n`sudo gedit sources.list`\n#### ssh配置\n```sh\n# 查看是否安装了SSH服务\nps -ef | grep ssh \n\n# 没有安装的话，执行下面语句\nsudo apt-get update                   #先更新下资源列表\nsudo apt-get install openssh-server   #安装openssh-server\nsudo ps -ef | grep ssh                #查看是否安装成功\nsudo systemctl restart sshd           #重新启动SSH服务 \n\n# 进入ssh配置文件\nsudo vim  /etc/ssh/sshd_config    \n```\n\n`PermitRootLogin` 是一个用于配置 SSH 服务器的选项。这个选项决定了是否允许 root 用户通过 SSH 直接登录到服务器。通常情况下，为了提高安全性，最好禁止 root 用户通过 SSH 直接登录，而是使用一个普通用户登录后再通过 su 或者 sudo 切换到 root 用户来执行需要特权的操作。这样可以降低系统受到攻击的风险。  \n常见的 PermitRootLogin 选项取值包括：\n\n- `yes`：允许 root 用户通过 SSH 直接登录。\n- `no`：禁止 root 用户通过 SSH 直接登录。\n- `without-password`：允许 root 用户通过 SSH 密钥登录，但不允许使用密码登录。\n\n按i进入编辑模式，找到`#PermitRootLogin prohibit-password`，默认是注释掉的。  \n把 `PermitRootLogin without-password` 改为 `PermitRootLogin yes`，注意`PermitRootLogin without-password`被注释掉了，要去掉注释。如果没有找到`PermitRootLogin without-password`，直接文件末尾添加`PermitRootLogin yes`即可。然后按esc，输入:wq保存并退出。  \n重启sshd服务\n\n```sh\nsudo systemctl restart sshd\n```\n\n#### 驱动更新\n\n```sh\n# 1. 更新软件包列表：\nsudo apt update\n\n# 2. 升级已安装的软件包：\nsudo apt upgrade -y\n\n# 3. 更新驱动程序：\nsudo apt install ubuntu-drivers-common\nsudo ubuntu-drivers autoinstall\n```\n\n\n#### 换源\n```text\ndeb http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse\n \ndeb http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse\n \ndeb http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse\n \ndeb http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse \n```\n#### 网络配置\n\n1. 打开终端，使用root权限登录或者使用sudo命令获取root权限。\n    \n2. 使用文本编辑器打开网络配置文件`/etc/netplan/00-installer-config.yaml`。\n    \n    ```bash\n    sudo vim /etc/netplan/00-installer-config.yaml\n    ```\n    \n3. 在文件中，找到`network`部分，然后根据你的网络设置进行编辑。以下是一个示例配置：\n    \n    ```yaml\n    network:\n      ethernets:\n        enp0s3:\n          addresses: [192.168.1.10/24]\n          gateway4: 192.168.1.1\n          nameservers:\n            addresses: [8.8.8.8, 8.8.4.4]\n      version: 2\n    ```\n    \n    - `enp0s3`是网络接口的名称，你需要根据你的实际网络接口名称进行替换。\n    - `addresses`是你的服务器的静态IP地址和子网掩码。\n    - `gateway4`是你的网关IP地址。\n    - `nameservers`是DNS服务器的IP地址。\n4. 保存文件并关闭文本编辑器。\n    \n5. 在终端中执行以下命令以应用配置更改：\n    \n    ```bash\n    sudo netplan apply\n    ```\n    \n6. 重新启动网络服务以使更改生效：\n    \n    ```bash\n    sudo systemctl restart networking\n    ```\n    \n\n现在，你的 Ubuntu Server 已经配置了静态网络。你可以通过 ping 命令或打开浏览器测试网络连接。\n\n#### 禁止自动休眠\n\n1. 执行如下命令查看休眠模式的情况，如果 sleep 状态是loaded，也就是处于自动休眠开启状态\n\n```sh\nsystemctl status sleep.target\n```\n\n2. 接下来，执行如下命令关闭系统的自动休眠开关：\n\n```sh\n# 这些命令做了以下几点：\n# 通过mask命令，你禁用了所有休眠相关的systemd目标。\n# 通过set-default命令，你设置默认的运行级别为多用户文本模式（即命令行界面）\nsudo systemctl mask sleep.target suspend.target hibernate.target hybrid-sleep.target\nsudo systemctl set-default multi-user.target\n\n####################################################\n# 如果你想要恢复自动休眠功能，可以使用以下命令：\nsudo systemctl unmask sleep.target suspend.target hibernate.target hybrid-sleep.target\nsudo systemctl set-default graphical.target\n\n```\n\n3. 再次执行查看命令，可以看到 sleep 的状态已经变成了 masked，也就是关闭了。\n4. 编辑`/etc/systemd/logind.conf`文件：\n    \n    ```bash\n    sudo vim /etc/systemd/logind.conf\n    ```\n    \n5. 在文件中找到以下行：\n    \n    ```bash\n    #IdleAction=\n    #IdleActionSec=\n    ```\n    \n6. 将这两行的注释符号`#`移除，并设置`IdleAction`为`ignore`，`IdleActionSec`为`0`，如下所示：\n    ```text\n\t    IdleAction=ignore\n\t    IdleActionSec=0\n    ```\n\t\n7. 保存文件并关闭编辑器。\n8. 使用以下命令重新加载systemd配置：\n    \n    ```undefined\n    sudo systemctl restart systemd-logind.service\n    ```\n    \n9. 完成！现在 Ubuntu Server 将不会因为无操作而自动休眠。\n\n#### 设置关盖/合盖不挂起/不睡眠\n\n1. 通过更改登录配置文件`logind.conf`设置\n\n```sh\nsudo vim /etc/systemd/logind.conf\n```\n\n2. 里面影响关盖操作的变量包括`HandleLidSwitch`、`HandleLidSwitchExternalPower`和`HandleLidSwitchDocked`。  \n    `logind.conf` 里面各项的含义如下：\n\n```ini\n1. NAutoVTs=6：指定系统启动时自动分配的虚拟终端数量。\n2. ReserveVT=6：指定系统保留的虚拟终端数量。\n3. KillUserProcesses=no：指定当用户注销时是否终止用户进程。\n4. KillOnlyUsers=：指定需要终止进程的用户列表。\n5. KillExcludeUsers=root：指定不需要终止进程的用户列表。\n6. InhibitDelayMaxSec=5：指定阻止操作的最大延迟时间（以秒为单位）。\n7. HandlePowerKey=poweroff：指定按下电源键时的操作，此处设置为关机。\n8. HandleSuspendKey=suspend：指定按下休眠键时的操作，此处设置为休眠。\n9. HandleHibernateKey=hibernate：指定按下休眠键时的操作，此处设置为休眠。\n10. HandleLidSwitch=suspend：指定关闭笔记本电脑盖子时的操作，此处设置为休眠。\n11. HandleLidSwitchExternalPower=suspend：指定在外部电源连接时关闭笔记本电脑盖子的操作，此处设置为休眠。\n12. HandleLidSwitchDocked=ignore：指定连接到底座时关闭笔记本电脑盖子的操作，此处设置为忽略。\n13. PowerKeyIgnoreInhibited=no：指定是否忽略阻止操作的电源键按下。\n14. SuspendKeyIgnoreInhibited=no：指定是否忽略阻止操作的休眠键按下。\n15. HibernateKeyIgnoreInhibited=no：指定是否忽略阻止操作的休眠键按下。\n16. LidSwitchIgnoreInhibited=yes：指定是否忽略阻止操作的盖子关闭。\n17. HoldoffTimeoutSec=30s：指定在执行操作前等待的时间（以秒为单位）。\n18. IdleAction=ignore：指定系统处于空闲状态时的操作，此处设置为忽略。\n19. IdleActionSec=30min：指定系统处于空闲状态多长时间后执行操作（以分钟为单位）。\n20. RuntimeDirectorySize=10%：指定运行时目录的最大大小，此处设置为总磁盘空间的10%。\n21. RemoveIPC=yes：指定是否在用户注销时删除IPC对象。\n22. InhibitorsMax=8192：指定系统允许的阻止操作的最大数量。\n```\n\n`HandleLidSwitch`: 定义笔记本电脑关闭盖子时的行为。可以设置的值有：\n\n- `ignore`：忽略关闭盖子的事件。\n- `poweroff`：关闭电源。\n- `reboot`：重新启动。\n- `halt`：停止系统。\n- `kexec`：通过 kexec 进行快速启动。\n- `suspend`：挂起系统。\n- `hibernate`：休眠系统。\n\n`HandleLidSwitchExternalPower`: 定义当笔记本电脑连接外部电源时关闭盖子的行为。可以设置的值与 `HandleLidSwitch` 相同。\n\n`HandleLidSwitchDocked`: 定义当笔记本电脑连接到底座时关闭盖子的行为。可以设置的值与 `HandleLidSwitch` 相同。\n\n`HandlePowerKey`: 定义电源按钮的行为。可以设置的值与 `HandleLidSwitch` 相同。\n\n`IdleAction`: 定义系统空闲时的行为。可以设置的值有：\n\n- `ignore`：忽略空闲事件。\n- `poweroff`：关闭电源。\n- `reboot`：重新启动。\n- `halt`：停止系统。\n- `kexec`：通过 kexec 进行快速启动。\n- `suspend`：挂起系统。\n- `hibernate`：休眠系统。\n\n`IdleActionSec`: 定义系统空闲多少秒后触发 `IdleAction`。\n\n`UserTasksMax`: 定义每个用户可以同时运行的任务数的最大值。\n\n`KillUserProcesses`: 定义当用户注销时是否终止用户的进程。可以设置的值有：\n\n- `yes`：终止用户的进程。\n- `no`：不终止用户的进程。\n\n#### 定时自动关闭显示器\n\n1. 想要定时关闭显示器，可以编辑`/etc/default/grub`这个文件\n2. 通过修改GRUB_CMDLINE_LINUX_DEFAULT变量，你可以添加或修改传递给内核的参数，以便在启动时对系统进行自定义配置。\n\n```sh\n# ipv6.disable=1：禁用 IPv6 协议。\n# consoleblank=300：设置控制台空闲时间为 300 秒后自动关闭。\nGRUB_CMDLINE_LINUX_DEFAULT=\"ipv6.disable=1 consoleblank=300\"\n```\n\n3. 修改完了运行`sudo update-grub`，然后重启，即可设置系统5分钟没有活动自动关闭显示器。\n\n#### 网络自动认证\nhttps://github.com/kewuaa/uestc_wifi_helper/releases/download/v0.4.1/uestc_wifi_helper-x86_64-linux\n\n1. 将软件放在 /root/path/uestc-network-login/uestc_wifi_helper_cli-x86_64-linux\n2. 将脚本放在 /root/boot/auto-login-uestc-network.sh\n3. 部署服务在 /etc/systemd/system/auto-network-login.service\n4. 启动服务。\n#### 外接 U 盘挂载\n\n1. 确认 U 盘被正确地检测到：在终端中输入以下命令来查看系统识别的存储设备列表：\n   ```\n   lsblk\n   ``` \n   这将显示所有已连接的存储设备，包括 U 盘。通常，U 盘的设备名称类似于 `/dev/sdb` 或 `/dev/sdc`。\n\n2. 挂载 U 盘：在 Linux 中，需要将 U 盘挂载到文件系统才能访问其中的文件。首先，创建一个用于挂载的目录。在终端中输入以下命令：\n   ```\n   sudo mkdir /mnt/usb\n   ```\n   这将创建一个名为 `/mnt/usb` 的目录作为挂载点。\n\n3. 挂载 U 盘：使用 `mount` 命令将 U 盘挂载到刚刚创建的目录。假设 U 盘的设备名称为 `/dev/sdb1`，在终端中输入以下命令：\n   ```\n   sudo mount /dev/sdb1 /mnt/usb\n   ```\n   如果 U 盘有多个分区，将 `/dev/sdb1` 替换为相应的分区设备名称。\n\n4. 访问 U 盘中的文件：现在，可以通过访问挂载点 `/mnt/usb` 来查看和操作 U 盘中的文件。你可以使用文件管理器（如 Nautilus、Dolphin 或 Thunar）浏览 U 盘，也可以在终端中使用命令行来执行相关操作。\n\n5. 卸载 U 盘：在完成对 U 盘的操作后，应该将其卸载以安全地移除。在终端中输入以下命令来卸载 U 盘：\n   ```\n   sudo umount /mnt/usb\n   ```\n   确保在操作完成后再拔出 U 盘。\n\n请注意，U 盘的设备名称和挂载点可能会根据系统和具体情况有所不同。因此，在使用上述命令时，请根据你的实际情况进行相应的调整。\n\n#### 域名配置\n在 Ubuntu 22.04 TLS 上进行动态 DNS 部署的步骤：\n0. 注册 DNS 服务商账号\n\t[ZoneEdit - Control Panel: Sign Up](https://cp.zoneedit.com/signup/)\n1. 安装 `ddclient`：\n   打开终端并执行以下命令来安装 `ddclient`：\n   ```\n   sudo apt update\n   sudo apt install ddclient\n   ```\n\n2. 配置 `ddclient`：\n   `ddclient` 的配置文件位于 `/etc/ddclient.conf`。使用你喜欢的文本编辑器（如 nano）打开该文件：\n   ```\n   sudo nano /etc/ddclient.conf\n   ```\n\n   在配置文件中，你需要提供动态 DNS 服务提供商的相关信息，例如域名、用户名、密码等。具体配置取决于你选择的动态 DNS 服务提供商。以下是一个示例配置文件的部分内容：\n\n   ```\n   # 使用动态 DNS 服务提供商的示例配置\n   protocol=dyndns2\n   server=members.dyndns.org\n   login=username\n   password='password'\n   your.domain.com\n   \n   # DIY\n   protocol=zoneedit1\n   use=if, if=eno1\n   server=dns1.zoneedit.com \n   ssl=yes \n   login=dinream \n   password='dreamin8888' \n   lm.lab302.com\n   \n   ```\n\n   替换示例配置中的 `protocol`、`server`、`login`、`password` 和 `your.domain.com` 为你的实际设置。请参考你选择的动态 DNS 服务提供商的文档，获取正确的配置参数。\n\n3. 保存并关闭配置文件。\n\n4. 启用并启动 `ddclient` 服务：\n   执行以下命令启用 `ddclient` 服务：\n   ```\n   sudo systemctl enable ddclient\n   ```\n\n   然后，执行以下命令启动服务：\n   ```\n   sudo systemctl start ddclient\n   ```\n\n   `ddclient` 将会读取配置文件并在启动时或 IP 地址变化时更新动态 DNS 记录。\n\n5. 验证配置：\n   执行以下命令来检查 `ddclient` 服务的状态：\n   ```\n   sudo systemctl status ddclient\n   ```\n\n   如果状态显示为 \"active\"，则表示 `ddclient` 服务已成功启动并正在运行。\n6. 查看详细信息\n\t```sh\n\tddclient -foreground  -verbose -force\n\n\tddclient -daemon=0 -debug -verbose -noquiet\n\n\t```\n7. 注意域名的更新在域名服务器之间可能需要一个小时左右，需要等待。\nhttps://blog.cre0809.com/archives/231/\n内网穿透：\nhttps://juejin.cn/post/7346072037674418187\n多种方式解决：\n[如何映射我的私人IP动态变化到我的VPS IP？ - adsl - 码客 (oomake.com)](https://www.oomake.com/question/9612393)\n\n\n# 网络高级配置\n## 双网卡跨网卡 iptables 完成数据转发\n目标：将主机的一个 ip 的发送包，转换为主机另一个 ip 的发送包。\n\n1. 配置网卡IP地址， 配置静态IP地址， \n\t/etc/sysconfig/network-stripts/ifcfg-eth0 配置网卡一， 外网卡， 可以联网\n\t/etc/sysconfig/network-stripts/ifcfg-eth1 配置网卡二， 内网卡， 连接内网\n\n\t配置网卡配置文件\n\tDEVICE=eth1\n\tIPADDR=192.168.145.122// IP地址  \n\tNETMASK=255.255.255.0// IP掩码  \n\tgateway=192.168.142.2// 外网网关地址  \n\tONBOOT=yes\n\t\n\t或者配置/etc/sysconfig/network 添加网关地址\n\tgateway=192.168.142.2  // 外网网关地址\n\n  \n\n2. 打开包转发功能：\n\n\techo \"1\" > /proc/sys/net/ipv4/ip_forward\n\n3. 修改/etc/sysctl.conf文件， 让包转发功能在系统启动时自动生效：\n\n\tnet.ipv4.ip_forward = 1\n\n4. 添加iptables nat路由规则： // 清楚其他不需要的iptables规则\n\n\t/sbin/iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE// 其中网卡eth0 为外网卡。  \n\n5. 保存规则到/etc/sysconfig/iptables 配置文件中\n\n\tservice iptables save\n\n6. 重新启动iptables\n\n\tservice iptables restart\n\n\n\n1、首先确保转发开关打开\n\n\tvim /etc/sysctl.conf\n\n\t\tnet.ipv4.ip_forward = 1\n\n\tsysctl -p\n\n2、核对双网卡配置\n\n\tcat /etc/sysconfig/network-scripts/ifcfg-eth0\n\t\tDEVICE=eth0  \n\t\tHWADDR=  \n\t\tTYPE=Ethernet  \n\t\tUUID=61e9bdb5-b1ff-4c8f-8c19-938c834de345  \n\t\tONBOOT=yes  \n\t\tNM_CONTROLLED=yes  \n\t\tBOOTPROTO=static  \n\t\tIPADDR=192.8.8.57  \n\t\tNETMASK=255.255.255.224  \n\t\tGATEWAY=192.8.8.62\n\n\tcat /etc/sysconfig/network-scripts/ifcfg-eth2\n\t\tDEVICE=eth2\n\t\tHWADDR=\n\t\tTYPE=Ethernet\n\t\tONBOOT=yes\n\t\tNM_CONTROLLED=no\n\t\tBOOTPROTO=static\n\t\tIPADDR=11.10.10.2\n\t\tNETMASK=255.255.255.0\n\n\n3、执行 iptables 并保存 \n\n\tiptables -t nat -A POSTROUTING -s 11.10.10.0/24 -j SNAT  --to 192.8.8.57  \n\tservice iptables save\n\n\n## 局域网自动认证 TODO\n对于学校或者公司，每次主机重启可能需要进行账号的认证，才可上网，这里实现一个脚本进行自动登录\n```text\n一个请求\n[10.253.0.237/cgi-bin/rad_user_info?callback=jQuery]\n(http://10.253.0.237/cgi-bin/rad_user_info?callback=jQuery)\n可以获取，断开网线没有响应。\n\njQuery({\"client_ip\":\"113.54.145.42\",\"ecode\":0,\"error\":\"not_online_error\",\"error_msg\":\"\",\"online_ip\":\"113.54.145.42\",\"res\":\"not_online_error\",\"srun_ver\":\"SRunCGIAuthIntfSvr V1.18 B20181212\",\"st\":1712478100})\n\n\n登录页面的请求。\n请求 URL:\nhttp://10.253.0.237/srun_portal_pc?ac_id=1&theme=dx\n请求方法:\nGET\nStatus Code:\n200 OK\n远程地址:\n10.253.0.237:80\nReferrer Policy:\nstrict-origin-when-cross-origin\n\n\n请求指令\nhttp://10.253.0.237/cgi-bin/get_challenge?callback=jQuery112405824069609933546_1712476428639&username=202321081216%40dx-uestc&ip=8.8.8.8%2C+113.54.145.42\n\nRequest URL:\n\nhttp://10.253.0.237/cgi-bin/get_challenge?callback=jQuery1124028377090795615145_1712478534516&username=202321081216%40dx-uestc&ip=113.54.145.42&_=1712478534518\n\nRequest Method:\n\nGET\n\nStatus Code:\n\n502 Bad Gateway\n\nRemote Address:\n\n127.0.0.1:7890\n\nReferrer Policy:\n\nstrict-origin-when-cross-origin\n\n\n如果连接成功，http://10.253.0.237/cgi-bin/rad_user_info 也可也正常获取数据，但是是字符串形式。而不是json\n\nhttp://10.253.0.237/cgi-bin/srun_portal?callback=jQuery112405960456199614257_1712479784865&action=login&username=202321081216%40dx-uestc&password=%7BMD5%7Dfb5b782af15febf4ebd53a45952273b8&ac_id=1&ip=8.8.8.8%2C+113.54.145.42&chksum=567d3b8c5bd5ef9c7f14c76b487e7ba67a3d245a&info=%7BSRBX1%7D3OHj0r4O4ZBBY1c%2FRJUyhmdftyTtmQ%2BTHXWm%2BGqNqPp2dL59T78gfgRJXnmUW55cnpEZ3LfJ4NvTAu0bX76wfxQdKZrCon42SRXUdymVpUCnBoBvn1cq7pCYcgK%2BGQ7GA%2BClDLGqvIsHwc5ue8FYqip54p4C2MYgtlHTfv%3D%3D&n=200&type=1&os=Windows+10&name=Windows&double_stack=0&_=1712479784868\n\n```\ncurl -d \"username=202321081216&password=feng0408\" http://10.253.0.237/cgi-bin/srun_portal?callback=jQueryaction=login/\n```\n{\n    \"Code\": 0,\n    \"Message\": \"ok\",\n    \"Data\": [\n        {\n            \"Id\": 3,\n            \"Title\": \"清水河校区办公教学区通知\",\n            \"Content\": \"\\u003cp style=\\\"margin-top:auto;margin-bottom: auto;text-align:left;text-indent:36px;line-height: 24px;background:white\\\"\\u003e\\u003cspan style=\\\"font-size: 18px;font-family:宋体\\\"\\u003e清水河校区办公教学区通过墙面预制网络接口连接到有线校园网。连接成功后，打开浏览器输入aaa.uestc.edu.cn弹出认证页面，可选择校园网登录或电信登录。具体使用方法如下：\\u003c/span\\u003e\\u003c/p\\u003e\\u003cp style=\\\"margin-top:auto;margin-bottom: auto;text-align:left;line-height:24px;background: white\\\"\\u003e\\u003cspan style=\\\"font-size:18px;font-family:宋体\\\"\\u003e1\\u003c/span\\u003e\\u003cspan style=\\\"font-size:18px;font-family: 宋体\\\"\\u003e、校园网登录：在右侧登录框输入统一身份认证信息（工资号或学号），点击校园网登录。\\u003c/span\\u003e\\u003c/p\\u003e\\u003cp style=\\\"margin-top:auto;margin-bottom: auto;text-align:left;line-height:24px;background: white\\\"\\u003e\\u003cspan style=\\\"font-size:18px;font-family:宋体\\\"\\u003e2\\u003c/span\\u003e\\u003cspan style=\\\"font-size:18px;font-family: 宋体\\\"\\u003e、电信登录：先点击右侧自服务按钮，进行电信账号绑定；绑定完成重新打开aaa.uestc.edu.cn，输入学校统一身份认证信息，点击电信登录。电信账号绑定流程详见《清水河有线校园网使用手册》。\\u003c/span\\u003e\\u003c/p\\u003e\\u003cp style=\\\"margin-top:auto;margin-bottom: auto;text-align:left;line-height:24px;background: white\\\"\\u003e\\u003cstrong\\u003e\\u003cspan style=\\\"font-size:18px;font-family:宋体\\\"\\u003e用户服务电话：61831184\\u003c/span\\u003e\\u003c/strong\\u003e\\u003c/p\\u003e\\u003cp\\u003e\\u003cbr/\\u003e\\u003c/p\\u003e\",\n            \"Created_by\": \"srun\",\n            \"Created_at\": 1622792930,\n            \"Updated_at\": 1622792930\n        },\n        {\n            \"Id\": 2,\n            \"Title\": \"清水河行政教学区有线网络割接通知\",\n            \"Content\": \"\\u003cp style=\\\"margin-top:5px;margin-right:0;margin-bottom:5px;margin-left: 0;text-indent:28px\\\"\\u003e\\u003cspan style=\\\"font-size: 18px;\\\"\\u003e\\u003c/span\\u003e\\u003c/p\\u003e\\u003cp style=\\\"line-height: 1.5em;\\\"\\u003e清水河校区有线网络设备已运行10年以上，故障频发，不支持IPv6，802.1X认证系统对于终端兼容性较差。为解决以上问题，信息中心协调中国电信高新西区分公司对清水河校区有线网进行改造。改造后网络使用web认证，支持IPv6协议，用户可选择校园网登录或电信登录。具体使用方法如下：\\u003c/p\\u003e\\u003cp style=\\\"line-height: 1.5em;\\\"\\u003e1、校园网登录：在右侧登录框输入统一身份认证信息，点击校园网登录。\\u003c/p\\u003e\\u003cp style=\\\"line-height: 1.5em;\\\"\\u003e2、电信登录：先点击右侧自服务按钮，进行电信账号绑定；绑定完成重新打开aaa.uestc.edu.cn，输入学校统一身份认证信息，点击电信登录。电信账号绑定流程详见《清水河有线校园网使用手册》。\\u003c/p\\u003e\\u003cp style=\\\"line-height: 1.5em;\\\"\\u003e我们对给您带来的不便表示歉意！如有任何疑问，请联系信息中心61831184。\\u003c/p\\u003e\\u003cp style=\\\"margin-top:5px;margin-right:0;margin-bottom:5px;margin-left: 0;text-indent:28px;font-variant-ligatures: normal;font-variant-caps: normal;orphans: 2;text-align:start;widows: 2;-webkit-text-stroke-width: 0px;word-spacing: 0px\\\"\\u003e\\u003cbr/\\u003e\\u003c/p\\u003e\\u003cp\\u003e\\u003cbr/\\u003e\\u003c/p\\u003e\",\n            \"Created_by\": \"yqli\",\n            \"Created_at\": 1544507894,\n            \"Updated_at\": 1622792876\n        }\n    ]\n}\n```\n\n# 程序自启动\n在 Ubuntu 中，你可以使用 Systemd 来配置在系统启动时自动后台执行可执行程序。\n\n下面是一些基本的步骤：\n\n1. 创建一个用于 Systemd 配置的服务文件。在终端中使用以下命令创建一个新的服务文件：\n   ```\n   sudo nano /etc/systemd/system/test.service\n   ```\n\n2. 在打开的编辑器中，输入以下内容：\n   ```\n   [Unit]\n   Description=Test Service\n   After=network.target\n\n   [Service]\n   ExecStart=/path/to/test\n   Type=simple\n   Restart=always\n   User=your_username\n\n   [Install]\n   WantedBy=multi-user.target\n   ```\n\n   请确保将 `/path/to/test` 替换为你的可执行程序的实际路径，并将 `your_username` 替换为你的用户名。\n\n3. 保存并关闭文件。使用 `Ctrl + X`，然后输入 `Y` 保存文件并退出编辑器。\n\n4. 重新加载 Systemd 配置，使其识别新的服务文件。在终端中使用以下命令：\n   ```\n   sudo systemctl daemon-reload\n   ```\n\n5. 启用服务，使其在系统启动时自动运行。在终端中使用以下命令：\n   ```\n   sudo systemctl enable test.service\n   ```\n\n6. 最后，启动服务。在终端中使用以下命令：\n   ```\n   sudo systemctl start test.service\n   ```\n\n现在，你的可执行程序 `test` 将在系统启动时自动以后台进程的形式运行。\n\n你可以使用以下命令来检查服务的状态：\n```\nsudo systemctl status test.service\n```\n\n如果需要停止服务，可以使用以下命令：\n```\nsudo systemctl stop test.service\n```\n\n\n# 后台运行程序\n\n\n1. 在执行命令时，可以使用 `&` 符号将其放在命令的末尾。这样会将命令放入后台运行，并且不会阻塞当前终端。例如：\n```\n\t./test & \n```\n2.  如果你希望程序在后台运行的同时不产生任何输出，你可以将其输出重定向到 `/dev/null`，这样输出将被丢弃。例如：\n```\n\tnohup ./clash-linux-amd64 > /dev/null 2>&1 &\n\tnohup ./aaa > output.log 2>&1 &\n\tdisown\n\n```\n这样，可执行程序 `./test` 将在后台运行，并与当前终端解耦。它不会阻塞当前终端，并且输出将被重定向到 `/dev/null`，不会显示在终端上。\n\n请注意，使用这种方法运行程序后，你将无法看到程序的输出。如果你需要查看程序的输出或进行其他交互操作，可能需要使用其他工具或技术来实现。\n\n\n\n# 离线安装包的使用\n## Centos\n1. 打包\n\t```bash\n\tyum install [package]--downloadonly --downloaddir=dir/\n\t```\n2. 使用\n\t```bash\n\tyum -y localinstall dir/*\n```\n\n\n# 查询指定域名的 IP\n\n```sh\nnsloopup\n```\n\n\n# 日志查看\n```sh\n/var/log/syslog\n/var/log/kern.log\n```\n\n# 查看显存运行情况\n\n\n```shell\nwatch -n 0.1 nvidia-smi\n```\n","source":"_posts/工具教程/配置：Linux 系统.md","raw":"# Linux 安装盘安装\n## 准备工作\n1. 准备一个空 U 盘，作为后续安装盘。\n2. 下载 rufus  U 盘 格式化软件，分区类型：选择GPT，目标系统类型UEFI（非SM） [下载地址](https://rufus.ie/zh/#google_vignette) \n3. 下载 Ubuntu iso 镜像 [Ubuntu22.04.4](https://ubuntu.com/download/server/thank-you?version=22.04.4&architecture=amd64)\n4. 使用 rufus 对安装盘进行制作，配置如下\n\t![[Pasted image 20240406101639.png]]\n\t磁盘分区方式：MBR和GPT，MBR的主分区只能划分最多4个，GPT的分区数量没有限制，这里选择 GPT。\n## 开始安装\n1. 开启服务器主机，进入系统 BIOS（Del键、F2键、F10键或者ESC键，依据主板型号，或者在开机界面一般会显示具体按键）\n2. 选择 UEFI  U 盘作为启动盘。保存并重启系统。\n\t- Secure Boot设置：Security —> Secure Boot —> Disabled\n\t- Boot Option设置：Boot —> Boot Option #1 —> 将 UEFI USB Key: **** 选择至第一位\n\t- 保存BIOS设置：Exit—>Save Changes and Reset\n3. 大部分默认设置。\n\t1. 网络 IP 使用默认？\n\t2. 安装源：http://mirrors.aliyun.com/ubuntu\n\t3. 磁盘分区：[参考](https://blog.csdn.net/2301_79810514/article/details/137122218)\n\t\t1. SWAP 分区：Linux 的虚拟内存，建议将交换分区的大小设置为物理内存的1.5倍到2倍。\n\t\t2. /boot 分区：引导分区，建议 300-500M ；\n\t\t\t【关于是否要分/boot分区的问题：如果你的主板bios里设置的是UEFI+GPT分区表模式，那么给ubuntu分区的时候不用设置这个/boot分区，设置下面第3步的efi系统分区即可； 但如果你用的是legacy+MBR分区表那就正常设置/boot分区，这个很重要，特别是装双系统或多系统时，避免破坏到其他系统的引导文件】\n\t\t3. EFI引导分区，类型为逻辑分区，，默认ext4。 推荐分 512 ~ 1024M，注意：放在空间起始位置。\n\t\t4. /var 分区（可选）：log 的日志文件存放，如果不分则默认在 / 下。如果 linux 用于服务器和经常做日志分析，建议划分。最少 300-500M，一般 2-3 G。\n\t\t5. 根分区（/）：存储操作系统文件、应用程序和用户数据。建议较大，15G+；\n\t\t6. home 分区：存放个人的文件，建议最大；（/ 和 /home 之间类似 C 和 D 盘的关系）\n# Linux 系统配置\n#### root 账户设置密码\n当前普通用户界面下输入命令，然后按提示两次输入密码即可。\n\n```sh\nsudo passwd root\n```\n\n#### 新增用户并且增加用户权限\n1. `useradd`：用于创建新用户账号。\n    ```\n    sudo useradd username\n    ```\n    其中，`username` 是要创建的新用户的用户名。该命令会创建一个新的用户账号，并分配一个默认的用户ID和组ID。\n    \n2. `passwd`：用于设置用户的密码。\n    ```\n    sudo passwd username\n    ```\n    其中，`username` 是要设置密码的用户的用户名。该命令会提示你输入新的密码，并要求确认密码。\n    \n3. `usermod`：用于修改用户的属性，包括用户权限。\n    ```\n    sudo usermod -aG groupname username\n    ```\n    其中，`groupname` 是要将用户添加到的用户组的组名，`username` 是要修改权限的用户的用户名。该命令会将指定用户添加到指定用户组中，从而增加用户的权限。\n    注意：在执行 `usermod` 命令时，使用 `-aG` 选项是为了将用户添加到用户组而不覆盖用户原有的用户组。\n    \n4. 重新登录：在完成上述步骤后，建议重新登录用户账号，以使用户权限的更改生效。\n\n\n#### 源配置\n###### 1. 首先备份官方自带的软件源\n\n`cp /etc/apt/sources.list /etc/apt/sources.list.bak`\n\n###### 2.然后编辑修改为清华源\n\n`sudo gedit sources.list`\n#### ssh配置\n```sh\n# 查看是否安装了SSH服务\nps -ef | grep ssh \n\n# 没有安装的话，执行下面语句\nsudo apt-get update                   #先更新下资源列表\nsudo apt-get install openssh-server   #安装openssh-server\nsudo ps -ef | grep ssh                #查看是否安装成功\nsudo systemctl restart sshd           #重新启动SSH服务 \n\n# 进入ssh配置文件\nsudo vim  /etc/ssh/sshd_config    \n```\n\n`PermitRootLogin` 是一个用于配置 SSH 服务器的选项。这个选项决定了是否允许 root 用户通过 SSH 直接登录到服务器。通常情况下，为了提高安全性，最好禁止 root 用户通过 SSH 直接登录，而是使用一个普通用户登录后再通过 su 或者 sudo 切换到 root 用户来执行需要特权的操作。这样可以降低系统受到攻击的风险。  \n常见的 PermitRootLogin 选项取值包括：\n\n- `yes`：允许 root 用户通过 SSH 直接登录。\n- `no`：禁止 root 用户通过 SSH 直接登录。\n- `without-password`：允许 root 用户通过 SSH 密钥登录，但不允许使用密码登录。\n\n按i进入编辑模式，找到`#PermitRootLogin prohibit-password`，默认是注释掉的。  \n把 `PermitRootLogin without-password` 改为 `PermitRootLogin yes`，注意`PermitRootLogin without-password`被注释掉了，要去掉注释。如果没有找到`PermitRootLogin without-password`，直接文件末尾添加`PermitRootLogin yes`即可。然后按esc，输入:wq保存并退出。  \n重启sshd服务\n\n```sh\nsudo systemctl restart sshd\n```\n\n#### 驱动更新\n\n```sh\n# 1. 更新软件包列表：\nsudo apt update\n\n# 2. 升级已安装的软件包：\nsudo apt upgrade -y\n\n# 3. 更新驱动程序：\nsudo apt install ubuntu-drivers-common\nsudo ubuntu-drivers autoinstall\n```\n\n\n#### 换源\n```text\ndeb http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse\n \ndeb http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse\n \ndeb http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse\n \ndeb http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse \n```\n#### 网络配置\n\n1. 打开终端，使用root权限登录或者使用sudo命令获取root权限。\n    \n2. 使用文本编辑器打开网络配置文件`/etc/netplan/00-installer-config.yaml`。\n    \n    ```bash\n    sudo vim /etc/netplan/00-installer-config.yaml\n    ```\n    \n3. 在文件中，找到`network`部分，然后根据你的网络设置进行编辑。以下是一个示例配置：\n    \n    ```yaml\n    network:\n      ethernets:\n        enp0s3:\n          addresses: [192.168.1.10/24]\n          gateway4: 192.168.1.1\n          nameservers:\n            addresses: [8.8.8.8, 8.8.4.4]\n      version: 2\n    ```\n    \n    - `enp0s3`是网络接口的名称，你需要根据你的实际网络接口名称进行替换。\n    - `addresses`是你的服务器的静态IP地址和子网掩码。\n    - `gateway4`是你的网关IP地址。\n    - `nameservers`是DNS服务器的IP地址。\n4. 保存文件并关闭文本编辑器。\n    \n5. 在终端中执行以下命令以应用配置更改：\n    \n    ```bash\n    sudo netplan apply\n    ```\n    \n6. 重新启动网络服务以使更改生效：\n    \n    ```bash\n    sudo systemctl restart networking\n    ```\n    \n\n现在，你的 Ubuntu Server 已经配置了静态网络。你可以通过 ping 命令或打开浏览器测试网络连接。\n\n#### 禁止自动休眠\n\n1. 执行如下命令查看休眠模式的情况，如果 sleep 状态是loaded，也就是处于自动休眠开启状态\n\n```sh\nsystemctl status sleep.target\n```\n\n2. 接下来，执行如下命令关闭系统的自动休眠开关：\n\n```sh\n# 这些命令做了以下几点：\n# 通过mask命令，你禁用了所有休眠相关的systemd目标。\n# 通过set-default命令，你设置默认的运行级别为多用户文本模式（即命令行界面）\nsudo systemctl mask sleep.target suspend.target hibernate.target hybrid-sleep.target\nsudo systemctl set-default multi-user.target\n\n####################################################\n# 如果你想要恢复自动休眠功能，可以使用以下命令：\nsudo systemctl unmask sleep.target suspend.target hibernate.target hybrid-sleep.target\nsudo systemctl set-default graphical.target\n\n```\n\n3. 再次执行查看命令，可以看到 sleep 的状态已经变成了 masked，也就是关闭了。\n4. 编辑`/etc/systemd/logind.conf`文件：\n    \n    ```bash\n    sudo vim /etc/systemd/logind.conf\n    ```\n    \n5. 在文件中找到以下行：\n    \n    ```bash\n    #IdleAction=\n    #IdleActionSec=\n    ```\n    \n6. 将这两行的注释符号`#`移除，并设置`IdleAction`为`ignore`，`IdleActionSec`为`0`，如下所示：\n    ```text\n\t    IdleAction=ignore\n\t    IdleActionSec=0\n    ```\n\t\n7. 保存文件并关闭编辑器。\n8. 使用以下命令重新加载systemd配置：\n    \n    ```undefined\n    sudo systemctl restart systemd-logind.service\n    ```\n    \n9. 完成！现在 Ubuntu Server 将不会因为无操作而自动休眠。\n\n#### 设置关盖/合盖不挂起/不睡眠\n\n1. 通过更改登录配置文件`logind.conf`设置\n\n```sh\nsudo vim /etc/systemd/logind.conf\n```\n\n2. 里面影响关盖操作的变量包括`HandleLidSwitch`、`HandleLidSwitchExternalPower`和`HandleLidSwitchDocked`。  \n    `logind.conf` 里面各项的含义如下：\n\n```ini\n1. NAutoVTs=6：指定系统启动时自动分配的虚拟终端数量。\n2. ReserveVT=6：指定系统保留的虚拟终端数量。\n3. KillUserProcesses=no：指定当用户注销时是否终止用户进程。\n4. KillOnlyUsers=：指定需要终止进程的用户列表。\n5. KillExcludeUsers=root：指定不需要终止进程的用户列表。\n6. InhibitDelayMaxSec=5：指定阻止操作的最大延迟时间（以秒为单位）。\n7. HandlePowerKey=poweroff：指定按下电源键时的操作，此处设置为关机。\n8. HandleSuspendKey=suspend：指定按下休眠键时的操作，此处设置为休眠。\n9. HandleHibernateKey=hibernate：指定按下休眠键时的操作，此处设置为休眠。\n10. HandleLidSwitch=suspend：指定关闭笔记本电脑盖子时的操作，此处设置为休眠。\n11. HandleLidSwitchExternalPower=suspend：指定在外部电源连接时关闭笔记本电脑盖子的操作，此处设置为休眠。\n12. HandleLidSwitchDocked=ignore：指定连接到底座时关闭笔记本电脑盖子的操作，此处设置为忽略。\n13. PowerKeyIgnoreInhibited=no：指定是否忽略阻止操作的电源键按下。\n14. SuspendKeyIgnoreInhibited=no：指定是否忽略阻止操作的休眠键按下。\n15. HibernateKeyIgnoreInhibited=no：指定是否忽略阻止操作的休眠键按下。\n16. LidSwitchIgnoreInhibited=yes：指定是否忽略阻止操作的盖子关闭。\n17. HoldoffTimeoutSec=30s：指定在执行操作前等待的时间（以秒为单位）。\n18. IdleAction=ignore：指定系统处于空闲状态时的操作，此处设置为忽略。\n19. IdleActionSec=30min：指定系统处于空闲状态多长时间后执行操作（以分钟为单位）。\n20. RuntimeDirectorySize=10%：指定运行时目录的最大大小，此处设置为总磁盘空间的10%。\n21. RemoveIPC=yes：指定是否在用户注销时删除IPC对象。\n22. InhibitorsMax=8192：指定系统允许的阻止操作的最大数量。\n```\n\n`HandleLidSwitch`: 定义笔记本电脑关闭盖子时的行为。可以设置的值有：\n\n- `ignore`：忽略关闭盖子的事件。\n- `poweroff`：关闭电源。\n- `reboot`：重新启动。\n- `halt`：停止系统。\n- `kexec`：通过 kexec 进行快速启动。\n- `suspend`：挂起系统。\n- `hibernate`：休眠系统。\n\n`HandleLidSwitchExternalPower`: 定义当笔记本电脑连接外部电源时关闭盖子的行为。可以设置的值与 `HandleLidSwitch` 相同。\n\n`HandleLidSwitchDocked`: 定义当笔记本电脑连接到底座时关闭盖子的行为。可以设置的值与 `HandleLidSwitch` 相同。\n\n`HandlePowerKey`: 定义电源按钮的行为。可以设置的值与 `HandleLidSwitch` 相同。\n\n`IdleAction`: 定义系统空闲时的行为。可以设置的值有：\n\n- `ignore`：忽略空闲事件。\n- `poweroff`：关闭电源。\n- `reboot`：重新启动。\n- `halt`：停止系统。\n- `kexec`：通过 kexec 进行快速启动。\n- `suspend`：挂起系统。\n- `hibernate`：休眠系统。\n\n`IdleActionSec`: 定义系统空闲多少秒后触发 `IdleAction`。\n\n`UserTasksMax`: 定义每个用户可以同时运行的任务数的最大值。\n\n`KillUserProcesses`: 定义当用户注销时是否终止用户的进程。可以设置的值有：\n\n- `yes`：终止用户的进程。\n- `no`：不终止用户的进程。\n\n#### 定时自动关闭显示器\n\n1. 想要定时关闭显示器，可以编辑`/etc/default/grub`这个文件\n2. 通过修改GRUB_CMDLINE_LINUX_DEFAULT变量，你可以添加或修改传递给内核的参数，以便在启动时对系统进行自定义配置。\n\n```sh\n# ipv6.disable=1：禁用 IPv6 协议。\n# consoleblank=300：设置控制台空闲时间为 300 秒后自动关闭。\nGRUB_CMDLINE_LINUX_DEFAULT=\"ipv6.disable=1 consoleblank=300\"\n```\n\n3. 修改完了运行`sudo update-grub`，然后重启，即可设置系统5分钟没有活动自动关闭显示器。\n\n#### 网络自动认证\nhttps://github.com/kewuaa/uestc_wifi_helper/releases/download/v0.4.1/uestc_wifi_helper-x86_64-linux\n\n1. 将软件放在 /root/path/uestc-network-login/uestc_wifi_helper_cli-x86_64-linux\n2. 将脚本放在 /root/boot/auto-login-uestc-network.sh\n3. 部署服务在 /etc/systemd/system/auto-network-login.service\n4. 启动服务。\n#### 外接 U 盘挂载\n\n1. 确认 U 盘被正确地检测到：在终端中输入以下命令来查看系统识别的存储设备列表：\n   ```\n   lsblk\n   ``` \n   这将显示所有已连接的存储设备，包括 U 盘。通常，U 盘的设备名称类似于 `/dev/sdb` 或 `/dev/sdc`。\n\n2. 挂载 U 盘：在 Linux 中，需要将 U 盘挂载到文件系统才能访问其中的文件。首先，创建一个用于挂载的目录。在终端中输入以下命令：\n   ```\n   sudo mkdir /mnt/usb\n   ```\n   这将创建一个名为 `/mnt/usb` 的目录作为挂载点。\n\n3. 挂载 U 盘：使用 `mount` 命令将 U 盘挂载到刚刚创建的目录。假设 U 盘的设备名称为 `/dev/sdb1`，在终端中输入以下命令：\n   ```\n   sudo mount /dev/sdb1 /mnt/usb\n   ```\n   如果 U 盘有多个分区，将 `/dev/sdb1` 替换为相应的分区设备名称。\n\n4. 访问 U 盘中的文件：现在，可以通过访问挂载点 `/mnt/usb` 来查看和操作 U 盘中的文件。你可以使用文件管理器（如 Nautilus、Dolphin 或 Thunar）浏览 U 盘，也可以在终端中使用命令行来执行相关操作。\n\n5. 卸载 U 盘：在完成对 U 盘的操作后，应该将其卸载以安全地移除。在终端中输入以下命令来卸载 U 盘：\n   ```\n   sudo umount /mnt/usb\n   ```\n   确保在操作完成后再拔出 U 盘。\n\n请注意，U 盘的设备名称和挂载点可能会根据系统和具体情况有所不同。因此，在使用上述命令时，请根据你的实际情况进行相应的调整。\n\n#### 域名配置\n在 Ubuntu 22.04 TLS 上进行动态 DNS 部署的步骤：\n0. 注册 DNS 服务商账号\n\t[ZoneEdit - Control Panel: Sign Up](https://cp.zoneedit.com/signup/)\n1. 安装 `ddclient`：\n   打开终端并执行以下命令来安装 `ddclient`：\n   ```\n   sudo apt update\n   sudo apt install ddclient\n   ```\n\n2. 配置 `ddclient`：\n   `ddclient` 的配置文件位于 `/etc/ddclient.conf`。使用你喜欢的文本编辑器（如 nano）打开该文件：\n   ```\n   sudo nano /etc/ddclient.conf\n   ```\n\n   在配置文件中，你需要提供动态 DNS 服务提供商的相关信息，例如域名、用户名、密码等。具体配置取决于你选择的动态 DNS 服务提供商。以下是一个示例配置文件的部分内容：\n\n   ```\n   # 使用动态 DNS 服务提供商的示例配置\n   protocol=dyndns2\n   server=members.dyndns.org\n   login=username\n   password='password'\n   your.domain.com\n   \n   # DIY\n   protocol=zoneedit1\n   use=if, if=eno1\n   server=dns1.zoneedit.com \n   ssl=yes \n   login=dinream \n   password='dreamin8888' \n   lm.lab302.com\n   \n   ```\n\n   替换示例配置中的 `protocol`、`server`、`login`、`password` 和 `your.domain.com` 为你的实际设置。请参考你选择的动态 DNS 服务提供商的文档，获取正确的配置参数。\n\n3. 保存并关闭配置文件。\n\n4. 启用并启动 `ddclient` 服务：\n   执行以下命令启用 `ddclient` 服务：\n   ```\n   sudo systemctl enable ddclient\n   ```\n\n   然后，执行以下命令启动服务：\n   ```\n   sudo systemctl start ddclient\n   ```\n\n   `ddclient` 将会读取配置文件并在启动时或 IP 地址变化时更新动态 DNS 记录。\n\n5. 验证配置：\n   执行以下命令来检查 `ddclient` 服务的状态：\n   ```\n   sudo systemctl status ddclient\n   ```\n\n   如果状态显示为 \"active\"，则表示 `ddclient` 服务已成功启动并正在运行。\n6. 查看详细信息\n\t```sh\n\tddclient -foreground  -verbose -force\n\n\tddclient -daemon=0 -debug -verbose -noquiet\n\n\t```\n7. 注意域名的更新在域名服务器之间可能需要一个小时左右，需要等待。\nhttps://blog.cre0809.com/archives/231/\n内网穿透：\nhttps://juejin.cn/post/7346072037674418187\n多种方式解决：\n[如何映射我的私人IP动态变化到我的VPS IP？ - adsl - 码客 (oomake.com)](https://www.oomake.com/question/9612393)\n\n\n# 网络高级配置\n## 双网卡跨网卡 iptables 完成数据转发\n目标：将主机的一个 ip 的发送包，转换为主机另一个 ip 的发送包。\n\n1. 配置网卡IP地址， 配置静态IP地址， \n\t/etc/sysconfig/network-stripts/ifcfg-eth0 配置网卡一， 外网卡， 可以联网\n\t/etc/sysconfig/network-stripts/ifcfg-eth1 配置网卡二， 内网卡， 连接内网\n\n\t配置网卡配置文件\n\tDEVICE=eth1\n\tIPADDR=192.168.145.122// IP地址  \n\tNETMASK=255.255.255.0// IP掩码  \n\tgateway=192.168.142.2// 外网网关地址  \n\tONBOOT=yes\n\t\n\t或者配置/etc/sysconfig/network 添加网关地址\n\tgateway=192.168.142.2  // 外网网关地址\n\n  \n\n2. 打开包转发功能：\n\n\techo \"1\" > /proc/sys/net/ipv4/ip_forward\n\n3. 修改/etc/sysctl.conf文件， 让包转发功能在系统启动时自动生效：\n\n\tnet.ipv4.ip_forward = 1\n\n4. 添加iptables nat路由规则： // 清楚其他不需要的iptables规则\n\n\t/sbin/iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE// 其中网卡eth0 为外网卡。  \n\n5. 保存规则到/etc/sysconfig/iptables 配置文件中\n\n\tservice iptables save\n\n6. 重新启动iptables\n\n\tservice iptables restart\n\n\n\n1、首先确保转发开关打开\n\n\tvim /etc/sysctl.conf\n\n\t\tnet.ipv4.ip_forward = 1\n\n\tsysctl -p\n\n2、核对双网卡配置\n\n\tcat /etc/sysconfig/network-scripts/ifcfg-eth0\n\t\tDEVICE=eth0  \n\t\tHWADDR=  \n\t\tTYPE=Ethernet  \n\t\tUUID=61e9bdb5-b1ff-4c8f-8c19-938c834de345  \n\t\tONBOOT=yes  \n\t\tNM_CONTROLLED=yes  \n\t\tBOOTPROTO=static  \n\t\tIPADDR=192.8.8.57  \n\t\tNETMASK=255.255.255.224  \n\t\tGATEWAY=192.8.8.62\n\n\tcat /etc/sysconfig/network-scripts/ifcfg-eth2\n\t\tDEVICE=eth2\n\t\tHWADDR=\n\t\tTYPE=Ethernet\n\t\tONBOOT=yes\n\t\tNM_CONTROLLED=no\n\t\tBOOTPROTO=static\n\t\tIPADDR=11.10.10.2\n\t\tNETMASK=255.255.255.0\n\n\n3、执行 iptables 并保存 \n\n\tiptables -t nat -A POSTROUTING -s 11.10.10.0/24 -j SNAT  --to 192.8.8.57  \n\tservice iptables save\n\n\n## 局域网自动认证 TODO\n对于学校或者公司，每次主机重启可能需要进行账号的认证，才可上网，这里实现一个脚本进行自动登录\n```text\n一个请求\n[10.253.0.237/cgi-bin/rad_user_info?callback=jQuery]\n(http://10.253.0.237/cgi-bin/rad_user_info?callback=jQuery)\n可以获取，断开网线没有响应。\n\njQuery({\"client_ip\":\"113.54.145.42\",\"ecode\":0,\"error\":\"not_online_error\",\"error_msg\":\"\",\"online_ip\":\"113.54.145.42\",\"res\":\"not_online_error\",\"srun_ver\":\"SRunCGIAuthIntfSvr V1.18 B20181212\",\"st\":1712478100})\n\n\n登录页面的请求。\n请求 URL:\nhttp://10.253.0.237/srun_portal_pc?ac_id=1&theme=dx\n请求方法:\nGET\nStatus Code:\n200 OK\n远程地址:\n10.253.0.237:80\nReferrer Policy:\nstrict-origin-when-cross-origin\n\n\n请求指令\nhttp://10.253.0.237/cgi-bin/get_challenge?callback=jQuery112405824069609933546_1712476428639&username=202321081216%40dx-uestc&ip=8.8.8.8%2C+113.54.145.42\n\nRequest URL:\n\nhttp://10.253.0.237/cgi-bin/get_challenge?callback=jQuery1124028377090795615145_1712478534516&username=202321081216%40dx-uestc&ip=113.54.145.42&_=1712478534518\n\nRequest Method:\n\nGET\n\nStatus Code:\n\n502 Bad Gateway\n\nRemote Address:\n\n127.0.0.1:7890\n\nReferrer Policy:\n\nstrict-origin-when-cross-origin\n\n\n如果连接成功，http://10.253.0.237/cgi-bin/rad_user_info 也可也正常获取数据，但是是字符串形式。而不是json\n\nhttp://10.253.0.237/cgi-bin/srun_portal?callback=jQuery112405960456199614257_1712479784865&action=login&username=202321081216%40dx-uestc&password=%7BMD5%7Dfb5b782af15febf4ebd53a45952273b8&ac_id=1&ip=8.8.8.8%2C+113.54.145.42&chksum=567d3b8c5bd5ef9c7f14c76b487e7ba67a3d245a&info=%7BSRBX1%7D3OHj0r4O4ZBBY1c%2FRJUyhmdftyTtmQ%2BTHXWm%2BGqNqPp2dL59T78gfgRJXnmUW55cnpEZ3LfJ4NvTAu0bX76wfxQdKZrCon42SRXUdymVpUCnBoBvn1cq7pCYcgK%2BGQ7GA%2BClDLGqvIsHwc5ue8FYqip54p4C2MYgtlHTfv%3D%3D&n=200&type=1&os=Windows+10&name=Windows&double_stack=0&_=1712479784868\n\n```\ncurl -d \"username=202321081216&password=feng0408\" http://10.253.0.237/cgi-bin/srun_portal?callback=jQueryaction=login/\n```\n{\n    \"Code\": 0,\n    \"Message\": \"ok\",\n    \"Data\": [\n        {\n            \"Id\": 3,\n            \"Title\": \"清水河校区办公教学区通知\",\n            \"Content\": \"\\u003cp style=\\\"margin-top:auto;margin-bottom: auto;text-align:left;text-indent:36px;line-height: 24px;background:white\\\"\\u003e\\u003cspan style=\\\"font-size: 18px;font-family:宋体\\\"\\u003e清水河校区办公教学区通过墙面预制网络接口连接到有线校园网。连接成功后，打开浏览器输入aaa.uestc.edu.cn弹出认证页面，可选择校园网登录或电信登录。具体使用方法如下：\\u003c/span\\u003e\\u003c/p\\u003e\\u003cp style=\\\"margin-top:auto;margin-bottom: auto;text-align:left;line-height:24px;background: white\\\"\\u003e\\u003cspan style=\\\"font-size:18px;font-family:宋体\\\"\\u003e1\\u003c/span\\u003e\\u003cspan style=\\\"font-size:18px;font-family: 宋体\\\"\\u003e、校园网登录：在右侧登录框输入统一身份认证信息（工资号或学号），点击校园网登录。\\u003c/span\\u003e\\u003c/p\\u003e\\u003cp style=\\\"margin-top:auto;margin-bottom: auto;text-align:left;line-height:24px;background: white\\\"\\u003e\\u003cspan style=\\\"font-size:18px;font-family:宋体\\\"\\u003e2\\u003c/span\\u003e\\u003cspan style=\\\"font-size:18px;font-family: 宋体\\\"\\u003e、电信登录：先点击右侧自服务按钮，进行电信账号绑定；绑定完成重新打开aaa.uestc.edu.cn，输入学校统一身份认证信息，点击电信登录。电信账号绑定流程详见《清水河有线校园网使用手册》。\\u003c/span\\u003e\\u003c/p\\u003e\\u003cp style=\\\"margin-top:auto;margin-bottom: auto;text-align:left;line-height:24px;background: white\\\"\\u003e\\u003cstrong\\u003e\\u003cspan style=\\\"font-size:18px;font-family:宋体\\\"\\u003e用户服务电话：61831184\\u003c/span\\u003e\\u003c/strong\\u003e\\u003c/p\\u003e\\u003cp\\u003e\\u003cbr/\\u003e\\u003c/p\\u003e\",\n            \"Created_by\": \"srun\",\n            \"Created_at\": 1622792930,\n            \"Updated_at\": 1622792930\n        },\n        {\n            \"Id\": 2,\n            \"Title\": \"清水河行政教学区有线网络割接通知\",\n            \"Content\": \"\\u003cp style=\\\"margin-top:5px;margin-right:0;margin-bottom:5px;margin-left: 0;text-indent:28px\\\"\\u003e\\u003cspan style=\\\"font-size: 18px;\\\"\\u003e\\u003c/span\\u003e\\u003c/p\\u003e\\u003cp style=\\\"line-height: 1.5em;\\\"\\u003e清水河校区有线网络设备已运行10年以上，故障频发，不支持IPv6，802.1X认证系统对于终端兼容性较差。为解决以上问题，信息中心协调中国电信高新西区分公司对清水河校区有线网进行改造。改造后网络使用web认证，支持IPv6协议，用户可选择校园网登录或电信登录。具体使用方法如下：\\u003c/p\\u003e\\u003cp style=\\\"line-height: 1.5em;\\\"\\u003e1、校园网登录：在右侧登录框输入统一身份认证信息，点击校园网登录。\\u003c/p\\u003e\\u003cp style=\\\"line-height: 1.5em;\\\"\\u003e2、电信登录：先点击右侧自服务按钮，进行电信账号绑定；绑定完成重新打开aaa.uestc.edu.cn，输入学校统一身份认证信息，点击电信登录。电信账号绑定流程详见《清水河有线校园网使用手册》。\\u003c/p\\u003e\\u003cp style=\\\"line-height: 1.5em;\\\"\\u003e我们对给您带来的不便表示歉意！如有任何疑问，请联系信息中心61831184。\\u003c/p\\u003e\\u003cp style=\\\"margin-top:5px;margin-right:0;margin-bottom:5px;margin-left: 0;text-indent:28px;font-variant-ligatures: normal;font-variant-caps: normal;orphans: 2;text-align:start;widows: 2;-webkit-text-stroke-width: 0px;word-spacing: 0px\\\"\\u003e\\u003cbr/\\u003e\\u003c/p\\u003e\\u003cp\\u003e\\u003cbr/\\u003e\\u003c/p\\u003e\",\n            \"Created_by\": \"yqli\",\n            \"Created_at\": 1544507894,\n            \"Updated_at\": 1622792876\n        }\n    ]\n}\n```\n\n# 程序自启动\n在 Ubuntu 中，你可以使用 Systemd 来配置在系统启动时自动后台执行可执行程序。\n\n下面是一些基本的步骤：\n\n1. 创建一个用于 Systemd 配置的服务文件。在终端中使用以下命令创建一个新的服务文件：\n   ```\n   sudo nano /etc/systemd/system/test.service\n   ```\n\n2. 在打开的编辑器中，输入以下内容：\n   ```\n   [Unit]\n   Description=Test Service\n   After=network.target\n\n   [Service]\n   ExecStart=/path/to/test\n   Type=simple\n   Restart=always\n   User=your_username\n\n   [Install]\n   WantedBy=multi-user.target\n   ```\n\n   请确保将 `/path/to/test` 替换为你的可执行程序的实际路径，并将 `your_username` 替换为你的用户名。\n\n3. 保存并关闭文件。使用 `Ctrl + X`，然后输入 `Y` 保存文件并退出编辑器。\n\n4. 重新加载 Systemd 配置，使其识别新的服务文件。在终端中使用以下命令：\n   ```\n   sudo systemctl daemon-reload\n   ```\n\n5. 启用服务，使其在系统启动时自动运行。在终端中使用以下命令：\n   ```\n   sudo systemctl enable test.service\n   ```\n\n6. 最后，启动服务。在终端中使用以下命令：\n   ```\n   sudo systemctl start test.service\n   ```\n\n现在，你的可执行程序 `test` 将在系统启动时自动以后台进程的形式运行。\n\n你可以使用以下命令来检查服务的状态：\n```\nsudo systemctl status test.service\n```\n\n如果需要停止服务，可以使用以下命令：\n```\nsudo systemctl stop test.service\n```\n\n\n# 后台运行程序\n\n\n1. 在执行命令时，可以使用 `&` 符号将其放在命令的末尾。这样会将命令放入后台运行，并且不会阻塞当前终端。例如：\n```\n\t./test & \n```\n2.  如果你希望程序在后台运行的同时不产生任何输出，你可以将其输出重定向到 `/dev/null`，这样输出将被丢弃。例如：\n```\n\tnohup ./clash-linux-amd64 > /dev/null 2>&1 &\n\tnohup ./aaa > output.log 2>&1 &\n\tdisown\n\n```\n这样，可执行程序 `./test` 将在后台运行，并与当前终端解耦。它不会阻塞当前终端，并且输出将被重定向到 `/dev/null`，不会显示在终端上。\n\n请注意，使用这种方法运行程序后，你将无法看到程序的输出。如果你需要查看程序的输出或进行其他交互操作，可能需要使用其他工具或技术来实现。\n\n\n\n# 离线安装包的使用\n## Centos\n1. 打包\n\t```bash\n\tyum install [package]--downloadonly --downloaddir=dir/\n\t```\n2. 使用\n\t```bash\n\tyum -y localinstall dir/*\n```\n\n\n# 查询指定域名的 IP\n\n```sh\nnsloopup\n```\n\n\n# 日志查看\n```sh\n/var/log/syslog\n/var/log/kern.log\n```\n\n# 查看显存运行情况\n\n\n```shell\nwatch -n 0.1 nvidia-smi\n```\n","slug":"工具教程/配置：Linux 系统","published":1,"date":"2024-04-22T13:14:48.761Z","updated":"2024-04-22T06:22:53.210Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0d000okgg4hkk029k7","content":"<h1 id=\"Linux-安装盘安装\"><a href=\"#Linux-安装盘安装\" class=\"headerlink\" title=\"Linux 安装盘安装\"></a>Linux 安装盘安装</h1><h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><ol>\n<li>准备一个空 U 盘，作为后续安装盘。</li>\n<li>下载 rufus  U 盘 格式化软件，分区类型：选择GPT，目标系统类型UEFI（非SM） <a href=\"https://rufus.ie/zh/#google_vignette\">下载地址</a> </li>\n<li>下载 Ubuntu iso 镜像 <a href=\"https://ubuntu.com/download/server/thank-you?version=22.04.4&architecture=amd64\">Ubuntu22.04.4</a></li>\n<li>使用 rufus 对安装盘进行制作，配置如下<br> ![[Pasted image 20240406101639.png]]<br> 磁盘分区方式：MBR和GPT，MBR的主分区只能划分最多4个，GPT的分区数量没有限制，这里选择 GPT。</li>\n</ol>\n<h2 id=\"开始安装\"><a href=\"#开始安装\" class=\"headerlink\" title=\"开始安装\"></a>开始安装</h2><ol>\n<li>开启服务器主机，进入系统 BIOS（Del键、F2键、F10键或者ESC键，依据主板型号，或者在开机界面一般会显示具体按键）</li>\n<li>选择 UEFI  U 盘作为启动盘。保存并重启系统。<ul>\n<li>Secure Boot设置：Security —&gt; Secure Boot —&gt; Disabled</li>\n<li>Boot Option设置：Boot —&gt; Boot Option #1 —&gt; 将 UEFI USB Key: **** 选择至第一位</li>\n<li>保存BIOS设置：Exit—&gt;Save Changes and Reset</li>\n</ul>\n</li>\n<li>大部分默认设置。<ol>\n<li>网络 IP 使用默认？</li>\n<li>安装源：<a href=\"http://mirrors.aliyun.com/ubuntu\">http://mirrors.aliyun.com/ubuntu</a></li>\n<li>磁盘分区：<a href=\"https://blog.csdn.net/2301_79810514/article/details/137122218\">参考</a><ol>\n<li>SWAP 分区：Linux 的虚拟内存，建议将交换分区的大小设置为物理内存的1.5倍到2倍。</li>\n<li>&#x2F;boot 分区：引导分区，建议 300-500M ；<br> 【关于是否要分&#x2F;boot分区的问题：如果你的主板bios里设置的是UEFI+GPT分区表模式，那么给ubuntu分区的时候不用设置这个&#x2F;boot分区，设置下面第3步的efi系统分区即可； 但如果你用的是legacy+MBR分区表那就正常设置&#x2F;boot分区，这个很重要，特别是装双系统或多系统时，避免破坏到其他系统的引导文件】</li>\n<li>EFI引导分区，类型为逻辑分区，，默认ext4。 推荐分 512 ~ 1024M，注意：放在空间起始位置。</li>\n<li>&#x2F;var 分区（可选）：log 的日志文件存放，如果不分则默认在 &#x2F; 下。如果 linux 用于服务器和经常做日志分析，建议划分。最少 300-500M，一般 2-3 G。</li>\n<li>根分区（&#x2F;）：存储操作系统文件、应用程序和用户数据。建议较大，15G+；</li>\n<li>home 分区：存放个人的文件，建议最大；（&#x2F; 和 &#x2F;home 之间类似 C 和 D 盘的关系）</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"Linux-系统配置\"><a href=\"#Linux-系统配置\" class=\"headerlink\" title=\"Linux 系统配置\"></a>Linux 系统配置</h1><h4 id=\"root-账户设置密码\"><a href=\"#root-账户设置密码\" class=\"headerlink\" title=\"root 账户设置密码\"></a>root 账户设置密码</h4><p>当前普通用户界面下输入命令，然后按提示两次输入密码即可。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo passwd root</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"新增用户并且增加用户权限\"><a href=\"#新增用户并且增加用户权限\" class=\"headerlink\" title=\"新增用户并且增加用户权限\"></a>新增用户并且增加用户权限</h4><ol>\n<li><p><code>useradd</code>：用于创建新用户账号。</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo useradd username</span><br></pre></td></tr></table></figure>\n<p> 其中，<code>username</code> 是要创建的新用户的用户名。该命令会创建一个新的用户账号，并分配一个默认的用户ID和组ID。</p>\n</li>\n<li><p><code>passwd</code>：用于设置用户的密码。</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo passwd username</span><br></pre></td></tr></table></figure>\n<p> 其中，<code>username</code> 是要设置密码的用户的用户名。该命令会提示你输入新的密码，并要求确认密码。</p>\n</li>\n<li><p><code>usermod</code>：用于修改用户的属性，包括用户权限。</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo usermod -aG groupname username</span><br></pre></td></tr></table></figure>\n<p> 其中，<code>groupname</code> 是要将用户添加到的用户组的组名，<code>username</code> 是要修改权限的用户的用户名。该命令会将指定用户添加到指定用户组中，从而增加用户的权限。<br> 注意：在执行 <code>usermod</code> 命令时，使用 <code>-aG</code> 选项是为了将用户添加到用户组而不覆盖用户原有的用户组。</p>\n</li>\n<li><p>重新登录：在完成上述步骤后，建议重新登录用户账号，以使用户权限的更改生效。</p>\n</li>\n</ol>\n<h4 id=\"源配置\"><a href=\"#源配置\" class=\"headerlink\" title=\"源配置\"></a>源配置</h4><h6 id=\"1-首先备份官方自带的软件源\"><a href=\"#1-首先备份官方自带的软件源\" class=\"headerlink\" title=\"1. 首先备份官方自带的软件源\"></a>1. 首先备份官方自带的软件源</h6><p><code>cp /etc/apt/sources.list /etc/apt/sources.list.bak</code></p>\n<h6 id=\"2-然后编辑修改为清华源\"><a href=\"#2-然后编辑修改为清华源\" class=\"headerlink\" title=\"2.然后编辑修改为清华源\"></a>2.然后编辑修改为清华源</h6><p><code>sudo gedit sources.list</code></p>\n<h4 id=\"ssh配置\"><a href=\"#ssh配置\" class=\"headerlink\" title=\"ssh配置\"></a>ssh配置</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看是否安装了SSH服务</span></span><br><span class=\"line\">ps -ef | grep ssh </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 没有安装的话，执行下面语句</span></span><br><span class=\"line\">sudo apt-get update                   <span class=\"comment\">#先更新下资源列表</span></span><br><span class=\"line\">sudo apt-get install openssh-server   <span class=\"comment\">#安装openssh-server</span></span><br><span class=\"line\">sudo ps -ef | grep ssh                <span class=\"comment\">#查看是否安装成功</span></span><br><span class=\"line\">sudo systemctl restart sshd           <span class=\"comment\">#重新启动SSH服务 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 进入ssh配置文件</span></span><br><span class=\"line\">sudo vim  /etc/ssh/sshd_config    </span><br></pre></td></tr></table></figure>\n\n<p><code>PermitRootLogin</code> 是一个用于配置 SSH 服务器的选项。这个选项决定了是否允许 root 用户通过 SSH 直接登录到服务器。通常情况下，为了提高安全性，最好禁止 root 用户通过 SSH 直接登录，而是使用一个普通用户登录后再通过 su 或者 sudo 切换到 root 用户来执行需要特权的操作。这样可以降低系统受到攻击的风险。<br>常见的 PermitRootLogin 选项取值包括：</p>\n<ul>\n<li><code>yes</code>：允许 root 用户通过 SSH 直接登录。</li>\n<li><code>no</code>：禁止 root 用户通过 SSH 直接登录。</li>\n<li><code>without-password</code>：允许 root 用户通过 SSH 密钥登录，但不允许使用密码登录。</li>\n</ul>\n<p>按i进入编辑模式，找到<code>#PermitRootLogin prohibit-password</code>，默认是注释掉的。<br>把 <code>PermitRootLogin without-password</code> 改为 <code>PermitRootLogin yes</code>，注意<code>PermitRootLogin without-password</code>被注释掉了，要去掉注释。如果没有找到<code>PermitRootLogin without-password</code>，直接文件末尾添加<code>PermitRootLogin yes</code>即可。然后按esc，输入:wq保存并退出。<br>重启sshd服务</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl restart sshd</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"驱动更新\"><a href=\"#驱动更新\" class=\"headerlink\" title=\"驱动更新\"></a>驱动更新</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. 更新软件包列表：</span></span><br><span class=\"line\">sudo apt update</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2. 升级已安装的软件包：</span></span><br><span class=\"line\">sudo apt upgrade -y</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3. 更新驱动程序：</span></span><br><span class=\"line\">sudo apt install ubuntu-drivers-common</span><br><span class=\"line\">sudo ubuntu-drivers autoinstall</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"换源\"><a href=\"#换源\" class=\"headerlink\" title=\"换源\"></a>换源</h4><figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse</span><br><span class=\"line\"> </span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class=\"line\"> </span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse</span><br><span class=\"line\"> </span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse </span><br></pre></td></tr></table></figure>\n<h4 id=\"网络配置\"><a href=\"#网络配置\" class=\"headerlink\" title=\"网络配置\"></a>网络配置</h4><ol>\n<li><p>打开终端，使用root权限登录或者使用sudo命令获取root权限。</p>\n</li>\n<li><p>使用文本编辑器打开网络配置文件<code>/etc/netplan/00-installer-config.yaml</code>。</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo vim /etc/netplan/00-installer-config.yaml</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在文件中，找到<code>network</code>部分，然后根据你的网络设置进行编辑。以下是一个示例配置：</p>\n <figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">network:</span></span><br><span class=\"line\">  <span class=\"attr\">ethernets:</span></span><br><span class=\"line\">    <span class=\"attr\">enp0s3:</span></span><br><span class=\"line\">      <span class=\"attr\">addresses:</span> [<span class=\"number\">192.168</span><span class=\"number\">.1</span><span class=\"number\">.10</span><span class=\"string\">/24</span>]</span><br><span class=\"line\">      <span class=\"attr\">gateway4:</span> <span class=\"number\">192.168</span><span class=\"number\">.1</span><span class=\"number\">.1</span></span><br><span class=\"line\">      <span class=\"attr\">nameservers:</span></span><br><span class=\"line\">        <span class=\"attr\">addresses:</span> [<span class=\"number\">8.8</span><span class=\"number\">.8</span><span class=\"number\">.8</span>, <span class=\"number\">8.8</span><span class=\"number\">.4</span><span class=\"number\">.4</span>]</span><br><span class=\"line\">  <span class=\"attr\">version:</span> <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>enp0s3</code>是网络接口的名称，你需要根据你的实际网络接口名称进行替换。</li>\n<li><code>addresses</code>是你的服务器的静态IP地址和子网掩码。</li>\n<li><code>gateway4</code>是你的网关IP地址。</li>\n<li><code>nameservers</code>是DNS服务器的IP地址。</li>\n</ul>\n</li>\n<li><p>保存文件并关闭文本编辑器。</p>\n</li>\n<li><p>在终端中执行以下命令以应用配置更改：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo netplan apply</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重新启动网络服务以使更改生效：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl restart networking</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>现在，你的 Ubuntu Server 已经配置了静态网络。你可以通过 ping 命令或打开浏览器测试网络连接。</p>\n<h4 id=\"禁止自动休眠\"><a href=\"#禁止自动休眠\" class=\"headerlink\" title=\"禁止自动休眠\"></a>禁止自动休眠</h4><ol>\n<li>执行如下命令查看休眠模式的情况，如果 sleep 状态是loaded，也就是处于自动休眠开启状态</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl status sleep.target</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>接下来，执行如下命令关闭系统的自动休眠开关：</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 这些命令做了以下几点：</span></span><br><span class=\"line\"><span class=\"comment\"># 通过mask命令，你禁用了所有休眠相关的systemd目标。</span></span><br><span class=\"line\"><span class=\"comment\"># 通过set-default命令，你设置默认的运行级别为多用户文本模式（即命令行界面）</span></span><br><span class=\"line\">sudo systemctl mask sleep.target suspend.target hibernate.target hybrid-sleep.target</span><br><span class=\"line\">sudo systemctl set-default multi-user.target</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">####################################################</span></span><br><span class=\"line\"><span class=\"comment\"># 如果你想要恢复自动休眠功能，可以使用以下命令：</span></span><br><span class=\"line\">sudo systemctl unmask sleep.target suspend.target hibernate.target hybrid-sleep.target</span><br><span class=\"line\">sudo systemctl set-default graphical.target</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><p>再次执行查看命令，可以看到 sleep 的状态已经变成了 masked，也就是关闭了。</p>\n</li>\n<li><p>编辑<code>/etc/systemd/logind.conf</code>文件：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo vim /etc/systemd/logind.conf</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在文件中找到以下行：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#IdleAction=</span></span><br><span class=\"line\"><span class=\"comment\">#IdleActionSec=</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>将这两行的注释符号<code>#</code>移除，并设置<code>IdleAction</code>为<code>ignore</code>，<code>IdleActionSec</code>为<code>0</code>，如下所示：</p>\n <figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IdleAction=ignore</span><br><span class=\"line\">IdleActionSec=0</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>保存文件并关闭编辑器。</p>\n</li>\n<li><p>使用以下命令重新加载systemd配置：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl restart systemd-logind.service</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>完成！现在 Ubuntu Server 将不会因为无操作而自动休眠。</p>\n</li>\n</ol>\n<h4 id=\"设置关盖-合盖不挂起-不睡眠\"><a href=\"#设置关盖-合盖不挂起-不睡眠\" class=\"headerlink\" title=\"设置关盖&#x2F;合盖不挂起&#x2F;不睡眠\"></a>设置关盖&#x2F;合盖不挂起&#x2F;不睡眠</h4><ol>\n<li>通过更改登录配置文件<code>logind.conf</code>设置</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo vim /etc/systemd/logind.conf</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>里面影响关盖操作的变量包括<code>HandleLidSwitch</code>、<code>HandleLidSwitchExternalPower</code>和<code>HandleLidSwitchDocked</code>。<br> <code>logind.conf</code> 里面各项的含义如下：</li>\n</ol>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">1. NAutoVTs</span>=<span class=\"number\">6</span>：指定系统启动时自动分配的虚拟终端数量。</span><br><span class=\"line\"><span class=\"attr\">2. ReserveVT</span>=<span class=\"number\">6</span>：指定系统保留的虚拟终端数量。</span><br><span class=\"line\"><span class=\"attr\">3. KillUserProcesses</span>=<span class=\"literal\">no</span>：指定当用户注销时是否终止用户进程。</span><br><span class=\"line\"><span class=\"attr\">4. KillOnlyUsers</span>=：指定需要终止进程的用户列表。</span><br><span class=\"line\"><span class=\"attr\">5. KillExcludeUsers</span>=root：指定不需要终止进程的用户列表。</span><br><span class=\"line\"><span class=\"attr\">6. InhibitDelayMaxSec</span>=<span class=\"number\">5</span>：指定阻止操作的最大延迟时间（以秒为单位）。</span><br><span class=\"line\"><span class=\"attr\">7. HandlePowerKey</span>=power<span class=\"literal\">off</span>：指定按下电源键时的操作，此处设置为关机。</span><br><span class=\"line\"><span class=\"attr\">8. HandleSuspendKey</span>=suspend：指定按下休眠键时的操作，此处设置为休眠。</span><br><span class=\"line\"><span class=\"attr\">9. HandleHibernateKey</span>=hibernate：指定按下休眠键时的操作，此处设置为休眠。</span><br><span class=\"line\"><span class=\"attr\">10. HandleLidSwitch</span>=suspend：指定关闭笔记本电脑盖子时的操作，此处设置为休眠。</span><br><span class=\"line\"><span class=\"attr\">11. HandleLidSwitchExternalPower</span>=suspend：指定在外部电源连接时关闭笔记本电脑盖子的操作，此处设置为休眠。</span><br><span class=\"line\"><span class=\"attr\">12. HandleLidSwitchDocked</span>=ignore：指定连接到底座时关闭笔记本电脑盖子的操作，此处设置为忽略。</span><br><span class=\"line\"><span class=\"attr\">13. PowerKeyIgnoreInhibited</span>=<span class=\"literal\">no</span>：指定是否忽略阻止操作的电源键按下。</span><br><span class=\"line\"><span class=\"attr\">14. SuspendKeyIgnoreInhibited</span>=<span class=\"literal\">no</span>：指定是否忽略阻止操作的休眠键按下。</span><br><span class=\"line\"><span class=\"attr\">15. HibernateKeyIgnoreInhibited</span>=<span class=\"literal\">no</span>：指定是否忽略阻止操作的休眠键按下。</span><br><span class=\"line\"><span class=\"attr\">16. LidSwitchIgnoreInhibited</span>=<span class=\"literal\">yes</span>：指定是否忽略阻止操作的盖子关闭。</span><br><span class=\"line\"><span class=\"attr\">17. HoldoffTimeoutSec</span>=<span class=\"number\">30</span>s：指定在执行操作前等待的时间（以秒为单位）。</span><br><span class=\"line\"><span class=\"attr\">18. IdleAction</span>=ignore：指定系统处于空闲状态时的操作，此处设置为忽略。</span><br><span class=\"line\"><span class=\"attr\">19. IdleActionSec</span>=<span class=\"number\">30</span>min：指定系统处于空闲状态多长时间后执行操作（以分钟为单位）。</span><br><span class=\"line\"><span class=\"attr\">20. RuntimeDirectorySize</span>=<span class=\"number\">10</span>%：指定运行时目录的最大大小，此处设置为总磁盘空间的<span class=\"number\">10</span>%。</span><br><span class=\"line\"><span class=\"attr\">21. RemoveIPC</span>=<span class=\"literal\">yes</span>：指定是否在用户注销时删除IPC对象。</span><br><span class=\"line\"><span class=\"attr\">22. InhibitorsMax</span>=<span class=\"number\">8192</span>：指定系统允许的阻止操作的最大数量。</span><br></pre></td></tr></table></figure>\n\n<p><code>HandleLidSwitch</code>: 定义笔记本电脑关闭盖子时的行为。可以设置的值有：</p>\n<ul>\n<li><code>ignore</code>：忽略关闭盖子的事件。</li>\n<li><code>poweroff</code>：关闭电源。</li>\n<li><code>reboot</code>：重新启动。</li>\n<li><code>halt</code>：停止系统。</li>\n<li><code>kexec</code>：通过 kexec 进行快速启动。</li>\n<li><code>suspend</code>：挂起系统。</li>\n<li><code>hibernate</code>：休眠系统。</li>\n</ul>\n<p><code>HandleLidSwitchExternalPower</code>: 定义当笔记本电脑连接外部电源时关闭盖子的行为。可以设置的值与 <code>HandleLidSwitch</code> 相同。</p>\n<p><code>HandleLidSwitchDocked</code>: 定义当笔记本电脑连接到底座时关闭盖子的行为。可以设置的值与 <code>HandleLidSwitch</code> 相同。</p>\n<p><code>HandlePowerKey</code>: 定义电源按钮的行为。可以设置的值与 <code>HandleLidSwitch</code> 相同。</p>\n<p><code>IdleAction</code>: 定义系统空闲时的行为。可以设置的值有：</p>\n<ul>\n<li><code>ignore</code>：忽略空闲事件。</li>\n<li><code>poweroff</code>：关闭电源。</li>\n<li><code>reboot</code>：重新启动。</li>\n<li><code>halt</code>：停止系统。</li>\n<li><code>kexec</code>：通过 kexec 进行快速启动。</li>\n<li><code>suspend</code>：挂起系统。</li>\n<li><code>hibernate</code>：休眠系统。</li>\n</ul>\n<p><code>IdleActionSec</code>: 定义系统空闲多少秒后触发 <code>IdleAction</code>。</p>\n<p><code>UserTasksMax</code>: 定义每个用户可以同时运行的任务数的最大值。</p>\n<p><code>KillUserProcesses</code>: 定义当用户注销时是否终止用户的进程。可以设置的值有：</p>\n<ul>\n<li><code>yes</code>：终止用户的进程。</li>\n<li><code>no</code>：不终止用户的进程。</li>\n</ul>\n<h4 id=\"定时自动关闭显示器\"><a href=\"#定时自动关闭显示器\" class=\"headerlink\" title=\"定时自动关闭显示器\"></a>定时自动关闭显示器</h4><ol>\n<li>想要定时关闭显示器，可以编辑<code>/etc/default/grub</code>这个文件</li>\n<li>通过修改GRUB_CMDLINE_LINUX_DEFAULT变量，你可以添加或修改传递给内核的参数，以便在启动时对系统进行自定义配置。</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ipv6.disable=1：禁用 IPv6 协议。</span></span><br><span class=\"line\"><span class=\"comment\"># consoleblank=300：设置控制台空闲时间为 300 秒后自动关闭。</span></span><br><span class=\"line\">GRUB_CMDLINE_LINUX_DEFAULT=<span class=\"string\">&quot;ipv6.disable=1 consoleblank=300&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>修改完了运行<code>sudo update-grub</code>，然后重启，即可设置系统5分钟没有活动自动关闭显示器。</li>\n</ol>\n<h4 id=\"网络自动认证\"><a href=\"#网络自动认证\" class=\"headerlink\" title=\"网络自动认证\"></a>网络自动认证</h4><p><a href=\"https://github.com/kewuaa/uestc_wifi_helper/releases/download/v0.4.1/uestc_wifi_helper-x86_64-linux\">https://github.com/kewuaa/uestc_wifi_helper/releases/download/v0.4.1/uestc_wifi_helper-x86_64-linux</a></p>\n<ol>\n<li>将软件放在 &#x2F;root&#x2F;path&#x2F;uestc-network-login&#x2F;uestc_wifi_helper_cli-x86_64-linux</li>\n<li>将脚本放在 &#x2F;root&#x2F;boot&#x2F;auto-login-uestc-network.sh</li>\n<li>部署服务在 &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;auto-network-login.service</li>\n<li>启动服务。</li>\n</ol>\n<h4 id=\"外接-U-盘挂载\"><a href=\"#外接-U-盘挂载\" class=\"headerlink\" title=\"外接 U 盘挂载\"></a>外接 U 盘挂载</h4><ol>\n<li><p>确认 U 盘被正确地检测到：在终端中输入以下命令来查看系统识别的存储设备列表：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsblk</span><br></pre></td></tr></table></figure>\n<p>这将显示所有已连接的存储设备，包括 U 盘。通常，U 盘的设备名称类似于 <code>/dev/sdb</code> 或 <code>/dev/sdc</code>。</p>\n</li>\n<li><p>挂载 U 盘：在 Linux 中，需要将 U 盘挂载到文件系统才能访问其中的文件。首先，创建一个用于挂载的目录。在终端中输入以下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mkdir /mnt/usb</span><br></pre></td></tr></table></figure>\n<p>这将创建一个名为 <code>/mnt/usb</code> 的目录作为挂载点。</p>\n</li>\n<li><p>挂载 U 盘：使用 <code>mount</code> 命令将 U 盘挂载到刚刚创建的目录。假设 U 盘的设备名称为 <code>/dev/sdb1</code>，在终端中输入以下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mount /dev/sdb1 /mnt/usb</span><br></pre></td></tr></table></figure>\n<p>如果 U 盘有多个分区，将 <code>/dev/sdb1</code> 替换为相应的分区设备名称。</p>\n</li>\n<li><p>访问 U 盘中的文件：现在，可以通过访问挂载点 <code>/mnt/usb</code> 来查看和操作 U 盘中的文件。你可以使用文件管理器（如 Nautilus、Dolphin 或 Thunar）浏览 U 盘，也可以在终端中使用命令行来执行相关操作。</p>\n</li>\n<li><p>卸载 U 盘：在完成对 U 盘的操作后，应该将其卸载以安全地移除。在终端中输入以下命令来卸载 U 盘：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo umount /mnt/usb</span><br></pre></td></tr></table></figure>\n<p>确保在操作完成后再拔出 U 盘。</p>\n</li>\n</ol>\n<p>请注意，U 盘的设备名称和挂载点可能会根据系统和具体情况有所不同。因此，在使用上述命令时，请根据你的实际情况进行相应的调整。</p>\n<h4 id=\"域名配置\"><a href=\"#域名配置\" class=\"headerlink\" title=\"域名配置\"></a>域名配置</h4><p>在 Ubuntu 22.04 TLS 上进行动态 DNS 部署的步骤：<br>0. 注册 DNS 服务商账号<br>    <a href=\"https://cp.zoneedit.com/signup/\">ZoneEdit - Control Panel: Sign Up</a></p>\n<ol>\n<li><p>安装 <code>ddclient</code>：<br>打开终端并执行以下命令来安装 <code>ddclient</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br><span class=\"line\">sudo apt install ddclient</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>配置 <code>ddclient</code>：<br><code>ddclient</code> 的配置文件位于 <code>/etc/ddclient.conf</code>。使用你喜欢的文本编辑器（如 nano）打开该文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo nano /etc/ddclient.conf</span><br></pre></td></tr></table></figure>\n\n<p>在配置文件中，你需要提供动态 DNS 服务提供商的相关信息，例如域名、用户名、密码等。具体配置取决于你选择的动态 DNS 服务提供商。以下是一个示例配置文件的部分内容：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 使用动态 DNS 服务提供商的示例配置</span><br><span class=\"line\">protocol=dyndns2</span><br><span class=\"line\">server=members.dyndns.org</span><br><span class=\"line\">login=username</span><br><span class=\"line\">password=&#x27;password&#x27;</span><br><span class=\"line\">your.domain.com</span><br><span class=\"line\"></span><br><span class=\"line\"># DIY</span><br><span class=\"line\">protocol=zoneedit1</span><br><span class=\"line\">use=if, if=eno1</span><br><span class=\"line\">server=dns1.zoneedit.com </span><br><span class=\"line\">ssl=yes </span><br><span class=\"line\">login=dinream </span><br><span class=\"line\">password=&#x27;dreamin8888&#x27; </span><br><span class=\"line\">lm.lab302.com</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>替换示例配置中的 <code>protocol</code>、<code>server</code>、<code>login</code>、<code>password</code> 和 <code>your.domain.com</code> 为你的实际设置。请参考你选择的动态 DNS 服务提供商的文档，获取正确的配置参数。</p>\n</li>\n<li><p>保存并关闭配置文件。</p>\n</li>\n<li><p>启用并启动 <code>ddclient</code> 服务：<br>执行以下命令启用 <code>ddclient</code> 服务：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl enable ddclient</span><br></pre></td></tr></table></figure>\n\n<p>然后，执行以下命令启动服务：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl start ddclient</span><br></pre></td></tr></table></figure>\n\n<p><code>ddclient</code> 将会读取配置文件并在启动时或 IP 地址变化时更新动态 DNS 记录。</p>\n</li>\n<li><p>验证配置：<br>执行以下命令来检查 <code>ddclient</code> 服务的状态：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl status ddclient</span><br></pre></td></tr></table></figure>\n\n<p>如果状态显示为 “active”，则表示 <code>ddclient</code> 服务已成功启动并正在运行。</p>\n</li>\n<li><p>查看详细信息</p>\n <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ddclient -foreground  -verbose -force</span><br><span class=\"line\"></span><br><span class=\"line\">ddclient -daemon=0 -debug -verbose -noquiet</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li><p>注意域名的更新在域名服务器之间可能需要一个小时左右，需要等待。<br><a href=\"https://blog.cre0809.com/archives/231/\">https://blog.cre0809.com/archives/231/</a><br>内网穿透：<br><a href=\"https://juejin.cn/post/7346072037674418187\">https://juejin.cn/post/7346072037674418187</a><br>多种方式解决：<br><a href=\"https://www.oomake.com/question/9612393\">如何映射我的私人IP动态变化到我的VPS IP？ - adsl - 码客 (oomake.com)</a></p>\n</li>\n</ol>\n<h1 id=\"网络高级配置\"><a href=\"#网络高级配置\" class=\"headerlink\" title=\"网络高级配置\"></a>网络高级配置</h1><h2 id=\"双网卡跨网卡-iptables-完成数据转发\"><a href=\"#双网卡跨网卡-iptables-完成数据转发\" class=\"headerlink\" title=\"双网卡跨网卡 iptables 完成数据转发\"></a>双网卡跨网卡 iptables 完成数据转发</h2><p>目标：将主机的一个 ip 的发送包，转换为主机另一个 ip 的发送包。</p>\n<ol>\n<li><p>配置网卡IP地址， 配置静态IP地址， <br> &#x2F;etc&#x2F;sysconfig&#x2F;network-stripts&#x2F;ifcfg-eth0 配置网卡一， 外网卡， 可以联网<br> &#x2F;etc&#x2F;sysconfig&#x2F;network-stripts&#x2F;ifcfg-eth1 配置网卡二， 内网卡， 连接内网</p>\n<p> 配置网卡配置文件<br> DEVICE&#x3D;eth1<br> IPADDR&#x3D;192.168.145.122&#x2F;&#x2F; IP地址<br> NETMASK&#x3D;255.255.255.0&#x2F;&#x2F; IP掩码<br> gateway&#x3D;192.168.142.2&#x2F;&#x2F; 外网网关地址<br> ONBOOT&#x3D;yes</p>\n<p> 或者配置&#x2F;etc&#x2F;sysconfig&#x2F;network 添加网关地址<br> gateway&#x3D;192.168.142.2  &#x2F;&#x2F; 外网网关地址</p>\n</li>\n<li><p>打开包转发功能：</p>\n<p> echo “1” &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward</p>\n</li>\n<li><p>修改&#x2F;etc&#x2F;sysctl.conf文件， 让包转发功能在系统启动时自动生效：</p>\n<p> net.ipv4.ip_forward &#x3D; 1</p>\n</li>\n<li><p>添加iptables nat路由规则： &#x2F;&#x2F; 清楚其他不需要的iptables规则</p>\n<p> &#x2F;sbin&#x2F;iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE&#x2F;&#x2F; 其中网卡eth0 为外网卡。  </p>\n</li>\n<li><p>保存规则到&#x2F;etc&#x2F;sysconfig&#x2F;iptables 配置文件中</p>\n<p> service iptables save</p>\n</li>\n<li><p>重新启动iptables</p>\n<p> service iptables restart</p>\n</li>\n</ol>\n<p>1、首先确保转发开关打开</p>\n<pre><code>vim /etc/sysctl.conf\n\n    net.ipv4.ip_forward = 1\n\nsysctl -p\n</code></pre>\n<p>2、核对双网卡配置</p>\n<pre><code>cat /etc/sysconfig/network-scripts/ifcfg-eth0\n    DEVICE=eth0  \n    HWADDR=  \n    TYPE=Ethernet  \n    UUID=61e9bdb5-b1ff-4c8f-8c19-938c834de345  \n    ONBOOT=yes  \n    NM_CONTROLLED=yes  \n    BOOTPROTO=static  \n    IPADDR=192.8.8.57  \n    NETMASK=255.255.255.224  \n    GATEWAY=192.8.8.62\n\ncat /etc/sysconfig/network-scripts/ifcfg-eth2\n    DEVICE=eth2\n    HWADDR=\n    TYPE=Ethernet\n    ONBOOT=yes\n    NM_CONTROLLED=no\n    BOOTPROTO=static\n    IPADDR=11.10.10.2\n    NETMASK=255.255.255.0\n</code></pre>\n<p>3、执行 iptables 并保存 </p>\n<pre><code>iptables -t nat -A POSTROUTING -s 11.10.10.0/24 -j SNAT  --to 192.8.8.57  \nservice iptables save\n</code></pre>\n<h2 id=\"局域网自动认证-TODO\"><a href=\"#局域网自动认证-TODO\" class=\"headerlink\" title=\"局域网自动认证 TODO\"></a>局域网自动认证 TODO</h2><p>对于学校或者公司，每次主机重启可能需要进行账号的认证，才可上网，这里实现一个脚本进行自动登录</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一个请求</span><br><span class=\"line\">[10.253.0.237/cgi-bin/rad_user_info?callback=jQuery]</span><br><span class=\"line\">(http://10.253.0.237/cgi-bin/rad_user_info?callback=jQuery)</span><br><span class=\"line\">可以获取，断开网线没有响应。</span><br><span class=\"line\"></span><br><span class=\"line\">jQuery(&#123;&quot;client_ip&quot;:&quot;113.54.145.42&quot;,&quot;ecode&quot;:0,&quot;error&quot;:&quot;not_online_error&quot;,&quot;error_msg&quot;:&quot;&quot;,&quot;online_ip&quot;:&quot;113.54.145.42&quot;,&quot;res&quot;:&quot;not_online_error&quot;,&quot;srun_ver&quot;:&quot;SRunCGIAuthIntfSvr V1.18 B20181212&quot;,&quot;st&quot;:1712478100&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">登录页面的请求。</span><br><span class=\"line\">请求 URL:</span><br><span class=\"line\">http://10.253.0.237/srun_portal_pc?ac_id=1&amp;theme=dx</span><br><span class=\"line\">请求方法:</span><br><span class=\"line\">GET</span><br><span class=\"line\">Status Code:</span><br><span class=\"line\">200 OK</span><br><span class=\"line\">远程地址:</span><br><span class=\"line\">10.253.0.237:80</span><br><span class=\"line\">Referrer Policy:</span><br><span class=\"line\">strict-origin-when-cross-origin</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">请求指令</span><br><span class=\"line\">http://10.253.0.237/cgi-bin/get_challenge?callback=jQuery112405824069609933546_1712476428639&amp;username=202321081216%40dx-uestc&amp;ip=8.8.8.8%2C+113.54.145.42</span><br><span class=\"line\"></span><br><span class=\"line\">Request URL:</span><br><span class=\"line\"></span><br><span class=\"line\">http://10.253.0.237/cgi-bin/get_challenge?callback=jQuery1124028377090795615145_1712478534516&amp;username=202321081216%40dx-uestc&amp;ip=113.54.145.42&amp;_=1712478534518</span><br><span class=\"line\"></span><br><span class=\"line\">Request Method:</span><br><span class=\"line\"></span><br><span class=\"line\">GET</span><br><span class=\"line\"></span><br><span class=\"line\">Status Code:</span><br><span class=\"line\"></span><br><span class=\"line\">502 Bad Gateway</span><br><span class=\"line\"></span><br><span class=\"line\">Remote Address:</span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:7890</span><br><span class=\"line\"></span><br><span class=\"line\">Referrer Policy:</span><br><span class=\"line\"></span><br><span class=\"line\">strict-origin-when-cross-origin</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">如果连接成功，http://10.253.0.237/cgi-bin/rad_user_info 也可也正常获取数据，但是是字符串形式。而不是json</span><br><span class=\"line\"></span><br><span class=\"line\">http://10.253.0.237/cgi-bin/srun_portal?callback=jQuery112405960456199614257_1712479784865&amp;action=login&amp;username=202321081216%40dx-uestc&amp;password=%7BMD5%7Dfb5b782af15febf4ebd53a45952273b8&amp;ac_id=1&amp;ip=8.8.8.8%2C+113.54.145.42&amp;chksum=567d3b8c5bd5ef9c7f14c76b487e7ba67a3d245a&amp;info=%7BSRBX1%7D3OHj0r4O4ZBBY1c%2FRJUyhmdftyTtmQ%2BTHXWm%2BGqNqPp2dL59T78gfgRJXnmUW55cnpEZ3LfJ4NvTAu0bX76wfxQdKZrCon42SRXUdymVpUCnBoBvn1cq7pCYcgK%2BGQ7GA%2BClDLGqvIsHwc5ue8FYqip54p4C2MYgtlHTfv%3D%3D&amp;n=200&amp;type=1&amp;os=Windows+10&amp;name=Windows&amp;double_stack=0&amp;_=1712479784868</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>curl -d “username&#x3D;202321081216&amp;password&#x3D;feng0408” <a href=\"http://10.253.0.237/cgi-bin/srun_portal?callback=jQueryaction=login/\">http://10.253.0.237/cgi-bin/srun_portal?callback=jQueryaction=login/</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;Code&quot;: 0,</span><br><span class=\"line\">    &quot;Message&quot;: &quot;ok&quot;,</span><br><span class=\"line\">    &quot;Data&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;Id&quot;: 3,</span><br><span class=\"line\">            &quot;Title&quot;: &quot;清水河校区办公教学区通知&quot;,</span><br><span class=\"line\">            &quot;Content&quot;: &quot;\\u003cp style=\\&quot;margin-top:auto;margin-bottom: auto;text-align:left;text-indent:36px;line-height: 24px;background:white\\&quot;\\u003e\\u003cspan style=\\&quot;font-size: 18px;font-family:宋体\\&quot;\\u003e清水河校区办公教学区通过墙面预制网络接口连接到有线校园网。连接成功后，打开浏览器输入aaa.uestc.edu.cn弹出认证页面，可选择校园网登录或电信登录。具体使用方法如下：\\u003c/span\\u003e\\u003c/p\\u003e\\u003cp style=\\&quot;margin-top:auto;margin-bottom: auto;text-align:left;line-height:24px;background: white\\&quot;\\u003e\\u003cspan style=\\&quot;font-size:18px;font-family:宋体\\&quot;\\u003e1\\u003c/span\\u003e\\u003cspan style=\\&quot;font-size:18px;font-family: 宋体\\&quot;\\u003e、校园网登录：在右侧登录框输入统一身份认证信息（工资号或学号），点击校园网登录。\\u003c/span\\u003e\\u003c/p\\u003e\\u003cp style=\\&quot;margin-top:auto;margin-bottom: auto;text-align:left;line-height:24px;background: white\\&quot;\\u003e\\u003cspan style=\\&quot;font-size:18px;font-family:宋体\\&quot;\\u003e2\\u003c/span\\u003e\\u003cspan style=\\&quot;font-size:18px;font-family: 宋体\\&quot;\\u003e、电信登录：先点击右侧自服务按钮，进行电信账号绑定；绑定完成重新打开aaa.uestc.edu.cn，输入学校统一身份认证信息，点击电信登录。电信账号绑定流程详见《清水河有线校园网使用手册》。\\u003c/span\\u003e\\u003c/p\\u003e\\u003cp style=\\&quot;margin-top:auto;margin-bottom: auto;text-align:left;line-height:24px;background: white\\&quot;\\u003e\\u003cstrong\\u003e\\u003cspan style=\\&quot;font-size:18px;font-family:宋体\\&quot;\\u003e用户服务电话：61831184\\u003c/span\\u003e\\u003c/strong\\u003e\\u003c/p\\u003e\\u003cp\\u003e\\u003cbr/\\u003e\\u003c/p\\u003e&quot;,</span><br><span class=\"line\">            &quot;Created_by&quot;: &quot;srun&quot;,</span><br><span class=\"line\">            &quot;Created_at&quot;: 1622792930,</span><br><span class=\"line\">            &quot;Updated_at&quot;: 1622792930</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;Id&quot;: 2,</span><br><span class=\"line\">            &quot;Title&quot;: &quot;清水河行政教学区有线网络割接通知&quot;,</span><br><span class=\"line\">            &quot;Content&quot;: &quot;\\u003cp style=\\&quot;margin-top:5px;margin-right:0;margin-bottom:5px;margin-left: 0;text-indent:28px\\&quot;\\u003e\\u003cspan style=\\&quot;font-size: 18px;\\&quot;\\u003e\\u003c/span\\u003e\\u003c/p\\u003e\\u003cp style=\\&quot;line-height: 1.5em;\\&quot;\\u003e清水河校区有线网络设备已运行10年以上，故障频发，不支持IPv6，802.1X认证系统对于终端兼容性较差。为解决以上问题，信息中心协调中国电信高新西区分公司对清水河校区有线网进行改造。改造后网络使用web认证，支持IPv6协议，用户可选择校园网登录或电信登录。具体使用方法如下：\\u003c/p\\u003e\\u003cp style=\\&quot;line-height: 1.5em;\\&quot;\\u003e1、校园网登录：在右侧登录框输入统一身份认证信息，点击校园网登录。\\u003c/p\\u003e\\u003cp style=\\&quot;line-height: 1.5em;\\&quot;\\u003e2、电信登录：先点击右侧自服务按钮，进行电信账号绑定；绑定完成重新打开aaa.uestc.edu.cn，输入学校统一身份认证信息，点击电信登录。电信账号绑定流程详见《清水河有线校园网使用手册》。\\u003c/p\\u003e\\u003cp style=\\&quot;line-height: 1.5em;\\&quot;\\u003e我们对给您带来的不便表示歉意！如有任何疑问，请联系信息中心61831184。\\u003c/p\\u003e\\u003cp style=\\&quot;margin-top:5px;margin-right:0;margin-bottom:5px;margin-left: 0;text-indent:28px;font-variant-ligatures: normal;font-variant-caps: normal;orphans: 2;text-align:start;widows: 2;-webkit-text-stroke-width: 0px;word-spacing: 0px\\&quot;\\u003e\\u003cbr/\\u003e\\u003c/p\\u003e\\u003cp\\u003e\\u003cbr/\\u003e\\u003c/p\\u003e&quot;,</span><br><span class=\"line\">            &quot;Created_by&quot;: &quot;yqli&quot;,</span><br><span class=\"line\">            &quot;Created_at&quot;: 1544507894,</span><br><span class=\"line\">            &quot;Updated_at&quot;: 1622792876</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"程序自启动\"><a href=\"#程序自启动\" class=\"headerlink\" title=\"程序自启动\"></a>程序自启动</h1><p>在 Ubuntu 中，你可以使用 Systemd 来配置在系统启动时自动后台执行可执行程序。</p>\n<p>下面是一些基本的步骤：</p>\n<ol>\n<li><p>创建一个用于 Systemd 配置的服务文件。在终端中使用以下命令创建一个新的服务文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo nano /etc/systemd/system/test.service</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在打开的编辑器中，输入以下内容：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=Test Service</span><br><span class=\"line\">After=network.target</span><br><span class=\"line\"></span><br><span class=\"line\">[Service]</span><br><span class=\"line\">ExecStart=/path/to/test</span><br><span class=\"line\">Type=simple</span><br><span class=\"line\">Restart=always</span><br><span class=\"line\">User=your_username</span><br><span class=\"line\"></span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>\n\n<p>请确保将 <code>/path/to/test</code> 替换为你的可执行程序的实际路径，并将 <code>your_username</code> 替换为你的用户名。</p>\n</li>\n<li><p>保存并关闭文件。使用 <code>Ctrl + X</code>，然后输入 <code>Y</code> 保存文件并退出编辑器。</p>\n</li>\n<li><p>重新加载 Systemd 配置，使其识别新的服务文件。在终端中使用以下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启用服务，使其在系统启动时自动运行。在终端中使用以下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl enable test.service</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>最后，启动服务。在终端中使用以下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl start test.service</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>现在，你的可执行程序 <code>test</code> 将在系统启动时自动以后台进程的形式运行。</p>\n<p>你可以使用以下命令来检查服务的状态：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl status test.service</span><br></pre></td></tr></table></figure>\n\n<p>如果需要停止服务，可以使用以下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl stop test.service</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"后台运行程序\"><a href=\"#后台运行程序\" class=\"headerlink\" title=\"后台运行程序\"></a>后台运行程序</h1><ol>\n<li>在执行命令时，可以使用 <code>&amp;</code> 符号将其放在命令的末尾。这样会将命令放入后台运行，并且不会阻塞当前终端。例如：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./test &amp; </span><br></pre></td></tr></table></figure></li>\n<li>如果你希望程序在后台运行的同时不产生任何输出，你可以将其输出重定向到 <code>/dev/null</code>，这样输出将被丢弃。例如：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup ./clash-linux-amd64 &gt; /dev/null 2&gt;&amp;1 &amp;</span><br><span class=\"line\">nohup ./aaa &gt; output.log 2&gt;&amp;1 &amp;</span><br><span class=\"line\">disown</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n这样，可执行程序 <code>./test</code> 将在后台运行，并与当前终端解耦。它不会阻塞当前终端，并且输出将被重定向到 <code>/dev/null</code>，不会显示在终端上。</li>\n</ol>\n<p>请注意，使用这种方法运行程序后，你将无法看到程序的输出。如果你需要查看程序的输出或进行其他交互操作，可能需要使用其他工具或技术来实现。</p>\n<h1 id=\"离线安装包的使用\"><a href=\"#离线安装包的使用\" class=\"headerlink\" title=\"离线安装包的使用\"></a>离线安装包的使用</h1><h2 id=\"Centos\"><a href=\"#Centos\" class=\"headerlink\" title=\"Centos\"></a>Centos</h2><ol>\n<li>打包 <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install [package]--downloadonly --downloaddir=<span class=\"built_in\">dir</span>/</span><br></pre></td></tr></table></figure></li>\n<li>使用 <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum -y localinstall <span class=\"built_in\">dir</span>/*</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"查询指定域名的-IP\"><a href=\"#查询指定域名的-IP\" class=\"headerlink\" title=\"查询指定域名的 IP\"></a>查询指定域名的 IP</h1><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nsloopup</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"日志查看\"><a href=\"#日志查看\" class=\"headerlink\" title=\"日志查看\"></a>日志查看</h1><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/var/log/syslog</span><br><span class=\"line\">/var/log/kern.log</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"查看显存运行情况\"><a href=\"#查看显存运行情况\" class=\"headerlink\" title=\"查看显存运行情况\"></a>查看显存运行情况</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">watch -n 0.1 nvidia-smi</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<h1 id=\"Linux-安装盘安装\"><a href=\"#Linux-安装盘安装\" class=\"headerlink\" title=\"Linux 安装盘安装\"></a>Linux 安装盘安装</h1><h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><ol>\n<li>准备一个空 U 盘，作为后续安装盘。</li>\n<li>下载 rufus  U 盘 格式化软件，分区类型：选择GPT，目标系统类型UEFI（非SM） <a href=\"https://rufus.ie/zh/#google_vignette\">下载地址</a> </li>\n<li>下载 Ubuntu iso 镜像 <a href=\"https://ubuntu.com/download/server/thank-you?version=22.04.4&architecture=amd64\">Ubuntu22.04.4</a></li>\n<li>使用 rufus 对安装盘进行制作，配置如下<br> ![[Pasted image 20240406101639.png]]<br> 磁盘分区方式：MBR和GPT，MBR的主分区只能划分最多4个，GPT的分区数量没有限制，这里选择 GPT。</li>\n</ol>\n<h2 id=\"开始安装\"><a href=\"#开始安装\" class=\"headerlink\" title=\"开始安装\"></a>开始安装</h2><ol>\n<li>开启服务器主机，进入系统 BIOS（Del键、F2键、F10键或者ESC键，依据主板型号，或者在开机界面一般会显示具体按键）</li>\n<li>选择 UEFI  U 盘作为启动盘。保存并重启系统。<ul>\n<li>Secure Boot设置：Security —&gt; Secure Boot —&gt; Disabled</li>\n<li>Boot Option设置：Boot —&gt; Boot Option #1 —&gt; 将 UEFI USB Key: **** 选择至第一位</li>\n<li>保存BIOS设置：Exit—&gt;Save Changes and Reset</li>\n</ul>\n</li>\n<li>大部分默认设置。<ol>\n<li>网络 IP 使用默认？</li>\n<li>安装源：<a href=\"http://mirrors.aliyun.com/ubuntu\">http://mirrors.aliyun.com/ubuntu</a></li>\n<li>磁盘分区：<a href=\"https://blog.csdn.net/2301_79810514/article/details/137122218\">参考</a><ol>\n<li>SWAP 分区：Linux 的虚拟内存，建议将交换分区的大小设置为物理内存的1.5倍到2倍。</li>\n<li>&#x2F;boot 分区：引导分区，建议 300-500M ；<br> 【关于是否要分&#x2F;boot分区的问题：如果你的主板bios里设置的是UEFI+GPT分区表模式，那么给ubuntu分区的时候不用设置这个&#x2F;boot分区，设置下面第3步的efi系统分区即可； 但如果你用的是legacy+MBR分区表那就正常设置&#x2F;boot分区，这个很重要，特别是装双系统或多系统时，避免破坏到其他系统的引导文件】</li>\n<li>EFI引导分区，类型为逻辑分区，，默认ext4。 推荐分 512 ~ 1024M，注意：放在空间起始位置。</li>\n<li>&#x2F;var 分区（可选）：log 的日志文件存放，如果不分则默认在 &#x2F; 下。如果 linux 用于服务器和经常做日志分析，建议划分。最少 300-500M，一般 2-3 G。</li>\n<li>根分区（&#x2F;）：存储操作系统文件、应用程序和用户数据。建议较大，15G+；</li>\n<li>home 分区：存放个人的文件，建议最大；（&#x2F; 和 &#x2F;home 之间类似 C 和 D 盘的关系）</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"Linux-系统配置\"><a href=\"#Linux-系统配置\" class=\"headerlink\" title=\"Linux 系统配置\"></a>Linux 系统配置</h1><h4 id=\"root-账户设置密码\"><a href=\"#root-账户设置密码\" class=\"headerlink\" title=\"root 账户设置密码\"></a>root 账户设置密码</h4><p>当前普通用户界面下输入命令，然后按提示两次输入密码即可。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo passwd root</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"新增用户并且增加用户权限\"><a href=\"#新增用户并且增加用户权限\" class=\"headerlink\" title=\"新增用户并且增加用户权限\"></a>新增用户并且增加用户权限</h4><ol>\n<li><p><code>useradd</code>：用于创建新用户账号。</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo useradd username</span><br></pre></td></tr></table></figure>\n<p> 其中，<code>username</code> 是要创建的新用户的用户名。该命令会创建一个新的用户账号，并分配一个默认的用户ID和组ID。</p>\n</li>\n<li><p><code>passwd</code>：用于设置用户的密码。</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo passwd username</span><br></pre></td></tr></table></figure>\n<p> 其中，<code>username</code> 是要设置密码的用户的用户名。该命令会提示你输入新的密码，并要求确认密码。</p>\n</li>\n<li><p><code>usermod</code>：用于修改用户的属性，包括用户权限。</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo usermod -aG groupname username</span><br></pre></td></tr></table></figure>\n<p> 其中，<code>groupname</code> 是要将用户添加到的用户组的组名，<code>username</code> 是要修改权限的用户的用户名。该命令会将指定用户添加到指定用户组中，从而增加用户的权限。<br> 注意：在执行 <code>usermod</code> 命令时，使用 <code>-aG</code> 选项是为了将用户添加到用户组而不覆盖用户原有的用户组。</p>\n</li>\n<li><p>重新登录：在完成上述步骤后，建议重新登录用户账号，以使用户权限的更改生效。</p>\n</li>\n</ol>\n<h4 id=\"源配置\"><a href=\"#源配置\" class=\"headerlink\" title=\"源配置\"></a>源配置</h4><h6 id=\"1-首先备份官方自带的软件源\"><a href=\"#1-首先备份官方自带的软件源\" class=\"headerlink\" title=\"1. 首先备份官方自带的软件源\"></a>1. 首先备份官方自带的软件源</h6><p><code>cp /etc/apt/sources.list /etc/apt/sources.list.bak</code></p>\n<h6 id=\"2-然后编辑修改为清华源\"><a href=\"#2-然后编辑修改为清华源\" class=\"headerlink\" title=\"2.然后编辑修改为清华源\"></a>2.然后编辑修改为清华源</h6><p><code>sudo gedit sources.list</code></p>\n<h4 id=\"ssh配置\"><a href=\"#ssh配置\" class=\"headerlink\" title=\"ssh配置\"></a>ssh配置</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看是否安装了SSH服务</span></span><br><span class=\"line\">ps -ef | grep ssh </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 没有安装的话，执行下面语句</span></span><br><span class=\"line\">sudo apt-get update                   <span class=\"comment\">#先更新下资源列表</span></span><br><span class=\"line\">sudo apt-get install openssh-server   <span class=\"comment\">#安装openssh-server</span></span><br><span class=\"line\">sudo ps -ef | grep ssh                <span class=\"comment\">#查看是否安装成功</span></span><br><span class=\"line\">sudo systemctl restart sshd           <span class=\"comment\">#重新启动SSH服务 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 进入ssh配置文件</span></span><br><span class=\"line\">sudo vim  /etc/ssh/sshd_config    </span><br></pre></td></tr></table></figure>\n\n<p><code>PermitRootLogin</code> 是一个用于配置 SSH 服务器的选项。这个选项决定了是否允许 root 用户通过 SSH 直接登录到服务器。通常情况下，为了提高安全性，最好禁止 root 用户通过 SSH 直接登录，而是使用一个普通用户登录后再通过 su 或者 sudo 切换到 root 用户来执行需要特权的操作。这样可以降低系统受到攻击的风险。<br>常见的 PermitRootLogin 选项取值包括：</p>\n<ul>\n<li><code>yes</code>：允许 root 用户通过 SSH 直接登录。</li>\n<li><code>no</code>：禁止 root 用户通过 SSH 直接登录。</li>\n<li><code>without-password</code>：允许 root 用户通过 SSH 密钥登录，但不允许使用密码登录。</li>\n</ul>\n<p>按i进入编辑模式，找到<code>#PermitRootLogin prohibit-password</code>，默认是注释掉的。<br>把 <code>PermitRootLogin without-password</code> 改为 <code>PermitRootLogin yes</code>，注意<code>PermitRootLogin without-password</code>被注释掉了，要去掉注释。如果没有找到<code>PermitRootLogin without-password</code>，直接文件末尾添加<code>PermitRootLogin yes</code>即可。然后按esc，输入:wq保存并退出。<br>重启sshd服务</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl restart sshd</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"驱动更新\"><a href=\"#驱动更新\" class=\"headerlink\" title=\"驱动更新\"></a>驱动更新</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. 更新软件包列表：</span></span><br><span class=\"line\">sudo apt update</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2. 升级已安装的软件包：</span></span><br><span class=\"line\">sudo apt upgrade -y</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3. 更新驱动程序：</span></span><br><span class=\"line\">sudo apt install ubuntu-drivers-common</span><br><span class=\"line\">sudo ubuntu-drivers autoinstall</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"换源\"><a href=\"#换源\" class=\"headerlink\" title=\"换源\"></a>换源</h4><figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse</span><br><span class=\"line\"> </span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class=\"line\"> </span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse</span><br><span class=\"line\"> </span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse </span><br></pre></td></tr></table></figure>\n<h4 id=\"网络配置\"><a href=\"#网络配置\" class=\"headerlink\" title=\"网络配置\"></a>网络配置</h4><ol>\n<li><p>打开终端，使用root权限登录或者使用sudo命令获取root权限。</p>\n</li>\n<li><p>使用文本编辑器打开网络配置文件<code>/etc/netplan/00-installer-config.yaml</code>。</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo vim /etc/netplan/00-installer-config.yaml</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在文件中，找到<code>network</code>部分，然后根据你的网络设置进行编辑。以下是一个示例配置：</p>\n <figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">network:</span></span><br><span class=\"line\">  <span class=\"attr\">ethernets:</span></span><br><span class=\"line\">    <span class=\"attr\">enp0s3:</span></span><br><span class=\"line\">      <span class=\"attr\">addresses:</span> [<span class=\"number\">192.168</span><span class=\"number\">.1</span><span class=\"number\">.10</span><span class=\"string\">/24</span>]</span><br><span class=\"line\">      <span class=\"attr\">gateway4:</span> <span class=\"number\">192.168</span><span class=\"number\">.1</span><span class=\"number\">.1</span></span><br><span class=\"line\">      <span class=\"attr\">nameservers:</span></span><br><span class=\"line\">        <span class=\"attr\">addresses:</span> [<span class=\"number\">8.8</span><span class=\"number\">.8</span><span class=\"number\">.8</span>, <span class=\"number\">8.8</span><span class=\"number\">.4</span><span class=\"number\">.4</span>]</span><br><span class=\"line\">  <span class=\"attr\">version:</span> <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>enp0s3</code>是网络接口的名称，你需要根据你的实际网络接口名称进行替换。</li>\n<li><code>addresses</code>是你的服务器的静态IP地址和子网掩码。</li>\n<li><code>gateway4</code>是你的网关IP地址。</li>\n<li><code>nameservers</code>是DNS服务器的IP地址。</li>\n</ul>\n</li>\n<li><p>保存文件并关闭文本编辑器。</p>\n</li>\n<li><p>在终端中执行以下命令以应用配置更改：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo netplan apply</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重新启动网络服务以使更改生效：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl restart networking</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>现在，你的 Ubuntu Server 已经配置了静态网络。你可以通过 ping 命令或打开浏览器测试网络连接。</p>\n<h4 id=\"禁止自动休眠\"><a href=\"#禁止自动休眠\" class=\"headerlink\" title=\"禁止自动休眠\"></a>禁止自动休眠</h4><ol>\n<li>执行如下命令查看休眠模式的情况，如果 sleep 状态是loaded，也就是处于自动休眠开启状态</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl status sleep.target</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>接下来，执行如下命令关闭系统的自动休眠开关：</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 这些命令做了以下几点：</span></span><br><span class=\"line\"><span class=\"comment\"># 通过mask命令，你禁用了所有休眠相关的systemd目标。</span></span><br><span class=\"line\"><span class=\"comment\"># 通过set-default命令，你设置默认的运行级别为多用户文本模式（即命令行界面）</span></span><br><span class=\"line\">sudo systemctl mask sleep.target suspend.target hibernate.target hybrid-sleep.target</span><br><span class=\"line\">sudo systemctl set-default multi-user.target</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">####################################################</span></span><br><span class=\"line\"><span class=\"comment\"># 如果你想要恢复自动休眠功能，可以使用以下命令：</span></span><br><span class=\"line\">sudo systemctl unmask sleep.target suspend.target hibernate.target hybrid-sleep.target</span><br><span class=\"line\">sudo systemctl set-default graphical.target</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><p>再次执行查看命令，可以看到 sleep 的状态已经变成了 masked，也就是关闭了。</p>\n</li>\n<li><p>编辑<code>/etc/systemd/logind.conf</code>文件：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo vim /etc/systemd/logind.conf</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在文件中找到以下行：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#IdleAction=</span></span><br><span class=\"line\"><span class=\"comment\">#IdleActionSec=</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>将这两行的注释符号<code>#</code>移除，并设置<code>IdleAction</code>为<code>ignore</code>，<code>IdleActionSec</code>为<code>0</code>，如下所示：</p>\n <figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IdleAction=ignore</span><br><span class=\"line\">IdleActionSec=0</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>保存文件并关闭编辑器。</p>\n</li>\n<li><p>使用以下命令重新加载systemd配置：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl restart systemd-logind.service</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>完成！现在 Ubuntu Server 将不会因为无操作而自动休眠。</p>\n</li>\n</ol>\n<h4 id=\"设置关盖-合盖不挂起-不睡眠\"><a href=\"#设置关盖-合盖不挂起-不睡眠\" class=\"headerlink\" title=\"设置关盖&#x2F;合盖不挂起&#x2F;不睡眠\"></a>设置关盖&#x2F;合盖不挂起&#x2F;不睡眠</h4><ol>\n<li>通过更改登录配置文件<code>logind.conf</code>设置</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo vim /etc/systemd/logind.conf</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>里面影响关盖操作的变量包括<code>HandleLidSwitch</code>、<code>HandleLidSwitchExternalPower</code>和<code>HandleLidSwitchDocked</code>。<br> <code>logind.conf</code> 里面各项的含义如下：</li>\n</ol>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">1. NAutoVTs</span>=<span class=\"number\">6</span>：指定系统启动时自动分配的虚拟终端数量。</span><br><span class=\"line\"><span class=\"attr\">2. ReserveVT</span>=<span class=\"number\">6</span>：指定系统保留的虚拟终端数量。</span><br><span class=\"line\"><span class=\"attr\">3. KillUserProcesses</span>=<span class=\"literal\">no</span>：指定当用户注销时是否终止用户进程。</span><br><span class=\"line\"><span class=\"attr\">4. KillOnlyUsers</span>=：指定需要终止进程的用户列表。</span><br><span class=\"line\"><span class=\"attr\">5. KillExcludeUsers</span>=root：指定不需要终止进程的用户列表。</span><br><span class=\"line\"><span class=\"attr\">6. InhibitDelayMaxSec</span>=<span class=\"number\">5</span>：指定阻止操作的最大延迟时间（以秒为单位）。</span><br><span class=\"line\"><span class=\"attr\">7. HandlePowerKey</span>=power<span class=\"literal\">off</span>：指定按下电源键时的操作，此处设置为关机。</span><br><span class=\"line\"><span class=\"attr\">8. HandleSuspendKey</span>=suspend：指定按下休眠键时的操作，此处设置为休眠。</span><br><span class=\"line\"><span class=\"attr\">9. HandleHibernateKey</span>=hibernate：指定按下休眠键时的操作，此处设置为休眠。</span><br><span class=\"line\"><span class=\"attr\">10. HandleLidSwitch</span>=suspend：指定关闭笔记本电脑盖子时的操作，此处设置为休眠。</span><br><span class=\"line\"><span class=\"attr\">11. HandleLidSwitchExternalPower</span>=suspend：指定在外部电源连接时关闭笔记本电脑盖子的操作，此处设置为休眠。</span><br><span class=\"line\"><span class=\"attr\">12. HandleLidSwitchDocked</span>=ignore：指定连接到底座时关闭笔记本电脑盖子的操作，此处设置为忽略。</span><br><span class=\"line\"><span class=\"attr\">13. PowerKeyIgnoreInhibited</span>=<span class=\"literal\">no</span>：指定是否忽略阻止操作的电源键按下。</span><br><span class=\"line\"><span class=\"attr\">14. SuspendKeyIgnoreInhibited</span>=<span class=\"literal\">no</span>：指定是否忽略阻止操作的休眠键按下。</span><br><span class=\"line\"><span class=\"attr\">15. HibernateKeyIgnoreInhibited</span>=<span class=\"literal\">no</span>：指定是否忽略阻止操作的休眠键按下。</span><br><span class=\"line\"><span class=\"attr\">16. LidSwitchIgnoreInhibited</span>=<span class=\"literal\">yes</span>：指定是否忽略阻止操作的盖子关闭。</span><br><span class=\"line\"><span class=\"attr\">17. HoldoffTimeoutSec</span>=<span class=\"number\">30</span>s：指定在执行操作前等待的时间（以秒为单位）。</span><br><span class=\"line\"><span class=\"attr\">18. IdleAction</span>=ignore：指定系统处于空闲状态时的操作，此处设置为忽略。</span><br><span class=\"line\"><span class=\"attr\">19. IdleActionSec</span>=<span class=\"number\">30</span>min：指定系统处于空闲状态多长时间后执行操作（以分钟为单位）。</span><br><span class=\"line\"><span class=\"attr\">20. RuntimeDirectorySize</span>=<span class=\"number\">10</span>%：指定运行时目录的最大大小，此处设置为总磁盘空间的<span class=\"number\">10</span>%。</span><br><span class=\"line\"><span class=\"attr\">21. RemoveIPC</span>=<span class=\"literal\">yes</span>：指定是否在用户注销时删除IPC对象。</span><br><span class=\"line\"><span class=\"attr\">22. InhibitorsMax</span>=<span class=\"number\">8192</span>：指定系统允许的阻止操作的最大数量。</span><br></pre></td></tr></table></figure>\n\n<p><code>HandleLidSwitch</code>: 定义笔记本电脑关闭盖子时的行为。可以设置的值有：</p>\n<ul>\n<li><code>ignore</code>：忽略关闭盖子的事件。</li>\n<li><code>poweroff</code>：关闭电源。</li>\n<li><code>reboot</code>：重新启动。</li>\n<li><code>halt</code>：停止系统。</li>\n<li><code>kexec</code>：通过 kexec 进行快速启动。</li>\n<li><code>suspend</code>：挂起系统。</li>\n<li><code>hibernate</code>：休眠系统。</li>\n</ul>\n<p><code>HandleLidSwitchExternalPower</code>: 定义当笔记本电脑连接外部电源时关闭盖子的行为。可以设置的值与 <code>HandleLidSwitch</code> 相同。</p>\n<p><code>HandleLidSwitchDocked</code>: 定义当笔记本电脑连接到底座时关闭盖子的行为。可以设置的值与 <code>HandleLidSwitch</code> 相同。</p>\n<p><code>HandlePowerKey</code>: 定义电源按钮的行为。可以设置的值与 <code>HandleLidSwitch</code> 相同。</p>\n<p><code>IdleAction</code>: 定义系统空闲时的行为。可以设置的值有：</p>\n<ul>\n<li><code>ignore</code>：忽略空闲事件。</li>\n<li><code>poweroff</code>：关闭电源。</li>\n<li><code>reboot</code>：重新启动。</li>\n<li><code>halt</code>：停止系统。</li>\n<li><code>kexec</code>：通过 kexec 进行快速启动。</li>\n<li><code>suspend</code>：挂起系统。</li>\n<li><code>hibernate</code>：休眠系统。</li>\n</ul>\n<p><code>IdleActionSec</code>: 定义系统空闲多少秒后触发 <code>IdleAction</code>。</p>\n<p><code>UserTasksMax</code>: 定义每个用户可以同时运行的任务数的最大值。</p>\n<p><code>KillUserProcesses</code>: 定义当用户注销时是否终止用户的进程。可以设置的值有：</p>\n<ul>\n<li><code>yes</code>：终止用户的进程。</li>\n<li><code>no</code>：不终止用户的进程。</li>\n</ul>\n<h4 id=\"定时自动关闭显示器\"><a href=\"#定时自动关闭显示器\" class=\"headerlink\" title=\"定时自动关闭显示器\"></a>定时自动关闭显示器</h4><ol>\n<li>想要定时关闭显示器，可以编辑<code>/etc/default/grub</code>这个文件</li>\n<li>通过修改GRUB_CMDLINE_LINUX_DEFAULT变量，你可以添加或修改传递给内核的参数，以便在启动时对系统进行自定义配置。</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ipv6.disable=1：禁用 IPv6 协议。</span></span><br><span class=\"line\"><span class=\"comment\"># consoleblank=300：设置控制台空闲时间为 300 秒后自动关闭。</span></span><br><span class=\"line\">GRUB_CMDLINE_LINUX_DEFAULT=<span class=\"string\">&quot;ipv6.disable=1 consoleblank=300&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>修改完了运行<code>sudo update-grub</code>，然后重启，即可设置系统5分钟没有活动自动关闭显示器。</li>\n</ol>\n<h4 id=\"网络自动认证\"><a href=\"#网络自动认证\" class=\"headerlink\" title=\"网络自动认证\"></a>网络自动认证</h4><p><a href=\"https://github.com/kewuaa/uestc_wifi_helper/releases/download/v0.4.1/uestc_wifi_helper-x86_64-linux\">https://github.com/kewuaa/uestc_wifi_helper/releases/download/v0.4.1/uestc_wifi_helper-x86_64-linux</a></p>\n<ol>\n<li>将软件放在 &#x2F;root&#x2F;path&#x2F;uestc-network-login&#x2F;uestc_wifi_helper_cli-x86_64-linux</li>\n<li>将脚本放在 &#x2F;root&#x2F;boot&#x2F;auto-login-uestc-network.sh</li>\n<li>部署服务在 &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;auto-network-login.service</li>\n<li>启动服务。</li>\n</ol>\n<h4 id=\"外接-U-盘挂载\"><a href=\"#外接-U-盘挂载\" class=\"headerlink\" title=\"外接 U 盘挂载\"></a>外接 U 盘挂载</h4><ol>\n<li><p>确认 U 盘被正确地检测到：在终端中输入以下命令来查看系统识别的存储设备列表：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsblk</span><br></pre></td></tr></table></figure>\n<p>这将显示所有已连接的存储设备，包括 U 盘。通常，U 盘的设备名称类似于 <code>/dev/sdb</code> 或 <code>/dev/sdc</code>。</p>\n</li>\n<li><p>挂载 U 盘：在 Linux 中，需要将 U 盘挂载到文件系统才能访问其中的文件。首先，创建一个用于挂载的目录。在终端中输入以下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mkdir /mnt/usb</span><br></pre></td></tr></table></figure>\n<p>这将创建一个名为 <code>/mnt/usb</code> 的目录作为挂载点。</p>\n</li>\n<li><p>挂载 U 盘：使用 <code>mount</code> 命令将 U 盘挂载到刚刚创建的目录。假设 U 盘的设备名称为 <code>/dev/sdb1</code>，在终端中输入以下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mount /dev/sdb1 /mnt/usb</span><br></pre></td></tr></table></figure>\n<p>如果 U 盘有多个分区，将 <code>/dev/sdb1</code> 替换为相应的分区设备名称。</p>\n</li>\n<li><p>访问 U 盘中的文件：现在，可以通过访问挂载点 <code>/mnt/usb</code> 来查看和操作 U 盘中的文件。你可以使用文件管理器（如 Nautilus、Dolphin 或 Thunar）浏览 U 盘，也可以在终端中使用命令行来执行相关操作。</p>\n</li>\n<li><p>卸载 U 盘：在完成对 U 盘的操作后，应该将其卸载以安全地移除。在终端中输入以下命令来卸载 U 盘：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo umount /mnt/usb</span><br></pre></td></tr></table></figure>\n<p>确保在操作完成后再拔出 U 盘。</p>\n</li>\n</ol>\n<p>请注意，U 盘的设备名称和挂载点可能会根据系统和具体情况有所不同。因此，在使用上述命令时，请根据你的实际情况进行相应的调整。</p>\n<h4 id=\"域名配置\"><a href=\"#域名配置\" class=\"headerlink\" title=\"域名配置\"></a>域名配置</h4><p>在 Ubuntu 22.04 TLS 上进行动态 DNS 部署的步骤：<br>0. 注册 DNS 服务商账号<br>    <a href=\"https://cp.zoneedit.com/signup/\">ZoneEdit - Control Panel: Sign Up</a></p>\n<ol>\n<li><p>安装 <code>ddclient</code>：<br>打开终端并执行以下命令来安装 <code>ddclient</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br><span class=\"line\">sudo apt install ddclient</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>配置 <code>ddclient</code>：<br><code>ddclient</code> 的配置文件位于 <code>/etc/ddclient.conf</code>。使用你喜欢的文本编辑器（如 nano）打开该文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo nano /etc/ddclient.conf</span><br></pre></td></tr></table></figure>\n\n<p>在配置文件中，你需要提供动态 DNS 服务提供商的相关信息，例如域名、用户名、密码等。具体配置取决于你选择的动态 DNS 服务提供商。以下是一个示例配置文件的部分内容：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 使用动态 DNS 服务提供商的示例配置</span><br><span class=\"line\">protocol=dyndns2</span><br><span class=\"line\">server=members.dyndns.org</span><br><span class=\"line\">login=username</span><br><span class=\"line\">password=&#x27;password&#x27;</span><br><span class=\"line\">your.domain.com</span><br><span class=\"line\"></span><br><span class=\"line\"># DIY</span><br><span class=\"line\">protocol=zoneedit1</span><br><span class=\"line\">use=if, if=eno1</span><br><span class=\"line\">server=dns1.zoneedit.com </span><br><span class=\"line\">ssl=yes </span><br><span class=\"line\">login=dinream </span><br><span class=\"line\">password=&#x27;dreamin8888&#x27; </span><br><span class=\"line\">lm.lab302.com</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>替换示例配置中的 <code>protocol</code>、<code>server</code>、<code>login</code>、<code>password</code> 和 <code>your.domain.com</code> 为你的实际设置。请参考你选择的动态 DNS 服务提供商的文档，获取正确的配置参数。</p>\n</li>\n<li><p>保存并关闭配置文件。</p>\n</li>\n<li><p>启用并启动 <code>ddclient</code> 服务：<br>执行以下命令启用 <code>ddclient</code> 服务：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl enable ddclient</span><br></pre></td></tr></table></figure>\n\n<p>然后，执行以下命令启动服务：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl start ddclient</span><br></pre></td></tr></table></figure>\n\n<p><code>ddclient</code> 将会读取配置文件并在启动时或 IP 地址变化时更新动态 DNS 记录。</p>\n</li>\n<li><p>验证配置：<br>执行以下命令来检查 <code>ddclient</code> 服务的状态：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl status ddclient</span><br></pre></td></tr></table></figure>\n\n<p>如果状态显示为 “active”，则表示 <code>ddclient</code> 服务已成功启动并正在运行。</p>\n</li>\n<li><p>查看详细信息</p>\n <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ddclient -foreground  -verbose -force</span><br><span class=\"line\"></span><br><span class=\"line\">ddclient -daemon=0 -debug -verbose -noquiet</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li><p>注意域名的更新在域名服务器之间可能需要一个小时左右，需要等待。<br><a href=\"https://blog.cre0809.com/archives/231/\">https://blog.cre0809.com/archives/231/</a><br>内网穿透：<br><a href=\"https://juejin.cn/post/7346072037674418187\">https://juejin.cn/post/7346072037674418187</a><br>多种方式解决：<br><a href=\"https://www.oomake.com/question/9612393\">如何映射我的私人IP动态变化到我的VPS IP？ - adsl - 码客 (oomake.com)</a></p>\n</li>\n</ol>\n<h1 id=\"网络高级配置\"><a href=\"#网络高级配置\" class=\"headerlink\" title=\"网络高级配置\"></a>网络高级配置</h1><h2 id=\"双网卡跨网卡-iptables-完成数据转发\"><a href=\"#双网卡跨网卡-iptables-完成数据转发\" class=\"headerlink\" title=\"双网卡跨网卡 iptables 完成数据转发\"></a>双网卡跨网卡 iptables 完成数据转发</h2><p>目标：将主机的一个 ip 的发送包，转换为主机另一个 ip 的发送包。</p>\n<ol>\n<li><p>配置网卡IP地址， 配置静态IP地址， <br> &#x2F;etc&#x2F;sysconfig&#x2F;network-stripts&#x2F;ifcfg-eth0 配置网卡一， 外网卡， 可以联网<br> &#x2F;etc&#x2F;sysconfig&#x2F;network-stripts&#x2F;ifcfg-eth1 配置网卡二， 内网卡， 连接内网</p>\n<p> 配置网卡配置文件<br> DEVICE&#x3D;eth1<br> IPADDR&#x3D;192.168.145.122&#x2F;&#x2F; IP地址<br> NETMASK&#x3D;255.255.255.0&#x2F;&#x2F; IP掩码<br> gateway&#x3D;192.168.142.2&#x2F;&#x2F; 外网网关地址<br> ONBOOT&#x3D;yes</p>\n<p> 或者配置&#x2F;etc&#x2F;sysconfig&#x2F;network 添加网关地址<br> gateway&#x3D;192.168.142.2  &#x2F;&#x2F; 外网网关地址</p>\n</li>\n<li><p>打开包转发功能：</p>\n<p> echo “1” &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward</p>\n</li>\n<li><p>修改&#x2F;etc&#x2F;sysctl.conf文件， 让包转发功能在系统启动时自动生效：</p>\n<p> net.ipv4.ip_forward &#x3D; 1</p>\n</li>\n<li><p>添加iptables nat路由规则： &#x2F;&#x2F; 清楚其他不需要的iptables规则</p>\n<p> &#x2F;sbin&#x2F;iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE&#x2F;&#x2F; 其中网卡eth0 为外网卡。  </p>\n</li>\n<li><p>保存规则到&#x2F;etc&#x2F;sysconfig&#x2F;iptables 配置文件中</p>\n<p> service iptables save</p>\n</li>\n<li><p>重新启动iptables</p>\n<p> service iptables restart</p>\n</li>\n</ol>\n<p>1、首先确保转发开关打开</p>\n<pre><code>vim /etc/sysctl.conf\n\n    net.ipv4.ip_forward = 1\n\nsysctl -p\n</code></pre>\n<p>2、核对双网卡配置</p>\n<pre><code>cat /etc/sysconfig/network-scripts/ifcfg-eth0\n    DEVICE=eth0  \n    HWADDR=  \n    TYPE=Ethernet  \n    UUID=61e9bdb5-b1ff-4c8f-8c19-938c834de345  \n    ONBOOT=yes  \n    NM_CONTROLLED=yes  \n    BOOTPROTO=static  \n    IPADDR=192.8.8.57  \n    NETMASK=255.255.255.224  \n    GATEWAY=192.8.8.62\n\ncat /etc/sysconfig/network-scripts/ifcfg-eth2\n    DEVICE=eth2\n    HWADDR=\n    TYPE=Ethernet\n    ONBOOT=yes\n    NM_CONTROLLED=no\n    BOOTPROTO=static\n    IPADDR=11.10.10.2\n    NETMASK=255.255.255.0\n</code></pre>\n<p>3、执行 iptables 并保存 </p>\n<pre><code>iptables -t nat -A POSTROUTING -s 11.10.10.0/24 -j SNAT  --to 192.8.8.57  \nservice iptables save\n</code></pre>\n<h2 id=\"局域网自动认证-TODO\"><a href=\"#局域网自动认证-TODO\" class=\"headerlink\" title=\"局域网自动认证 TODO\"></a>局域网自动认证 TODO</h2><p>对于学校或者公司，每次主机重启可能需要进行账号的认证，才可上网，这里实现一个脚本进行自动登录</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一个请求</span><br><span class=\"line\">[10.253.0.237/cgi-bin/rad_user_info?callback=jQuery]</span><br><span class=\"line\">(http://10.253.0.237/cgi-bin/rad_user_info?callback=jQuery)</span><br><span class=\"line\">可以获取，断开网线没有响应。</span><br><span class=\"line\"></span><br><span class=\"line\">jQuery(&#123;&quot;client_ip&quot;:&quot;113.54.145.42&quot;,&quot;ecode&quot;:0,&quot;error&quot;:&quot;not_online_error&quot;,&quot;error_msg&quot;:&quot;&quot;,&quot;online_ip&quot;:&quot;113.54.145.42&quot;,&quot;res&quot;:&quot;not_online_error&quot;,&quot;srun_ver&quot;:&quot;SRunCGIAuthIntfSvr V1.18 B20181212&quot;,&quot;st&quot;:1712478100&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">登录页面的请求。</span><br><span class=\"line\">请求 URL:</span><br><span class=\"line\">http://10.253.0.237/srun_portal_pc?ac_id=1&amp;theme=dx</span><br><span class=\"line\">请求方法:</span><br><span class=\"line\">GET</span><br><span class=\"line\">Status Code:</span><br><span class=\"line\">200 OK</span><br><span class=\"line\">远程地址:</span><br><span class=\"line\">10.253.0.237:80</span><br><span class=\"line\">Referrer Policy:</span><br><span class=\"line\">strict-origin-when-cross-origin</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">请求指令</span><br><span class=\"line\">http://10.253.0.237/cgi-bin/get_challenge?callback=jQuery112405824069609933546_1712476428639&amp;username=202321081216%40dx-uestc&amp;ip=8.8.8.8%2C+113.54.145.42</span><br><span class=\"line\"></span><br><span class=\"line\">Request URL:</span><br><span class=\"line\"></span><br><span class=\"line\">http://10.253.0.237/cgi-bin/get_challenge?callback=jQuery1124028377090795615145_1712478534516&amp;username=202321081216%40dx-uestc&amp;ip=113.54.145.42&amp;_=1712478534518</span><br><span class=\"line\"></span><br><span class=\"line\">Request Method:</span><br><span class=\"line\"></span><br><span class=\"line\">GET</span><br><span class=\"line\"></span><br><span class=\"line\">Status Code:</span><br><span class=\"line\"></span><br><span class=\"line\">502 Bad Gateway</span><br><span class=\"line\"></span><br><span class=\"line\">Remote Address:</span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:7890</span><br><span class=\"line\"></span><br><span class=\"line\">Referrer Policy:</span><br><span class=\"line\"></span><br><span class=\"line\">strict-origin-when-cross-origin</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">如果连接成功，http://10.253.0.237/cgi-bin/rad_user_info 也可也正常获取数据，但是是字符串形式。而不是json</span><br><span class=\"line\"></span><br><span class=\"line\">http://10.253.0.237/cgi-bin/srun_portal?callback=jQuery112405960456199614257_1712479784865&amp;action=login&amp;username=202321081216%40dx-uestc&amp;password=%7BMD5%7Dfb5b782af15febf4ebd53a45952273b8&amp;ac_id=1&amp;ip=8.8.8.8%2C+113.54.145.42&amp;chksum=567d3b8c5bd5ef9c7f14c76b487e7ba67a3d245a&amp;info=%7BSRBX1%7D3OHj0r4O4ZBBY1c%2FRJUyhmdftyTtmQ%2BTHXWm%2BGqNqPp2dL59T78gfgRJXnmUW55cnpEZ3LfJ4NvTAu0bX76wfxQdKZrCon42SRXUdymVpUCnBoBvn1cq7pCYcgK%2BGQ7GA%2BClDLGqvIsHwc5ue8FYqip54p4C2MYgtlHTfv%3D%3D&amp;n=200&amp;type=1&amp;os=Windows+10&amp;name=Windows&amp;double_stack=0&amp;_=1712479784868</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>curl -d “username&#x3D;202321081216&amp;password&#x3D;feng0408” <a href=\"http://10.253.0.237/cgi-bin/srun_portal?callback=jQueryaction=login/\">http://10.253.0.237/cgi-bin/srun_portal?callback=jQueryaction=login/</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;Code&quot;: 0,</span><br><span class=\"line\">    &quot;Message&quot;: &quot;ok&quot;,</span><br><span class=\"line\">    &quot;Data&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;Id&quot;: 3,</span><br><span class=\"line\">            &quot;Title&quot;: &quot;清水河校区办公教学区通知&quot;,</span><br><span class=\"line\">            &quot;Content&quot;: &quot;\\u003cp style=\\&quot;margin-top:auto;margin-bottom: auto;text-align:left;text-indent:36px;line-height: 24px;background:white\\&quot;\\u003e\\u003cspan style=\\&quot;font-size: 18px;font-family:宋体\\&quot;\\u003e清水河校区办公教学区通过墙面预制网络接口连接到有线校园网。连接成功后，打开浏览器输入aaa.uestc.edu.cn弹出认证页面，可选择校园网登录或电信登录。具体使用方法如下：\\u003c/span\\u003e\\u003c/p\\u003e\\u003cp style=\\&quot;margin-top:auto;margin-bottom: auto;text-align:left;line-height:24px;background: white\\&quot;\\u003e\\u003cspan style=\\&quot;font-size:18px;font-family:宋体\\&quot;\\u003e1\\u003c/span\\u003e\\u003cspan style=\\&quot;font-size:18px;font-family: 宋体\\&quot;\\u003e、校园网登录：在右侧登录框输入统一身份认证信息（工资号或学号），点击校园网登录。\\u003c/span\\u003e\\u003c/p\\u003e\\u003cp style=\\&quot;margin-top:auto;margin-bottom: auto;text-align:left;line-height:24px;background: white\\&quot;\\u003e\\u003cspan style=\\&quot;font-size:18px;font-family:宋体\\&quot;\\u003e2\\u003c/span\\u003e\\u003cspan style=\\&quot;font-size:18px;font-family: 宋体\\&quot;\\u003e、电信登录：先点击右侧自服务按钮，进行电信账号绑定；绑定完成重新打开aaa.uestc.edu.cn，输入学校统一身份认证信息，点击电信登录。电信账号绑定流程详见《清水河有线校园网使用手册》。\\u003c/span\\u003e\\u003c/p\\u003e\\u003cp style=\\&quot;margin-top:auto;margin-bottom: auto;text-align:left;line-height:24px;background: white\\&quot;\\u003e\\u003cstrong\\u003e\\u003cspan style=\\&quot;font-size:18px;font-family:宋体\\&quot;\\u003e用户服务电话：61831184\\u003c/span\\u003e\\u003c/strong\\u003e\\u003c/p\\u003e\\u003cp\\u003e\\u003cbr/\\u003e\\u003c/p\\u003e&quot;,</span><br><span class=\"line\">            &quot;Created_by&quot;: &quot;srun&quot;,</span><br><span class=\"line\">            &quot;Created_at&quot;: 1622792930,</span><br><span class=\"line\">            &quot;Updated_at&quot;: 1622792930</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;Id&quot;: 2,</span><br><span class=\"line\">            &quot;Title&quot;: &quot;清水河行政教学区有线网络割接通知&quot;,</span><br><span class=\"line\">            &quot;Content&quot;: &quot;\\u003cp style=\\&quot;margin-top:5px;margin-right:0;margin-bottom:5px;margin-left: 0;text-indent:28px\\&quot;\\u003e\\u003cspan style=\\&quot;font-size: 18px;\\&quot;\\u003e\\u003c/span\\u003e\\u003c/p\\u003e\\u003cp style=\\&quot;line-height: 1.5em;\\&quot;\\u003e清水河校区有线网络设备已运行10年以上，故障频发，不支持IPv6，802.1X认证系统对于终端兼容性较差。为解决以上问题，信息中心协调中国电信高新西区分公司对清水河校区有线网进行改造。改造后网络使用web认证，支持IPv6协议，用户可选择校园网登录或电信登录。具体使用方法如下：\\u003c/p\\u003e\\u003cp style=\\&quot;line-height: 1.5em;\\&quot;\\u003e1、校园网登录：在右侧登录框输入统一身份认证信息，点击校园网登录。\\u003c/p\\u003e\\u003cp style=\\&quot;line-height: 1.5em;\\&quot;\\u003e2、电信登录：先点击右侧自服务按钮，进行电信账号绑定；绑定完成重新打开aaa.uestc.edu.cn，输入学校统一身份认证信息，点击电信登录。电信账号绑定流程详见《清水河有线校园网使用手册》。\\u003c/p\\u003e\\u003cp style=\\&quot;line-height: 1.5em;\\&quot;\\u003e我们对给您带来的不便表示歉意！如有任何疑问，请联系信息中心61831184。\\u003c/p\\u003e\\u003cp style=\\&quot;margin-top:5px;margin-right:0;margin-bottom:5px;margin-left: 0;text-indent:28px;font-variant-ligatures: normal;font-variant-caps: normal;orphans: 2;text-align:start;widows: 2;-webkit-text-stroke-width: 0px;word-spacing: 0px\\&quot;\\u003e\\u003cbr/\\u003e\\u003c/p\\u003e\\u003cp\\u003e\\u003cbr/\\u003e\\u003c/p\\u003e&quot;,</span><br><span class=\"line\">            &quot;Created_by&quot;: &quot;yqli&quot;,</span><br><span class=\"line\">            &quot;Created_at&quot;: 1544507894,</span><br><span class=\"line\">            &quot;Updated_at&quot;: 1622792876</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"程序自启动\"><a href=\"#程序自启动\" class=\"headerlink\" title=\"程序自启动\"></a>程序自启动</h1><p>在 Ubuntu 中，你可以使用 Systemd 来配置在系统启动时自动后台执行可执行程序。</p>\n<p>下面是一些基本的步骤：</p>\n<ol>\n<li><p>创建一个用于 Systemd 配置的服务文件。在终端中使用以下命令创建一个新的服务文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo nano /etc/systemd/system/test.service</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在打开的编辑器中，输入以下内容：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=Test Service</span><br><span class=\"line\">After=network.target</span><br><span class=\"line\"></span><br><span class=\"line\">[Service]</span><br><span class=\"line\">ExecStart=/path/to/test</span><br><span class=\"line\">Type=simple</span><br><span class=\"line\">Restart=always</span><br><span class=\"line\">User=your_username</span><br><span class=\"line\"></span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>\n\n<p>请确保将 <code>/path/to/test</code> 替换为你的可执行程序的实际路径，并将 <code>your_username</code> 替换为你的用户名。</p>\n</li>\n<li><p>保存并关闭文件。使用 <code>Ctrl + X</code>，然后输入 <code>Y</code> 保存文件并退出编辑器。</p>\n</li>\n<li><p>重新加载 Systemd 配置，使其识别新的服务文件。在终端中使用以下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启用服务，使其在系统启动时自动运行。在终端中使用以下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl enable test.service</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>最后，启动服务。在终端中使用以下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl start test.service</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>现在，你的可执行程序 <code>test</code> 将在系统启动时自动以后台进程的形式运行。</p>\n<p>你可以使用以下命令来检查服务的状态：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl status test.service</span><br></pre></td></tr></table></figure>\n\n<p>如果需要停止服务，可以使用以下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl stop test.service</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"后台运行程序\"><a href=\"#后台运行程序\" class=\"headerlink\" title=\"后台运行程序\"></a>后台运行程序</h1><ol>\n<li>在执行命令时，可以使用 <code>&amp;</code> 符号将其放在命令的末尾。这样会将命令放入后台运行，并且不会阻塞当前终端。例如：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./test &amp; </span><br></pre></td></tr></table></figure></li>\n<li>如果你希望程序在后台运行的同时不产生任何输出，你可以将其输出重定向到 <code>/dev/null</code>，这样输出将被丢弃。例如：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup ./clash-linux-amd64 &gt; /dev/null 2&gt;&amp;1 &amp;</span><br><span class=\"line\">nohup ./aaa &gt; output.log 2&gt;&amp;1 &amp;</span><br><span class=\"line\">disown</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n这样，可执行程序 <code>./test</code> 将在后台运行，并与当前终端解耦。它不会阻塞当前终端，并且输出将被重定向到 <code>/dev/null</code>，不会显示在终端上。</li>\n</ol>\n<p>请注意，使用这种方法运行程序后，你将无法看到程序的输出。如果你需要查看程序的输出或进行其他交互操作，可能需要使用其他工具或技术来实现。</p>\n<h1 id=\"离线安装包的使用\"><a href=\"#离线安装包的使用\" class=\"headerlink\" title=\"离线安装包的使用\"></a>离线安装包的使用</h1><h2 id=\"Centos\"><a href=\"#Centos\" class=\"headerlink\" title=\"Centos\"></a>Centos</h2><ol>\n<li>打包 <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install [package]--downloadonly --downloaddir=<span class=\"built_in\">dir</span>/</span><br></pre></td></tr></table></figure></li>\n<li>使用 <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum -y localinstall <span class=\"built_in\">dir</span>/*</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"查询指定域名的-IP\"><a href=\"#查询指定域名的-IP\" class=\"headerlink\" title=\"查询指定域名的 IP\"></a>查询指定域名的 IP</h1><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nsloopup</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"日志查看\"><a href=\"#日志查看\" class=\"headerlink\" title=\"日志查看\"></a>日志查看</h1><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/var/log/syslog</span><br><span class=\"line\">/var/log/kern.log</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"查看显存运行情况\"><a href=\"#查看显存运行情况\" class=\"headerlink\" title=\"查看显存运行情况\"></a>查看显存运行情况</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">watch -n 0.1 nvidia-smi</span><br></pre></td></tr></table></figure>\n"},{"_content":"\n\nvscode 终端不显示 环境\n\nhttps://github.com/microsoft/vscode-python/wiki/Activate-Environments-in-Terminal-Using-Environment-Variables\n\n\n# 相关工具\n### Anaconda 命令行界面使用\n\n1. 防止不是最新的，更新：\n\n   `conda update -n base -c defaults conda`\n\n2. 查看版本：\n\t`conda --version`\n\n3. 管理虚拟环境\n\n   1. active【环境名】：引导用户进入独立的环境。在不加参数的情况下，默认进入base环境。这里不加参数\n\n   2. conda create -n 【环境名】 python=【版本号】：创建一个虚拟环境。\n\n      `conda create -n test_env python=3`\n\n      (python版本为3(这里conda会自动找python3中最新的版本下载))\n\n   3. conda env list：列出所有环境。验证。\n\n   4. activate 【环境名】：进入环境\n\n      `activate test_env`\n\n   5. conda \n\n   6. activate 【环境名】：进入（激活）环境\n\n4. 安装\n\t`conda install 【包名】` \n\n\n#### Conda常见命令\n\n**使用 conda包管理工具需要进入`anaconda prompt`**\n\nconda --version，输出anaconda的版本\n\n```python\nconda install --offline ../input/efficient-net/dist/efficientnet_pytorch-0.7.0.tar`\n# 其中 `../input/efficient-net/dist/efficientnet_pytorch-0.7.0.tar\n```\n\n\n\n\n# 安装 python Jupyter 版\n\n### 介绍\n\nJupyter Notebook是基于网页的用于交互计算的应用程序。其可被应用于全过程计算：开发、文档编写、运行代码和展示结果。——[Jupyter Notebook官方介绍](https://link.zhihu.com/?target=https%3A//jupyter-notebook.readthedocs.io/en/stable/notebook.html)\n\nJupyter Notebook是以网页的形式打开，可以在网页页面中**直接编写代码**和**运行代码**，代码的**运行结果**也会直接在代码块下显示的程序。如在编程过程中需要编写说明文档，可在同一个页面中直接编写，便于作及时的说明和解释。\n\n# 安装 python\n参考：https://zhuanlan.zhihu.com/p/33105153\n参考：\n\n1. [神器 VS Code，讲讲超详细的 Python 配置使用指南_用vs code开发python需要准备什么-CSDN博客](https://blog.csdn.net/pythonhy/article/details/131701597)\n2. [Anaconda搭建python环境 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/643022828?utm_id=0)\n\n补充：conda、anaconda概念的差别\n\n1. conda可以理解为一个工具，也是一个可执行命令，其核心功能是包管理与环境管理。包管理与pip的使用类似，环境管理则允许用户方便地安装不同版本的python并快速切换。\n\n2. Anaconda是一个打包的集合，里面预装好了conda、某个版本的python、众多packages、科学计算工具等，也称为Python的一种发行版。\n\n## Windows安装\n\n### 一、Python安装\n\n依照教程，Python 可以从 Python 官网下载安装，也可以使用 Anaconda 来安装。本教程选择了 用  Anaconda。\n\n##### 下载地址\n\nhttps://www.anaconda.com/products/individual\n\n下载完成之后直接按照默认设置一步步安装即可。（挺大的，5G左右，换个合适的目录）\n\n### 二、Vscode 安装\n\n这里好多教程，最好直接官网上下一个。\n\n\n\n### 三、环境配置\n\n进行到这一步之后，只是工具的准备完成，但是：\n\n1. win 的 cmd 命令行 不能找到 python 指令\n2. VScode 的 终端都不能识别到 python 指令\n3. 打开 Anaconda 界面，在界面中打开 VScode，可以识别 python 指令\n\n#### 环境变量配置\n\n1. 保存 anaconda 路径到系统 “用户变量” 的 path 变量中。保存。此时 Win cmd 中就可以 识别到 conda 指令。\n\n\n\n### 四、VScode插件安装\n\n1. 扩展插件：Python \n\n2. 代码补齐：Pylance\n\n3. JupyterNotebook 支持：Jupyter\n\n4. 高亮缩进：indent-rainbow\n\n5. 括号高亮：Bracket pair Colorizer\n\n6. 注释高亮：Better Comments\n\n7. settings.json\n\n   ```json\n       \n       // python \n       \"python.defaultInterpreterPath\": \"D:\\\\Users\\\\fyn\\\\anaconda3\\\\python.exe\", \n       \"python.condaPath\": \"D:\\\\Users\\\\fyn\\\\anaconda3\\\\Scripts\\\\conda-script.py\",\n       \"python.experiments.optInto\": [\n           \"pythonTerminalEnvVarActivation\"\n       ],\n       // \"python.formatting.provider\": \"D:\\\\Users\\\\fyn\\\\anaconda3\\\\lib\\\\yapf\",\n       // \"python.pythonPath\": \"D:\\\\Users\\\\fyn\\\\anaconda3\\\\python.exe\",\n       \"python.terminal.activateEnvInCurrentTerminal\": true,\n       \"python.terminal.activateEnvironment\": true,\n   ```\n\n   \n\n\n\n## Linux Conda 安装\n\n[Ubuntu安装anaconda,tensorflow等 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/43348901)\n\n### 一、Conda 安装\n\n```bash\nwget https://repo.anaconda.com/archive/Anaconda3-2023.09-0-Linux-x86_64.sh\nbash a*.sh\n\n# 回车 查看协议 \n# q 退出查看\n# yes 确认\n# 回车确定 安装目录， 一般为 /home/Anaconda  \n# 对应目录增加权限方便所有用户使用 conda chmod -R a+rx /opt/anaconda3\n\n# yes 确定通过 conda init 启动\n```\n\n### 二、Conda 启动环境变量\n\n```bash\n# 首先 关闭并重新打开终端，使得conda 生效\n# 升级\nconda update -n base -c defaults conda\n# 修改 Path\nexport PATH=\"/root/anaconda3/bin:$PATH\"\nsource ~/.bashrc\n\n```\n\n### 三、Conda 修改国内源\n\n```bash\n# 输入\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/\nconda config --set show_channel_urls yes\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/\nconda create -n py39 python=3.9\n\n# 若是CondaHTTPError，\n\nconda config --add channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\nconda config --add channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/\n（http不要s)\n\n```\n\n### 四、Conda 进行环境管理\n\n#### 环境创建\n\n```bash\n# 查看 conda 信息\nconda info --env\n# 创建环境 \nconda create -n your_env_name python=x.x\nconda create -n fyn_python2 python=2.7.12\n# 删除环境\nconda remove -n your_env_name --all\n# 切换环境\nconda activate your_env_name \n# 退出/关闭环境\n\n\n  \npip3 list --format=columns\n```\n\n#### 利用依赖包安装环境\n\n```bash\npip install -r requirements.txt\n# 引用清华镜像源\n# -i https://pypi.tuna.tsinghua.edu.cn/simple/ \n```\n\n####  生成依赖包配置\n\n```bash\n# 第一种，一般只适合完全相同的环境\npip freeze > d:/requirements.txt\n# 可能出现格式： 包名＋版本号＋@ file:///tmp/build/xxx/xxx/work\n# 此格式无法在其他系统识别，\n\n# 第二种，解决第一种的问题。\npip list --format=freeze > requirements.txt\n```\n\n## Linux 离线安装\n```bash\n## 准备 离线依赖包 和 python 安装包\n# 离线包安装依赖\nyum -y localinstall ./gcc/*.rpm\nyum -y localinstall ./bzip2-devel/*.rpm\nyum -y localinstall ./libffi-devel/*.rpm\nyum -y localinstall ./openssl-devel/*.rpm\nyum -y localinstall ./zlib-devel/*.rpm\n\n# 安装\ntar -xf Python-3.9.10.tgz\ncd Python-3.9.10\n./configure --prefix=/usr/local/python-3.9.10 --enable-optimizations\nmake \nmake altinstall\nln -s /usr/local/python-3.9.10/bin/python3.9 /usr/bin/python3\n```\n# 卸载 python\n## Linux\n```bash\n# 卸载 python3.6---没测\nrm -rf /usr/local/bin/python3\nrm -rf /usr/local/bin/python3.6\nrm -rf /usr/local/include/python3.6m\nrm -rf /usr/local/lib/python3.6\nrm -rf /usr/local/lib/libpython3.6m.a\n```\n# 使用 python 库\n## 离线包安装\n1. 打包\n\t```python\n\tpython3 -m pip download <package>\n\t```\n2. 使用\n\t```python\n\t pip install <package>.whl\n\t```\n\n## 安装 CUDA\n\nhttps://link.zhihu.com/?target=https%3A//developer.nvidia.com/rdp/cudnn-download\n\n[Log in | NVIDIA Developer](https://developer.nvidia.com/login)\n\n```bash\nsudo cp cuda/include/cudnn.h /usr/local/cuda/include\nsudo cp cuda/lib64/libcudnn* /usr/local/cuda/lib64\nsudo chmod a+r /usr/local/cuda/include/cudnn.h /usr/local/cuda/lib64/libcudnn*\n```\n\n## 安装 tensorflow/torch\n\n```bash\nhttps://link.zhihu.com/?target=https%3A//github.com/mind/wheels/releases\n```\n\n- PyTorch: `pip install torch`\n- TensorFlow: `pip install tensorflow`\n- Flax: `pip install flax`\n\n来更新已安装的库：\n\n- PyTorch: `pip install --upgrade torch`\n- TensorFlow: `pip install --upgrade tensorflow`\n- Flax: `pip install --upgrade flax`\n\n安装 参考https://blog.csdn.net/CLOUD_J/article/details/112474224\n\n1. 安装 runfile\n\n   https://developer.nvidia.com/cuda-downloads?target_os=Linux&target_arch=x86_64&Distribution=Ubuntu&target_version=22.04&target_type=runfile_local\n\n   选择runfile，按照给出来的指令执行：\n\n   ```\n   wget https://developer.download.nvidia.com/compute/cuda/12.3.2/local_installers/cuda_12.3.2_545.23.08_linux.run\n   sudo sh cuda_12.3.2_545.23.08_linux.run\n   ```\n\n   1. 第一个ACCEPT接受\n   2. 第二个选择安装的东西\n   3. 带X的是要安装的，有驱动就把驱动关掉，只安装cuda tool kit即可\n   4. 然后移动到最下面install\n   5. 点回车\n   6. 等待片刻安装好了\n\n2. 环境变量\n\n   ```\n   vim ~/.bashrc\n   #下面加进去有\n   export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda/lib64\n   export PATH=$PATH:/usr/local/cuda/bin\n   export CUDA_HOME=$CUDA_HOME:/usr/local/cuda\n   #source一下\n   source ~/.bashrc\n   \n   ### /usr/local/cuda-12.3/bin  实际上与上面相同\n   \n   ```\n\n   安装结束\n\n   ```\n   ===========\n   = Summary =\n   ===========\n   \n   Driver:   Not Selected\n   Toolkit:  Installed in /usr/local/cuda-12.3/\n   \n   Please make sure that\n    -   PATH includes /usr/local/cuda-12.3/bin\n    -   LD_LIBRARY_PATH includes /usr/local/cuda-12.3/lib64, or, add /usr/local/cuda-12.3/lib64 to /etc/ld.so.conf and run ldconfig as root\n   \n   To uninstall the CUDA Toolkit, run cuda-uninstaller in /usr/local/cuda-12.3/bin\n   ***WARNING: Incomplete installation! This installation did not install the CUDA Driver. A driver of version at least 545.00 is required for CUDA 12.3 functionality to work.\n   To install the driver using this installer, run the following command, replacing <CudaInstaller> with the name of this run file:\n       sudo <CudaInstaller>.run --silent --driver\n   \n   Logfile is /var/log/cuda-installer.log\n   ```\n\n   \n\n3. nvcc -V检查安装是否成功，显示版本则成功。\n\n   此时就可以执行\n\n4. 安装 CUDNN\n\n\n\n\n## 深度学习库比较\n> scikit-learn、PyTorch 和 Keras 的信息：\n>\n>1. scikit-learn（sklearn）:\n>   - 是一个流行的 Python 机器学习库，提供了各种经典的机器学习算法和工具。\n>   - 包含用于分类、回归、聚类、降维、特征选择等任务的算法。\n>   - 提供了数据预处理、特征工程、模型评估和模型选择的功能。\n>   - 具有简单且一致的API，易于使用和上手。\n>   - 适合处理传统机器学习任务，特别是在数据量较小或特征工程较为重要的情况下。\n>2. PyTorch:\n>   - 是一个用于构建和训练神经网络的深度学习库。\n>   - 提供了动态计算图的能力，使得模型构建和调整更加灵活。\n>   - 具有丰富的深度学习函数和模块，用于处理张量操作、构建神经网络层、定义损失函数等。\n>   - 支持自动求导，方便进行反向传播和梯度更新。\n>   - 提供了灵活的调试和自定义选项，适合深入研究和开发深度学习模型。\n>3. Keras:\n>   - 是一个高级的神经网络 API，用于构建和训练深度学习模型。\n>   - 提供了简洁、一致的接口，使得模型的原型设计和实验更加快速和便捷。\n>   - 可以作为 TensorFlow、Theano 和 Microsoft CNTK 等深度学习框架的后端。\n>   - 支持多种网络结构，包括顺序模型、函数式 API 和子类化 API。\n>   - 提供了丰富的预处理工具、模型评估和可视化工具。\n\n#\n\n\n\n","source":"_posts/工具教程/配置：python 安装文档.md","raw":"\n\nvscode 终端不显示 环境\n\nhttps://github.com/microsoft/vscode-python/wiki/Activate-Environments-in-Terminal-Using-Environment-Variables\n\n\n# 相关工具\n### Anaconda 命令行界面使用\n\n1. 防止不是最新的，更新：\n\n   `conda update -n base -c defaults conda`\n\n2. 查看版本：\n\t`conda --version`\n\n3. 管理虚拟环境\n\n   1. active【环境名】：引导用户进入独立的环境。在不加参数的情况下，默认进入base环境。这里不加参数\n\n   2. conda create -n 【环境名】 python=【版本号】：创建一个虚拟环境。\n\n      `conda create -n test_env python=3`\n\n      (python版本为3(这里conda会自动找python3中最新的版本下载))\n\n   3. conda env list：列出所有环境。验证。\n\n   4. activate 【环境名】：进入环境\n\n      `activate test_env`\n\n   5. conda \n\n   6. activate 【环境名】：进入（激活）环境\n\n4. 安装\n\t`conda install 【包名】` \n\n\n#### Conda常见命令\n\n**使用 conda包管理工具需要进入`anaconda prompt`**\n\nconda --version，输出anaconda的版本\n\n```python\nconda install --offline ../input/efficient-net/dist/efficientnet_pytorch-0.7.0.tar`\n# 其中 `../input/efficient-net/dist/efficientnet_pytorch-0.7.0.tar\n```\n\n\n\n\n# 安装 python Jupyter 版\n\n### 介绍\n\nJupyter Notebook是基于网页的用于交互计算的应用程序。其可被应用于全过程计算：开发、文档编写、运行代码和展示结果。——[Jupyter Notebook官方介绍](https://link.zhihu.com/?target=https%3A//jupyter-notebook.readthedocs.io/en/stable/notebook.html)\n\nJupyter Notebook是以网页的形式打开，可以在网页页面中**直接编写代码**和**运行代码**，代码的**运行结果**也会直接在代码块下显示的程序。如在编程过程中需要编写说明文档，可在同一个页面中直接编写，便于作及时的说明和解释。\n\n# 安装 python\n参考：https://zhuanlan.zhihu.com/p/33105153\n参考：\n\n1. [神器 VS Code，讲讲超详细的 Python 配置使用指南_用vs code开发python需要准备什么-CSDN博客](https://blog.csdn.net/pythonhy/article/details/131701597)\n2. [Anaconda搭建python环境 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/643022828?utm_id=0)\n\n补充：conda、anaconda概念的差别\n\n1. conda可以理解为一个工具，也是一个可执行命令，其核心功能是包管理与环境管理。包管理与pip的使用类似，环境管理则允许用户方便地安装不同版本的python并快速切换。\n\n2. Anaconda是一个打包的集合，里面预装好了conda、某个版本的python、众多packages、科学计算工具等，也称为Python的一种发行版。\n\n## Windows安装\n\n### 一、Python安装\n\n依照教程，Python 可以从 Python 官网下载安装，也可以使用 Anaconda 来安装。本教程选择了 用  Anaconda。\n\n##### 下载地址\n\nhttps://www.anaconda.com/products/individual\n\n下载完成之后直接按照默认设置一步步安装即可。（挺大的，5G左右，换个合适的目录）\n\n### 二、Vscode 安装\n\n这里好多教程，最好直接官网上下一个。\n\n\n\n### 三、环境配置\n\n进行到这一步之后，只是工具的准备完成，但是：\n\n1. win 的 cmd 命令行 不能找到 python 指令\n2. VScode 的 终端都不能识别到 python 指令\n3. 打开 Anaconda 界面，在界面中打开 VScode，可以识别 python 指令\n\n#### 环境变量配置\n\n1. 保存 anaconda 路径到系统 “用户变量” 的 path 变量中。保存。此时 Win cmd 中就可以 识别到 conda 指令。\n\n\n\n### 四、VScode插件安装\n\n1. 扩展插件：Python \n\n2. 代码补齐：Pylance\n\n3. JupyterNotebook 支持：Jupyter\n\n4. 高亮缩进：indent-rainbow\n\n5. 括号高亮：Bracket pair Colorizer\n\n6. 注释高亮：Better Comments\n\n7. settings.json\n\n   ```json\n       \n       // python \n       \"python.defaultInterpreterPath\": \"D:\\\\Users\\\\fyn\\\\anaconda3\\\\python.exe\", \n       \"python.condaPath\": \"D:\\\\Users\\\\fyn\\\\anaconda3\\\\Scripts\\\\conda-script.py\",\n       \"python.experiments.optInto\": [\n           \"pythonTerminalEnvVarActivation\"\n       ],\n       // \"python.formatting.provider\": \"D:\\\\Users\\\\fyn\\\\anaconda3\\\\lib\\\\yapf\",\n       // \"python.pythonPath\": \"D:\\\\Users\\\\fyn\\\\anaconda3\\\\python.exe\",\n       \"python.terminal.activateEnvInCurrentTerminal\": true,\n       \"python.terminal.activateEnvironment\": true,\n   ```\n\n   \n\n\n\n## Linux Conda 安装\n\n[Ubuntu安装anaconda,tensorflow等 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/43348901)\n\n### 一、Conda 安装\n\n```bash\nwget https://repo.anaconda.com/archive/Anaconda3-2023.09-0-Linux-x86_64.sh\nbash a*.sh\n\n# 回车 查看协议 \n# q 退出查看\n# yes 确认\n# 回车确定 安装目录， 一般为 /home/Anaconda  \n# 对应目录增加权限方便所有用户使用 conda chmod -R a+rx /opt/anaconda3\n\n# yes 确定通过 conda init 启动\n```\n\n### 二、Conda 启动环境变量\n\n```bash\n# 首先 关闭并重新打开终端，使得conda 生效\n# 升级\nconda update -n base -c defaults conda\n# 修改 Path\nexport PATH=\"/root/anaconda3/bin:$PATH\"\nsource ~/.bashrc\n\n```\n\n### 三、Conda 修改国内源\n\n```bash\n# 输入\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/\nconda config --set show_channel_urls yes\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/\nconda create -n py39 python=3.9\n\n# 若是CondaHTTPError，\n\nconda config --add channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\nconda config --add channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/\n（http不要s)\n\n```\n\n### 四、Conda 进行环境管理\n\n#### 环境创建\n\n```bash\n# 查看 conda 信息\nconda info --env\n# 创建环境 \nconda create -n your_env_name python=x.x\nconda create -n fyn_python2 python=2.7.12\n# 删除环境\nconda remove -n your_env_name --all\n# 切换环境\nconda activate your_env_name \n# 退出/关闭环境\n\n\n  \npip3 list --format=columns\n```\n\n#### 利用依赖包安装环境\n\n```bash\npip install -r requirements.txt\n# 引用清华镜像源\n# -i https://pypi.tuna.tsinghua.edu.cn/simple/ \n```\n\n####  生成依赖包配置\n\n```bash\n# 第一种，一般只适合完全相同的环境\npip freeze > d:/requirements.txt\n# 可能出现格式： 包名＋版本号＋@ file:///tmp/build/xxx/xxx/work\n# 此格式无法在其他系统识别，\n\n# 第二种，解决第一种的问题。\npip list --format=freeze > requirements.txt\n```\n\n## Linux 离线安装\n```bash\n## 准备 离线依赖包 和 python 安装包\n# 离线包安装依赖\nyum -y localinstall ./gcc/*.rpm\nyum -y localinstall ./bzip2-devel/*.rpm\nyum -y localinstall ./libffi-devel/*.rpm\nyum -y localinstall ./openssl-devel/*.rpm\nyum -y localinstall ./zlib-devel/*.rpm\n\n# 安装\ntar -xf Python-3.9.10.tgz\ncd Python-3.9.10\n./configure --prefix=/usr/local/python-3.9.10 --enable-optimizations\nmake \nmake altinstall\nln -s /usr/local/python-3.9.10/bin/python3.9 /usr/bin/python3\n```\n# 卸载 python\n## Linux\n```bash\n# 卸载 python3.6---没测\nrm -rf /usr/local/bin/python3\nrm -rf /usr/local/bin/python3.6\nrm -rf /usr/local/include/python3.6m\nrm -rf /usr/local/lib/python3.6\nrm -rf /usr/local/lib/libpython3.6m.a\n```\n# 使用 python 库\n## 离线包安装\n1. 打包\n\t```python\n\tpython3 -m pip download <package>\n\t```\n2. 使用\n\t```python\n\t pip install <package>.whl\n\t```\n\n## 安装 CUDA\n\nhttps://link.zhihu.com/?target=https%3A//developer.nvidia.com/rdp/cudnn-download\n\n[Log in | NVIDIA Developer](https://developer.nvidia.com/login)\n\n```bash\nsudo cp cuda/include/cudnn.h /usr/local/cuda/include\nsudo cp cuda/lib64/libcudnn* /usr/local/cuda/lib64\nsudo chmod a+r /usr/local/cuda/include/cudnn.h /usr/local/cuda/lib64/libcudnn*\n```\n\n## 安装 tensorflow/torch\n\n```bash\nhttps://link.zhihu.com/?target=https%3A//github.com/mind/wheels/releases\n```\n\n- PyTorch: `pip install torch`\n- TensorFlow: `pip install tensorflow`\n- Flax: `pip install flax`\n\n来更新已安装的库：\n\n- PyTorch: `pip install --upgrade torch`\n- TensorFlow: `pip install --upgrade tensorflow`\n- Flax: `pip install --upgrade flax`\n\n安装 参考https://blog.csdn.net/CLOUD_J/article/details/112474224\n\n1. 安装 runfile\n\n   https://developer.nvidia.com/cuda-downloads?target_os=Linux&target_arch=x86_64&Distribution=Ubuntu&target_version=22.04&target_type=runfile_local\n\n   选择runfile，按照给出来的指令执行：\n\n   ```\n   wget https://developer.download.nvidia.com/compute/cuda/12.3.2/local_installers/cuda_12.3.2_545.23.08_linux.run\n   sudo sh cuda_12.3.2_545.23.08_linux.run\n   ```\n\n   1. 第一个ACCEPT接受\n   2. 第二个选择安装的东西\n   3. 带X的是要安装的，有驱动就把驱动关掉，只安装cuda tool kit即可\n   4. 然后移动到最下面install\n   5. 点回车\n   6. 等待片刻安装好了\n\n2. 环境变量\n\n   ```\n   vim ~/.bashrc\n   #下面加进去有\n   export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda/lib64\n   export PATH=$PATH:/usr/local/cuda/bin\n   export CUDA_HOME=$CUDA_HOME:/usr/local/cuda\n   #source一下\n   source ~/.bashrc\n   \n   ### /usr/local/cuda-12.3/bin  实际上与上面相同\n   \n   ```\n\n   安装结束\n\n   ```\n   ===========\n   = Summary =\n   ===========\n   \n   Driver:   Not Selected\n   Toolkit:  Installed in /usr/local/cuda-12.3/\n   \n   Please make sure that\n    -   PATH includes /usr/local/cuda-12.3/bin\n    -   LD_LIBRARY_PATH includes /usr/local/cuda-12.3/lib64, or, add /usr/local/cuda-12.3/lib64 to /etc/ld.so.conf and run ldconfig as root\n   \n   To uninstall the CUDA Toolkit, run cuda-uninstaller in /usr/local/cuda-12.3/bin\n   ***WARNING: Incomplete installation! This installation did not install the CUDA Driver. A driver of version at least 545.00 is required for CUDA 12.3 functionality to work.\n   To install the driver using this installer, run the following command, replacing <CudaInstaller> with the name of this run file:\n       sudo <CudaInstaller>.run --silent --driver\n   \n   Logfile is /var/log/cuda-installer.log\n   ```\n\n   \n\n3. nvcc -V检查安装是否成功，显示版本则成功。\n\n   此时就可以执行\n\n4. 安装 CUDNN\n\n\n\n\n## 深度学习库比较\n> scikit-learn、PyTorch 和 Keras 的信息：\n>\n>1. scikit-learn（sklearn）:\n>   - 是一个流行的 Python 机器学习库，提供了各种经典的机器学习算法和工具。\n>   - 包含用于分类、回归、聚类、降维、特征选择等任务的算法。\n>   - 提供了数据预处理、特征工程、模型评估和模型选择的功能。\n>   - 具有简单且一致的API，易于使用和上手。\n>   - 适合处理传统机器学习任务，特别是在数据量较小或特征工程较为重要的情况下。\n>2. PyTorch:\n>   - 是一个用于构建和训练神经网络的深度学习库。\n>   - 提供了动态计算图的能力，使得模型构建和调整更加灵活。\n>   - 具有丰富的深度学习函数和模块，用于处理张量操作、构建神经网络层、定义损失函数等。\n>   - 支持自动求导，方便进行反向传播和梯度更新。\n>   - 提供了灵活的调试和自定义选项，适合深入研究和开发深度学习模型。\n>3. Keras:\n>   - 是一个高级的神经网络 API，用于构建和训练深度学习模型。\n>   - 提供了简洁、一致的接口，使得模型的原型设计和实验更加快速和便捷。\n>   - 可以作为 TensorFlow、Theano 和 Microsoft CNTK 等深度学习框架的后端。\n>   - 支持多种网络结构，包括顺序模型、函数式 API 和子类化 API。\n>   - 提供了丰富的预处理工具、模型评估和可视化工具。\n\n#\n\n\n\n","slug":"工具教程/配置：python 安装文档","published":1,"date":"2024-04-22T13:14:48.764Z","updated":"2024-04-22T08:16:06.717Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0d000pkgg490kd9u8a","content":"<p>vscode 终端不显示 环境</p>\n<p><a href=\"https://github.com/microsoft/vscode-python/wiki/Activate-Environments-in-Terminal-Using-Environment-Variables\">https://github.com/microsoft/vscode-python/wiki/Activate-Environments-in-Terminal-Using-Environment-Variables</a></p>\n<h1 id=\"相关工具\"><a href=\"#相关工具\" class=\"headerlink\" title=\"相关工具\"></a>相关工具</h1><h3 id=\"Anaconda-命令行界面使用\"><a href=\"#Anaconda-命令行界面使用\" class=\"headerlink\" title=\"Anaconda 命令行界面使用\"></a>Anaconda 命令行界面使用</h3><ol>\n<li><p>防止不是最新的，更新：</p>\n<p><code>conda update -n base -c defaults conda</code></p>\n</li>\n<li><p>查看版本：<br> <code>conda --version</code></p>\n</li>\n<li><p>管理虚拟环境</p>\n<ol>\n<li><p>active【环境名】：引导用户进入独立的环境。在不加参数的情况下，默认进入base环境。这里不加参数</p>\n</li>\n<li><p>conda create -n 【环境名】 python&#x3D;【版本号】：创建一个虚拟环境。</p>\n<p><code>conda create -n test_env python=3</code></p>\n<p>(python版本为3(这里conda会自动找python3中最新的版本下载))</p>\n</li>\n<li><p>conda env list：列出所有环境。验证。</p>\n</li>\n<li><p>activate 【环境名】：进入环境</p>\n<p><code>activate test_env</code></p>\n</li>\n<li><p>conda </p>\n</li>\n<li><p>activate 【环境名】：进入（激活）环境</p>\n</li>\n</ol>\n</li>\n<li><p>安装<br> <code>conda install 【包名】</code></p>\n</li>\n</ol>\n<h4 id=\"Conda常见命令\"><a href=\"#Conda常见命令\" class=\"headerlink\" title=\"Conda常见命令\"></a>Conda常见命令</h4><p><strong>使用 conda包管理工具需要进入<code>anaconda prompt</code></strong></p>\n<p>conda –version，输出anaconda的版本</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda install --offline ../<span class=\"built_in\">input</span>/efficient-net/dist/efficientnet_pytorch-<span class=\"number\">0.7</span><span class=\"number\">.0</span>.tar`</span><br><span class=\"line\"><span class=\"comment\"># 其中 `../input/efficient-net/dist/efficientnet_pytorch-0.7.0.tar</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n<h1 id=\"安装-python-Jupyter-版\"><a href=\"#安装-python-Jupyter-版\" class=\"headerlink\" title=\"安装 python Jupyter 版\"></a>安装 python Jupyter 版</h1><h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>Jupyter Notebook是基于网页的用于交互计算的应用程序。其可被应用于全过程计算：开发、文档编写、运行代码和展示结果。——<a href=\"https://link.zhihu.com/?target=https://jupyter-notebook.readthedocs.io/en/stable/notebook.html\">Jupyter Notebook官方介绍</a></p>\n<p>Jupyter Notebook是以网页的形式打开，可以在网页页面中<strong>直接编写代码</strong>和<strong>运行代码</strong>，代码的<strong>运行结果</strong>也会直接在代码块下显示的程序。如在编程过程中需要编写说明文档，可在同一个页面中直接编写，便于作及时的说明和解释。</p>\n<h1 id=\"安装-python\"><a href=\"#安装-python\" class=\"headerlink\" title=\"安装 python\"></a>安装 python</h1><p>参考：<a href=\"https://zhuanlan.zhihu.com/p/33105153\">https://zhuanlan.zhihu.com/p/33105153</a><br>参考：</p>\n<ol>\n<li><a href=\"https://blog.csdn.net/pythonhy/article/details/131701597\">神器 VS Code，讲讲超详细的 Python 配置使用指南_用vs code开发python需要准备什么-CSDN博客</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/643022828?utm_id=0\">Anaconda搭建python环境 - 知乎 (zhihu.com)</a></li>\n</ol>\n<p>补充：conda、anaconda概念的差别</p>\n<ol>\n<li><p>conda可以理解为一个工具，也是一个可执行命令，其核心功能是包管理与环境管理。包管理与pip的使用类似，环境管理则允许用户方便地安装不同版本的python并快速切换。</p>\n</li>\n<li><p>Anaconda是一个打包的集合，里面预装好了conda、某个版本的python、众多packages、科学计算工具等，也称为Python的一种发行版。</p>\n</li>\n</ol>\n<h2 id=\"Windows安装\"><a href=\"#Windows安装\" class=\"headerlink\" title=\"Windows安装\"></a>Windows安装</h2><h3 id=\"一、Python安装\"><a href=\"#一、Python安装\" class=\"headerlink\" title=\"一、Python安装\"></a>一、Python安装</h3><p>依照教程，Python 可以从 Python 官网下载安装，也可以使用 Anaconda 来安装。本教程选择了 用  Anaconda。</p>\n<h5 id=\"下载地址\"><a href=\"#下载地址\" class=\"headerlink\" title=\"下载地址\"></a>下载地址</h5><p><a href=\"https://www.anaconda.com/products/individual\">https://www.anaconda.com/products/individual</a></p>\n<p>下载完成之后直接按照默认设置一步步安装即可。（挺大的，5G左右，换个合适的目录）</p>\n<h3 id=\"二、Vscode-安装\"><a href=\"#二、Vscode-安装\" class=\"headerlink\" title=\"二、Vscode 安装\"></a>二、Vscode 安装</h3><p>这里好多教程，最好直接官网上下一个。</p>\n<h3 id=\"三、环境配置\"><a href=\"#三、环境配置\" class=\"headerlink\" title=\"三、环境配置\"></a>三、环境配置</h3><p>进行到这一步之后，只是工具的准备完成，但是：</p>\n<ol>\n<li>win 的 cmd 命令行 不能找到 python 指令</li>\n<li>VScode 的 终端都不能识别到 python 指令</li>\n<li>打开 Anaconda 界面，在界面中打开 VScode，可以识别 python 指令</li>\n</ol>\n<h4 id=\"环境变量配置\"><a href=\"#环境变量配置\" class=\"headerlink\" title=\"环境变量配置\"></a>环境变量配置</h4><ol>\n<li>保存 anaconda 路径到系统 “用户变量” 的 path 变量中。保存。此时 Win cmd 中就可以 识别到 conda 指令。</li>\n</ol>\n<h3 id=\"四、VScode插件安装\"><a href=\"#四、VScode插件安装\" class=\"headerlink\" title=\"四、VScode插件安装\"></a>四、VScode插件安装</h3><ol>\n<li><p>扩展插件：Python </p>\n</li>\n<li><p>代码补齐：Pylance</p>\n</li>\n<li><p>JupyterNotebook 支持：Jupyter</p>\n</li>\n<li><p>高亮缩进：indent-rainbow</p>\n</li>\n<li><p>括号高亮：Bracket pair Colorizer</p>\n</li>\n<li><p>注释高亮：Better Comments</p>\n</li>\n<li><p>settings.json</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// python </span></span><br><span class=\"line\"><span class=\"attr\">&quot;python.defaultInterpreterPath&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;D:\\\\Users\\\\fyn\\\\anaconda3\\\\python.exe&quot;</span><span class=\"punctuation\">,</span> </span><br><span class=\"line\"><span class=\"attr\">&quot;python.condaPath&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;D:\\\\Users\\\\fyn\\\\anaconda3\\\\Scripts\\\\conda-script.py&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"attr\">&quot;python.experiments.optInto&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">    <span class=\"string\">&quot;pythonTerminalEnvVarActivation&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"comment\">// &quot;python.formatting.provider&quot;: &quot;D:\\\\Users\\\\fyn\\\\anaconda3\\\\lib\\\\yapf&quot;,</span></span><br><span class=\"line\"><span class=\"comment\">// &quot;python.pythonPath&quot;: &quot;D:\\\\Users\\\\fyn\\\\anaconda3\\\\python.exe&quot;,</span></span><br><span class=\"line\"><span class=\"attr\">&quot;python.terminal.activateEnvInCurrentTerminal&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"attr\">&quot;python.terminal.activateEnvironment&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"Linux-Conda-安装\"><a href=\"#Linux-Conda-安装\" class=\"headerlink\" title=\"Linux Conda 安装\"></a>Linux Conda 安装</h2><p><a href=\"https://zhuanlan.zhihu.com/p/43348901\">Ubuntu安装anaconda,tensorflow等 - 知乎 (zhihu.com)</a></p>\n<h3 id=\"一、Conda-安装\"><a href=\"#一、Conda-安装\" class=\"headerlink\" title=\"一、Conda 安装\"></a>一、Conda 安装</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://repo.anaconda.com/archive/Anaconda3-2023.09-0-Linux-x86_64.sh</span><br><span class=\"line\">bash a*.sh</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 回车 查看协议 </span></span><br><span class=\"line\"><span class=\"comment\"># q 退出查看</span></span><br><span class=\"line\"><span class=\"comment\"># yes 确认</span></span><br><span class=\"line\"><span class=\"comment\"># 回车确定 安装目录， 一般为 /home/Anaconda  </span></span><br><span class=\"line\"><span class=\"comment\"># 对应目录增加权限方便所有用户使用 conda chmod -R a+rx /opt/anaconda3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># yes 确定通过 conda init 启动</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二、Conda-启动环境变量\"><a href=\"#二、Conda-启动环境变量\" class=\"headerlink\" title=\"二、Conda 启动环境变量\"></a>二、Conda 启动环境变量</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 首先 关闭并重新打开终端，使得conda 生效</span></span><br><span class=\"line\"><span class=\"comment\"># 升级</span></span><br><span class=\"line\">conda update -n base -c defaults conda</span><br><span class=\"line\"><span class=\"comment\"># 修改 Path</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"string\">&quot;/root/anaconda3/bin:<span class=\"variable\">$PATH</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.bashrc</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"三、Conda-修改国内源\"><a href=\"#三、Conda-修改国内源\" class=\"headerlink\" title=\"三、Conda 修改国内源\"></a>三、Conda 修改国内源</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 输入</span></span><br><span class=\"line\">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class=\"line\">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class=\"line\">conda config --<span class=\"built_in\">set</span> show_channel_urls <span class=\"built_in\">yes</span></span><br><span class=\"line\">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/</span><br><span class=\"line\">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/</span><br><span class=\"line\">conda create -n py39 python=3.9</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 若是CondaHTTPError，</span></span><br><span class=\"line\"></span><br><span class=\"line\">conda config --add channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class=\"line\">conda config --add channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class=\"line\">（http不要s)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"四、Conda-进行环境管理\"><a href=\"#四、Conda-进行环境管理\" class=\"headerlink\" title=\"四、Conda 进行环境管理\"></a>四、Conda 进行环境管理</h3><h4 id=\"环境创建\"><a href=\"#环境创建\" class=\"headerlink\" title=\"环境创建\"></a>环境创建</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看 conda 信息</span></span><br><span class=\"line\">conda info --<span class=\"built_in\">env</span></span><br><span class=\"line\"><span class=\"comment\"># 创建环境 </span></span><br><span class=\"line\">conda create -n your_env_name python=x.x</span><br><span class=\"line\">conda create -n fyn_python2 python=2.7.12</span><br><span class=\"line\"><span class=\"comment\"># 删除环境</span></span><br><span class=\"line\">conda remove -n your_env_name --all</span><br><span class=\"line\"><span class=\"comment\"># 切换环境</span></span><br><span class=\"line\">conda activate your_env_name </span><br><span class=\"line\"><span class=\"comment\"># 退出/关闭环境</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\">pip3 list --format=columns</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"利用依赖包安装环境\"><a href=\"#利用依赖包安装环境\" class=\"headerlink\" title=\"利用依赖包安装环境\"></a>利用依赖包安装环境</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install -r requirements.txt</span><br><span class=\"line\"><span class=\"comment\"># 引用清华镜像源</span></span><br><span class=\"line\"><span class=\"comment\"># -i https://pypi.tuna.tsinghua.edu.cn/simple/ </span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"生成依赖包配置\"><a href=\"#生成依赖包配置\" class=\"headerlink\" title=\"生成依赖包配置\"></a>生成依赖包配置</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 第一种，一般只适合完全相同的环境</span></span><br><span class=\"line\">pip freeze &gt; d:/requirements.txt</span><br><span class=\"line\"><span class=\"comment\"># 可能出现格式： 包名＋版本号＋@ file:///tmp/build/xxx/xxx/work</span></span><br><span class=\"line\"><span class=\"comment\"># 此格式无法在其他系统识别，</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 第二种，解决第一种的问题。</span></span><br><span class=\"line\">pip list --format=freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Linux-离线安装\"><a href=\"#Linux-离线安装\" class=\"headerlink\" title=\"Linux 离线安装\"></a>Linux 离线安装</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## 准备 离线依赖包 和 python 安装包</span></span><br><span class=\"line\"><span class=\"comment\"># 离线包安装依赖</span></span><br><span class=\"line\">yum -y localinstall ./gcc/*.rpm</span><br><span class=\"line\">yum -y localinstall ./bzip2-devel/*.rpm</span><br><span class=\"line\">yum -y localinstall ./libffi-devel/*.rpm</span><br><span class=\"line\">yum -y localinstall ./openssl-devel/*.rpm</span><br><span class=\"line\">yum -y localinstall ./zlib-devel/*.rpm</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装</span></span><br><span class=\"line\">tar -xf Python-3.9.10.tgz</span><br><span class=\"line\"><span class=\"built_in\">cd</span> Python-3.9.10</span><br><span class=\"line\">./configure --prefix=/usr/local/python-3.9.10 --enable-optimizations</span><br><span class=\"line\">make </span><br><span class=\"line\">make altinstall</span><br><span class=\"line\"><span class=\"built_in\">ln</span> -s /usr/local/python-3.9.10/bin/python3.9 /usr/bin/python3</span><br></pre></td></tr></table></figure>\n<h1 id=\"卸载-python\"><a href=\"#卸载-python\" class=\"headerlink\" title=\"卸载 python\"></a>卸载 python</h1><h2 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 卸载 python3.6---没测</span></span><br><span class=\"line\"><span class=\"built_in\">rm</span> -rf /usr/local/bin/python3</span><br><span class=\"line\"><span class=\"built_in\">rm</span> -rf /usr/local/bin/python3.6</span><br><span class=\"line\"><span class=\"built_in\">rm</span> -rf /usr/local/include/python3.6m</span><br><span class=\"line\"><span class=\"built_in\">rm</span> -rf /usr/local/lib/python3.6</span><br><span class=\"line\"><span class=\"built_in\">rm</span> -rf /usr/local/lib/libpython3.6m.a</span><br></pre></td></tr></table></figure>\n<h1 id=\"使用-python-库\"><a href=\"#使用-python-库\" class=\"headerlink\" title=\"使用 python 库\"></a>使用 python 库</h1><h2 id=\"离线包安装\"><a href=\"#离线包安装\" class=\"headerlink\" title=\"离线包安装\"></a>离线包安装</h2><ol>\n<li>打包 <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python3 -m pip download &lt;package&gt;</span><br></pre></td></tr></table></figure></li>\n<li>使用 <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install &lt;package&gt;.whl</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"安装-CUDA\"><a href=\"#安装-CUDA\" class=\"headerlink\" title=\"安装 CUDA\"></a>安装 CUDA</h2><p><a href=\"https://link.zhihu.com/?target=https://developer.nvidia.com/rdp/cudnn-download\">https://link.zhihu.com/?target=https%3A//developer.nvidia.com/rdp/cudnn-download</a></p>\n<p><a href=\"https://developer.nvidia.com/login\">Log in | NVIDIA Developer</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo <span class=\"built_in\">cp</span> cuda/include/cudnn.h /usr/local/cuda/include</span><br><span class=\"line\">sudo <span class=\"built_in\">cp</span> cuda/lib64/libcudnn* /usr/local/cuda/lib64</span><br><span class=\"line\">sudo <span class=\"built_in\">chmod</span> a+r /usr/local/cuda/include/cudnn.h /usr/local/cuda/lib64/libcudnn*</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"安装-tensorflow-torch\"><a href=\"#安装-tensorflow-torch\" class=\"headerlink\" title=\"安装 tensorflow&#x2F;torch\"></a>安装 tensorflow&#x2F;torch</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://link.zhihu.com/?target=https%3A//github.com/mind/wheels/releases</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>PyTorch: <code>pip install torch</code></li>\n<li>TensorFlow: <code>pip install tensorflow</code></li>\n<li>Flax: <code>pip install flax</code></li>\n</ul>\n<p>来更新已安装的库：</p>\n<ul>\n<li>PyTorch: <code>pip install --upgrade torch</code></li>\n<li>TensorFlow: <code>pip install --upgrade tensorflow</code></li>\n<li>Flax: <code>pip install --upgrade flax</code></li>\n</ul>\n<p>安装 参考<a href=\"https://blog.csdn.net/CLOUD_J/article/details/112474224\">https://blog.csdn.net/CLOUD_J/article/details/112474224</a></p>\n<ol>\n<li><p>安装 runfile</p>\n<p><a href=\"https://developer.nvidia.com/cuda-downloads?target_os=Linux&target_arch=x86_64&Distribution=Ubuntu&target_version=22.04&target_type=runfile_local\">https://developer.nvidia.com/cuda-downloads?target_os=Linux&amp;target_arch=x86_64&amp;Distribution=Ubuntu&amp;target_version=22.04&amp;target_type=runfile_local</a></p>\n<p>选择runfile，按照给出来的指令执行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://developer.download.nvidia.com/compute/cuda/12.3.2/local_installers/cuda_12.3.2_545.23.08_linux.run</span><br><span class=\"line\">sudo sh cuda_12.3.2_545.23.08_linux.run</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>第一个ACCEPT接受</li>\n<li>第二个选择安装的东西</li>\n<li>带X的是要安装的，有驱动就把驱动关掉，只安装cuda tool kit即可</li>\n<li>然后移动到最下面install</li>\n<li>点回车</li>\n<li>等待片刻安装好了</li>\n</ol>\n</li>\n<li><p>环境变量</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim ~/.bashrc</span><br><span class=\"line\">#下面加进去有</span><br><span class=\"line\">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda/lib64</span><br><span class=\"line\">export PATH=$PATH:/usr/local/cuda/bin</span><br><span class=\"line\">export CUDA_HOME=$CUDA_HOME:/usr/local/cuda</span><br><span class=\"line\">#source一下</span><br><span class=\"line\">source ~/.bashrc</span><br><span class=\"line\"></span><br><span class=\"line\">### /usr/local/cuda-12.3/bin  实际上与上面相同</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>安装结束</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">===========</span><br><span class=\"line\">= Summary =</span><br><span class=\"line\">===========</span><br><span class=\"line\"></span><br><span class=\"line\">Driver:   Not Selected</span><br><span class=\"line\">Toolkit:  Installed in /usr/local/cuda-12.3/</span><br><span class=\"line\"></span><br><span class=\"line\">Please make sure that</span><br><span class=\"line\"> -   PATH includes /usr/local/cuda-12.3/bin</span><br><span class=\"line\"> -   LD_LIBRARY_PATH includes /usr/local/cuda-12.3/lib64, or, add /usr/local/cuda-12.3/lib64 to /etc/ld.so.conf and run ldconfig as root</span><br><span class=\"line\"></span><br><span class=\"line\">To uninstall the CUDA Toolkit, run cuda-uninstaller in /usr/local/cuda-12.3/bin</span><br><span class=\"line\">***WARNING: Incomplete installation! This installation did not install the CUDA Driver. A driver of version at least 545.00 is required for CUDA 12.3 functionality to work.</span><br><span class=\"line\">To install the driver using this installer, run the following command, replacing &lt;CudaInstaller&gt; with the name of this run file:</span><br><span class=\"line\">    sudo &lt;CudaInstaller&gt;.run --silent --driver</span><br><span class=\"line\"></span><br><span class=\"line\">Logfile is /var/log/cuda-installer.log</span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><p>nvcc -V检查安装是否成功，显示版本则成功。</p>\n<p>此时就可以执行</p>\n</li>\n<li><p>安装 CUDNN</p>\n</li>\n</ol>\n<h2 id=\"深度学习库比较\"><a href=\"#深度学习库比较\" class=\"headerlink\" title=\"深度学习库比较\"></a>深度学习库比较</h2><blockquote>\n<p>scikit-learn、PyTorch 和 Keras 的信息：</p>\n<ol>\n<li>scikit-learn（sklearn）:</li>\n</ol>\n<ul>\n<li>是一个流行的 Python 机器学习库，提供了各种经典的机器学习算法和工具。</li>\n<li>包含用于分类、回归、聚类、降维、特征选择等任务的算法。</li>\n<li>提供了数据预处理、特征工程、模型评估和模型选择的功能。</li>\n<li>具有简单且一致的API，易于使用和上手。</li>\n<li>适合处理传统机器学习任务，特别是在数据量较小或特征工程较为重要的情况下。</li>\n</ul>\n<ol start=\"2\">\n<li>PyTorch:</li>\n</ol>\n<ul>\n<li>是一个用于构建和训练神经网络的深度学习库。</li>\n<li>提供了动态计算图的能力，使得模型构建和调整更加灵活。</li>\n<li>具有丰富的深度学习函数和模块，用于处理张量操作、构建神经网络层、定义损失函数等。</li>\n<li>支持自动求导，方便进行反向传播和梯度更新。</li>\n<li>提供了灵活的调试和自定义选项，适合深入研究和开发深度学习模型。</li>\n</ul>\n<ol start=\"3\">\n<li>Keras:</li>\n</ol>\n<ul>\n<li>是一个高级的神经网络 API，用于构建和训练深度学习模型。</li>\n<li>提供了简洁、一致的接口，使得模型的原型设计和实验更加快速和便捷。</li>\n<li>可以作为 TensorFlow、Theano 和 Microsoft CNTK 等深度学习框架的后端。</li>\n<li>支持多种网络结构，包括顺序模型、函数式 API 和子类化 API。</li>\n<li>提供了丰富的预处理工具、模型评估和可视化工具。</li>\n</ul>\n</blockquote>\n<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1>","excerpt":"","more":"<p>vscode 终端不显示 环境</p>\n<p><a href=\"https://github.com/microsoft/vscode-python/wiki/Activate-Environments-in-Terminal-Using-Environment-Variables\">https://github.com/microsoft/vscode-python/wiki/Activate-Environments-in-Terminal-Using-Environment-Variables</a></p>\n<h1 id=\"相关工具\"><a href=\"#相关工具\" class=\"headerlink\" title=\"相关工具\"></a>相关工具</h1><h3 id=\"Anaconda-命令行界面使用\"><a href=\"#Anaconda-命令行界面使用\" class=\"headerlink\" title=\"Anaconda 命令行界面使用\"></a>Anaconda 命令行界面使用</h3><ol>\n<li><p>防止不是最新的，更新：</p>\n<p><code>conda update -n base -c defaults conda</code></p>\n</li>\n<li><p>查看版本：<br> <code>conda --version</code></p>\n</li>\n<li><p>管理虚拟环境</p>\n<ol>\n<li><p>active【环境名】：引导用户进入独立的环境。在不加参数的情况下，默认进入base环境。这里不加参数</p>\n</li>\n<li><p>conda create -n 【环境名】 python&#x3D;【版本号】：创建一个虚拟环境。</p>\n<p><code>conda create -n test_env python=3</code></p>\n<p>(python版本为3(这里conda会自动找python3中最新的版本下载))</p>\n</li>\n<li><p>conda env list：列出所有环境。验证。</p>\n</li>\n<li><p>activate 【环境名】：进入环境</p>\n<p><code>activate test_env</code></p>\n</li>\n<li><p>conda </p>\n</li>\n<li><p>activate 【环境名】：进入（激活）环境</p>\n</li>\n</ol>\n</li>\n<li><p>安装<br> <code>conda install 【包名】</code></p>\n</li>\n</ol>\n<h4 id=\"Conda常见命令\"><a href=\"#Conda常见命令\" class=\"headerlink\" title=\"Conda常见命令\"></a>Conda常见命令</h4><p><strong>使用 conda包管理工具需要进入<code>anaconda prompt</code></strong></p>\n<p>conda –version，输出anaconda的版本</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda install --offline ../<span class=\"built_in\">input</span>/efficient-net/dist/efficientnet_pytorch-<span class=\"number\">0.7</span><span class=\"number\">.0</span>.tar`</span><br><span class=\"line\"><span class=\"comment\"># 其中 `../input/efficient-net/dist/efficientnet_pytorch-0.7.0.tar</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n<h1 id=\"安装-python-Jupyter-版\"><a href=\"#安装-python-Jupyter-版\" class=\"headerlink\" title=\"安装 python Jupyter 版\"></a>安装 python Jupyter 版</h1><h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>Jupyter Notebook是基于网页的用于交互计算的应用程序。其可被应用于全过程计算：开发、文档编写、运行代码和展示结果。——<a href=\"https://link.zhihu.com/?target=https://jupyter-notebook.readthedocs.io/en/stable/notebook.html\">Jupyter Notebook官方介绍</a></p>\n<p>Jupyter Notebook是以网页的形式打开，可以在网页页面中<strong>直接编写代码</strong>和<strong>运行代码</strong>，代码的<strong>运行结果</strong>也会直接在代码块下显示的程序。如在编程过程中需要编写说明文档，可在同一个页面中直接编写，便于作及时的说明和解释。</p>\n<h1 id=\"安装-python\"><a href=\"#安装-python\" class=\"headerlink\" title=\"安装 python\"></a>安装 python</h1><p>参考：<a href=\"https://zhuanlan.zhihu.com/p/33105153\">https://zhuanlan.zhihu.com/p/33105153</a><br>参考：</p>\n<ol>\n<li><a href=\"https://blog.csdn.net/pythonhy/article/details/131701597\">神器 VS Code，讲讲超详细的 Python 配置使用指南_用vs code开发python需要准备什么-CSDN博客</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/643022828?utm_id=0\">Anaconda搭建python环境 - 知乎 (zhihu.com)</a></li>\n</ol>\n<p>补充：conda、anaconda概念的差别</p>\n<ol>\n<li><p>conda可以理解为一个工具，也是一个可执行命令，其核心功能是包管理与环境管理。包管理与pip的使用类似，环境管理则允许用户方便地安装不同版本的python并快速切换。</p>\n</li>\n<li><p>Anaconda是一个打包的集合，里面预装好了conda、某个版本的python、众多packages、科学计算工具等，也称为Python的一种发行版。</p>\n</li>\n</ol>\n<h2 id=\"Windows安装\"><a href=\"#Windows安装\" class=\"headerlink\" title=\"Windows安装\"></a>Windows安装</h2><h3 id=\"一、Python安装\"><a href=\"#一、Python安装\" class=\"headerlink\" title=\"一、Python安装\"></a>一、Python安装</h3><p>依照教程，Python 可以从 Python 官网下载安装，也可以使用 Anaconda 来安装。本教程选择了 用  Anaconda。</p>\n<h5 id=\"下载地址\"><a href=\"#下载地址\" class=\"headerlink\" title=\"下载地址\"></a>下载地址</h5><p><a href=\"https://www.anaconda.com/products/individual\">https://www.anaconda.com/products/individual</a></p>\n<p>下载完成之后直接按照默认设置一步步安装即可。（挺大的，5G左右，换个合适的目录）</p>\n<h3 id=\"二、Vscode-安装\"><a href=\"#二、Vscode-安装\" class=\"headerlink\" title=\"二、Vscode 安装\"></a>二、Vscode 安装</h3><p>这里好多教程，最好直接官网上下一个。</p>\n<h3 id=\"三、环境配置\"><a href=\"#三、环境配置\" class=\"headerlink\" title=\"三、环境配置\"></a>三、环境配置</h3><p>进行到这一步之后，只是工具的准备完成，但是：</p>\n<ol>\n<li>win 的 cmd 命令行 不能找到 python 指令</li>\n<li>VScode 的 终端都不能识别到 python 指令</li>\n<li>打开 Anaconda 界面，在界面中打开 VScode，可以识别 python 指令</li>\n</ol>\n<h4 id=\"环境变量配置\"><a href=\"#环境变量配置\" class=\"headerlink\" title=\"环境变量配置\"></a>环境变量配置</h4><ol>\n<li>保存 anaconda 路径到系统 “用户变量” 的 path 变量中。保存。此时 Win cmd 中就可以 识别到 conda 指令。</li>\n</ol>\n<h3 id=\"四、VScode插件安装\"><a href=\"#四、VScode插件安装\" class=\"headerlink\" title=\"四、VScode插件安装\"></a>四、VScode插件安装</h3><ol>\n<li><p>扩展插件：Python </p>\n</li>\n<li><p>代码补齐：Pylance</p>\n</li>\n<li><p>JupyterNotebook 支持：Jupyter</p>\n</li>\n<li><p>高亮缩进：indent-rainbow</p>\n</li>\n<li><p>括号高亮：Bracket pair Colorizer</p>\n</li>\n<li><p>注释高亮：Better Comments</p>\n</li>\n<li><p>settings.json</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// python </span></span><br><span class=\"line\"><span class=\"attr\">&quot;python.defaultInterpreterPath&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;D:\\\\Users\\\\fyn\\\\anaconda3\\\\python.exe&quot;</span><span class=\"punctuation\">,</span> </span><br><span class=\"line\"><span class=\"attr\">&quot;python.condaPath&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;D:\\\\Users\\\\fyn\\\\anaconda3\\\\Scripts\\\\conda-script.py&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"attr\">&quot;python.experiments.optInto&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">    <span class=\"string\">&quot;pythonTerminalEnvVarActivation&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"comment\">// &quot;python.formatting.provider&quot;: &quot;D:\\\\Users\\\\fyn\\\\anaconda3\\\\lib\\\\yapf&quot;,</span></span><br><span class=\"line\"><span class=\"comment\">// &quot;python.pythonPath&quot;: &quot;D:\\\\Users\\\\fyn\\\\anaconda3\\\\python.exe&quot;,</span></span><br><span class=\"line\"><span class=\"attr\">&quot;python.terminal.activateEnvInCurrentTerminal&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"attr\">&quot;python.terminal.activateEnvironment&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"Linux-Conda-安装\"><a href=\"#Linux-Conda-安装\" class=\"headerlink\" title=\"Linux Conda 安装\"></a>Linux Conda 安装</h2><p><a href=\"https://zhuanlan.zhihu.com/p/43348901\">Ubuntu安装anaconda,tensorflow等 - 知乎 (zhihu.com)</a></p>\n<h3 id=\"一、Conda-安装\"><a href=\"#一、Conda-安装\" class=\"headerlink\" title=\"一、Conda 安装\"></a>一、Conda 安装</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://repo.anaconda.com/archive/Anaconda3-2023.09-0-Linux-x86_64.sh</span><br><span class=\"line\">bash a*.sh</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 回车 查看协议 </span></span><br><span class=\"line\"><span class=\"comment\"># q 退出查看</span></span><br><span class=\"line\"><span class=\"comment\"># yes 确认</span></span><br><span class=\"line\"><span class=\"comment\"># 回车确定 安装目录， 一般为 /home/Anaconda  </span></span><br><span class=\"line\"><span class=\"comment\"># 对应目录增加权限方便所有用户使用 conda chmod -R a+rx /opt/anaconda3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># yes 确定通过 conda init 启动</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二、Conda-启动环境变量\"><a href=\"#二、Conda-启动环境变量\" class=\"headerlink\" title=\"二、Conda 启动环境变量\"></a>二、Conda 启动环境变量</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 首先 关闭并重新打开终端，使得conda 生效</span></span><br><span class=\"line\"><span class=\"comment\"># 升级</span></span><br><span class=\"line\">conda update -n base -c defaults conda</span><br><span class=\"line\"><span class=\"comment\"># 修改 Path</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"string\">&quot;/root/anaconda3/bin:<span class=\"variable\">$PATH</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.bashrc</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"三、Conda-修改国内源\"><a href=\"#三、Conda-修改国内源\" class=\"headerlink\" title=\"三、Conda 修改国内源\"></a>三、Conda 修改国内源</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 输入</span></span><br><span class=\"line\">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class=\"line\">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class=\"line\">conda config --<span class=\"built_in\">set</span> show_channel_urls <span class=\"built_in\">yes</span></span><br><span class=\"line\">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/</span><br><span class=\"line\">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/</span><br><span class=\"line\">conda create -n py39 python=3.9</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 若是CondaHTTPError，</span></span><br><span class=\"line\"></span><br><span class=\"line\">conda config --add channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class=\"line\">conda config --add channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class=\"line\">（http不要s)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"四、Conda-进行环境管理\"><a href=\"#四、Conda-进行环境管理\" class=\"headerlink\" title=\"四、Conda 进行环境管理\"></a>四、Conda 进行环境管理</h3><h4 id=\"环境创建\"><a href=\"#环境创建\" class=\"headerlink\" title=\"环境创建\"></a>环境创建</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看 conda 信息</span></span><br><span class=\"line\">conda info --<span class=\"built_in\">env</span></span><br><span class=\"line\"><span class=\"comment\"># 创建环境 </span></span><br><span class=\"line\">conda create -n your_env_name python=x.x</span><br><span class=\"line\">conda create -n fyn_python2 python=2.7.12</span><br><span class=\"line\"><span class=\"comment\"># 删除环境</span></span><br><span class=\"line\">conda remove -n your_env_name --all</span><br><span class=\"line\"><span class=\"comment\"># 切换环境</span></span><br><span class=\"line\">conda activate your_env_name </span><br><span class=\"line\"><span class=\"comment\"># 退出/关闭环境</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\">pip3 list --format=columns</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"利用依赖包安装环境\"><a href=\"#利用依赖包安装环境\" class=\"headerlink\" title=\"利用依赖包安装环境\"></a>利用依赖包安装环境</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install -r requirements.txt</span><br><span class=\"line\"><span class=\"comment\"># 引用清华镜像源</span></span><br><span class=\"line\"><span class=\"comment\"># -i https://pypi.tuna.tsinghua.edu.cn/simple/ </span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"生成依赖包配置\"><a href=\"#生成依赖包配置\" class=\"headerlink\" title=\"生成依赖包配置\"></a>生成依赖包配置</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 第一种，一般只适合完全相同的环境</span></span><br><span class=\"line\">pip freeze &gt; d:/requirements.txt</span><br><span class=\"line\"><span class=\"comment\"># 可能出现格式： 包名＋版本号＋@ file:///tmp/build/xxx/xxx/work</span></span><br><span class=\"line\"><span class=\"comment\"># 此格式无法在其他系统识别，</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 第二种，解决第一种的问题。</span></span><br><span class=\"line\">pip list --format=freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Linux-离线安装\"><a href=\"#Linux-离线安装\" class=\"headerlink\" title=\"Linux 离线安装\"></a>Linux 离线安装</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## 准备 离线依赖包 和 python 安装包</span></span><br><span class=\"line\"><span class=\"comment\"># 离线包安装依赖</span></span><br><span class=\"line\">yum -y localinstall ./gcc/*.rpm</span><br><span class=\"line\">yum -y localinstall ./bzip2-devel/*.rpm</span><br><span class=\"line\">yum -y localinstall ./libffi-devel/*.rpm</span><br><span class=\"line\">yum -y localinstall ./openssl-devel/*.rpm</span><br><span class=\"line\">yum -y localinstall ./zlib-devel/*.rpm</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装</span></span><br><span class=\"line\">tar -xf Python-3.9.10.tgz</span><br><span class=\"line\"><span class=\"built_in\">cd</span> Python-3.9.10</span><br><span class=\"line\">./configure --prefix=/usr/local/python-3.9.10 --enable-optimizations</span><br><span class=\"line\">make </span><br><span class=\"line\">make altinstall</span><br><span class=\"line\"><span class=\"built_in\">ln</span> -s /usr/local/python-3.9.10/bin/python3.9 /usr/bin/python3</span><br></pre></td></tr></table></figure>\n<h1 id=\"卸载-python\"><a href=\"#卸载-python\" class=\"headerlink\" title=\"卸载 python\"></a>卸载 python</h1><h2 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 卸载 python3.6---没测</span></span><br><span class=\"line\"><span class=\"built_in\">rm</span> -rf /usr/local/bin/python3</span><br><span class=\"line\"><span class=\"built_in\">rm</span> -rf /usr/local/bin/python3.6</span><br><span class=\"line\"><span class=\"built_in\">rm</span> -rf /usr/local/include/python3.6m</span><br><span class=\"line\"><span class=\"built_in\">rm</span> -rf /usr/local/lib/python3.6</span><br><span class=\"line\"><span class=\"built_in\">rm</span> -rf /usr/local/lib/libpython3.6m.a</span><br></pre></td></tr></table></figure>\n<h1 id=\"使用-python-库\"><a href=\"#使用-python-库\" class=\"headerlink\" title=\"使用 python 库\"></a>使用 python 库</h1><h2 id=\"离线包安装\"><a href=\"#离线包安装\" class=\"headerlink\" title=\"离线包安装\"></a>离线包安装</h2><ol>\n<li>打包 <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python3 -m pip download &lt;package&gt;</span><br></pre></td></tr></table></figure></li>\n<li>使用 <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install &lt;package&gt;.whl</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"安装-CUDA\"><a href=\"#安装-CUDA\" class=\"headerlink\" title=\"安装 CUDA\"></a>安装 CUDA</h2><p><a href=\"https://link.zhihu.com/?target=https://developer.nvidia.com/rdp/cudnn-download\">https://link.zhihu.com/?target=https%3A//developer.nvidia.com/rdp/cudnn-download</a></p>\n<p><a href=\"https://developer.nvidia.com/login\">Log in | NVIDIA Developer</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo <span class=\"built_in\">cp</span> cuda/include/cudnn.h /usr/local/cuda/include</span><br><span class=\"line\">sudo <span class=\"built_in\">cp</span> cuda/lib64/libcudnn* /usr/local/cuda/lib64</span><br><span class=\"line\">sudo <span class=\"built_in\">chmod</span> a+r /usr/local/cuda/include/cudnn.h /usr/local/cuda/lib64/libcudnn*</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"安装-tensorflow-torch\"><a href=\"#安装-tensorflow-torch\" class=\"headerlink\" title=\"安装 tensorflow&#x2F;torch\"></a>安装 tensorflow&#x2F;torch</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://link.zhihu.com/?target=https%3A//github.com/mind/wheels/releases</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>PyTorch: <code>pip install torch</code></li>\n<li>TensorFlow: <code>pip install tensorflow</code></li>\n<li>Flax: <code>pip install flax</code></li>\n</ul>\n<p>来更新已安装的库：</p>\n<ul>\n<li>PyTorch: <code>pip install --upgrade torch</code></li>\n<li>TensorFlow: <code>pip install --upgrade tensorflow</code></li>\n<li>Flax: <code>pip install --upgrade flax</code></li>\n</ul>\n<p>安装 参考<a href=\"https://blog.csdn.net/CLOUD_J/article/details/112474224\">https://blog.csdn.net/CLOUD_J/article/details/112474224</a></p>\n<ol>\n<li><p>安装 runfile</p>\n<p><a href=\"https://developer.nvidia.com/cuda-downloads?target_os=Linux&target_arch=x86_64&Distribution=Ubuntu&target_version=22.04&target_type=runfile_local\">https://developer.nvidia.com/cuda-downloads?target_os=Linux&amp;target_arch=x86_64&amp;Distribution=Ubuntu&amp;target_version=22.04&amp;target_type=runfile_local</a></p>\n<p>选择runfile，按照给出来的指令执行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://developer.download.nvidia.com/compute/cuda/12.3.2/local_installers/cuda_12.3.2_545.23.08_linux.run</span><br><span class=\"line\">sudo sh cuda_12.3.2_545.23.08_linux.run</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>第一个ACCEPT接受</li>\n<li>第二个选择安装的东西</li>\n<li>带X的是要安装的，有驱动就把驱动关掉，只安装cuda tool kit即可</li>\n<li>然后移动到最下面install</li>\n<li>点回车</li>\n<li>等待片刻安装好了</li>\n</ol>\n</li>\n<li><p>环境变量</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim ~/.bashrc</span><br><span class=\"line\">#下面加进去有</span><br><span class=\"line\">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda/lib64</span><br><span class=\"line\">export PATH=$PATH:/usr/local/cuda/bin</span><br><span class=\"line\">export CUDA_HOME=$CUDA_HOME:/usr/local/cuda</span><br><span class=\"line\">#source一下</span><br><span class=\"line\">source ~/.bashrc</span><br><span class=\"line\"></span><br><span class=\"line\">### /usr/local/cuda-12.3/bin  实际上与上面相同</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>安装结束</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">===========</span><br><span class=\"line\">= Summary =</span><br><span class=\"line\">===========</span><br><span class=\"line\"></span><br><span class=\"line\">Driver:   Not Selected</span><br><span class=\"line\">Toolkit:  Installed in /usr/local/cuda-12.3/</span><br><span class=\"line\"></span><br><span class=\"line\">Please make sure that</span><br><span class=\"line\"> -   PATH includes /usr/local/cuda-12.3/bin</span><br><span class=\"line\"> -   LD_LIBRARY_PATH includes /usr/local/cuda-12.3/lib64, or, add /usr/local/cuda-12.3/lib64 to /etc/ld.so.conf and run ldconfig as root</span><br><span class=\"line\"></span><br><span class=\"line\">To uninstall the CUDA Toolkit, run cuda-uninstaller in /usr/local/cuda-12.3/bin</span><br><span class=\"line\">***WARNING: Incomplete installation! This installation did not install the CUDA Driver. A driver of version at least 545.00 is required for CUDA 12.3 functionality to work.</span><br><span class=\"line\">To install the driver using this installer, run the following command, replacing &lt;CudaInstaller&gt; with the name of this run file:</span><br><span class=\"line\">    sudo &lt;CudaInstaller&gt;.run --silent --driver</span><br><span class=\"line\"></span><br><span class=\"line\">Logfile is /var/log/cuda-installer.log</span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><p>nvcc -V检查安装是否成功，显示版本则成功。</p>\n<p>此时就可以执行</p>\n</li>\n<li><p>安装 CUDNN</p>\n</li>\n</ol>\n<h2 id=\"深度学习库比较\"><a href=\"#深度学习库比较\" class=\"headerlink\" title=\"深度学习库比较\"></a>深度学习库比较</h2><blockquote>\n<p>scikit-learn、PyTorch 和 Keras 的信息：</p>\n<ol>\n<li>scikit-learn（sklearn）:</li>\n</ol>\n<ul>\n<li>是一个流行的 Python 机器学习库，提供了各种经典的机器学习算法和工具。</li>\n<li>包含用于分类、回归、聚类、降维、特征选择等任务的算法。</li>\n<li>提供了数据预处理、特征工程、模型评估和模型选择的功能。</li>\n<li>具有简单且一致的API，易于使用和上手。</li>\n<li>适合处理传统机器学习任务，特别是在数据量较小或特征工程较为重要的情况下。</li>\n</ul>\n<ol start=\"2\">\n<li>PyTorch:</li>\n</ol>\n<ul>\n<li>是一个用于构建和训练神经网络的深度学习库。</li>\n<li>提供了动态计算图的能力，使得模型构建和调整更加灵活。</li>\n<li>具有丰富的深度学习函数和模块，用于处理张量操作、构建神经网络层、定义损失函数等。</li>\n<li>支持自动求导，方便进行反向传播和梯度更新。</li>\n<li>提供了灵活的调试和自定义选项，适合深入研究和开发深度学习模型。</li>\n</ul>\n<ol start=\"3\">\n<li>Keras:</li>\n</ol>\n<ul>\n<li>是一个高级的神经网络 API，用于构建和训练深度学习模型。</li>\n<li>提供了简洁、一致的接口，使得模型的原型设计和实验更加快速和便捷。</li>\n<li>可以作为 TensorFlow、Theano 和 Microsoft CNTK 等深度学习框架的后端。</li>\n<li>支持多种网络结构，包括顺序模型、函数式 API 和子类化 API。</li>\n<li>提供了丰富的预处理工具、模型评估和可视化工具。</li>\n</ul>\n</blockquote>\n<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1>"},{"_content":"1. tinykv  --- OK\n2. 论文 —— OK \n3. 复现-------进一步实验。\n4. 老师要求的网络配置，使用虚拟机进行模拟。 周五下午来做。\n5. 准备实现，破解空间的测量，周五下午来做。","source":"_posts/日程安排/今日计划.md","raw":"1. tinykv  --- OK\n2. 论文 —— OK \n3. 复现-------进一步实验。\n4. 老师要求的网络配置，使用虚拟机进行模拟。 周五下午来做。\n5. 准备实现，破解空间的测量，周五下午来做。","slug":"日程安排/今日计划","published":1,"date":"2024-04-22T13:14:49.057Z","updated":"2024-03-27T10:44:10.292Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0e000qkgg47awqb5lz","content":"<ol>\n<li>tinykv  — OK</li>\n<li>论文 —— OK </li>\n<li>复现——-进一步实验。</li>\n<li>老师要求的网络配置，使用虚拟机进行模拟。 周五下午来做。</li>\n<li>准备实现，破解空间的测量，周五下午来做。</li>\n</ol>\n","excerpt":"","more":"<ol>\n<li>tinykv  — OK</li>\n<li>论文 —— OK </li>\n<li>复现——-进一步实验。</li>\n<li>老师要求的网络配置，使用虚拟机进行模拟。 周五下午来做。</li>\n<li>准备实现，破解空间的测量，周五下午来做。</li>\n</ol>\n"},{"_content":"bellcrackit => mimacracker\n\nbell =>mmck\n\nhttp://192.168.3.19:9090/api/server.php\n\n\nFound existing lock.pid, checking if python process is running...\nIgnoringlock.pid filebecause PID is not existent anymore or not running python! \nStarting client 's3-python-0.7.1'... \nPlease enter the url to the API of your MimaCracker installation:\n\n\n![[Pasted image 20240319155428.png]]\n\n","source":"_posts/日程安排/草稿.md","raw":"bellcrackit => mimacracker\n\nbell =>mmck\n\nhttp://192.168.3.19:9090/api/server.php\n\n\nFound existing lock.pid, checking if python process is running...\nIgnoringlock.pid filebecause PID is not existent anymore or not running python! \nStarting client 's3-python-0.7.1'... \nPlease enter the url to the API of your MimaCracker installation:\n\n\n![[Pasted image 20240319155428.png]]\n\n","slug":"日程安排/草稿","published":1,"date":"2024-04-22T13:14:49.077Z","updated":"2024-03-19T08:02:07.253Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0e000rkgg417wlhms7","content":"<p>bellcrackit &#x3D;&gt; mimacracker</p>\n<p>bell &#x3D;&gt;mmck</p>\n<p><a href=\"http://192.168.3.19:9090/api/server.php\">http://192.168.3.19:9090/api/server.php</a></p>\n<p>Found existing lock.pid, checking if python process is running…<br>Ignoringlock.pid filebecause PID is not existent anymore or not running python!<br>Starting client ‘s3-python-0.7.1’…<br>Please enter the url to the API of your MimaCracker installation:</p>\n<p>![[Pasted image 20240319155428.png]]</p>\n","excerpt":"","more":"<p>bellcrackit &#x3D;&gt; mimacracker</p>\n<p>bell &#x3D;&gt;mmck</p>\n<p><a href=\"http://192.168.3.19:9090/api/server.php\">http://192.168.3.19:9090/api/server.php</a></p>\n<p>Found existing lock.pid, checking if python process is running…<br>Ignoringlock.pid filebecause PID is not existent anymore or not running python!<br>Starting client ‘s3-python-0.7.1’…<br>Please enter the url to the API of your MimaCracker installation:</p>\n<p>![[Pasted image 20240319155428.png]]</p>\n"},{"_content":"1. 网络的端口服务测试  ok\n3. 密码空间优化    ok\n4. zip推荐  ok\n5. 剩余时间---后续  ok\n6. 下载相关离线包     ok\n7. bug --- 密钥空间 ：因为后续计算密钥空间了！！，前面某些密钥空间是 0\n8. bug---- .后缀 的 归档任务 详情无法打开。\n9. bug --- 进度： ok\n10. bug --- 文件删除问题：\n\n\nTODO:\n1. 运行 md5  破解。do ing  下载字典有点久\n2. 整理包。 ---- \n3. 整理指令。————— TODO \n\nFactory::getTaskFactory()->set($task, Task::KEYSPACE, $keyspace);\n      DServerLog::log(DServerLog::TRACE, \"已保存 Keyspace\", [$this->agent, $task]);\n         $this->sendResponse(array(\n\n        PResponseSendKeyspace::ACTION => PActions::SEND_KEYSPACE,\n\n        PResponseSendKeyspace::RESPONSE => PValues::SUCCESS,\n\n        PResponseSendKeyspace::KEYSPACE => PValues::OK\n\n      )\n\n    );\n   $task->setKeyspace(Factory::getFileFactory()->get($fileId)->getLineCount());\nFactory::getFileFactory()->get($fileId)->getLineCount(),\n\n\nmsgs = \n[\n{MsgRequestVote 1 1 0 0 0 [] 0 <nil> false {} [] 0} {MsgRequestVote 1 1 0 0 0 [] 0 <nil> false {} [] 0} \n{MsgRequestVote 2 1 0 0 0 [] 0 <nil> false {} [] 0} {MsgRequestVote 2 1 0 0 0 [] 0 <nil> false {} [] 0} \n{MsgRequestVote 3 1 0 0 0 [] 0 <nil> false {} [] 0} {MsgRequestVote 3 1 0 0 0 [] 0 <nil> false {} [] 0}\n],\nwant [\n{MsgRequestVote 2 1 2 0 0 [] 0 <nil> false {} [] 0} {MsgRequestVote 3 1 2 0 0 [] 0 <nil> false {} [] 0}\n]\n\n","source":"_posts/日程安排/TEMP.md","raw":"1. 网络的端口服务测试  ok\n3. 密码空间优化    ok\n4. zip推荐  ok\n5. 剩余时间---后续  ok\n6. 下载相关离线包     ok\n7. bug --- 密钥空间 ：因为后续计算密钥空间了！！，前面某些密钥空间是 0\n8. bug---- .后缀 的 归档任务 详情无法打开。\n9. bug --- 进度： ok\n10. bug --- 文件删除问题：\n\n\nTODO:\n1. 运行 md5  破解。do ing  下载字典有点久\n2. 整理包。 ---- \n3. 整理指令。————— TODO \n\nFactory::getTaskFactory()->set($task, Task::KEYSPACE, $keyspace);\n      DServerLog::log(DServerLog::TRACE, \"已保存 Keyspace\", [$this->agent, $task]);\n         $this->sendResponse(array(\n\n        PResponseSendKeyspace::ACTION => PActions::SEND_KEYSPACE,\n\n        PResponseSendKeyspace::RESPONSE => PValues::SUCCESS,\n\n        PResponseSendKeyspace::KEYSPACE => PValues::OK\n\n      )\n\n    );\n   $task->setKeyspace(Factory::getFileFactory()->get($fileId)->getLineCount());\nFactory::getFileFactory()->get($fileId)->getLineCount(),\n\n\nmsgs = \n[\n{MsgRequestVote 1 1 0 0 0 [] 0 <nil> false {} [] 0} {MsgRequestVote 1 1 0 0 0 [] 0 <nil> false {} [] 0} \n{MsgRequestVote 2 1 0 0 0 [] 0 <nil> false {} [] 0} {MsgRequestVote 2 1 0 0 0 [] 0 <nil> false {} [] 0} \n{MsgRequestVote 3 1 0 0 0 [] 0 <nil> false {} [] 0} {MsgRequestVote 3 1 0 0 0 [] 0 <nil> false {} [] 0}\n],\nwant [\n{MsgRequestVote 2 1 2 0 0 [] 0 <nil> false {} [] 0} {MsgRequestVote 3 1 2 0 0 [] 0 <nil> false {} [] 0}\n]\n\n","slug":"日程安排/TEMP","published":1,"date":"2024-04-22T13:14:49.057Z","updated":"2024-04-09T01:53:23.586Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0e000skgg4e3cih8sr","content":"<ol>\n<li>网络的端口服务测试  ok</li>\n<li>密码空间优化    ok</li>\n<li>zip推荐  ok</li>\n<li>剩余时间—后续  ok</li>\n<li>下载相关离线包     ok</li>\n<li>bug — 密钥空间 ：因为后续计算密钥空间了！！，前面某些密钥空间是 0</li>\n<li>bug—- .后缀 的 归档任务 详情无法打开。</li>\n<li>bug — 进度： ok</li>\n<li>bug — 文件删除问题：</li>\n</ol>\n<p>TODO:</p>\n<ol>\n<li>运行 md5  破解。do ing  下载字典有点久</li>\n<li>整理包。 —- </li>\n<li>整理指令。————— TODO</li>\n</ol>\n<p>Factory::getTaskFactory()-&gt;set($task, Task::KEYSPACE, $keyspace);<br>      DServerLog::log(DServerLog::TRACE, “已保存 Keyspace”, [$this-&gt;agent, $task]);<br>         $this-&gt;sendResponse(array(</p>\n<p>        PResponseSendKeyspace::ACTION &#x3D;&gt; PActions::SEND_KEYSPACE,</p>\n<p>        PResponseSendKeyspace::RESPONSE &#x3D;&gt; PValues::SUCCESS,</p>\n<p>        PResponseSendKeyspace::KEYSPACE &#x3D;&gt; PValues::OK</p>\n<p>      )</p>\n<p>    );<br>   $task-&gt;setKeyspace(Factory::getFileFactory()-&gt;get($fileId)-&gt;getLineCount());<br>Factory::getFileFactory()-&gt;get($fileId)-&gt;getLineCount(),</p>\n<p>msgs &#x3D;<br>[<br>{MsgRequestVote 1 1 0 0 0 [] 0 <nil> false {} [] 0} {MsgRequestVote 1 1 0 0 0 [] 0 <nil> false {} [] 0}<br>{MsgRequestVote 2 1 0 0 0 [] 0 <nil> false {} [] 0} {MsgRequestVote 2 1 0 0 0 [] 0 <nil> false {} [] 0}<br>{MsgRequestVote 3 1 0 0 0 [] 0 <nil> false {} [] 0} {MsgRequestVote 3 1 0 0 0 [] 0 <nil> false {} [] 0}<br>],<br>want [<br>{MsgRequestVote 2 1 2 0 0 [] 0 <nil> false {} [] 0} {MsgRequestVote 3 1 2 0 0 [] 0 <nil> false {} [] 0}<br>]</p>\n","excerpt":"","more":"<ol>\n<li>网络的端口服务测试  ok</li>\n<li>密码空间优化    ok</li>\n<li>zip推荐  ok</li>\n<li>剩余时间—后续  ok</li>\n<li>下载相关离线包     ok</li>\n<li>bug — 密钥空间 ：因为后续计算密钥空间了！！，前面某些密钥空间是 0</li>\n<li>bug—- .后缀 的 归档任务 详情无法打开。</li>\n<li>bug — 进度： ok</li>\n<li>bug — 文件删除问题：</li>\n</ol>\n<p>TODO:</p>\n<ol>\n<li>运行 md5  破解。do ing  下载字典有点久</li>\n<li>整理包。 —- </li>\n<li>整理指令。————— TODO</li>\n</ol>\n<p>Factory::getTaskFactory()-&gt;set($task, Task::KEYSPACE, $keyspace);<br>      DServerLog::log(DServerLog::TRACE, “已保存 Keyspace”, [$this-&gt;agent, $task]);<br>         $this-&gt;sendResponse(array(</p>\n<p>        PResponseSendKeyspace::ACTION &#x3D;&gt; PActions::SEND_KEYSPACE,</p>\n<p>        PResponseSendKeyspace::RESPONSE &#x3D;&gt; PValues::SUCCESS,</p>\n<p>        PResponseSendKeyspace::KEYSPACE &#x3D;&gt; PValues::OK</p>\n<p>      )</p>\n<p>    );<br>   $task-&gt;setKeyspace(Factory::getFileFactory()-&gt;get($fileId)-&gt;getLineCount());<br>Factory::getFileFactory()-&gt;get($fileId)-&gt;getLineCount(),</p>\n<p>msgs &#x3D;<br>[<br>{MsgRequestVote 1 1 0 0 0 [] 0 <nil> false {} [] 0} {MsgRequestVote 1 1 0 0 0 [] 0 <nil> false {} [] 0}<br>{MsgRequestVote 2 1 0 0 0 [] 0 <nil> false {} [] 0} {MsgRequestVote 2 1 0 0 0 [] 0 <nil> false {} [] 0}<br>{MsgRequestVote 3 1 0 0 0 [] 0 <nil> false {} [] 0} {MsgRequestVote 3 1 0 0 0 [] 0 <nil> false {} [] 0}<br>],<br>want [<br>{MsgRequestVote 2 1 2 0 0 [] 0 <nil> false {} [] 0} {MsgRequestVote 3 1 2 0 0 [] 0 <nil> false {} [] 0}<br>]</p>\n"},{"_content":"\n\n[[近期计划]]\n[[今日计划]]\n\n\n[[日程安排/TEMP]]\n\n[[草稿]]","source":"_posts/日程安排/工作日志.md","raw":"\n\n[[近期计划]]\n[[今日计划]]\n\n\n[[日程安排/TEMP]]\n\n[[草稿]]","slug":"日程安排/工作日志","published":1,"date":"2024-04-22T13:14:49.076Z","updated":"2024-04-16T13:01:37.004Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0e000tkgg48v2bdsy1","content":"<p>[[近期计划]]<br>[[今日计划]]</p>\n<p>[[日程安排&#x2F;TEMP]]</p>\n<p>[[草稿]]</p>\n","excerpt":"","more":"<p>[[近期计划]]<br>[[今日计划]]</p>\n<p>[[日程安排&#x2F;TEMP]]</p>\n<p>[[草稿]]</p>\n"},{"_content":"# 2024-02-04 \n1. 整理一下github如何搭建博客，其实就是建立一个仓库\n\t这里的 内容相对来说其实其实就只是一个文档的上传功能，\n2. 整理一下 csdn\n\t确实需要，但是这个整理是在逐渐完善文档之后才需要发布的\n3. 浏览工作网站，定成长路线。\n\t**需要下载几个软件**\n\t\t晚上睡觉看看\n4. 优化一下 go 的grpc，Go的\n\t**确实需要整理**\n\t\t\n5. 整理一下 论文方向\n\t1. 老师要求看看大模型和字典生成相关的事情。\n\t2. 我是重点看大模型，--分支看看字典相关的事情\n\n6. 整理 图说数据库内容，\n\t1. 就两个部分，读文档，百度，google 抄就完事了\n### 基本安排\n晚上睡觉看看博客啥的，就业相关\n晚上看看grpc 相关 和 go 语言， 优先 grpc 相关，整理为一个开源项目\n早上整理文档，数据库基本知识。\n\n\n## 就业APP\n\n一、BOSS  \n■优点  \n1.回复率高。直接和hr或者boss谈的机制，能让你投递岗位后很快就能直接得到回应。  \n2.招聘周期短，功能性岗位多。例如推销，营销，人力，行政，后勤等岗位，boss直聘的招聘效率都不错。  \n■缺点  \n1.薪资虚假，很多公司标的薪资和实际薪姿不符。  \n2.审核把关不严，岗位质量良不齐。  \n■推荐人群（应届生，工作1-3年的求职者）  \n刚开始找工作或者是刚离职的求职者，往往急需更换工作，缩短求职周期，期待得到及时的面试反馈。  \n  \n二、智联招聘/前程无忧  \n■优点  \n1.基础性岗位，传统行业岗位都比较全面，大中小各类规模的企业覆盖比较齐全。基本上你想找的工作行业和类别，智联招聘都囊括了。  \n2.软件下沉做得比较好，三四线及以下城市工作岗位比较多。  \n■缺点  \n1.反馈很慢，投递简历后石沉大海的情况比比皆是。  \n2.推荐岗位不匹配，岗位和薪资挂羊头卖狗肉的情况也比较多，需要你擦亮眼睛。  \n■推荐人群（全年龄段求职者）  \n适合广撒网，多积粮的求职者，由于岗位覆盖面全，适合传统行业，基础性岗位，小众专业的求职者找工作，在三四线城市比较适用。 \n\n三、拉勾  \n■优点  \n1.主打互联网行业，垂直度和专业程度比较高。  \n2.页面简洁，互联网岗位的搜索和筛选都很便捷。  \n3.同类岗位推荐和一键投递功能不要太爽有木有，投简历就完事儿了！  \n■缺点  \n1.反馈也很慢，需要耐心等待。  \n2.垂直度高既是优点也是缺点，其他行业的岗位不够全面。  \n■推荐人群（互联网求职者首选）  \n一线和新一线城市互联网岗位求职者的首选，想进互联网大厂，拉钩是个很好的选择。\n\n","source":"_posts/日程安排/近期计划.md","raw":"# 2024-02-04 \n1. 整理一下github如何搭建博客，其实就是建立一个仓库\n\t这里的 内容相对来说其实其实就只是一个文档的上传功能，\n2. 整理一下 csdn\n\t确实需要，但是这个整理是在逐渐完善文档之后才需要发布的\n3. 浏览工作网站，定成长路线。\n\t**需要下载几个软件**\n\t\t晚上睡觉看看\n4. 优化一下 go 的grpc，Go的\n\t**确实需要整理**\n\t\t\n5. 整理一下 论文方向\n\t1. 老师要求看看大模型和字典生成相关的事情。\n\t2. 我是重点看大模型，--分支看看字典相关的事情\n\n6. 整理 图说数据库内容，\n\t1. 就两个部分，读文档，百度，google 抄就完事了\n### 基本安排\n晚上睡觉看看博客啥的，就业相关\n晚上看看grpc 相关 和 go 语言， 优先 grpc 相关，整理为一个开源项目\n早上整理文档，数据库基本知识。\n\n\n## 就业APP\n\n一、BOSS  \n■优点  \n1.回复率高。直接和hr或者boss谈的机制，能让你投递岗位后很快就能直接得到回应。  \n2.招聘周期短，功能性岗位多。例如推销，营销，人力，行政，后勤等岗位，boss直聘的招聘效率都不错。  \n■缺点  \n1.薪资虚假，很多公司标的薪资和实际薪姿不符。  \n2.审核把关不严，岗位质量良不齐。  \n■推荐人群（应届生，工作1-3年的求职者）  \n刚开始找工作或者是刚离职的求职者，往往急需更换工作，缩短求职周期，期待得到及时的面试反馈。  \n  \n二、智联招聘/前程无忧  \n■优点  \n1.基础性岗位，传统行业岗位都比较全面，大中小各类规模的企业覆盖比较齐全。基本上你想找的工作行业和类别，智联招聘都囊括了。  \n2.软件下沉做得比较好，三四线及以下城市工作岗位比较多。  \n■缺点  \n1.反馈很慢，投递简历后石沉大海的情况比比皆是。  \n2.推荐岗位不匹配，岗位和薪资挂羊头卖狗肉的情况也比较多，需要你擦亮眼睛。  \n■推荐人群（全年龄段求职者）  \n适合广撒网，多积粮的求职者，由于岗位覆盖面全，适合传统行业，基础性岗位，小众专业的求职者找工作，在三四线城市比较适用。 \n\n三、拉勾  \n■优点  \n1.主打互联网行业，垂直度和专业程度比较高。  \n2.页面简洁，互联网岗位的搜索和筛选都很便捷。  \n3.同类岗位推荐和一键投递功能不要太爽有木有，投简历就完事儿了！  \n■缺点  \n1.反馈也很慢，需要耐心等待。  \n2.垂直度高既是优点也是缺点，其他行业的岗位不够全面。  \n■推荐人群（互联网求职者首选）  \n一线和新一线城市互联网岗位求职者的首选，想进互联网大厂，拉钩是个很好的选择。\n\n","slug":"日程安排/近期计划","published":1,"date":"2024-04-22T13:14:49.078Z","updated":"2024-02-22T02:49:54.802Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0e000ukgg4adhe66u7","content":"<h1 id=\"2024-02-04\"><a href=\"#2024-02-04\" class=\"headerlink\" title=\"2024-02-04\"></a>2024-02-04</h1><ol>\n<li><p>整理一下github如何搭建博客，其实就是建立一个仓库<br> 这里的 内容相对来说其实其实就只是一个文档的上传功能，</p>\n</li>\n<li><p>整理一下 csdn<br> 确实需要，但是这个整理是在逐渐完善文档之后才需要发布的</p>\n</li>\n<li><p>浏览工作网站，定成长路线。<br> <strong>需要下载几个软件</strong><br> 晚上睡觉看看</p>\n</li>\n<li><p>优化一下 go 的grpc，Go的<br> <strong>确实需要整理</strong></p>\n</li>\n<li><p>整理一下 论文方向</p>\n<ol>\n<li>老师要求看看大模型和字典生成相关的事情。</li>\n<li>我是重点看大模型，–分支看看字典相关的事情</li>\n</ol>\n</li>\n<li><p>整理 图说数据库内容，</p>\n<ol>\n<li>就两个部分，读文档，百度，google 抄就完事了</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"基本安排\"><a href=\"#基本安排\" class=\"headerlink\" title=\"基本安排\"></a>基本安排</h3><p>晚上睡觉看看博客啥的，就业相关<br>晚上看看grpc 相关 和 go 语言， 优先 grpc 相关，整理为一个开源项目<br>早上整理文档，数据库基本知识。</p>\n<h2 id=\"就业APP\"><a href=\"#就业APP\" class=\"headerlink\" title=\"就业APP\"></a>就业APP</h2><p>一、BOSS<br>■优点<br>1.回复率高。直接和hr或者boss谈的机制，能让你投递岗位后很快就能直接得到回应。<br>2.招聘周期短，功能性岗位多。例如推销，营销，人力，行政，后勤等岗位，boss直聘的招聘效率都不错。<br>■缺点<br>1.薪资虚假，很多公司标的薪资和实际薪姿不符。<br>2.审核把关不严，岗位质量良不齐。<br>■推荐人群（应届生，工作1-3年的求职者）<br>刚开始找工作或者是刚离职的求职者，往往急需更换工作，缩短求职周期，期待得到及时的面试反馈。  </p>\n<p>二、智联招聘&#x2F;前程无忧<br>■优点<br>1.基础性岗位，传统行业岗位都比较全面，大中小各类规模的企业覆盖比较齐全。基本上你想找的工作行业和类别，智联招聘都囊括了。<br>2.软件下沉做得比较好，三四线及以下城市工作岗位比较多。<br>■缺点<br>1.反馈很慢，投递简历后石沉大海的情况比比皆是。<br>2.推荐岗位不匹配，岗位和薪资挂羊头卖狗肉的情况也比较多，需要你擦亮眼睛。<br>■推荐人群（全年龄段求职者）<br>适合广撒网，多积粮的求职者，由于岗位覆盖面全，适合传统行业，基础性岗位，小众专业的求职者找工作，在三四线城市比较适用。 </p>\n<p>三、拉勾<br>■优点<br>1.主打互联网行业，垂直度和专业程度比较高。<br>2.页面简洁，互联网岗位的搜索和筛选都很便捷。<br>3.同类岗位推荐和一键投递功能不要太爽有木有，投简历就完事儿了！<br>■缺点<br>1.反馈也很慢，需要耐心等待。<br>2.垂直度高既是优点也是缺点，其他行业的岗位不够全面。<br>■推荐人群（互联网求职者首选）<br>一线和新一线城市互联网岗位求职者的首选，想进互联网大厂，拉钩是个很好的选择。</p>\n","excerpt":"","more":"<h1 id=\"2024-02-04\"><a href=\"#2024-02-04\" class=\"headerlink\" title=\"2024-02-04\"></a>2024-02-04</h1><ol>\n<li><p>整理一下github如何搭建博客，其实就是建立一个仓库<br> 这里的 内容相对来说其实其实就只是一个文档的上传功能，</p>\n</li>\n<li><p>整理一下 csdn<br> 确实需要，但是这个整理是在逐渐完善文档之后才需要发布的</p>\n</li>\n<li><p>浏览工作网站，定成长路线。<br> <strong>需要下载几个软件</strong><br> 晚上睡觉看看</p>\n</li>\n<li><p>优化一下 go 的grpc，Go的<br> <strong>确实需要整理</strong></p>\n</li>\n<li><p>整理一下 论文方向</p>\n<ol>\n<li>老师要求看看大模型和字典生成相关的事情。</li>\n<li>我是重点看大模型，–分支看看字典相关的事情</li>\n</ol>\n</li>\n<li><p>整理 图说数据库内容，</p>\n<ol>\n<li>就两个部分，读文档，百度，google 抄就完事了</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"基本安排\"><a href=\"#基本安排\" class=\"headerlink\" title=\"基本安排\"></a>基本安排</h3><p>晚上睡觉看看博客啥的，就业相关<br>晚上看看grpc 相关 和 go 语言， 优先 grpc 相关，整理为一个开源项目<br>早上整理文档，数据库基本知识。</p>\n<h2 id=\"就业APP\"><a href=\"#就业APP\" class=\"headerlink\" title=\"就业APP\"></a>就业APP</h2><p>一、BOSS<br>■优点<br>1.回复率高。直接和hr或者boss谈的机制，能让你投递岗位后很快就能直接得到回应。<br>2.招聘周期短，功能性岗位多。例如推销，营销，人力，行政，后勤等岗位，boss直聘的招聘效率都不错。<br>■缺点<br>1.薪资虚假，很多公司标的薪资和实际薪姿不符。<br>2.审核把关不严，岗位质量良不齐。<br>■推荐人群（应届生，工作1-3年的求职者）<br>刚开始找工作或者是刚离职的求职者，往往急需更换工作，缩短求职周期，期待得到及时的面试反馈。  </p>\n<p>二、智联招聘&#x2F;前程无忧<br>■优点<br>1.基础性岗位，传统行业岗位都比较全面，大中小各类规模的企业覆盖比较齐全。基本上你想找的工作行业和类别，智联招聘都囊括了。<br>2.软件下沉做得比较好，三四线及以下城市工作岗位比较多。<br>■缺点<br>1.反馈很慢，投递简历后石沉大海的情况比比皆是。<br>2.推荐岗位不匹配，岗位和薪资挂羊头卖狗肉的情况也比较多，需要你擦亮眼睛。<br>■推荐人群（全年龄段求职者）<br>适合广撒网，多积粮的求职者，由于岗位覆盖面全，适合传统行业，基础性岗位，小众专业的求职者找工作，在三四线城市比较适用。 </p>\n<p>三、拉勾<br>■优点<br>1.主打互联网行业，垂直度和专业程度比较高。<br>2.页面简洁，互联网岗位的搜索和筛选都很便捷。<br>3.同类岗位推荐和一键投递功能不要太爽有木有，投简历就完事儿了！<br>■缺点<br>1.反馈也很慢，需要耐心等待。<br>2.垂直度高既是优点也是缺点，其他行业的岗位不够全面。<br>■推荐人群（互联网求职者首选）<br>一线和新一线城市互联网岗位求职者的首选，想进互联网大厂，拉钩是个很好的选择。</p>\n"},{"_content":"在这个充满喜悦和爱的日子里，我们聚集一堂，庆祝我亲爱的外甥和他的爱人步入婚姻的殿堂。作为家族的长辈，我感到无比的骄傲和幸福。\n\n回望过去，我见证了我的外甥从一个天真无邪的孩童成长为今天这个成熟、负责任的年轻人。今天，他终于与心爱的人一起，准备开始自己的新生活，我感到非常的开心。\n\n在此，我想对你们两位年轻人说几句话：\n亲爱的昕琦，作为你的外公，我深深为你感到骄傲。我着你长大，也看到你的善良、你的稳重与勇敢，我就知道，你绝对会是个好伴侣，也会是家里的那个靠山。\n李娜，我欢迎你加入我们的大家庭。我们也见过不少面了，你带来的，不仅是你俩之间的爱情，还有你的笑声、以及你那会让周围人都感到舒服的幽默感。我看得出来，你是那种能在任何情况下都能让昕琦感到支持和安心的人。我真心觉得，无论是好天还是坏天，你都会和（你的名字）肩并肩，一起撑起这个家。\n\n接下来，我真心希望，从今往后的每一天，你们都能更加深入地了解对方，更加珍惜彼此。咱们都知道，生活偶尔会给我们来点小挑战，但只要你们一直手拉手，心连心，那么没有什么困难是过不去的。\n\n最重要的，我期待你们能一起建立一个充满爱、笑声不断、幸福满满的家。就像你们从小在我们这个大家庭中感受到的那样温馨和美好。\n\n此刻，我想要对你们表达我所有的祝福。愿你们的爱情永远美丽如今日，愿你们对未来的承诺，比今天的誓言更加坚定不移。\n\n祝福你们，新婚快乐。\n\n谢谢大家。\n","source":"_posts/生活琐事/祝词.md","raw":"在这个充满喜悦和爱的日子里，我们聚集一堂，庆祝我亲爱的外甥和他的爱人步入婚姻的殿堂。作为家族的长辈，我感到无比的骄傲和幸福。\n\n回望过去，我见证了我的外甥从一个天真无邪的孩童成长为今天这个成熟、负责任的年轻人。今天，他终于与心爱的人一起，准备开始自己的新生活，我感到非常的开心。\n\n在此，我想对你们两位年轻人说几句话：\n亲爱的昕琦，作为你的外公，我深深为你感到骄傲。我着你长大，也看到你的善良、你的稳重与勇敢，我就知道，你绝对会是个好伴侣，也会是家里的那个靠山。\n李娜，我欢迎你加入我们的大家庭。我们也见过不少面了，你带来的，不仅是你俩之间的爱情，还有你的笑声、以及你那会让周围人都感到舒服的幽默感。我看得出来，你是那种能在任何情况下都能让昕琦感到支持和安心的人。我真心觉得，无论是好天还是坏天，你都会和（你的名字）肩并肩，一起撑起这个家。\n\n接下来，我真心希望，从今往后的每一天，你们都能更加深入地了解对方，更加珍惜彼此。咱们都知道，生活偶尔会给我们来点小挑战，但只要你们一直手拉手，心连心，那么没有什么困难是过不去的。\n\n最重要的，我期待你们能一起建立一个充满爱、笑声不断、幸福满满的家。就像你们从小在我们这个大家庭中感受到的那样温馨和美好。\n\n此刻，我想要对你们表达我所有的祝福。愿你们的爱情永远美丽如今日，愿你们对未来的承诺，比今天的誓言更加坚定不移。\n\n祝福你们，新婚快乐。\n\n谢谢大家。\n","slug":"生活琐事/祝词","published":1,"date":"2024-04-22T13:14:49.156Z","updated":"2024-03-26T10:14:00.676Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0f000vkgg47snjdtix","content":"<p>在这个充满喜悦和爱的日子里，我们聚集一堂，庆祝我亲爱的外甥和他的爱人步入婚姻的殿堂。作为家族的长辈，我感到无比的骄傲和幸福。</p>\n<p>回望过去，我见证了我的外甥从一个天真无邪的孩童成长为今天这个成熟、负责任的年轻人。今天，他终于与心爱的人一起，准备开始自己的新生活，我感到非常的开心。</p>\n<p>在此，我想对你们两位年轻人说几句话：<br>亲爱的昕琦，作为你的外公，我深深为你感到骄傲。我着你长大，也看到你的善良、你的稳重与勇敢，我就知道，你绝对会是个好伴侣，也会是家里的那个靠山。<br>李娜，我欢迎你加入我们的大家庭。我们也见过不少面了，你带来的，不仅是你俩之间的爱情，还有你的笑声、以及你那会让周围人都感到舒服的幽默感。我看得出来，你是那种能在任何情况下都能让昕琦感到支持和安心的人。我真心觉得，无论是好天还是坏天，你都会和（你的名字）肩并肩，一起撑起这个家。</p>\n<p>接下来，我真心希望，从今往后的每一天，你们都能更加深入地了解对方，更加珍惜彼此。咱们都知道，生活偶尔会给我们来点小挑战，但只要你们一直手拉手，心连心，那么没有什么困难是过不去的。</p>\n<p>最重要的，我期待你们能一起建立一个充满爱、笑声不断、幸福满满的家。就像你们从小在我们这个大家庭中感受到的那样温馨和美好。</p>\n<p>此刻，我想要对你们表达我所有的祝福。愿你们的爱情永远美丽如今日，愿你们对未来的承诺，比今天的誓言更加坚定不移。</p>\n<p>祝福你们，新婚快乐。</p>\n<p>谢谢大家。</p>\n","excerpt":"","more":"<p>在这个充满喜悦和爱的日子里，我们聚集一堂，庆祝我亲爱的外甥和他的爱人步入婚姻的殿堂。作为家族的长辈，我感到无比的骄傲和幸福。</p>\n<p>回望过去，我见证了我的外甥从一个天真无邪的孩童成长为今天这个成熟、负责任的年轻人。今天，他终于与心爱的人一起，准备开始自己的新生活，我感到非常的开心。</p>\n<p>在此，我想对你们两位年轻人说几句话：<br>亲爱的昕琦，作为你的外公，我深深为你感到骄傲。我着你长大，也看到你的善良、你的稳重与勇敢，我就知道，你绝对会是个好伴侣，也会是家里的那个靠山。<br>李娜，我欢迎你加入我们的大家庭。我们也见过不少面了，你带来的，不仅是你俩之间的爱情，还有你的笑声、以及你那会让周围人都感到舒服的幽默感。我看得出来，你是那种能在任何情况下都能让昕琦感到支持和安心的人。我真心觉得，无论是好天还是坏天，你都会和（你的名字）肩并肩，一起撑起这个家。</p>\n<p>接下来，我真心希望，从今往后的每一天，你们都能更加深入地了解对方，更加珍惜彼此。咱们都知道，生活偶尔会给我们来点小挑战，但只要你们一直手拉手，心连心，那么没有什么困难是过不去的。</p>\n<p>最重要的，我期待你们能一起建立一个充满爱、笑声不断、幸福满满的家。就像你们从小在我们这个大家庭中感受到的那样温馨和美好。</p>\n<p>此刻，我想要对你们表达我所有的祝福。愿你们的爱情永远美丽如今日，愿你们对未来的承诺，比今天的誓言更加坚定不移。</p>\n<p>祝福你们，新婚快乐。</p>\n<p>谢谢大家。</p>\n"},{"_content":"[[中国计算机学会推荐国际学术会议和期刊目录-2019.pdf]]\n# 会议级别\nei 会议 < ei 期刊 <  sci | ssci\n\n\n[会议信息 | 2023年12月截稿的密码学与信息安全会议整理 (qq.com)](https://mp.weixin.qq.com/s?__biz=MzkwMTM0NzU1MQ==&mid=2247505285&idx=1&sn=8f2fbac906e7bba64545fe9a30b8435e&chksm=c0b4b435f7c33d234329c1bdfa5e39fa1191cbb409b75b5dd7b412e54d12c7838211e74f0d97&scene=27)\n\n\n\n# 主要依据\n|         |     |\n| ------- | --- |\n| 期刊CCF等级 | 未收录 |\n| JCR分区   | Q2  |\n|         |     |\n|         |     |\n|         |     |\n\nJCR分区是通过将一个学科内收录的期刊总数分为四等份来进行的，其中影响因子排名前25%的期刊为一区（Q1），26-50%为二区（Q2），51-75%为三区（Q3），76-100%为四区（Q4）\n\nCCF分类则是中国计算机学会（CCF）对计算机科学领域的期刊和会议进行的评级，基于期刊和会议的国际影响力、学术水平等因素，通过将它们划分为不同的等级（A、B、C），\n\n中科院期刊分区根据13个大类学科，分别将各大类的SCI期刊由3年平均影响因子划分为 1 区（最高区）、2区、3区和4区四个等级。这种分区标准也被更多的机构采纳以作为科研评价的指标。","source":"_posts/研究方向/会议调研.md","raw":"[[中国计算机学会推荐国际学术会议和期刊目录-2019.pdf]]\n# 会议级别\nei 会议 < ei 期刊 <  sci | ssci\n\n\n[会议信息 | 2023年12月截稿的密码学与信息安全会议整理 (qq.com)](https://mp.weixin.qq.com/s?__biz=MzkwMTM0NzU1MQ==&mid=2247505285&idx=1&sn=8f2fbac906e7bba64545fe9a30b8435e&chksm=c0b4b435f7c33d234329c1bdfa5e39fa1191cbb409b75b5dd7b412e54d12c7838211e74f0d97&scene=27)\n\n\n\n# 主要依据\n|         |     |\n| ------- | --- |\n| 期刊CCF等级 | 未收录 |\n| JCR分区   | Q2  |\n|         |     |\n|         |     |\n|         |     |\n\nJCR分区是通过将一个学科内收录的期刊总数分为四等份来进行的，其中影响因子排名前25%的期刊为一区（Q1），26-50%为二区（Q2），51-75%为三区（Q3），76-100%为四区（Q4）\n\nCCF分类则是中国计算机学会（CCF）对计算机科学领域的期刊和会议进行的评级，基于期刊和会议的国际影响力、学术水平等因素，通过将它们划分为不同的等级（A、B、C），\n\n中科院期刊分区根据13个大类学科，分别将各大类的SCI期刊由3年平均影响因子划分为 1 区（最高区）、2区、3区和4区四个等级。这种分区标准也被更多的机构采纳以作为科研评价的指标。","slug":"研究方向/会议调研","published":1,"date":"2024-04-22T13:14:49.291Z","updated":"2024-04-05T02:50:10.354Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0f000wkgg4bpu04wd3","content":"<p>[[中国计算机学会推荐国际学术会议和期刊目录-2019.pdf]]</p>\n<h1 id=\"会议级别\"><a href=\"#会议级别\" class=\"headerlink\" title=\"会议级别\"></a>会议级别</h1><p>ei 会议 &lt; ei 期刊 &lt;  sci | ssci</p>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzkwMTM0NzU1MQ==&mid=2247505285&idx=1&sn=8f2fbac906e7bba64545fe9a30b8435e&chksm=c0b4b435f7c33d234329c1bdfa5e39fa1191cbb409b75b5dd7b412e54d12c7838211e74f0d97&scene=27\">会议信息 | 2023年12月截稿的密码学与信息安全会议整理 (qq.com)</a></p>\n<h1 id=\"主要依据\"><a href=\"#主要依据\" class=\"headerlink\" title=\"主要依据\"></a>主要依据</h1><table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>期刊CCF等级</td>\n<td>未收录</td>\n</tr>\n<tr>\n<td>JCR分区</td>\n<td>Q2</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p>JCR分区是通过将一个学科内收录的期刊总数分为四等份来进行的，其中影响因子排名前25%的期刊为一区（Q1），26-50%为二区（Q2），51-75%为三区（Q3），76-100%为四区（Q4）</p>\n<p>CCF分类则是中国计算机学会（CCF）对计算机科学领域的期刊和会议进行的评级，基于期刊和会议的国际影响力、学术水平等因素，通过将它们划分为不同的等级（A、B、C），</p>\n<p>中科院期刊分区根据13个大类学科，分别将各大类的SCI期刊由3年平均影响因子划分为 1 区（最高区）、2区、3区和4区四个等级。这种分区标准也被更多的机构采纳以作为科研评价的指标。</p>\n","excerpt":"","more":"<p>[[中国计算机学会推荐国际学术会议和期刊目录-2019.pdf]]</p>\n<h1 id=\"会议级别\"><a href=\"#会议级别\" class=\"headerlink\" title=\"会议级别\"></a>会议级别</h1><p>ei 会议 &lt; ei 期刊 &lt;  sci | ssci</p>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzkwMTM0NzU1MQ==&mid=2247505285&idx=1&sn=8f2fbac906e7bba64545fe9a30b8435e&chksm=c0b4b435f7c33d234329c1bdfa5e39fa1191cbb409b75b5dd7b412e54d12c7838211e74f0d97&scene=27\">会议信息 | 2023年12月截稿的密码学与信息安全会议整理 (qq.com)</a></p>\n<h1 id=\"主要依据\"><a href=\"#主要依据\" class=\"headerlink\" title=\"主要依据\"></a>主要依据</h1><table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>期刊CCF等级</td>\n<td>未收录</td>\n</tr>\n<tr>\n<td>JCR分区</td>\n<td>Q2</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p>JCR分区是通过将一个学科内收录的期刊总数分为四等份来进行的，其中影响因子排名前25%的期刊为一区（Q1），26-50%为二区（Q2），51-75%为三区（Q3），76-100%为四区（Q4）</p>\n<p>CCF分类则是中国计算机学会（CCF）对计算机科学领域的期刊和会议进行的评级，基于期刊和会议的国际影响力、学术水平等因素，通过将它们划分为不同的等级（A、B、C），</p>\n<p>中科院期刊分区根据13个大类学科，分别将各大类的SCI期刊由3年平均影响因子划分为 1 区（最高区）、2区、3区和4区四个等级。这种分区标准也被更多的机构采纳以作为科研评价的指标。</p>\n"},{"_content":"文档的重点是基于随机森林的密码猜测模型。它提出了一种新的技术路线，重新编码密码字符，使得可以应用经典的机器学习技术来进行密码猜测。具体来说，它使用随机森林、提升算法等经典的机器学习技术来处理多类分类问题，从而实现密码猜测。此外，它还提出了一种基于随机森林的框架RFGuess，该框架对三种最具代表性的密码猜测场景进行了特征化。实验证明，基于随机森林的猜测模型非常有效，在各种场景中都表现出色。同时，它还提出了一种新的PII匹配算法，能够更准确地捕捉用户的PII使用情况，并且可以改进主要猜测模型的成功率。总的来说，这篇文档提出了一种基于经典机器学习技术的密码猜测模型，并且在多个实验中证明了其有效性和实用性。\n# 摘要\n\n对密码字符进行重新编码，并使一系列解决多类分类问题的经典机器学习技术（例如随机森林、增强算法及其变体）用于密码猜测成为可能。 此外，我们提出了 RFGuess，一种基于随机森林的框架，它描述了三种最具代表性的密码猜测场景（即拖网猜测、基于个人身份信息 (PII) 和用户密码重用行为的有针对性的猜测）。 这项工作除了具有理论意义外，还具有实用价值。 使用 13 个大型真实密码数据集进行的实验表明，我们的基于随机森林的猜测模型是有效的：（1）RFGuess 用于拖网猜测场景，其猜测成功率与最先进的同行相当； （2）基于PII的定向猜测RFGuess-PII，在100次猜测中猜测了20%∼28%的普通用户，比最先进的对手高出7%∼13%； (3) RFGuess-Reuse 基于用户密码重用/修改行为进行定向猜测，在相关模型中表现最好或第二。 我们相信这项工作朝着将经典机器学习技术引入密码猜测迈出了实质性的一步。\n# 如何工作\n1. 首先对密码字符进行重新编码，将每个密码字符表示为n阶字符串，其中n可以是4、5或6\n2. 然后将这些字符串表示为四个维度：字符类型、字符的排名、键盘行号和键盘列号，再加上两个额外的维度：字符在密码中的位置和字符在当前段中的位置。这种表示方法使得经典的机器学习技术（如随机森林和Boosting算法）首次成功应用于密码猜测。\n3. 随后，模型使用这些特征进行训练，并利用训练好的随机森林模型来生成密码猜测。\n4. 通过大量实验，研究表明RFGuess在不同的猜测场景中都取得了很好的效果，包括对PII的目标猜测。因此，RFGuess模型通过经典机器学习技术的应用，为密码猜测领域带来了重要的突破。\n","source":"_posts/研究方向/PASS_RF.md","raw":"文档的重点是基于随机森林的密码猜测模型。它提出了一种新的技术路线，重新编码密码字符，使得可以应用经典的机器学习技术来进行密码猜测。具体来说，它使用随机森林、提升算法等经典的机器学习技术来处理多类分类问题，从而实现密码猜测。此外，它还提出了一种基于随机森林的框架RFGuess，该框架对三种最具代表性的密码猜测场景进行了特征化。实验证明，基于随机森林的猜测模型非常有效，在各种场景中都表现出色。同时，它还提出了一种新的PII匹配算法，能够更准确地捕捉用户的PII使用情况，并且可以改进主要猜测模型的成功率。总的来说，这篇文档提出了一种基于经典机器学习技术的密码猜测模型，并且在多个实验中证明了其有效性和实用性。\n# 摘要\n\n对密码字符进行重新编码，并使一系列解决多类分类问题的经典机器学习技术（例如随机森林、增强算法及其变体）用于密码猜测成为可能。 此外，我们提出了 RFGuess，一种基于随机森林的框架，它描述了三种最具代表性的密码猜测场景（即拖网猜测、基于个人身份信息 (PII) 和用户密码重用行为的有针对性的猜测）。 这项工作除了具有理论意义外，还具有实用价值。 使用 13 个大型真实密码数据集进行的实验表明，我们的基于随机森林的猜测模型是有效的：（1）RFGuess 用于拖网猜测场景，其猜测成功率与最先进的同行相当； （2）基于PII的定向猜测RFGuess-PII，在100次猜测中猜测了20%∼28%的普通用户，比最先进的对手高出7%∼13%； (3) RFGuess-Reuse 基于用户密码重用/修改行为进行定向猜测，在相关模型中表现最好或第二。 我们相信这项工作朝着将经典机器学习技术引入密码猜测迈出了实质性的一步。\n# 如何工作\n1. 首先对密码字符进行重新编码，将每个密码字符表示为n阶字符串，其中n可以是4、5或6\n2. 然后将这些字符串表示为四个维度：字符类型、字符的排名、键盘行号和键盘列号，再加上两个额外的维度：字符在密码中的位置和字符在当前段中的位置。这种表示方法使得经典的机器学习技术（如随机森林和Boosting算法）首次成功应用于密码猜测。\n3. 随后，模型使用这些特征进行训练，并利用训练好的随机森林模型来生成密码猜测。\n4. 通过大量实验，研究表明RFGuess在不同的猜测场景中都取得了很好的效果，包括对PII的目标猜测。因此，RFGuess模型通过经典机器学习技术的应用，为密码猜测领域带来了重要的突破。\n","slug":"研究方向/PASS_RF","published":1,"date":"2024-04-22T13:14:49.273Z","updated":"2024-04-16T13:42:21.199Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0f000xkgg4fjdcetk8","content":"<p>文档的重点是基于随机森林的密码猜测模型。它提出了一种新的技术路线，重新编码密码字符，使得可以应用经典的机器学习技术来进行密码猜测。具体来说，它使用随机森林、提升算法等经典的机器学习技术来处理多类分类问题，从而实现密码猜测。此外，它还提出了一种基于随机森林的框架RFGuess，该框架对三种最具代表性的密码猜测场景进行了特征化。实验证明，基于随机森林的猜测模型非常有效，在各种场景中都表现出色。同时，它还提出了一种新的PII匹配算法，能够更准确地捕捉用户的PII使用情况，并且可以改进主要猜测模型的成功率。总的来说，这篇文档提出了一种基于经典机器学习技术的密码猜测模型，并且在多个实验中证明了其有效性和实用性。</p>\n<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><p>对密码字符进行重新编码，并使一系列解决多类分类问题的经典机器学习技术（例如随机森林、增强算法及其变体）用于密码猜测成为可能。 此外，我们提出了 RFGuess，一种基于随机森林的框架，它描述了三种最具代表性的密码猜测场景（即拖网猜测、基于个人身份信息 (PII) 和用户密码重用行为的有针对性的猜测）。 这项工作除了具有理论意义外，还具有实用价值。 使用 13 个大型真实密码数据集进行的实验表明，我们的基于随机森林的猜测模型是有效的：（1）RFGuess 用于拖网猜测场景，其猜测成功率与最先进的同行相当； （2）基于PII的定向猜测RFGuess-PII，在100次猜测中猜测了20%∼28%的普通用户，比最先进的对手高出7%∼13%； (3) RFGuess-Reuse 基于用户密码重用&#x2F;修改行为进行定向猜测，在相关模型中表现最好或第二。 我们相信这项工作朝着将经典机器学习技术引入密码猜测迈出了实质性的一步。</p>\n<h1 id=\"如何工作\"><a href=\"#如何工作\" class=\"headerlink\" title=\"如何工作\"></a>如何工作</h1><ol>\n<li>首先对密码字符进行重新编码，将每个密码字符表示为n阶字符串，其中n可以是4、5或6</li>\n<li>然后将这些字符串表示为四个维度：字符类型、字符的排名、键盘行号和键盘列号，再加上两个额外的维度：字符在密码中的位置和字符在当前段中的位置。这种表示方法使得经典的机器学习技术（如随机森林和Boosting算法）首次成功应用于密码猜测。</li>\n<li>随后，模型使用这些特征进行训练，并利用训练好的随机森林模型来生成密码猜测。</li>\n<li>通过大量实验，研究表明RFGuess在不同的猜测场景中都取得了很好的效果，包括对PII的目标猜测。因此，RFGuess模型通过经典机器学习技术的应用，为密码猜测领域带来了重要的突破。</li>\n</ol>\n","excerpt":"","more":"<p>文档的重点是基于随机森林的密码猜测模型。它提出了一种新的技术路线，重新编码密码字符，使得可以应用经典的机器学习技术来进行密码猜测。具体来说，它使用随机森林、提升算法等经典的机器学习技术来处理多类分类问题，从而实现密码猜测。此外，它还提出了一种基于随机森林的框架RFGuess，该框架对三种最具代表性的密码猜测场景进行了特征化。实验证明，基于随机森林的猜测模型非常有效，在各种场景中都表现出色。同时，它还提出了一种新的PII匹配算法，能够更准确地捕捉用户的PII使用情况，并且可以改进主要猜测模型的成功率。总的来说，这篇文档提出了一种基于经典机器学习技术的密码猜测模型，并且在多个实验中证明了其有效性和实用性。</p>\n<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><p>对密码字符进行重新编码，并使一系列解决多类分类问题的经典机器学习技术（例如随机森林、增强算法及其变体）用于密码猜测成为可能。 此外，我们提出了 RFGuess，一种基于随机森林的框架，它描述了三种最具代表性的密码猜测场景（即拖网猜测、基于个人身份信息 (PII) 和用户密码重用行为的有针对性的猜测）。 这项工作除了具有理论意义外，还具有实用价值。 使用 13 个大型真实密码数据集进行的实验表明，我们的基于随机森林的猜测模型是有效的：（1）RFGuess 用于拖网猜测场景，其猜测成功率与最先进的同行相当； （2）基于PII的定向猜测RFGuess-PII，在100次猜测中猜测了20%∼28%的普通用户，比最先进的对手高出7%∼13%； (3) RFGuess-Reuse 基于用户密码重用&#x2F;修改行为进行定向猜测，在相关模型中表现最好或第二。 我们相信这项工作朝着将经典机器学习技术引入密码猜测迈出了实质性的一步。</p>\n<h1 id=\"如何工作\"><a href=\"#如何工作\" class=\"headerlink\" title=\"如何工作\"></a>如何工作</h1><ol>\n<li>首先对密码字符进行重新编码，将每个密码字符表示为n阶字符串，其中n可以是4、5或6</li>\n<li>然后将这些字符串表示为四个维度：字符类型、字符的排名、键盘行号和键盘列号，再加上两个额外的维度：字符在密码中的位置和字符在当前段中的位置。这种表示方法使得经典的机器学习技术（如随机森林和Boosting算法）首次成功应用于密码猜测。</li>\n<li>随后，模型使用这些特征进行训练，并利用训练好的随机森林模型来生成密码猜测。</li>\n<li>通过大量实验，研究表明RFGuess在不同的猜测场景中都取得了很好的效果，包括对PII的目标猜测。因此，RFGuess模型通过经典机器学习技术的应用，为密码猜测领域带来了重要的突破。</li>\n</ol>\n"},{"_content":"# 背景\n\n互联网和安全不断发展，互联网的开放性也带来了许多内在的安全隐患。\n\n为了保护用户信息，当前已经产生了多种认证方式： \n身份认证的分类：\n1. 用户知道的：密码，个人识别码\n2. 用户拥有的：U盾，加密卡\n3. 用户本身的：\n\t1. 生理特征：指纹，虹膜\n\t2. 行为特征：手写\n\n对于上面这些认证方式，其中密码（即口令）破解是最常见的认证方式，原因主要有：\n1. 互联网应用不断发展，人们不得不设置许多满足不同密码策略的密码来保护相应的软件应用程序。\n2. 人的记忆能力有限。研究表明，人类只能记住五到七个密码，因此在设置密码时普遍会使用一些低信息熵的密码，比如：\n\t1. 在多个系统中使用相同密码\n\t2. 在密码中使用个人相关信息\n3. 大量知名网站的密码文件被泄露：比如著名的 rockyou数据集就是2018年受黑客攻击而泄漏的。\n\n且人工智能以及到现在 大模型的产生和发展更进一步增强了破解口令认证系统的能力，因此对于这方面的研究也显得更加迫切和重要。\n（对口令认证系统攻击最严重的是口令猜测攻击）\n# 口令猜测分类\n（\n密码猜测的角度|方法：\n1. 启发式搜索\n2. 概率模型\n3. 深度学习\n）\n\n根据是否在线（也就是是否与服务器进行交互）：\n1. 离线密码猜测\n2. 在线密码猜测\n\n（前一种攻击要求身份验证服务器存储用户帐户密码文件，然后攻击者在本地主机上猜测密码。在这种情况下，可以尝试的猜测次数仅受攻击者的计算资源的限制。后者不需要密码文件，攻击者只需要连接到网络即可。然而，可以尝试的猜测次数往往受到服务器安全策略的限制，例如美国国家身份标准NIST-800-63-3，其中规定政府网站系统一个月允许的最大登录失败次数为100次，如果超过100次，帐户将被锁定。）\n\n根据是否利用用户的个人信息：\n1. 拖网猜测。\n2. 定向猜测，利用用户个人信息。\n（拖网猜测主要利用用户选择流行密码的倾向，而定向猜测不仅利用普通用户使用流行密码的漏洞，还利用用户重复使用密码和使用个人信息构建密码的漏洞。在个人身份信息和历史密码等信息的帮助下，定向密码猜测的成功率明显高于相同猜测次数的拖网猜测）\n\n\n是否使用人工智能：\n1. 传统攻击\n2. 神经攻击\n（前者将密码猜测作为一项文本生成任务，依靠人工智能相关技术在大规模密码训练语料库上生成文本密码。后者封装了其他方法，不包括深度神经网络猜测方法。）\n\n\n（几乎所有现有的工作都是离线猜测，而在线猜测太难在100个猜测内猜出一个密码。所以当前的分类方式主要为：传统的。。基于神经网络的。。）\n\n（说一下如何比较生成密码的质量：\n\t1. 生成的唯一密码个数和比例；\n\t2. 生成密码的速度；\n\t3. 生成的密码和训练数据集之外其他数据集的匹配个数\n   ）\n\n### 拖网猜测\n\n#### 传统拖网猜测\n1. 启发式算法\n\t> 这些算法没有严格的理论体系，严重依赖于零散的奇思妙想，例如，基于开源软件使用精心设计的猜测序列构建独特的猜测词典。这些启发式方法很难重现，也很难相互公平地比较。因此，在这里，我们只介绍一些常用的启发式密码猜测工具。\n\t1. Jtr是一个密码猜测工具，专注于破解UNIX/Linux系统的弱密码。在JTR中有四种模式--简单破解模式、单词表模式、增量模式和外部模式。\n\t2. Hashcat是世界上速度最快、最先进的密码恢复实用程序，支持针对300多种高度优化的哈希算法的五种独特攻击模式。Hashcat目前支持Linux、Windows和MacOS上的CPU、GPU和其他硬件加速器，并具有帮助启用分布式密码破解的设施。\n\t\t> 彩虹攻击：\n\t\t> 一种基于预先计算和空间-时间折中的攻击方法。通过事先计算大量的密码和散列值之间的对应关系（彩虹表），以便在攻击时快速查找并破解散列值。彩虹表是一个预先计算的表格，其中包含了大量的密码和对应的散列值。通过在彩虹表中进行查找，攻击者可以找到与目标散列值匹配的原始密码。\n2. 概率上下文无关语法\n\t该算法的核心假设是密码的字母段L、数字段D和特殊字符段S相互独立。该算法包括训练和猜测两个阶段。\n\t1. 在训练阶段，最关键的是根据泄露的密码数据集计算密码模式(结构)和字符成分(语义)的频率。\n\t2. 在猜测阶段，根据训练阶段得到的模式频率表和语义频率表生成具有频率猜测的集合，以模拟真实密码的概率分布。\n\t粒度太细，无法获得字符之间的语义关系，改进：\n\t1. 基于词的内聚力和自由度提取密码中的语义片段，并对基于语义片段的PCFG算法进行改进\n\t2. 密码视为由几个块组成，其中块是频繁出现在一起以模拟密码的相关字符的序列。\n\t3. 扩展字节对编码(BPE)算法，它使用块词汇表平均长度的可配置参数来替换合并操作的数量。\n\t4. 为了解决长密码猜测的困难，提出了一种改进的基于PCFG的LONG\n3. 马尔可夫序列决策\n\t该算法的核心假设是用户从前到后依次构造口令。它不像PCFG那样分割密码，而是训练整个密码，并通过从左到右链接字符来计算密码的概率。\n\t1. 传统的马尔可夫模型因其结构简单、推理速度快而被广泛应用于口令猜测工作中。但是，它也有一定的缺陷，如过度拟合、重复率高、基于随机抽样生成的密码覆盖率低等。\n\t2. 过拟合：将拉普拉斯平滑和结束符号正则化技术应用于马尔可夫模型。平滑策略消除了数据集中的过拟合问题，正则化技术使攻击算法产生的猜测概率总是和为1。\n\t3. 重复率：设计了一种基于随机抽样的动态分配机制。该机制允许动态调整密码的概率分布，并在猜测过程中严格收敛到均匀分布。基于上述动态分布机制，提出了一种动态马尔可夫模型。\n\t4. 对口令中的语义段进行建模：提出了一个名为Word马尔可夫的模型，通过语义分段从密码中提取单词的凝聚力和自由度。\n\n#### 神经拖网猜测算法\n密码猜测任务视为文本生成问题，核心就是把密码数据集给神经网络进行训练，并利用训练好的模型生成候选密码。\n1. 递归神经网络(RNN)：递归神经网络以序列数据为输入，在序列进化方向上递归，所有节点以链的形式连接。 RNN 有许多变体：如： LSTM，GRU，BiLSTM 等。\n\t1. 步骤：基于RNN的密码猜测方法通常有以下两个步骤：\n\t\t1. ·将训练集中的密码序列输入到RNN模型中，以进行顺序文本生成的训练。\n\t\t2. 训练好的 RNN 猜测模型旨在根据已有的密码字符生成下一个密码字符，直到输出终止字符位置。\n\t2. 在整个密码生成过程中，RNN计算任何字符作为下一个密码令牌的概率。对于给定的阈值，概率高于阈值的密码将被放入密码猜测集中作为有效密码。\n\t3. 一些变体：\n\t\t1. 对密码单词进行切分，在词段的基础上使用BiLSTM生成密码。\n\t\t2. 层次语义模型HSM，该模型将LSTM和语义分析相结合，用于挖掘用于密码猜测的词之间潜在的概率关系。\n\t\t3. 基于汉字音节的密码猜测方法。该方法将汉语音节作为整体元素对密码进行解析和处理。然后，在LSTM神经网络中对处理后的密码进行训练以生成密码。\n\t\t4. 特别是具有注意力机制的RNN来组合和内插同一组用户的信息，以定义比他们的密码分布更稳健和准确的优先级。推理时使用辅助数据来适应目标密码的分布。通过这种方式，开发了一种利用辅助信息并实例化上下文感知口令计量和猜测攻击的全自动方法，而不需要来自目标口令分布的任何明文样本。\n2. 生成式对抗网络（GAN）：\n\t1. 基于GAN的密码猜测模型由密码生成器和鉴别器组成。这两个网络相互对抗，不断地调整参数。最终目的是使鉴别器网络无法判断生成网络的输出是否真实，从而达到口令生成的效果。\n\t2. 问题：离散密码数据的不可微性可能导致梯度反向传播失败，基于GAN的密码猜测模型训练难以收敛，由GAN模型生成的密码重复率较高。\n\t3. 离散数据不可微问题解决：\n\t\t1. 使用Gumbel-Softmax松弛技术来训练基于GAN的密码猜测模型。\n\t\t2. 使用通过附加的自动编码器获得的真实口令的平滑表示。\n\t\t3. 种基于SeqGAN的密码猜测方法RLPassGAN，该方法使用策略梯度来确保模型参数的持续优化。\n\t4. 收敛困难的问题解决：基于双向生成对抗网络的猜测算法，提高了算法的收敛速度。与传统的GaN相比，它可以在更短的时间内产生相同数量的样本\n\t5. 重复率高问题解决：\n\t\t1. 使用蒙特卡罗搜索来评估中间层输出处的不完整密码序列，减少冗余的合成密码。（此外，通过蒙特卡罗搜索来评估输出的不完整密码序列。蒙特卡罗是一种使用大量随机样本来了解特定系统的计算方法。）\n\t\t2. 使用鉴别器和控制器构建额外的控制器网络，以分别学习生成的密码分布与真实密码分布和均匀分布之间的度量。然后利用这两个度量对生成器进行训练，从而降低了口令生成的重复率。\n\t\t3.  RLPass：还创新性地将表征学习用于密码猜测。具体地，将密码投影到隐藏空间，并且使用隐藏空间中的密码表示之间的距离来定义密码的相似性。基于口令的强局部性和弱局部性现象，提出了一种动态口令猜测和条件口令算法。\n\t6. GAN的模型生成的长密码质量较低的问题解决：设计了一种基于DenseNet的GAN密码猜测结构DenseGAN，并提出了两种新的密码猜测DenseGAN模型，这两种模型都能生成高质量的密码猜测。\n3. 自动编码器（AE）：它基于反向传播算法和优化方法，使用输入数据本身作为监督来指导神经网络学习映射关系，以获得重建的输出。AE 包括编码器和解码器两部分。根据学习范式，AE 可分为欠完备自动编码器、正则化自动编码器和变分自动编码器，其中前两种是判别性模型，后者是生成性模型。\n\t1. 在拖网密码猜测的研究中，通常使用**变分自动编码器**来生成密码猜测。将密码样本输入到VAE的编码器以获得表示，然后使用解码器基于该表示重建样本。基于输入和输出之间的重构损失来训练密码生成器。除了使用最经典的VAE框架来猜测密码，也提出来了许多优化。\n\t\t1. 优化 GAN：将VAE技术与GaN技术相结合，用VAE代替GaN生成器，旨在解决离散口令数据的反向传播问题。\n\t\t2. 轻量级问题：用门控卷积神经网络(GCNN)代替了复杂的RNN生成单元，降低了模型的复杂性。\n4. Transformer.\n\t![[Pasted image 20240305201324.png]]\n\tTransformer 模型采用编解码器体系结构，并使用注意力机制替换 Seq2Seq 模型中的递归结构，以实现序列建模的并行化。这种并行化结构给自然语言处理 (NLP) 领域带来了巨大的冲击。随着研究的深入，相关技术逐渐从自然语言处理向计算机视觉 (CV)、语音、生物、化学等领域发展。同样，在拖网密码猜测的研究中也出现了一些基于Transformer的方法：\n\t1. 基于改进 Transformer 的口令猜测模型：将消息（个人信息和密码的相关性）权重引入到数据预处理中，并在模型中使用改进的波束搜索算法来快速搜索排名靠前的密码猜测。\n\t2. PassBERT：基于双向 Transformer 的猜测框架，首次将预训练/微调的范式应用于密码破解。具体地说，\n\t\t1. 首先，作者设计了包含一般密码分布知识的通用密码预训练模型。\n\t\t2. 然后，提出了三种特定于攻击的微调方法来定制预先训练的口令模型以适应以下真实攻击场景：条件口令猜测、目标口令猜测和基于自适应规则的口令猜测。最后，他们进一步提出了一种混合密码强度计来降低这三种攻击的风险。\n5. Reinforcement Learning (RL) 强化学习\n\t1. RL是机器学习的范例和方法之一，用于描述和解决智能代理在与环境交互过程中最大化回报或实现特定目标的学习策略问题。密码生成器是代理，每个生成的密码序列代表一个完整的轨迹，生成过程中的每个字符都被视为一个操作。例如，由时间戳t生成的字符是action at。根据由所生成的不完整序列确定的关于当前状态ST的随机策略来生成每个动作At。生成器根据一组随机策略从任意字符生成密码，直到满足预定长度。\n\t2. RLPassGAN：遵循SeqGAN，将密码猜测视为一个连续决策，并使用策略梯度 来确保参数可以连续优化。\n6. Flow： （一个强大的密度估计统计工具）流动模型的一个非常独特的特征是，它的转变通常是可逆的。流模型不仅找到了从分布Z转移到分布X的网络路径，而且该路径还允许X改变为Z。简而言之，流模型找到了分布Z和X之间的双向路径（Z和X的数据维度必须相同）。\n\t1. PassFlow：基于产生流模型的口令猜测方法。基于流的口令猜测模型使用精确的对数似然计算和优化，使潜在变量的推断更加准确。此外，还给出了潜在空间的一种有意义的表示，这使得探索潜在空间的特定子空间和内插等操作成为可能。（密码猜测方面优于现有的基于GAN的方法）\n\n#### 另一种分类\n根据泄露的数据集和目标密码是否来自同一数据源，拖网场景可以进一步分为站内场景和跨站场景。 虽然跨站密码猜测场景较为真实，但攻击者一般以掌握目标数据的部分分布信息为前提来猜测密码。\n\n\n### 定向密码猜测\n定向整体来说其实是对传统的优化，比如不改变核心思想的前提下修改嵌入，数据预处理等方面。\n#### 神经定向密码猜测\n\n随着自然语言处理技术的发展，一些复杂的神经网络被应用到目标密码猜测领域。\n1. PG-PASS：由指针生成网络组成的有针对性的口令猜测模型。该工作创新性地将目标口令猜测作为一项摘要任务，并将智能摘要领域中常用的指针网络技术应用于该任务。需要注意的是，除了用户的人口统计相关信息(姓名、生日等)外，攻击者还可以利用用户在其他网站上泄露的密码进行有针对性的攻击。可以预期，这种利用用户密码重复使用这一易受攻击行为的定向攻击可能比基于人口统计相关信息的攻击更具危害性。\n2. 重用模型：重用或微调旧密码来生成新密码的事实，引入深度学习技术来表征用户的密码重复使用行为。更具体地说，他们训练了序列到序列(Seq2seq)模型，以预测将现有密码转换为其姊妹密码所需的修改，并在大规模数据集(即4iQ数据集)上进行了验证。\n3. PASS2EDIT：有针对性的密码猜测算法，用于模拟日益严重的凭据篡改攻击，在该攻击中，攻击者利用受害者泄露的密码来提高在其他站点猜测受害者密码的成功率。特别是，他们提出了一种多步决策训练机制，并建立了一个分类神经网络来学习一步编辑操作对现有密码的反应。由于每项工作使用的数据集不同，因此很难进行横断面比较。\n\n#### 传统定向密码猜测\n攻击者使用与目标人员相关的个人信息来增强猜测。\n\n基于拖网马尔可夫攻击模型的定向攻击猜测方法：\n1. 基本思想是，关于使用某些个人信息的人口的百分比，攻击目标也将具有相同的使用该个人信息的可能性百分比。\n\t1. 首先将PII划分为几种类型，如用户名-A、电子邮件前缀-E和名称-N，并根据所需的粒度进一步细分每种广泛的类型。然后，将训练集的每个密码中的所有PII替换为对应的PII类型。\n\t2. 训练阶段的其余步骤与行走马尔可夫模型的步骤相同。\n\t3. 猜测集生成阶段分为两个步骤。\n\t\t1. 在第一步中，运行马尔可夫模型以生成中间猜测集合，该中间猜测集合包含直接可用的猜测，\n\t\t2. 第二步用相应的PII信息替换中间猜测中的基本PII类型字符。\n\n基于PCFG的定向攻击猜测方法：\n1. --Personal-PCFG。。其基本思想与PCFG攻击模型相同：根据字符类型和长度对密码进行切片。为了实现这一思想，将六种PI字符类型 (即用户名-A、电子邮件前缀-E、姓名-N、生日-B、电话号码-P和ID-G)等同于拖网PCFG模型中的L、D和S，从而在个人PCFG中有九种类型的字符。然后，在训练过程中，与拖网PCFG攻击模型中一样，训练集中的每个密码根据相应的字符类型及其长度进行分段。\n2. TarGuess Wang等人。提出了一个框架，它用四个数学概率模型系统地刻画了典型的定向猜测场景。\n\t1. 第一个场景TarGuess-I旨在利用用户的PII创建在线目标密码猜测。为了在密码中表示PII令牌，除了PCFG模型中的L、D和S标签外，作者还定义了基于个人信息类型的28个PII标签(例如，N1−N7和B1−B10)。对于每个PII标签，其下标编号表示该类型的PII使用的细分，而不是指示相应长度的下标编号，例如L、D和S标签。例如，N表示名称信息，而N1表示全名，而n2表示全名的缩写\n\t2. 第二个是Targuess-II，目的是根据用户在其他网站(例如Dodonew)中泄露的密码来猜测目标网站(例如CSDN)中的用户密码。具体地，作者提出了6种结构级和2种字符级助记转换来描述密码重用，并基于上述重用规则使用马尔可夫模型来刻画上下文无关的转换文法。\n\t3. 第三个是TarGuessIII，目的是使用姐妹密码和一些PII信息来猜测用户的密码。TarGuess-III将PII信息引入到TarGuess-II模型中，允许在结构级密码重用中嵌入PII信息。\n\t4. 与TarGuess-III相比，TarGuess-IV场景中的攻击者知道难以量化的额外PII(例如，性别、教育)。为了解决某些PII难以直接体现在口令中的问题，在这种难以量化的PII的基础上，巧妙地引入贝叶斯理论来计算口令的重用概率。\n\n3. RFGuess-PII.在RFGuess的基础上，Wang et al.提出了一种新的目标口令猜测模型RFGuess-PII。密码训练和生成过程类似于拖网猜测场景。不同的是，通过新的PII匹配，密码中的PII字符串被替换为相应的数字标签。这种新的PII匹配旨在最小化信息熵，并试图准确地提取整个用户组的PII使用行为。PII匹配算法的第一步是细分PII的各种可能的变换，并使用数字标签来表示它们。第二步是为训练集中的每个密码列出具有PII标签的所有可能的表示。然后，按频率从高到低对表征进行排序。\n\n4. RFGuess-重复使用。除了基于PII的针对性密码破解研究外，作者还专注于对用户的密码重复使用行为进行建模。他们还考虑了结构级和段级转换，如TarGuess-II。具体地，它们通过计算训练集中每个密码对的编辑矩阵来计算结构级转换，并训练基于随机森林的段级转换(即，相同类型的字符串内的转换，例如字母段中的密码→密码)模型。\n\n5. TG-SPSR图谱。马尔可夫模型和PCFG模型转化为目标攻击，提出了一种基于结构划分和字符串重组的系统目标攻击模型，称为TG-SPSR。在结构划分阶段，除了将密码划分为类似于PCFG的基本结构外，还在基本语法模式中定义了基于轨迹的键盘，并引入了索引位来准确描述特殊字符的位置。此外，基于定义的9条修改规则，构造了一个BiLSTM分类器来重用和修改密码的行为。\n\n\n# 可能的方向\n总体来说还是做的工作挺多的，16-23年提出来了三十多种方法，2016年至2018年零星出版数量较少，2021年增至9种。。但是当前比较热门的还是基于深度学习的密码猜测方法。\n1. 修改模型结构提高模型训练时的速度：在低资源的情况下快速执行密码猜测也是具有挑战性的。\n2. 尝试大模型：预训练的语言模型近年来在自然语言处理领域应用很成熟。可以尝试关于密码猜测的预训练/精调范式，将预先训练的语言模型强大的通用语言建模功能与现有的密码猜测工作结合起来\n3. 尝试更多模型：目前的神经密码猜测方法都有一个前提，即密码字符串是一个字符序列，使用序列编码对密码进行处理。比如根据密码的语义依赖将密码组织成图，并使用最新的图神经网络(GNN)相关技术进行采样和生成。\n4. 传统猜测方法与深度学习方法相结合。比如用深度学习生成规则等。\n\n\n# 之后的想法\n1. 这两周涉及到了解一些背景所以读的也比较仔细，后面计划读快一些，重点关注方法和创新性。\n2. 选择较新，效果较好，的论文尝试复现，分析数据，寻找优化的点。\n\n","source":"_posts/研究方向/方向：密码生成.md","raw":"# 背景\n\n互联网和安全不断发展，互联网的开放性也带来了许多内在的安全隐患。\n\n为了保护用户信息，当前已经产生了多种认证方式： \n身份认证的分类：\n1. 用户知道的：密码，个人识别码\n2. 用户拥有的：U盾，加密卡\n3. 用户本身的：\n\t1. 生理特征：指纹，虹膜\n\t2. 行为特征：手写\n\n对于上面这些认证方式，其中密码（即口令）破解是最常见的认证方式，原因主要有：\n1. 互联网应用不断发展，人们不得不设置许多满足不同密码策略的密码来保护相应的软件应用程序。\n2. 人的记忆能力有限。研究表明，人类只能记住五到七个密码，因此在设置密码时普遍会使用一些低信息熵的密码，比如：\n\t1. 在多个系统中使用相同密码\n\t2. 在密码中使用个人相关信息\n3. 大量知名网站的密码文件被泄露：比如著名的 rockyou数据集就是2018年受黑客攻击而泄漏的。\n\n且人工智能以及到现在 大模型的产生和发展更进一步增强了破解口令认证系统的能力，因此对于这方面的研究也显得更加迫切和重要。\n（对口令认证系统攻击最严重的是口令猜测攻击）\n# 口令猜测分类\n（\n密码猜测的角度|方法：\n1. 启发式搜索\n2. 概率模型\n3. 深度学习\n）\n\n根据是否在线（也就是是否与服务器进行交互）：\n1. 离线密码猜测\n2. 在线密码猜测\n\n（前一种攻击要求身份验证服务器存储用户帐户密码文件，然后攻击者在本地主机上猜测密码。在这种情况下，可以尝试的猜测次数仅受攻击者的计算资源的限制。后者不需要密码文件，攻击者只需要连接到网络即可。然而，可以尝试的猜测次数往往受到服务器安全策略的限制，例如美国国家身份标准NIST-800-63-3，其中规定政府网站系统一个月允许的最大登录失败次数为100次，如果超过100次，帐户将被锁定。）\n\n根据是否利用用户的个人信息：\n1. 拖网猜测。\n2. 定向猜测，利用用户个人信息。\n（拖网猜测主要利用用户选择流行密码的倾向，而定向猜测不仅利用普通用户使用流行密码的漏洞，还利用用户重复使用密码和使用个人信息构建密码的漏洞。在个人身份信息和历史密码等信息的帮助下，定向密码猜测的成功率明显高于相同猜测次数的拖网猜测）\n\n\n是否使用人工智能：\n1. 传统攻击\n2. 神经攻击\n（前者将密码猜测作为一项文本生成任务，依靠人工智能相关技术在大规模密码训练语料库上生成文本密码。后者封装了其他方法，不包括深度神经网络猜测方法。）\n\n\n（几乎所有现有的工作都是离线猜测，而在线猜测太难在100个猜测内猜出一个密码。所以当前的分类方式主要为：传统的。。基于神经网络的。。）\n\n（说一下如何比较生成密码的质量：\n\t1. 生成的唯一密码个数和比例；\n\t2. 生成密码的速度；\n\t3. 生成的密码和训练数据集之外其他数据集的匹配个数\n   ）\n\n### 拖网猜测\n\n#### 传统拖网猜测\n1. 启发式算法\n\t> 这些算法没有严格的理论体系，严重依赖于零散的奇思妙想，例如，基于开源软件使用精心设计的猜测序列构建独特的猜测词典。这些启发式方法很难重现，也很难相互公平地比较。因此，在这里，我们只介绍一些常用的启发式密码猜测工具。\n\t1. Jtr是一个密码猜测工具，专注于破解UNIX/Linux系统的弱密码。在JTR中有四种模式--简单破解模式、单词表模式、增量模式和外部模式。\n\t2. Hashcat是世界上速度最快、最先进的密码恢复实用程序，支持针对300多种高度优化的哈希算法的五种独特攻击模式。Hashcat目前支持Linux、Windows和MacOS上的CPU、GPU和其他硬件加速器，并具有帮助启用分布式密码破解的设施。\n\t\t> 彩虹攻击：\n\t\t> 一种基于预先计算和空间-时间折中的攻击方法。通过事先计算大量的密码和散列值之间的对应关系（彩虹表），以便在攻击时快速查找并破解散列值。彩虹表是一个预先计算的表格，其中包含了大量的密码和对应的散列值。通过在彩虹表中进行查找，攻击者可以找到与目标散列值匹配的原始密码。\n2. 概率上下文无关语法\n\t该算法的核心假设是密码的字母段L、数字段D和特殊字符段S相互独立。该算法包括训练和猜测两个阶段。\n\t1. 在训练阶段，最关键的是根据泄露的密码数据集计算密码模式(结构)和字符成分(语义)的频率。\n\t2. 在猜测阶段，根据训练阶段得到的模式频率表和语义频率表生成具有频率猜测的集合，以模拟真实密码的概率分布。\n\t粒度太细，无法获得字符之间的语义关系，改进：\n\t1. 基于词的内聚力和自由度提取密码中的语义片段，并对基于语义片段的PCFG算法进行改进\n\t2. 密码视为由几个块组成，其中块是频繁出现在一起以模拟密码的相关字符的序列。\n\t3. 扩展字节对编码(BPE)算法，它使用块词汇表平均长度的可配置参数来替换合并操作的数量。\n\t4. 为了解决长密码猜测的困难，提出了一种改进的基于PCFG的LONG\n3. 马尔可夫序列决策\n\t该算法的核心假设是用户从前到后依次构造口令。它不像PCFG那样分割密码，而是训练整个密码，并通过从左到右链接字符来计算密码的概率。\n\t1. 传统的马尔可夫模型因其结构简单、推理速度快而被广泛应用于口令猜测工作中。但是，它也有一定的缺陷，如过度拟合、重复率高、基于随机抽样生成的密码覆盖率低等。\n\t2. 过拟合：将拉普拉斯平滑和结束符号正则化技术应用于马尔可夫模型。平滑策略消除了数据集中的过拟合问题，正则化技术使攻击算法产生的猜测概率总是和为1。\n\t3. 重复率：设计了一种基于随机抽样的动态分配机制。该机制允许动态调整密码的概率分布，并在猜测过程中严格收敛到均匀分布。基于上述动态分布机制，提出了一种动态马尔可夫模型。\n\t4. 对口令中的语义段进行建模：提出了一个名为Word马尔可夫的模型，通过语义分段从密码中提取单词的凝聚力和自由度。\n\n#### 神经拖网猜测算法\n密码猜测任务视为文本生成问题，核心就是把密码数据集给神经网络进行训练，并利用训练好的模型生成候选密码。\n1. 递归神经网络(RNN)：递归神经网络以序列数据为输入，在序列进化方向上递归，所有节点以链的形式连接。 RNN 有许多变体：如： LSTM，GRU，BiLSTM 等。\n\t1. 步骤：基于RNN的密码猜测方法通常有以下两个步骤：\n\t\t1. ·将训练集中的密码序列输入到RNN模型中，以进行顺序文本生成的训练。\n\t\t2. 训练好的 RNN 猜测模型旨在根据已有的密码字符生成下一个密码字符，直到输出终止字符位置。\n\t2. 在整个密码生成过程中，RNN计算任何字符作为下一个密码令牌的概率。对于给定的阈值，概率高于阈值的密码将被放入密码猜测集中作为有效密码。\n\t3. 一些变体：\n\t\t1. 对密码单词进行切分，在词段的基础上使用BiLSTM生成密码。\n\t\t2. 层次语义模型HSM，该模型将LSTM和语义分析相结合，用于挖掘用于密码猜测的词之间潜在的概率关系。\n\t\t3. 基于汉字音节的密码猜测方法。该方法将汉语音节作为整体元素对密码进行解析和处理。然后，在LSTM神经网络中对处理后的密码进行训练以生成密码。\n\t\t4. 特别是具有注意力机制的RNN来组合和内插同一组用户的信息，以定义比他们的密码分布更稳健和准确的优先级。推理时使用辅助数据来适应目标密码的分布。通过这种方式，开发了一种利用辅助信息并实例化上下文感知口令计量和猜测攻击的全自动方法，而不需要来自目标口令分布的任何明文样本。\n2. 生成式对抗网络（GAN）：\n\t1. 基于GAN的密码猜测模型由密码生成器和鉴别器组成。这两个网络相互对抗，不断地调整参数。最终目的是使鉴别器网络无法判断生成网络的输出是否真实，从而达到口令生成的效果。\n\t2. 问题：离散密码数据的不可微性可能导致梯度反向传播失败，基于GAN的密码猜测模型训练难以收敛，由GAN模型生成的密码重复率较高。\n\t3. 离散数据不可微问题解决：\n\t\t1. 使用Gumbel-Softmax松弛技术来训练基于GAN的密码猜测模型。\n\t\t2. 使用通过附加的自动编码器获得的真实口令的平滑表示。\n\t\t3. 种基于SeqGAN的密码猜测方法RLPassGAN，该方法使用策略梯度来确保模型参数的持续优化。\n\t4. 收敛困难的问题解决：基于双向生成对抗网络的猜测算法，提高了算法的收敛速度。与传统的GaN相比，它可以在更短的时间内产生相同数量的样本\n\t5. 重复率高问题解决：\n\t\t1. 使用蒙特卡罗搜索来评估中间层输出处的不完整密码序列，减少冗余的合成密码。（此外，通过蒙特卡罗搜索来评估输出的不完整密码序列。蒙特卡罗是一种使用大量随机样本来了解特定系统的计算方法。）\n\t\t2. 使用鉴别器和控制器构建额外的控制器网络，以分别学习生成的密码分布与真实密码分布和均匀分布之间的度量。然后利用这两个度量对生成器进行训练，从而降低了口令生成的重复率。\n\t\t3.  RLPass：还创新性地将表征学习用于密码猜测。具体地，将密码投影到隐藏空间，并且使用隐藏空间中的密码表示之间的距离来定义密码的相似性。基于口令的强局部性和弱局部性现象，提出了一种动态口令猜测和条件口令算法。\n\t6. GAN的模型生成的长密码质量较低的问题解决：设计了一种基于DenseNet的GAN密码猜测结构DenseGAN，并提出了两种新的密码猜测DenseGAN模型，这两种模型都能生成高质量的密码猜测。\n3. 自动编码器（AE）：它基于反向传播算法和优化方法，使用输入数据本身作为监督来指导神经网络学习映射关系，以获得重建的输出。AE 包括编码器和解码器两部分。根据学习范式，AE 可分为欠完备自动编码器、正则化自动编码器和变分自动编码器，其中前两种是判别性模型，后者是生成性模型。\n\t1. 在拖网密码猜测的研究中，通常使用**变分自动编码器**来生成密码猜测。将密码样本输入到VAE的编码器以获得表示，然后使用解码器基于该表示重建样本。基于输入和输出之间的重构损失来训练密码生成器。除了使用最经典的VAE框架来猜测密码，也提出来了许多优化。\n\t\t1. 优化 GAN：将VAE技术与GaN技术相结合，用VAE代替GaN生成器，旨在解决离散口令数据的反向传播问题。\n\t\t2. 轻量级问题：用门控卷积神经网络(GCNN)代替了复杂的RNN生成单元，降低了模型的复杂性。\n4. Transformer.\n\t![[Pasted image 20240305201324.png]]\n\tTransformer 模型采用编解码器体系结构，并使用注意力机制替换 Seq2Seq 模型中的递归结构，以实现序列建模的并行化。这种并行化结构给自然语言处理 (NLP) 领域带来了巨大的冲击。随着研究的深入，相关技术逐渐从自然语言处理向计算机视觉 (CV)、语音、生物、化学等领域发展。同样，在拖网密码猜测的研究中也出现了一些基于Transformer的方法：\n\t1. 基于改进 Transformer 的口令猜测模型：将消息（个人信息和密码的相关性）权重引入到数据预处理中，并在模型中使用改进的波束搜索算法来快速搜索排名靠前的密码猜测。\n\t2. PassBERT：基于双向 Transformer 的猜测框架，首次将预训练/微调的范式应用于密码破解。具体地说，\n\t\t1. 首先，作者设计了包含一般密码分布知识的通用密码预训练模型。\n\t\t2. 然后，提出了三种特定于攻击的微调方法来定制预先训练的口令模型以适应以下真实攻击场景：条件口令猜测、目标口令猜测和基于自适应规则的口令猜测。最后，他们进一步提出了一种混合密码强度计来降低这三种攻击的风险。\n5. Reinforcement Learning (RL) 强化学习\n\t1. RL是机器学习的范例和方法之一，用于描述和解决智能代理在与环境交互过程中最大化回报或实现特定目标的学习策略问题。密码生成器是代理，每个生成的密码序列代表一个完整的轨迹，生成过程中的每个字符都被视为一个操作。例如，由时间戳t生成的字符是action at。根据由所生成的不完整序列确定的关于当前状态ST的随机策略来生成每个动作At。生成器根据一组随机策略从任意字符生成密码，直到满足预定长度。\n\t2. RLPassGAN：遵循SeqGAN，将密码猜测视为一个连续决策，并使用策略梯度 来确保参数可以连续优化。\n6. Flow： （一个强大的密度估计统计工具）流动模型的一个非常独特的特征是，它的转变通常是可逆的。流模型不仅找到了从分布Z转移到分布X的网络路径，而且该路径还允许X改变为Z。简而言之，流模型找到了分布Z和X之间的双向路径（Z和X的数据维度必须相同）。\n\t1. PassFlow：基于产生流模型的口令猜测方法。基于流的口令猜测模型使用精确的对数似然计算和优化，使潜在变量的推断更加准确。此外，还给出了潜在空间的一种有意义的表示，这使得探索潜在空间的特定子空间和内插等操作成为可能。（密码猜测方面优于现有的基于GAN的方法）\n\n#### 另一种分类\n根据泄露的数据集和目标密码是否来自同一数据源，拖网场景可以进一步分为站内场景和跨站场景。 虽然跨站密码猜测场景较为真实，但攻击者一般以掌握目标数据的部分分布信息为前提来猜测密码。\n\n\n### 定向密码猜测\n定向整体来说其实是对传统的优化，比如不改变核心思想的前提下修改嵌入，数据预处理等方面。\n#### 神经定向密码猜测\n\n随着自然语言处理技术的发展，一些复杂的神经网络被应用到目标密码猜测领域。\n1. PG-PASS：由指针生成网络组成的有针对性的口令猜测模型。该工作创新性地将目标口令猜测作为一项摘要任务，并将智能摘要领域中常用的指针网络技术应用于该任务。需要注意的是，除了用户的人口统计相关信息(姓名、生日等)外，攻击者还可以利用用户在其他网站上泄露的密码进行有针对性的攻击。可以预期，这种利用用户密码重复使用这一易受攻击行为的定向攻击可能比基于人口统计相关信息的攻击更具危害性。\n2. 重用模型：重用或微调旧密码来生成新密码的事实，引入深度学习技术来表征用户的密码重复使用行为。更具体地说，他们训练了序列到序列(Seq2seq)模型，以预测将现有密码转换为其姊妹密码所需的修改，并在大规模数据集(即4iQ数据集)上进行了验证。\n3. PASS2EDIT：有针对性的密码猜测算法，用于模拟日益严重的凭据篡改攻击，在该攻击中，攻击者利用受害者泄露的密码来提高在其他站点猜测受害者密码的成功率。特别是，他们提出了一种多步决策训练机制，并建立了一个分类神经网络来学习一步编辑操作对现有密码的反应。由于每项工作使用的数据集不同，因此很难进行横断面比较。\n\n#### 传统定向密码猜测\n攻击者使用与目标人员相关的个人信息来增强猜测。\n\n基于拖网马尔可夫攻击模型的定向攻击猜测方法：\n1. 基本思想是，关于使用某些个人信息的人口的百分比，攻击目标也将具有相同的使用该个人信息的可能性百分比。\n\t1. 首先将PII划分为几种类型，如用户名-A、电子邮件前缀-E和名称-N，并根据所需的粒度进一步细分每种广泛的类型。然后，将训练集的每个密码中的所有PII替换为对应的PII类型。\n\t2. 训练阶段的其余步骤与行走马尔可夫模型的步骤相同。\n\t3. 猜测集生成阶段分为两个步骤。\n\t\t1. 在第一步中，运行马尔可夫模型以生成中间猜测集合，该中间猜测集合包含直接可用的猜测，\n\t\t2. 第二步用相应的PII信息替换中间猜测中的基本PII类型字符。\n\n基于PCFG的定向攻击猜测方法：\n1. --Personal-PCFG。。其基本思想与PCFG攻击模型相同：根据字符类型和长度对密码进行切片。为了实现这一思想，将六种PI字符类型 (即用户名-A、电子邮件前缀-E、姓名-N、生日-B、电话号码-P和ID-G)等同于拖网PCFG模型中的L、D和S，从而在个人PCFG中有九种类型的字符。然后，在训练过程中，与拖网PCFG攻击模型中一样，训练集中的每个密码根据相应的字符类型及其长度进行分段。\n2. TarGuess Wang等人。提出了一个框架，它用四个数学概率模型系统地刻画了典型的定向猜测场景。\n\t1. 第一个场景TarGuess-I旨在利用用户的PII创建在线目标密码猜测。为了在密码中表示PII令牌，除了PCFG模型中的L、D和S标签外，作者还定义了基于个人信息类型的28个PII标签(例如，N1−N7和B1−B10)。对于每个PII标签，其下标编号表示该类型的PII使用的细分，而不是指示相应长度的下标编号，例如L、D和S标签。例如，N表示名称信息，而N1表示全名，而n2表示全名的缩写\n\t2. 第二个是Targuess-II，目的是根据用户在其他网站(例如Dodonew)中泄露的密码来猜测目标网站(例如CSDN)中的用户密码。具体地，作者提出了6种结构级和2种字符级助记转换来描述密码重用，并基于上述重用规则使用马尔可夫模型来刻画上下文无关的转换文法。\n\t3. 第三个是TarGuessIII，目的是使用姐妹密码和一些PII信息来猜测用户的密码。TarGuess-III将PII信息引入到TarGuess-II模型中，允许在结构级密码重用中嵌入PII信息。\n\t4. 与TarGuess-III相比，TarGuess-IV场景中的攻击者知道难以量化的额外PII(例如，性别、教育)。为了解决某些PII难以直接体现在口令中的问题，在这种难以量化的PII的基础上，巧妙地引入贝叶斯理论来计算口令的重用概率。\n\n3. RFGuess-PII.在RFGuess的基础上，Wang et al.提出了一种新的目标口令猜测模型RFGuess-PII。密码训练和生成过程类似于拖网猜测场景。不同的是，通过新的PII匹配，密码中的PII字符串被替换为相应的数字标签。这种新的PII匹配旨在最小化信息熵，并试图准确地提取整个用户组的PII使用行为。PII匹配算法的第一步是细分PII的各种可能的变换，并使用数字标签来表示它们。第二步是为训练集中的每个密码列出具有PII标签的所有可能的表示。然后，按频率从高到低对表征进行排序。\n\n4. RFGuess-重复使用。除了基于PII的针对性密码破解研究外，作者还专注于对用户的密码重复使用行为进行建模。他们还考虑了结构级和段级转换，如TarGuess-II。具体地，它们通过计算训练集中每个密码对的编辑矩阵来计算结构级转换，并训练基于随机森林的段级转换(即，相同类型的字符串内的转换，例如字母段中的密码→密码)模型。\n\n5. TG-SPSR图谱。马尔可夫模型和PCFG模型转化为目标攻击，提出了一种基于结构划分和字符串重组的系统目标攻击模型，称为TG-SPSR。在结构划分阶段，除了将密码划分为类似于PCFG的基本结构外，还在基本语法模式中定义了基于轨迹的键盘，并引入了索引位来准确描述特殊字符的位置。此外，基于定义的9条修改规则，构造了一个BiLSTM分类器来重用和修改密码的行为。\n\n\n# 可能的方向\n总体来说还是做的工作挺多的，16-23年提出来了三十多种方法，2016年至2018年零星出版数量较少，2021年增至9种。。但是当前比较热门的还是基于深度学习的密码猜测方法。\n1. 修改模型结构提高模型训练时的速度：在低资源的情况下快速执行密码猜测也是具有挑战性的。\n2. 尝试大模型：预训练的语言模型近年来在自然语言处理领域应用很成熟。可以尝试关于密码猜测的预训练/精调范式，将预先训练的语言模型强大的通用语言建模功能与现有的密码猜测工作结合起来\n3. 尝试更多模型：目前的神经密码猜测方法都有一个前提，即密码字符串是一个字符序列，使用序列编码对密码进行处理。比如根据密码的语义依赖将密码组织成图，并使用最新的图神经网络(GNN)相关技术进行采样和生成。\n4. 传统猜测方法与深度学习方法相结合。比如用深度学习生成规则等。\n\n\n# 之后的想法\n1. 这两周涉及到了解一些背景所以读的也比较仔细，后面计划读快一些，重点关注方法和创新性。\n2. 选择较新，效果较好，的论文尝试复现，分析数据，寻找优化的点。\n\n","slug":"研究方向/方向：密码生成","published":1,"date":"2024-04-22T13:14:49.293Z","updated":"2024-04-18T12:01:59.583Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0f000ykgg40d72bbbs","content":"<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>互联网和安全不断发展，互联网的开放性也带来了许多内在的安全隐患。</p>\n<p>为了保护用户信息，当前已经产生了多种认证方式：<br>身份认证的分类：</p>\n<ol>\n<li>用户知道的：密码，个人识别码</li>\n<li>用户拥有的：U盾，加密卡</li>\n<li>用户本身的：<ol>\n<li>生理特征：指纹，虹膜</li>\n<li>行为特征：手写</li>\n</ol>\n</li>\n</ol>\n<p>对于上面这些认证方式，其中密码（即口令）破解是最常见的认证方式，原因主要有：</p>\n<ol>\n<li>互联网应用不断发展，人们不得不设置许多满足不同密码策略的密码来保护相应的软件应用程序。</li>\n<li>人的记忆能力有限。研究表明，人类只能记住五到七个密码，因此在设置密码时普遍会使用一些低信息熵的密码，比如：<ol>\n<li>在多个系统中使用相同密码</li>\n<li>在密码中使用个人相关信息</li>\n</ol>\n</li>\n<li>大量知名网站的密码文件被泄露：比如著名的 rockyou数据集就是2018年受黑客攻击而泄漏的。</li>\n</ol>\n<p>且人工智能以及到现在 大模型的产生和发展更进一步增强了破解口令认证系统的能力，因此对于这方面的研究也显得更加迫切和重要。<br>（对口令认证系统攻击最严重的是口令猜测攻击）</p>\n<h1 id=\"口令猜测分类\"><a href=\"#口令猜测分类\" class=\"headerlink\" title=\"口令猜测分类\"></a>口令猜测分类</h1><p>（<br>密码猜测的角度|方法：</p>\n<ol>\n<li>启发式搜索</li>\n<li>概率模型</li>\n<li>深度学习<br>）</li>\n</ol>\n<p>根据是否在线（也就是是否与服务器进行交互）：</p>\n<ol>\n<li>离线密码猜测</li>\n<li>在线密码猜测</li>\n</ol>\n<p>（前一种攻击要求身份验证服务器存储用户帐户密码文件，然后攻击者在本地主机上猜测密码。在这种情况下，可以尝试的猜测次数仅受攻击者的计算资源的限制。后者不需要密码文件，攻击者只需要连接到网络即可。然而，可以尝试的猜测次数往往受到服务器安全策略的限制，例如美国国家身份标准NIST-800-63-3，其中规定政府网站系统一个月允许的最大登录失败次数为100次，如果超过100次，帐户将被锁定。）</p>\n<p>根据是否利用用户的个人信息：</p>\n<ol>\n<li>拖网猜测。</li>\n<li>定向猜测，利用用户个人信息。<br>（拖网猜测主要利用用户选择流行密码的倾向，而定向猜测不仅利用普通用户使用流行密码的漏洞，还利用用户重复使用密码和使用个人信息构建密码的漏洞。在个人身份信息和历史密码等信息的帮助下，定向密码猜测的成功率明显高于相同猜测次数的拖网猜测）</li>\n</ol>\n<p>是否使用人工智能：</p>\n<ol>\n<li>传统攻击</li>\n<li>神经攻击<br>（前者将密码猜测作为一项文本生成任务，依靠人工智能相关技术在大规模密码训练语料库上生成文本密码。后者封装了其他方法，不包括深度神经网络猜测方法。）</li>\n</ol>\n<p>（几乎所有现有的工作都是离线猜测，而在线猜测太难在100个猜测内猜出一个密码。所以当前的分类方式主要为：传统的。。基于神经网络的。。）</p>\n<p>（说一下如何比较生成密码的质量：<br>    1. 生成的唯一密码个数和比例；<br>    2. 生成密码的速度；<br>    3. 生成的密码和训练数据集之外其他数据集的匹配个数<br>   ）</p>\n<h3 id=\"拖网猜测\"><a href=\"#拖网猜测\" class=\"headerlink\" title=\"拖网猜测\"></a>拖网猜测</h3><h4 id=\"传统拖网猜测\"><a href=\"#传统拖网猜测\" class=\"headerlink\" title=\"传统拖网猜测\"></a>传统拖网猜测</h4><ol>\n<li>启发式算法<blockquote>\n<p>这些算法没有严格的理论体系，严重依赖于零散的奇思妙想，例如，基于开源软件使用精心设计的猜测序列构建独特的猜测词典。这些启发式方法很难重现，也很难相互公平地比较。因此，在这里，我们只介绍一些常用的启发式密码猜测工具。</p>\n</blockquote>\n<ol>\n<li>Jtr是一个密码猜测工具，专注于破解UNIX&#x2F;Linux系统的弱密码。在JTR中有四种模式–简单破解模式、单词表模式、增量模式和外部模式。</li>\n<li>Hashcat是世界上速度最快、最先进的密码恢复实用程序，支持针对300多种高度优化的哈希算法的五种独特攻击模式。Hashcat目前支持Linux、Windows和MacOS上的CPU、GPU和其他硬件加速器，并具有帮助启用分布式密码破解的设施。<blockquote>\n<p>彩虹攻击：<br>一种基于预先计算和空间-时间折中的攻击方法。通过事先计算大量的密码和散列值之间的对应关系（彩虹表），以便在攻击时快速查找并破解散列值。彩虹表是一个预先计算的表格，其中包含了大量的密码和对应的散列值。通过在彩虹表中进行查找，攻击者可以找到与目标散列值匹配的原始密码。</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li>概率上下文无关语法<br> 该算法的核心假设是密码的字母段L、数字段D和特殊字符段S相互独立。该算法包括训练和猜测两个阶段。<ol>\n<li>在训练阶段，最关键的是根据泄露的密码数据集计算密码模式(结构)和字符成分(语义)的频率。</li>\n<li>在猜测阶段，根据训练阶段得到的模式频率表和语义频率表生成具有频率猜测的集合，以模拟真实密码的概率分布。<br> 粒度太细，无法获得字符之间的语义关系，改进：</li>\n<li>基于词的内聚力和自由度提取密码中的语义片段，并对基于语义片段的PCFG算法进行改进</li>\n<li>密码视为由几个块组成，其中块是频繁出现在一起以模拟密码的相关字符的序列。</li>\n<li>扩展字节对编码(BPE)算法，它使用块词汇表平均长度的可配置参数来替换合并操作的数量。</li>\n<li>为了解决长密码猜测的困难，提出了一种改进的基于PCFG的LONG</li>\n</ol>\n</li>\n<li>马尔可夫序列决策<br> 该算法的核心假设是用户从前到后依次构造口令。它不像PCFG那样分割密码，而是训练整个密码，并通过从左到右链接字符来计算密码的概率。<ol>\n<li>传统的马尔可夫模型因其结构简单、推理速度快而被广泛应用于口令猜测工作中。但是，它也有一定的缺陷，如过度拟合、重复率高、基于随机抽样生成的密码覆盖率低等。</li>\n<li>过拟合：将拉普拉斯平滑和结束符号正则化技术应用于马尔可夫模型。平滑策略消除了数据集中的过拟合问题，正则化技术使攻击算法产生的猜测概率总是和为1。</li>\n<li>重复率：设计了一种基于随机抽样的动态分配机制。该机制允许动态调整密码的概率分布，并在猜测过程中严格收敛到均匀分布。基于上述动态分布机制，提出了一种动态马尔可夫模型。</li>\n<li>对口令中的语义段进行建模：提出了一个名为Word马尔可夫的模型，通过语义分段从密码中提取单词的凝聚力和自由度。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"神经拖网猜测算法\"><a href=\"#神经拖网猜测算法\" class=\"headerlink\" title=\"神经拖网猜测算法\"></a>神经拖网猜测算法</h4><p>密码猜测任务视为文本生成问题，核心就是把密码数据集给神经网络进行训练，并利用训练好的模型生成候选密码。</p>\n<ol>\n<li>递归神经网络(RNN)：递归神经网络以序列数据为输入，在序列进化方向上递归，所有节点以链的形式连接。 RNN 有许多变体：如： LSTM，GRU，BiLSTM 等。<ol>\n<li>步骤：基于RNN的密码猜测方法通常有以下两个步骤：<ol>\n<li>·将训练集中的密码序列输入到RNN模型中，以进行顺序文本生成的训练。</li>\n<li>训练好的 RNN 猜测模型旨在根据已有的密码字符生成下一个密码字符，直到输出终止字符位置。</li>\n</ol>\n</li>\n<li>在整个密码生成过程中，RNN计算任何字符作为下一个密码令牌的概率。对于给定的阈值，概率高于阈值的密码将被放入密码猜测集中作为有效密码。</li>\n<li>一些变体：<ol>\n<li>对密码单词进行切分，在词段的基础上使用BiLSTM生成密码。</li>\n<li>层次语义模型HSM，该模型将LSTM和语义分析相结合，用于挖掘用于密码猜测的词之间潜在的概率关系。</li>\n<li>基于汉字音节的密码猜测方法。该方法将汉语音节作为整体元素对密码进行解析和处理。然后，在LSTM神经网络中对处理后的密码进行训练以生成密码。</li>\n<li>特别是具有注意力机制的RNN来组合和内插同一组用户的信息，以定义比他们的密码分布更稳健和准确的优先级。推理时使用辅助数据来适应目标密码的分布。通过这种方式，开发了一种利用辅助信息并实例化上下文感知口令计量和猜测攻击的全自动方法，而不需要来自目标口令分布的任何明文样本。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>生成式对抗网络（GAN）：<ol>\n<li>基于GAN的密码猜测模型由密码生成器和鉴别器组成。这两个网络相互对抗，不断地调整参数。最终目的是使鉴别器网络无法判断生成网络的输出是否真实，从而达到口令生成的效果。</li>\n<li>问题：离散密码数据的不可微性可能导致梯度反向传播失败，基于GAN的密码猜测模型训练难以收敛，由GAN模型生成的密码重复率较高。</li>\n<li>离散数据不可微问题解决：<ol>\n<li>使用Gumbel-Softmax松弛技术来训练基于GAN的密码猜测模型。</li>\n<li>使用通过附加的自动编码器获得的真实口令的平滑表示。</li>\n<li>种基于SeqGAN的密码猜测方法RLPassGAN，该方法使用策略梯度来确保模型参数的持续优化。</li>\n</ol>\n</li>\n<li>收敛困难的问题解决：基于双向生成对抗网络的猜测算法，提高了算法的收敛速度。与传统的GaN相比，它可以在更短的时间内产生相同数量的样本</li>\n<li>重复率高问题解决：<ol>\n<li>使用蒙特卡罗搜索来评估中间层输出处的不完整密码序列，减少冗余的合成密码。（此外，通过蒙特卡罗搜索来评估输出的不完整密码序列。蒙特卡罗是一种使用大量随机样本来了解特定系统的计算方法。）</li>\n<li>使用鉴别器和控制器构建额外的控制器网络，以分别学习生成的密码分布与真实密码分布和均匀分布之间的度量。然后利用这两个度量对生成器进行训练，从而降低了口令生成的重复率。</li>\n<li>RLPass：还创新性地将表征学习用于密码猜测。具体地，将密码投影到隐藏空间，并且使用隐藏空间中的密码表示之间的距离来定义密码的相似性。基于口令的强局部性和弱局部性现象，提出了一种动态口令猜测和条件口令算法。</li>\n</ol>\n</li>\n<li>GAN的模型生成的长密码质量较低的问题解决：设计了一种基于DenseNet的GAN密码猜测结构DenseGAN，并提出了两种新的密码猜测DenseGAN模型，这两种模型都能生成高质量的密码猜测。</li>\n</ol>\n</li>\n<li>自动编码器（AE）：它基于反向传播算法和优化方法，使用输入数据本身作为监督来指导神经网络学习映射关系，以获得重建的输出。AE 包括编码器和解码器两部分。根据学习范式，AE 可分为欠完备自动编码器、正则化自动编码器和变分自动编码器，其中前两种是判别性模型，后者是生成性模型。<ol>\n<li>在拖网密码猜测的研究中，通常使用<strong>变分自动编码器</strong>来生成密码猜测。将密码样本输入到VAE的编码器以获得表示，然后使用解码器基于该表示重建样本。基于输入和输出之间的重构损失来训练密码生成器。除了使用最经典的VAE框架来猜测密码，也提出来了许多优化。<ol>\n<li>优化 GAN：将VAE技术与GaN技术相结合，用VAE代替GaN生成器，旨在解决离散口令数据的反向传播问题。</li>\n<li>轻量级问题：用门控卷积神经网络(GCNN)代替了复杂的RNN生成单元，降低了模型的复杂性。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>Transformer.<br> ![[Pasted image 20240305201324.png]]<br> Transformer 模型采用编解码器体系结构，并使用注意力机制替换 Seq2Seq 模型中的递归结构，以实现序列建模的并行化。这种并行化结构给自然语言处理 (NLP) 领域带来了巨大的冲击。随着研究的深入，相关技术逐渐从自然语言处理向计算机视觉 (CV)、语音、生物、化学等领域发展。同样，在拖网密码猜测的研究中也出现了一些基于Transformer的方法：<ol>\n<li>基于改进 Transformer 的口令猜测模型：将消息（个人信息和密码的相关性）权重引入到数据预处理中，并在模型中使用改进的波束搜索算法来快速搜索排名靠前的密码猜测。</li>\n<li>PassBERT：基于双向 Transformer 的猜测框架，首次将预训练&#x2F;微调的范式应用于密码破解。具体地说，<ol>\n<li>首先，作者设计了包含一般密码分布知识的通用密码预训练模型。</li>\n<li>然后，提出了三种特定于攻击的微调方法来定制预先训练的口令模型以适应以下真实攻击场景：条件口令猜测、目标口令猜测和基于自适应规则的口令猜测。最后，他们进一步提出了一种混合密码强度计来降低这三种攻击的风险。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>Reinforcement Learning (RL) 强化学习<ol>\n<li>RL是机器学习的范例和方法之一，用于描述和解决智能代理在与环境交互过程中最大化回报或实现特定目标的学习策略问题。密码生成器是代理，每个生成的密码序列代表一个完整的轨迹，生成过程中的每个字符都被视为一个操作。例如，由时间戳t生成的字符是action at。根据由所生成的不完整序列确定的关于当前状态ST的随机策略来生成每个动作At。生成器根据一组随机策略从任意字符生成密码，直到满足预定长度。</li>\n<li>RLPassGAN：遵循SeqGAN，将密码猜测视为一个连续决策，并使用策略梯度 来确保参数可以连续优化。</li>\n</ol>\n</li>\n<li>Flow： （一个强大的密度估计统计工具）流动模型的一个非常独特的特征是，它的转变通常是可逆的。流模型不仅找到了从分布Z转移到分布X的网络路径，而且该路径还允许X改变为Z。简而言之，流模型找到了分布Z和X之间的双向路径（Z和X的数据维度必须相同）。<ol>\n<li>PassFlow：基于产生流模型的口令猜测方法。基于流的口令猜测模型使用精确的对数似然计算和优化，使潜在变量的推断更加准确。此外，还给出了潜在空间的一种有意义的表示，这使得探索潜在空间的特定子空间和内插等操作成为可能。（密码猜测方面优于现有的基于GAN的方法）</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"另一种分类\"><a href=\"#另一种分类\" class=\"headerlink\" title=\"另一种分类\"></a>另一种分类</h4><p>根据泄露的数据集和目标密码是否来自同一数据源，拖网场景可以进一步分为站内场景和跨站场景。 虽然跨站密码猜测场景较为真实，但攻击者一般以掌握目标数据的部分分布信息为前提来猜测密码。</p>\n<h3 id=\"定向密码猜测\"><a href=\"#定向密码猜测\" class=\"headerlink\" title=\"定向密码猜测\"></a>定向密码猜测</h3><p>定向整体来说其实是对传统的优化，比如不改变核心思想的前提下修改嵌入，数据预处理等方面。</p>\n<h4 id=\"神经定向密码猜测\"><a href=\"#神经定向密码猜测\" class=\"headerlink\" title=\"神经定向密码猜测\"></a>神经定向密码猜测</h4><p>随着自然语言处理技术的发展，一些复杂的神经网络被应用到目标密码猜测领域。</p>\n<ol>\n<li>PG-PASS：由指针生成网络组成的有针对性的口令猜测模型。该工作创新性地将目标口令猜测作为一项摘要任务，并将智能摘要领域中常用的指针网络技术应用于该任务。需要注意的是，除了用户的人口统计相关信息(姓名、生日等)外，攻击者还可以利用用户在其他网站上泄露的密码进行有针对性的攻击。可以预期，这种利用用户密码重复使用这一易受攻击行为的定向攻击可能比基于人口统计相关信息的攻击更具危害性。</li>\n<li>重用模型：重用或微调旧密码来生成新密码的事实，引入深度学习技术来表征用户的密码重复使用行为。更具体地说，他们训练了序列到序列(Seq2seq)模型，以预测将现有密码转换为其姊妹密码所需的修改，并在大规模数据集(即4iQ数据集)上进行了验证。</li>\n<li>PASS2EDIT：有针对性的密码猜测算法，用于模拟日益严重的凭据篡改攻击，在该攻击中，攻击者利用受害者泄露的密码来提高在其他站点猜测受害者密码的成功率。特别是，他们提出了一种多步决策训练机制，并建立了一个分类神经网络来学习一步编辑操作对现有密码的反应。由于每项工作使用的数据集不同，因此很难进行横断面比较。</li>\n</ol>\n<h4 id=\"传统定向密码猜测\"><a href=\"#传统定向密码猜测\" class=\"headerlink\" title=\"传统定向密码猜测\"></a>传统定向密码猜测</h4><p>攻击者使用与目标人员相关的个人信息来增强猜测。</p>\n<p>基于拖网马尔可夫攻击模型的定向攻击猜测方法：</p>\n<ol>\n<li>基本思想是，关于使用某些个人信息的人口的百分比，攻击目标也将具有相同的使用该个人信息的可能性百分比。<ol>\n<li>首先将PII划分为几种类型，如用户名-A、电子邮件前缀-E和名称-N，并根据所需的粒度进一步细分每种广泛的类型。然后，将训练集的每个密码中的所有PII替换为对应的PII类型。</li>\n<li>训练阶段的其余步骤与行走马尔可夫模型的步骤相同。</li>\n<li>猜测集生成阶段分为两个步骤。<ol>\n<li>在第一步中，运行马尔可夫模型以生成中间猜测集合，该中间猜测集合包含直接可用的猜测，</li>\n<li>第二步用相应的PII信息替换中间猜测中的基本PII类型字符。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p>基于PCFG的定向攻击猜测方法：</p>\n<ol>\n<li><p>–Personal-PCFG。。其基本思想与PCFG攻击模型相同：根据字符类型和长度对密码进行切片。为了实现这一思想，将六种PI字符类型 (即用户名-A、电子邮件前缀-E、姓名-N、生日-B、电话号码-P和ID-G)等同于拖网PCFG模型中的L、D和S，从而在个人PCFG中有九种类型的字符。然后，在训练过程中，与拖网PCFG攻击模型中一样，训练集中的每个密码根据相应的字符类型及其长度进行分段。</p>\n</li>\n<li><p>TarGuess Wang等人。提出了一个框架，它用四个数学概率模型系统地刻画了典型的定向猜测场景。</p>\n<ol>\n<li>第一个场景TarGuess-I旨在利用用户的PII创建在线目标密码猜测。为了在密码中表示PII令牌，除了PCFG模型中的L、D和S标签外，作者还定义了基于个人信息类型的28个PII标签(例如，N1−N7和B1−B10)。对于每个PII标签，其下标编号表示该类型的PII使用的细分，而不是指示相应长度的下标编号，例如L、D和S标签。例如，N表示名称信息，而N1表示全名，而n2表示全名的缩写</li>\n<li>第二个是Targuess-II，目的是根据用户在其他网站(例如Dodonew)中泄露的密码来猜测目标网站(例如CSDN)中的用户密码。具体地，作者提出了6种结构级和2种字符级助记转换来描述密码重用，并基于上述重用规则使用马尔可夫模型来刻画上下文无关的转换文法。</li>\n<li>第三个是TarGuessIII，目的是使用姐妹密码和一些PII信息来猜测用户的密码。TarGuess-III将PII信息引入到TarGuess-II模型中，允许在结构级密码重用中嵌入PII信息。</li>\n<li>与TarGuess-III相比，TarGuess-IV场景中的攻击者知道难以量化的额外PII(例如，性别、教育)。为了解决某些PII难以直接体现在口令中的问题，在这种难以量化的PII的基础上，巧妙地引入贝叶斯理论来计算口令的重用概率。</li>\n</ol>\n</li>\n<li><p>RFGuess-PII.在RFGuess的基础上，Wang et al.提出了一种新的目标口令猜测模型RFGuess-PII。密码训练和生成过程类似于拖网猜测场景。不同的是，通过新的PII匹配，密码中的PII字符串被替换为相应的数字标签。这种新的PII匹配旨在最小化信息熵，并试图准确地提取整个用户组的PII使用行为。PII匹配算法的第一步是细分PII的各种可能的变换，并使用数字标签来表示它们。第二步是为训练集中的每个密码列出具有PII标签的所有可能的表示。然后，按频率从高到低对表征进行排序。</p>\n</li>\n<li><p>RFGuess-重复使用。除了基于PII的针对性密码破解研究外，作者还专注于对用户的密码重复使用行为进行建模。他们还考虑了结构级和段级转换，如TarGuess-II。具体地，它们通过计算训练集中每个密码对的编辑矩阵来计算结构级转换，并训练基于随机森林的段级转换(即，相同类型的字符串内的转换，例如字母段中的密码→密码)模型。</p>\n</li>\n<li><p>TG-SPSR图谱。马尔可夫模型和PCFG模型转化为目标攻击，提出了一种基于结构划分和字符串重组的系统目标攻击模型，称为TG-SPSR。在结构划分阶段，除了将密码划分为类似于PCFG的基本结构外，还在基本语法模式中定义了基于轨迹的键盘，并引入了索引位来准确描述特殊字符的位置。此外，基于定义的9条修改规则，构造了一个BiLSTM分类器来重用和修改密码的行为。</p>\n</li>\n</ol>\n<h1 id=\"可能的方向\"><a href=\"#可能的方向\" class=\"headerlink\" title=\"可能的方向\"></a>可能的方向</h1><p>总体来说还是做的工作挺多的，16-23年提出来了三十多种方法，2016年至2018年零星出版数量较少，2021年增至9种。。但是当前比较热门的还是基于深度学习的密码猜测方法。</p>\n<ol>\n<li>修改模型结构提高模型训练时的速度：在低资源的情况下快速执行密码猜测也是具有挑战性的。</li>\n<li>尝试大模型：预训练的语言模型近年来在自然语言处理领域应用很成熟。可以尝试关于密码猜测的预训练&#x2F;精调范式，将预先训练的语言模型强大的通用语言建模功能与现有的密码猜测工作结合起来</li>\n<li>尝试更多模型：目前的神经密码猜测方法都有一个前提，即密码字符串是一个字符序列，使用序列编码对密码进行处理。比如根据密码的语义依赖将密码组织成图，并使用最新的图神经网络(GNN)相关技术进行采样和生成。</li>\n<li>传统猜测方法与深度学习方法相结合。比如用深度学习生成规则等。</li>\n</ol>\n<h1 id=\"之后的想法\"><a href=\"#之后的想法\" class=\"headerlink\" title=\"之后的想法\"></a>之后的想法</h1><ol>\n<li>这两周涉及到了解一些背景所以读的也比较仔细，后面计划读快一些，重点关注方法和创新性。</li>\n<li>选择较新，效果较好，的论文尝试复现，分析数据，寻找优化的点。</li>\n</ol>\n","excerpt":"","more":"<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>互联网和安全不断发展，互联网的开放性也带来了许多内在的安全隐患。</p>\n<p>为了保护用户信息，当前已经产生了多种认证方式：<br>身份认证的分类：</p>\n<ol>\n<li>用户知道的：密码，个人识别码</li>\n<li>用户拥有的：U盾，加密卡</li>\n<li>用户本身的：<ol>\n<li>生理特征：指纹，虹膜</li>\n<li>行为特征：手写</li>\n</ol>\n</li>\n</ol>\n<p>对于上面这些认证方式，其中密码（即口令）破解是最常见的认证方式，原因主要有：</p>\n<ol>\n<li>互联网应用不断发展，人们不得不设置许多满足不同密码策略的密码来保护相应的软件应用程序。</li>\n<li>人的记忆能力有限。研究表明，人类只能记住五到七个密码，因此在设置密码时普遍会使用一些低信息熵的密码，比如：<ol>\n<li>在多个系统中使用相同密码</li>\n<li>在密码中使用个人相关信息</li>\n</ol>\n</li>\n<li>大量知名网站的密码文件被泄露：比如著名的 rockyou数据集就是2018年受黑客攻击而泄漏的。</li>\n</ol>\n<p>且人工智能以及到现在 大模型的产生和发展更进一步增强了破解口令认证系统的能力，因此对于这方面的研究也显得更加迫切和重要。<br>（对口令认证系统攻击最严重的是口令猜测攻击）</p>\n<h1 id=\"口令猜测分类\"><a href=\"#口令猜测分类\" class=\"headerlink\" title=\"口令猜测分类\"></a>口令猜测分类</h1><p>（<br>密码猜测的角度|方法：</p>\n<ol>\n<li>启发式搜索</li>\n<li>概率模型</li>\n<li>深度学习<br>）</li>\n</ol>\n<p>根据是否在线（也就是是否与服务器进行交互）：</p>\n<ol>\n<li>离线密码猜测</li>\n<li>在线密码猜测</li>\n</ol>\n<p>（前一种攻击要求身份验证服务器存储用户帐户密码文件，然后攻击者在本地主机上猜测密码。在这种情况下，可以尝试的猜测次数仅受攻击者的计算资源的限制。后者不需要密码文件，攻击者只需要连接到网络即可。然而，可以尝试的猜测次数往往受到服务器安全策略的限制，例如美国国家身份标准NIST-800-63-3，其中规定政府网站系统一个月允许的最大登录失败次数为100次，如果超过100次，帐户将被锁定。）</p>\n<p>根据是否利用用户的个人信息：</p>\n<ol>\n<li>拖网猜测。</li>\n<li>定向猜测，利用用户个人信息。<br>（拖网猜测主要利用用户选择流行密码的倾向，而定向猜测不仅利用普通用户使用流行密码的漏洞，还利用用户重复使用密码和使用个人信息构建密码的漏洞。在个人身份信息和历史密码等信息的帮助下，定向密码猜测的成功率明显高于相同猜测次数的拖网猜测）</li>\n</ol>\n<p>是否使用人工智能：</p>\n<ol>\n<li>传统攻击</li>\n<li>神经攻击<br>（前者将密码猜测作为一项文本生成任务，依靠人工智能相关技术在大规模密码训练语料库上生成文本密码。后者封装了其他方法，不包括深度神经网络猜测方法。）</li>\n</ol>\n<p>（几乎所有现有的工作都是离线猜测，而在线猜测太难在100个猜测内猜出一个密码。所以当前的分类方式主要为：传统的。。基于神经网络的。。）</p>\n<p>（说一下如何比较生成密码的质量：<br>    1. 生成的唯一密码个数和比例；<br>    2. 生成密码的速度；<br>    3. 生成的密码和训练数据集之外其他数据集的匹配个数<br>   ）</p>\n<h3 id=\"拖网猜测\"><a href=\"#拖网猜测\" class=\"headerlink\" title=\"拖网猜测\"></a>拖网猜测</h3><h4 id=\"传统拖网猜测\"><a href=\"#传统拖网猜测\" class=\"headerlink\" title=\"传统拖网猜测\"></a>传统拖网猜测</h4><ol>\n<li>启发式算法<blockquote>\n<p>这些算法没有严格的理论体系，严重依赖于零散的奇思妙想，例如，基于开源软件使用精心设计的猜测序列构建独特的猜测词典。这些启发式方法很难重现，也很难相互公平地比较。因此，在这里，我们只介绍一些常用的启发式密码猜测工具。</p>\n</blockquote>\n<ol>\n<li>Jtr是一个密码猜测工具，专注于破解UNIX&#x2F;Linux系统的弱密码。在JTR中有四种模式–简单破解模式、单词表模式、增量模式和外部模式。</li>\n<li>Hashcat是世界上速度最快、最先进的密码恢复实用程序，支持针对300多种高度优化的哈希算法的五种独特攻击模式。Hashcat目前支持Linux、Windows和MacOS上的CPU、GPU和其他硬件加速器，并具有帮助启用分布式密码破解的设施。<blockquote>\n<p>彩虹攻击：<br>一种基于预先计算和空间-时间折中的攻击方法。通过事先计算大量的密码和散列值之间的对应关系（彩虹表），以便在攻击时快速查找并破解散列值。彩虹表是一个预先计算的表格，其中包含了大量的密码和对应的散列值。通过在彩虹表中进行查找，攻击者可以找到与目标散列值匹配的原始密码。</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li>概率上下文无关语法<br> 该算法的核心假设是密码的字母段L、数字段D和特殊字符段S相互独立。该算法包括训练和猜测两个阶段。<ol>\n<li>在训练阶段，最关键的是根据泄露的密码数据集计算密码模式(结构)和字符成分(语义)的频率。</li>\n<li>在猜测阶段，根据训练阶段得到的模式频率表和语义频率表生成具有频率猜测的集合，以模拟真实密码的概率分布。<br> 粒度太细，无法获得字符之间的语义关系，改进：</li>\n<li>基于词的内聚力和自由度提取密码中的语义片段，并对基于语义片段的PCFG算法进行改进</li>\n<li>密码视为由几个块组成，其中块是频繁出现在一起以模拟密码的相关字符的序列。</li>\n<li>扩展字节对编码(BPE)算法，它使用块词汇表平均长度的可配置参数来替换合并操作的数量。</li>\n<li>为了解决长密码猜测的困难，提出了一种改进的基于PCFG的LONG</li>\n</ol>\n</li>\n<li>马尔可夫序列决策<br> 该算法的核心假设是用户从前到后依次构造口令。它不像PCFG那样分割密码，而是训练整个密码，并通过从左到右链接字符来计算密码的概率。<ol>\n<li>传统的马尔可夫模型因其结构简单、推理速度快而被广泛应用于口令猜测工作中。但是，它也有一定的缺陷，如过度拟合、重复率高、基于随机抽样生成的密码覆盖率低等。</li>\n<li>过拟合：将拉普拉斯平滑和结束符号正则化技术应用于马尔可夫模型。平滑策略消除了数据集中的过拟合问题，正则化技术使攻击算法产生的猜测概率总是和为1。</li>\n<li>重复率：设计了一种基于随机抽样的动态分配机制。该机制允许动态调整密码的概率分布，并在猜测过程中严格收敛到均匀分布。基于上述动态分布机制，提出了一种动态马尔可夫模型。</li>\n<li>对口令中的语义段进行建模：提出了一个名为Word马尔可夫的模型，通过语义分段从密码中提取单词的凝聚力和自由度。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"神经拖网猜测算法\"><a href=\"#神经拖网猜测算法\" class=\"headerlink\" title=\"神经拖网猜测算法\"></a>神经拖网猜测算法</h4><p>密码猜测任务视为文本生成问题，核心就是把密码数据集给神经网络进行训练，并利用训练好的模型生成候选密码。</p>\n<ol>\n<li>递归神经网络(RNN)：递归神经网络以序列数据为输入，在序列进化方向上递归，所有节点以链的形式连接。 RNN 有许多变体：如： LSTM，GRU，BiLSTM 等。<ol>\n<li>步骤：基于RNN的密码猜测方法通常有以下两个步骤：<ol>\n<li>·将训练集中的密码序列输入到RNN模型中，以进行顺序文本生成的训练。</li>\n<li>训练好的 RNN 猜测模型旨在根据已有的密码字符生成下一个密码字符，直到输出终止字符位置。</li>\n</ol>\n</li>\n<li>在整个密码生成过程中，RNN计算任何字符作为下一个密码令牌的概率。对于给定的阈值，概率高于阈值的密码将被放入密码猜测集中作为有效密码。</li>\n<li>一些变体：<ol>\n<li>对密码单词进行切分，在词段的基础上使用BiLSTM生成密码。</li>\n<li>层次语义模型HSM，该模型将LSTM和语义分析相结合，用于挖掘用于密码猜测的词之间潜在的概率关系。</li>\n<li>基于汉字音节的密码猜测方法。该方法将汉语音节作为整体元素对密码进行解析和处理。然后，在LSTM神经网络中对处理后的密码进行训练以生成密码。</li>\n<li>特别是具有注意力机制的RNN来组合和内插同一组用户的信息，以定义比他们的密码分布更稳健和准确的优先级。推理时使用辅助数据来适应目标密码的分布。通过这种方式，开发了一种利用辅助信息并实例化上下文感知口令计量和猜测攻击的全自动方法，而不需要来自目标口令分布的任何明文样本。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>生成式对抗网络（GAN）：<ol>\n<li>基于GAN的密码猜测模型由密码生成器和鉴别器组成。这两个网络相互对抗，不断地调整参数。最终目的是使鉴别器网络无法判断生成网络的输出是否真实，从而达到口令生成的效果。</li>\n<li>问题：离散密码数据的不可微性可能导致梯度反向传播失败，基于GAN的密码猜测模型训练难以收敛，由GAN模型生成的密码重复率较高。</li>\n<li>离散数据不可微问题解决：<ol>\n<li>使用Gumbel-Softmax松弛技术来训练基于GAN的密码猜测模型。</li>\n<li>使用通过附加的自动编码器获得的真实口令的平滑表示。</li>\n<li>种基于SeqGAN的密码猜测方法RLPassGAN，该方法使用策略梯度来确保模型参数的持续优化。</li>\n</ol>\n</li>\n<li>收敛困难的问题解决：基于双向生成对抗网络的猜测算法，提高了算法的收敛速度。与传统的GaN相比，它可以在更短的时间内产生相同数量的样本</li>\n<li>重复率高问题解决：<ol>\n<li>使用蒙特卡罗搜索来评估中间层输出处的不完整密码序列，减少冗余的合成密码。（此外，通过蒙特卡罗搜索来评估输出的不完整密码序列。蒙特卡罗是一种使用大量随机样本来了解特定系统的计算方法。）</li>\n<li>使用鉴别器和控制器构建额外的控制器网络，以分别学习生成的密码分布与真实密码分布和均匀分布之间的度量。然后利用这两个度量对生成器进行训练，从而降低了口令生成的重复率。</li>\n<li>RLPass：还创新性地将表征学习用于密码猜测。具体地，将密码投影到隐藏空间，并且使用隐藏空间中的密码表示之间的距离来定义密码的相似性。基于口令的强局部性和弱局部性现象，提出了一种动态口令猜测和条件口令算法。</li>\n</ol>\n</li>\n<li>GAN的模型生成的长密码质量较低的问题解决：设计了一种基于DenseNet的GAN密码猜测结构DenseGAN，并提出了两种新的密码猜测DenseGAN模型，这两种模型都能生成高质量的密码猜测。</li>\n</ol>\n</li>\n<li>自动编码器（AE）：它基于反向传播算法和优化方法，使用输入数据本身作为监督来指导神经网络学习映射关系，以获得重建的输出。AE 包括编码器和解码器两部分。根据学习范式，AE 可分为欠完备自动编码器、正则化自动编码器和变分自动编码器，其中前两种是判别性模型，后者是生成性模型。<ol>\n<li>在拖网密码猜测的研究中，通常使用<strong>变分自动编码器</strong>来生成密码猜测。将密码样本输入到VAE的编码器以获得表示，然后使用解码器基于该表示重建样本。基于输入和输出之间的重构损失来训练密码生成器。除了使用最经典的VAE框架来猜测密码，也提出来了许多优化。<ol>\n<li>优化 GAN：将VAE技术与GaN技术相结合，用VAE代替GaN生成器，旨在解决离散口令数据的反向传播问题。</li>\n<li>轻量级问题：用门控卷积神经网络(GCNN)代替了复杂的RNN生成单元，降低了模型的复杂性。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>Transformer.<br> ![[Pasted image 20240305201324.png]]<br> Transformer 模型采用编解码器体系结构，并使用注意力机制替换 Seq2Seq 模型中的递归结构，以实现序列建模的并行化。这种并行化结构给自然语言处理 (NLP) 领域带来了巨大的冲击。随着研究的深入，相关技术逐渐从自然语言处理向计算机视觉 (CV)、语音、生物、化学等领域发展。同样，在拖网密码猜测的研究中也出现了一些基于Transformer的方法：<ol>\n<li>基于改进 Transformer 的口令猜测模型：将消息（个人信息和密码的相关性）权重引入到数据预处理中，并在模型中使用改进的波束搜索算法来快速搜索排名靠前的密码猜测。</li>\n<li>PassBERT：基于双向 Transformer 的猜测框架，首次将预训练&#x2F;微调的范式应用于密码破解。具体地说，<ol>\n<li>首先，作者设计了包含一般密码分布知识的通用密码预训练模型。</li>\n<li>然后，提出了三种特定于攻击的微调方法来定制预先训练的口令模型以适应以下真实攻击场景：条件口令猜测、目标口令猜测和基于自适应规则的口令猜测。最后，他们进一步提出了一种混合密码强度计来降低这三种攻击的风险。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>Reinforcement Learning (RL) 强化学习<ol>\n<li>RL是机器学习的范例和方法之一，用于描述和解决智能代理在与环境交互过程中最大化回报或实现特定目标的学习策略问题。密码生成器是代理，每个生成的密码序列代表一个完整的轨迹，生成过程中的每个字符都被视为一个操作。例如，由时间戳t生成的字符是action at。根据由所生成的不完整序列确定的关于当前状态ST的随机策略来生成每个动作At。生成器根据一组随机策略从任意字符生成密码，直到满足预定长度。</li>\n<li>RLPassGAN：遵循SeqGAN，将密码猜测视为一个连续决策，并使用策略梯度 来确保参数可以连续优化。</li>\n</ol>\n</li>\n<li>Flow： （一个强大的密度估计统计工具）流动模型的一个非常独特的特征是，它的转变通常是可逆的。流模型不仅找到了从分布Z转移到分布X的网络路径，而且该路径还允许X改变为Z。简而言之，流模型找到了分布Z和X之间的双向路径（Z和X的数据维度必须相同）。<ol>\n<li>PassFlow：基于产生流模型的口令猜测方法。基于流的口令猜测模型使用精确的对数似然计算和优化，使潜在变量的推断更加准确。此外，还给出了潜在空间的一种有意义的表示，这使得探索潜在空间的特定子空间和内插等操作成为可能。（密码猜测方面优于现有的基于GAN的方法）</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"另一种分类\"><a href=\"#另一种分类\" class=\"headerlink\" title=\"另一种分类\"></a>另一种分类</h4><p>根据泄露的数据集和目标密码是否来自同一数据源，拖网场景可以进一步分为站内场景和跨站场景。 虽然跨站密码猜测场景较为真实，但攻击者一般以掌握目标数据的部分分布信息为前提来猜测密码。</p>\n<h3 id=\"定向密码猜测\"><a href=\"#定向密码猜测\" class=\"headerlink\" title=\"定向密码猜测\"></a>定向密码猜测</h3><p>定向整体来说其实是对传统的优化，比如不改变核心思想的前提下修改嵌入，数据预处理等方面。</p>\n<h4 id=\"神经定向密码猜测\"><a href=\"#神经定向密码猜测\" class=\"headerlink\" title=\"神经定向密码猜测\"></a>神经定向密码猜测</h4><p>随着自然语言处理技术的发展，一些复杂的神经网络被应用到目标密码猜测领域。</p>\n<ol>\n<li>PG-PASS：由指针生成网络组成的有针对性的口令猜测模型。该工作创新性地将目标口令猜测作为一项摘要任务，并将智能摘要领域中常用的指针网络技术应用于该任务。需要注意的是，除了用户的人口统计相关信息(姓名、生日等)外，攻击者还可以利用用户在其他网站上泄露的密码进行有针对性的攻击。可以预期，这种利用用户密码重复使用这一易受攻击行为的定向攻击可能比基于人口统计相关信息的攻击更具危害性。</li>\n<li>重用模型：重用或微调旧密码来生成新密码的事实，引入深度学习技术来表征用户的密码重复使用行为。更具体地说，他们训练了序列到序列(Seq2seq)模型，以预测将现有密码转换为其姊妹密码所需的修改，并在大规模数据集(即4iQ数据集)上进行了验证。</li>\n<li>PASS2EDIT：有针对性的密码猜测算法，用于模拟日益严重的凭据篡改攻击，在该攻击中，攻击者利用受害者泄露的密码来提高在其他站点猜测受害者密码的成功率。特别是，他们提出了一种多步决策训练机制，并建立了一个分类神经网络来学习一步编辑操作对现有密码的反应。由于每项工作使用的数据集不同，因此很难进行横断面比较。</li>\n</ol>\n<h4 id=\"传统定向密码猜测\"><a href=\"#传统定向密码猜测\" class=\"headerlink\" title=\"传统定向密码猜测\"></a>传统定向密码猜测</h4><p>攻击者使用与目标人员相关的个人信息来增强猜测。</p>\n<p>基于拖网马尔可夫攻击模型的定向攻击猜测方法：</p>\n<ol>\n<li>基本思想是，关于使用某些个人信息的人口的百分比，攻击目标也将具有相同的使用该个人信息的可能性百分比。<ol>\n<li>首先将PII划分为几种类型，如用户名-A、电子邮件前缀-E和名称-N，并根据所需的粒度进一步细分每种广泛的类型。然后，将训练集的每个密码中的所有PII替换为对应的PII类型。</li>\n<li>训练阶段的其余步骤与行走马尔可夫模型的步骤相同。</li>\n<li>猜测集生成阶段分为两个步骤。<ol>\n<li>在第一步中，运行马尔可夫模型以生成中间猜测集合，该中间猜测集合包含直接可用的猜测，</li>\n<li>第二步用相应的PII信息替换中间猜测中的基本PII类型字符。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p>基于PCFG的定向攻击猜测方法：</p>\n<ol>\n<li><p>–Personal-PCFG。。其基本思想与PCFG攻击模型相同：根据字符类型和长度对密码进行切片。为了实现这一思想，将六种PI字符类型 (即用户名-A、电子邮件前缀-E、姓名-N、生日-B、电话号码-P和ID-G)等同于拖网PCFG模型中的L、D和S，从而在个人PCFG中有九种类型的字符。然后，在训练过程中，与拖网PCFG攻击模型中一样，训练集中的每个密码根据相应的字符类型及其长度进行分段。</p>\n</li>\n<li><p>TarGuess Wang等人。提出了一个框架，它用四个数学概率模型系统地刻画了典型的定向猜测场景。</p>\n<ol>\n<li>第一个场景TarGuess-I旨在利用用户的PII创建在线目标密码猜测。为了在密码中表示PII令牌，除了PCFG模型中的L、D和S标签外，作者还定义了基于个人信息类型的28个PII标签(例如，N1−N7和B1−B10)。对于每个PII标签，其下标编号表示该类型的PII使用的细分，而不是指示相应长度的下标编号，例如L、D和S标签。例如，N表示名称信息，而N1表示全名，而n2表示全名的缩写</li>\n<li>第二个是Targuess-II，目的是根据用户在其他网站(例如Dodonew)中泄露的密码来猜测目标网站(例如CSDN)中的用户密码。具体地，作者提出了6种结构级和2种字符级助记转换来描述密码重用，并基于上述重用规则使用马尔可夫模型来刻画上下文无关的转换文法。</li>\n<li>第三个是TarGuessIII，目的是使用姐妹密码和一些PII信息来猜测用户的密码。TarGuess-III将PII信息引入到TarGuess-II模型中，允许在结构级密码重用中嵌入PII信息。</li>\n<li>与TarGuess-III相比，TarGuess-IV场景中的攻击者知道难以量化的额外PII(例如，性别、教育)。为了解决某些PII难以直接体现在口令中的问题，在这种难以量化的PII的基础上，巧妙地引入贝叶斯理论来计算口令的重用概率。</li>\n</ol>\n</li>\n<li><p>RFGuess-PII.在RFGuess的基础上，Wang et al.提出了一种新的目标口令猜测模型RFGuess-PII。密码训练和生成过程类似于拖网猜测场景。不同的是，通过新的PII匹配，密码中的PII字符串被替换为相应的数字标签。这种新的PII匹配旨在最小化信息熵，并试图准确地提取整个用户组的PII使用行为。PII匹配算法的第一步是细分PII的各种可能的变换，并使用数字标签来表示它们。第二步是为训练集中的每个密码列出具有PII标签的所有可能的表示。然后，按频率从高到低对表征进行排序。</p>\n</li>\n<li><p>RFGuess-重复使用。除了基于PII的针对性密码破解研究外，作者还专注于对用户的密码重复使用行为进行建模。他们还考虑了结构级和段级转换，如TarGuess-II。具体地，它们通过计算训练集中每个密码对的编辑矩阵来计算结构级转换，并训练基于随机森林的段级转换(即，相同类型的字符串内的转换，例如字母段中的密码→密码)模型。</p>\n</li>\n<li><p>TG-SPSR图谱。马尔可夫模型和PCFG模型转化为目标攻击，提出了一种基于结构划分和字符串重组的系统目标攻击模型，称为TG-SPSR。在结构划分阶段，除了将密码划分为类似于PCFG的基本结构外，还在基本语法模式中定义了基于轨迹的键盘，并引入了索引位来准确描述特殊字符的位置。此外，基于定义的9条修改规则，构造了一个BiLSTM分类器来重用和修改密码的行为。</p>\n</li>\n</ol>\n<h1 id=\"可能的方向\"><a href=\"#可能的方向\" class=\"headerlink\" title=\"可能的方向\"></a>可能的方向</h1><p>总体来说还是做的工作挺多的，16-23年提出来了三十多种方法，2016年至2018年零星出版数量较少，2021年增至9种。。但是当前比较热门的还是基于深度学习的密码猜测方法。</p>\n<ol>\n<li>修改模型结构提高模型训练时的速度：在低资源的情况下快速执行密码猜测也是具有挑战性的。</li>\n<li>尝试大模型：预训练的语言模型近年来在自然语言处理领域应用很成熟。可以尝试关于密码猜测的预训练&#x2F;精调范式，将预先训练的语言模型强大的通用语言建模功能与现有的密码猜测工作结合起来</li>\n<li>尝试更多模型：目前的神经密码猜测方法都有一个前提，即密码字符串是一个字符序列，使用序列编码对密码进行处理。比如根据密码的语义依赖将密码组织成图，并使用最新的图神经网络(GNN)相关技术进行采样和生成。</li>\n<li>传统猜测方法与深度学习方法相结合。比如用深度学习生成规则等。</li>\n</ol>\n<h1 id=\"之后的想法\"><a href=\"#之后的想法\" class=\"headerlink\" title=\"之后的想法\"></a>之后的想法</h1><ol>\n<li>这两周涉及到了解一些背景所以读的也比较仔细，后面计划读快一些，重点关注方法和创新性。</li>\n<li>选择较新，效果较好，的论文尝试复现，分析数据，寻找优化的点。</li>\n</ol>\n"},{"_content":"[[方向调研]]\n\n[[检索工具]]\n\n[[会议调研]]\n\n\n\n- `@article`: 用于引用发表在学术期刊中的文章，包括期刊论文、期刊文章等。\n- `@book`: 用于引用书籍、专著等完整的出版物。\n- `@inproceedings`: 用于引用会议论文或会议文章。\n- `@thesis`: 用于引用学位论文、硕士论文、博士论文等。\n- `@techreport`: 用于引用技术报告、研究报告等非正式出版物。\n- `@website`: 用于引用网页、网站或在线资源。","source":"_posts/研究方向/研究.md","raw":"[[方向调研]]\n\n[[检索工具]]\n\n[[会议调研]]\n\n\n\n- `@article`: 用于引用发表在学术期刊中的文章，包括期刊论文、期刊文章等。\n- `@book`: 用于引用书籍、专著等完整的出版物。\n- `@inproceedings`: 用于引用会议论文或会议文章。\n- `@thesis`: 用于引用学位论文、硕士论文、博士论文等。\n- `@techreport`: 用于引用技术报告、研究报告等非正式出版物。\n- `@website`: 用于引用网页、网站或在线资源。","slug":"研究方向/研究","published":1,"date":"2024-04-22T13:14:49.295Z","updated":"2024-03-21T05:48:19.530Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0f000zkgg45z1f2x4o","content":"<p>[[方向调研]]</p>\n<p>[[检索工具]]</p>\n<p>[[会议调研]]</p>\n<ul>\n<li><code>@article</code>: 用于引用发表在学术期刊中的文章，包括期刊论文、期刊文章等。</li>\n<li><code>@book</code>: 用于引用书籍、专著等完整的出版物。</li>\n<li><code>@inproceedings</code>: 用于引用会议论文或会议文章。</li>\n<li><code>@thesis</code>: 用于引用学位论文、硕士论文、博士论文等。</li>\n<li><code>@techreport</code>: 用于引用技术报告、研究报告等非正式出版物。</li>\n<li><code>@website</code>: 用于引用网页、网站或在线资源。</li>\n</ul>\n","excerpt":"","more":"<p>[[方向调研]]</p>\n<p>[[检索工具]]</p>\n<p>[[会议调研]]</p>\n<ul>\n<li><code>@article</code>: 用于引用发表在学术期刊中的文章，包括期刊论文、期刊文章等。</li>\n<li><code>@book</code>: 用于引用书籍、专著等完整的出版物。</li>\n<li><code>@inproceedings</code>: 用于引用会议论文或会议文章。</li>\n<li><code>@thesis</code>: 用于引用学位论文、硕士论文、博士论文等。</li>\n<li><code>@techreport</code>: 用于引用技术报告、研究报告等非正式出版物。</li>\n<li><code>@website</code>: 用于引用网页、网站或在线资源。</li>\n</ul>\n"},{"_content":"\n","source":"_posts/毕业设计/TEMP.md","raw":"\n","slug":"毕业设计/TEMP","published":1,"date":"2024-04-22T13:14:48.629Z","updated":"2024-04-18T07:55:54.250Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0f0010kgg46tvpfvpp","content":"","excerpt":"","more":""},{"_content":"# 检索数据库\n\n| 名称                  | 描述                                                                                                                                                                                                                                                                                                                                                                                                                         | 链接                                                 |\n| ------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------- |\n| Engineering Village | 平台上的10多个数据库涵盖了工程、应用科学相关的最为广泛的领域，内容来源包括学术文献、商业出版物、[发明专利](https://baike.baidu.com/item/%E5%8F%91%E6%98%8E%E4%B8%93%E5%88%A9/1140123?fromModule=lemma_inlink)、[会议论文](https://baike.baidu.com/item/%E4%BC%9A%E8%AE%AE%E8%AE%BA%E6%96%87/4482302?fromModule=lemma_inlink)和[技术报告](https://baike.baidu.com/item/%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/8206960?fromModule=lemma_inlink)等等;其中的Compendex 就是美国工程索引Engineering Index数据库 | https://www.engineeringvillage.com/<br>（用 Edge 打开） |\n|                     |                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                    |\n","source":"_posts/研究方向/检索工具.md","raw":"# 检索数据库\n\n| 名称                  | 描述                                                                                                                                                                                                                                                                                                                                                                                                                         | 链接                                                 |\n| ------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------- |\n| Engineering Village | 平台上的10多个数据库涵盖了工程、应用科学相关的最为广泛的领域，内容来源包括学术文献、商业出版物、[发明专利](https://baike.baidu.com/item/%E5%8F%91%E6%98%8E%E4%B8%93%E5%88%A9/1140123?fromModule=lemma_inlink)、[会议论文](https://baike.baidu.com/item/%E4%BC%9A%E8%AE%AE%E8%AE%BA%E6%96%87/4482302?fromModule=lemma_inlink)和[技术报告](https://baike.baidu.com/item/%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/8206960?fromModule=lemma_inlink)等等;其中的Compendex 就是美国工程索引Engineering Index数据库 | https://www.engineeringvillage.com/<br>（用 Edge 打开） |\n|                     |                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                    |\n","slug":"研究方向/检索工具","published":1,"date":"2024-04-22T13:14:49.295Z","updated":"2024-03-07T13:39:49.254Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0g0011kgg46z9jfmq0","content":"<h1 id=\"检索数据库\"><a href=\"#检索数据库\" class=\"headerlink\" title=\"检索数据库\"></a>检索数据库</h1><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n<th>链接</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Engineering Village</td>\n<td>平台上的10多个数据库涵盖了工程、应用科学相关的最为广泛的领域，内容来源包括学术文献、商业出版物、<a href=\"https://baike.baidu.com/item/%E5%8F%91%E6%98%8E%E4%B8%93%E5%88%A9/1140123?fromModule=lemma_inlink\">发明专利</a>、<a href=\"https://baike.baidu.com/item/%E4%BC%9A%E8%AE%AE%E8%AE%BA%E6%96%87/4482302?fromModule=lemma_inlink\">会议论文</a>和<a href=\"https://baike.baidu.com/item/%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/8206960?fromModule=lemma_inlink\">技术报告</a>等等;其中的Compendex 就是美国工程索引Engineering Index数据库</td>\n<td><a href=\"https://www.engineeringvillage.com/\">https://www.engineeringvillage.com/</a><br>（用 Edge 打开）</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n","excerpt":"","more":"<h1 id=\"检索数据库\"><a href=\"#检索数据库\" class=\"headerlink\" title=\"检索数据库\"></a>检索数据库</h1><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n<th>链接</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Engineering Village</td>\n<td>平台上的10多个数据库涵盖了工程、应用科学相关的最为广泛的领域，内容来源包括学术文献、商业出版物、<a href=\"https://baike.baidu.com/item/%E5%8F%91%E6%98%8E%E4%B8%93%E5%88%A9/1140123?fromModule=lemma_inlink\">发明专利</a>、<a href=\"https://baike.baidu.com/item/%E4%BC%9A%E8%AE%AE%E8%AE%BA%E6%96%87/4482302?fromModule=lemma_inlink\">会议论文</a>和<a href=\"https://baike.baidu.com/item/%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/8206960?fromModule=lemma_inlink\">技术报告</a>等等;其中的Compendex 就是美国工程索引Engineering Index数据库</td>\n<td><a href=\"https://www.engineeringvillage.com/\">https://www.engineeringvillage.com/</a><br>（用 Edge 打开）</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n"},{"_content":"# Map\nmap是STL的一个关联容器，它提供一对一的[hash](https://so.csdn.net/so/search?q=hash&spm=1001.2101.3001.7020)。\n\n第一个可以称为关键字(key)，每个关键字只能在map中出现一次；  \n第二个可能称为该关键字的值(value)；\n\nmap以模板(泛型)方式实现，可以存储任意类型的数据，包括使用者自定义的数据类型。Map主要用于资料一对一映射(one-to-one)的情況，map內部的实现自建一颗[红黑树](https://so.csdn.net/so/search?q=%E7%BA%A2%E9%BB%91%E6%A0%91&spm=1001.2101.3001.7020)，这颗树具有对数据自动排序的功能。在map内部所有的数据都是有序的，后边我们会见识到有序的好处。比如一个班级中，每个学生的学号跟他的姓名就存在著一对一映射的关系。\n## map的功能\n\n自动建立key － value的对应。key 和 value可以是任意你需要的类型。\n## 使用 map\n使用map得包含map类所在的头文件\n\n```\n#include <map>  //注意，STL头文件没有扩展名.h\n```\n\nmap对象是模板类，需要关键字和存储对象两个模板参数：\n\n```\nstd:map<int, string> personnel;\n```\n\n这样就定义了一个用int作为索引,并拥有相关联的指向string的指针.\n\n为了使用方便，可以对模板类进行一下类型定义，\n\n```\ntypedef map<int,CString> UDT_MAP_INT_CSTRING;\n\nUDT_MAP_INT_CSTRING enumMap;\n```\n\n### 构造函数\nmap共提供了6个构造函数，这块涉及到内存分配器这些东西，略过不表，在下面我们将接触到一些map的构造方法，这里要说下的就是，我们通常用如下方法构造一个map：\n\n    map<int, string> mapStudent;\n\n### 插入元素\n```cpp\n// 定义一个map对象\nmap<int, string> mapStudent;\n \n// 第一种 用insert函數插入pair\nmapStudent.insert(pair<int, string>(000, \"student_zero\"));\n \n// 第二种 用insert函数插入value_type数据\nmapStudent.insert(map<int, string>::value_type(001, \"student_one\"));\n\n// 第三种 用\"array\"方式插入\nmapStudent[123] = \"student_first\";\nmapStudent[456] = \"student_second\";\n ```\n 第一种和第二种在效果上是完成一样的，用insert函数插入数据，在数据的 插入上涉及到集合的唯一性这个概念，即当map中有这个关键字时，insert操作是不能在插入数据的，但是用数组方式就不同了，它可以覆盖以前该关键字对 应的值，用程序说明如下：\n\n```cpp\n    mapStudent.insert(map<int, string>::value_type (001, \"student_one\"));\n     \n    mapStudent.insert(map<int, string>::value_type (001, \"student_two\"));\n```\n\n上面这两条语句执行后，map中001这个关键字对应的值是“student_one”，第二条语句并没有生效。\n 那么这就涉及到我们怎么知道insert语句是否插入成功的问题了，可以用pair来获得是否插入成功，程序如下\n```cpp\n    // 构造定义，返回一个pair对象\n    pair<iterator,bool> insert (const value_type& val);\n     \n    pair<map<int, string>::iterator, bool> Insert_Pair;\n     \n    Insert_Pair = mapStudent.insert(map<int, string>::value_type (001, \"student_one\"));\n     \n    if(!Insert_Pair.second)\n        cout << \"\"Error insert new element\" << endl;\n```\n我们通过pair的第二个变量来知道是否插入成功，它的第一个变量返回的是一个map的迭代器，如果插入成功的话Insert_Pair.second应该是true的，否则为false。\n\n### 查找元素\n\n当所查找的关键key出现时，它返回数据所在对象的位置，如果沒有，返回iter与end函数的值相同。\n```cpp\n    // find 返回迭代器指向当前查找元素的位置否则返回map::end()位置\n    iter = mapStudent.find(\"123\");\n     \n    if(iter != mapStudent.end())\n           cout<<\"Find, the value is\"<<iter->second<<endl;\n    else\n       cout<<\"Do not Find\"<<endl;\n```\n### 刪除与清空元素\n```cpp\n    //迭代器刪除\n    iter = mapStudent.find(\"123\");\n    mapStudent.erase(iter);\n     \n    //用关键字刪除\n    int n = mapStudent.erase(\"123\"); //如果刪除了會返回1，否則返回0\n     \n    //用迭代器范围刪除 : 把整个map清空\n    mapStudent.erase(mapStudent.begin(), mapStudent.end());\n    //等同于mapStudent.clear()\n```\n### 的大小\n\n在往map里面插入了数据，我们怎么知道当前已经插入了多少数据呢，可以用size函数，用法如下：\n\n    int nSize = mapStudent.size();\n\n \n\n### map的基本操作函数：\n\n    C++ maps是一种关联式容器，包含“关键字/值”对\n```cpp\n     begin()         返回指向map头部的迭代器\n\n     clear(）        删除所有元素\n\n     count()         返回指定元素出现的次数\n\n     empty()         如果map为空则返回true\n\n     end()           返回指向map末尾的迭代器\n\n     equal_range()   返回特殊条目的迭代器对\n\n     erase()         删除一个元素\n\n     find()          查找一个元素\n\n     get_allocator() 返回map的配置器\n\n     insert()        插入元素\n\n     key_comp()      返回比较元素key的函数\n\n     lower_bound()   返回键值>=给定元素的第一个位置\n\n     max_size()      返回可以容纳的最大元素个数\n\n     rbegin()        返回一个指向map尾部的逆向迭代器\n\n     rend()          返回一个指向map头部的逆向迭代器\n\n     size()          返回map中元素的个数\n\n     swap()           交换两个map\n\n     upper_bound()    返回键值>给定元素的第一个位置\n\n     value_comp()     返回比较元素value的函数\n```\n\n# hash_map\n \n\nhash_map基于hash table（哈希表）。 哈希表最大的优点，就是把数据的存储和查找消耗的时间大大降低，几乎可以看成是常数时间；而代价仅仅是消耗比较多的内存。然而在当前可利用内存越来越多的情况下，用空间换时间的做法是值得的。另外，编码比较容易也是它的特点之一。\n\n`hash_map`是一个哈希表容器，通常指的是`std::unordered_map`。在C++11标准之后，`std::unordered_map`已经取代了旧的`std::hash_map`。在`std::unordered_map`中，元素的存储位置是由哈希函数计算得出的。\n## 基本原理\n使用一个下标范围比较大的数组来存储元素。可以设计一个函数（哈希函数，也叫做散列函数），使得每个元素的关键字都与一个函数值（即数组下标，hash值）相对应，于是用这个数组单元来存储这个元素；也可以简单的理解为，按照关键字为每一个元素“分类”，然后将这个元素存储在相应“类”所对应的地方，称为桶。\n\n但是，不能够保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了“冲突”，换句话说，就是把不同的元素分在了相同的“类”之中。 总的来说，“直接定址”与“解决冲突”是哈希表的两大特点。\n\nhash_map，首先分配一大片内存，形成许多桶。是利用hash函数，对key进行映射到不同区域（桶）进行保存。其插入过程是：\n\n得到key\n通过hash函数得到hash值\n得到桶号(一般都为hash值对桶数求模)\n存放key和value在桶内。\n其取值过程是:\n\n得到key\n通过hash函数得到hash值\n得到桶号(一般都为hash值对桶数求模)\n比较桶的内部元素是否与key相等，若都不相等，则没有找到。\n取出相等的记录的value。\nhash_map中直接地址用hash函数生成，解决冲突，用比较函数解决。这里可以看出，如果每个桶内部只有一个元素，那么查找的时候只有一次比较。当许多桶内没有值时，许多查询就会更快了(指查不到的时候).\n\n由此可见，要实现哈希表, 和用户相关的是：**hash函数**和**比较函数**。这两个参数刚好是我们在使用hash_map时需要指定的参数。\n\n\n例子\n```cpp\n    #include <hash_map>\n    #include <string>\n    using namespace std;\n    int main(){\n            hash_map<int, string> mymap;\n            mymap[9527]=\"唐伯虎点秋香\";\n            mymap[1000000]=\"百万富翁的生活\";\n            mymap[10000]=\"白领的工资底线\";\n            ...\n            if(mymap.find(10000) != mymap.end()){\n                    ...\n            }\n```\n你没有指定hash函数和比较函数的时候，你会有一个缺省的函数，看看hash_map的声明，你会更加明白。下面是SGI STL的声明：\n```cpp\n    template <class _Key, class _Tp, class _HashFcn = hash<_Key>,\n    class _EqualKey = equal_to<_Key>,\n    class _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) >\n    class hash_map\n    {\n            ...\n    }\n```\n也就是说，在上例中，有以下等同关系：\n```cpp\n    hash_map<int, string> mymap;\n    //等同于:\n    hash_map<int, string, hash<int>, equal_to<int> > mymap;\n```\n## hash_map 的hash函数\nhash< int>到底是什么样子？看看源码:\n```cpp\n    struct hash<int> {\n            size_t operator()(int __x) const { return __x; }\n    };\n```\n原来是个函数对象。在SGI STL中，提供了以下hash函数：\n```cpp\n    struct hash<char*>\n    struct hash<const char*>\n    struct hash<char> \n    struct hash<unsigned char> \n    struct hash<signed char>\n    struct hash<short>\n    struct hash<unsigned short> \n    struct hash<int> \n    struct hash<unsigned int>\n    struct hash<long> \n    struct hash<unsigned long>\n```\n也就是说，如果你的key使用的是以上类型中的一种，你都可以使用缺省的hash函数。当然你自己也可以定义自己的hash函数。对于自定义变量，你只能如此，例如对于string，就必须自定义hash函数。例如：\n```cpp\n    struct str_hash{\n            size_t operator()(const string& str) const\n            {\n                    unsigned long __h = 0;\n                    for (size_t i = 0 ; i < str.size() ; i ++)\n                    __h = 5*__h + str[i];\n                    return size_t(__h);\n            }\n    };\n\n    //如果你希望利用系统定义的字符串hash函数，你可以这样写：\n    struct str_hash{\n            size_t operator()(const string& str) const\n            {\n                    return __stl_hash_string(str.c_str());\n            }\n    };\n```\n在声明自己的哈希函数时要注意以下几点：\n\n1、使用struct，然后重载operator().\n2、返回是size_t\n3、参数是你要hash的key的类型。\n4、函数是const类型的。\n\n现在可以对开头的string 进行哈希化了 . 直接替换成下面的声明即可：\n```cpp\n    map<string, string> namemap; \n    //改为：\n    hash_map<string, string, str_hash> namemap;\n```","source":"_posts/算法题目/STL.md","raw":"# Map\nmap是STL的一个关联容器，它提供一对一的[hash](https://so.csdn.net/so/search?q=hash&spm=1001.2101.3001.7020)。\n\n第一个可以称为关键字(key)，每个关键字只能在map中出现一次；  \n第二个可能称为该关键字的值(value)；\n\nmap以模板(泛型)方式实现，可以存储任意类型的数据，包括使用者自定义的数据类型。Map主要用于资料一对一映射(one-to-one)的情況，map內部的实现自建一颗[红黑树](https://so.csdn.net/so/search?q=%E7%BA%A2%E9%BB%91%E6%A0%91&spm=1001.2101.3001.7020)，这颗树具有对数据自动排序的功能。在map内部所有的数据都是有序的，后边我们会见识到有序的好处。比如一个班级中，每个学生的学号跟他的姓名就存在著一对一映射的关系。\n## map的功能\n\n自动建立key － value的对应。key 和 value可以是任意你需要的类型。\n## 使用 map\n使用map得包含map类所在的头文件\n\n```\n#include <map>  //注意，STL头文件没有扩展名.h\n```\n\nmap对象是模板类，需要关键字和存储对象两个模板参数：\n\n```\nstd:map<int, string> personnel;\n```\n\n这样就定义了一个用int作为索引,并拥有相关联的指向string的指针.\n\n为了使用方便，可以对模板类进行一下类型定义，\n\n```\ntypedef map<int,CString> UDT_MAP_INT_CSTRING;\n\nUDT_MAP_INT_CSTRING enumMap;\n```\n\n### 构造函数\nmap共提供了6个构造函数，这块涉及到内存分配器这些东西，略过不表，在下面我们将接触到一些map的构造方法，这里要说下的就是，我们通常用如下方法构造一个map：\n\n    map<int, string> mapStudent;\n\n### 插入元素\n```cpp\n// 定义一个map对象\nmap<int, string> mapStudent;\n \n// 第一种 用insert函數插入pair\nmapStudent.insert(pair<int, string>(000, \"student_zero\"));\n \n// 第二种 用insert函数插入value_type数据\nmapStudent.insert(map<int, string>::value_type(001, \"student_one\"));\n\n// 第三种 用\"array\"方式插入\nmapStudent[123] = \"student_first\";\nmapStudent[456] = \"student_second\";\n ```\n 第一种和第二种在效果上是完成一样的，用insert函数插入数据，在数据的 插入上涉及到集合的唯一性这个概念，即当map中有这个关键字时，insert操作是不能在插入数据的，但是用数组方式就不同了，它可以覆盖以前该关键字对 应的值，用程序说明如下：\n\n```cpp\n    mapStudent.insert(map<int, string>::value_type (001, \"student_one\"));\n     \n    mapStudent.insert(map<int, string>::value_type (001, \"student_two\"));\n```\n\n上面这两条语句执行后，map中001这个关键字对应的值是“student_one”，第二条语句并没有生效。\n 那么这就涉及到我们怎么知道insert语句是否插入成功的问题了，可以用pair来获得是否插入成功，程序如下\n```cpp\n    // 构造定义，返回一个pair对象\n    pair<iterator,bool> insert (const value_type& val);\n     \n    pair<map<int, string>::iterator, bool> Insert_Pair;\n     \n    Insert_Pair = mapStudent.insert(map<int, string>::value_type (001, \"student_one\"));\n     \n    if(!Insert_Pair.second)\n        cout << \"\"Error insert new element\" << endl;\n```\n我们通过pair的第二个变量来知道是否插入成功，它的第一个变量返回的是一个map的迭代器，如果插入成功的话Insert_Pair.second应该是true的，否则为false。\n\n### 查找元素\n\n当所查找的关键key出现时，它返回数据所在对象的位置，如果沒有，返回iter与end函数的值相同。\n```cpp\n    // find 返回迭代器指向当前查找元素的位置否则返回map::end()位置\n    iter = mapStudent.find(\"123\");\n     \n    if(iter != mapStudent.end())\n           cout<<\"Find, the value is\"<<iter->second<<endl;\n    else\n       cout<<\"Do not Find\"<<endl;\n```\n### 刪除与清空元素\n```cpp\n    //迭代器刪除\n    iter = mapStudent.find(\"123\");\n    mapStudent.erase(iter);\n     \n    //用关键字刪除\n    int n = mapStudent.erase(\"123\"); //如果刪除了會返回1，否則返回0\n     \n    //用迭代器范围刪除 : 把整个map清空\n    mapStudent.erase(mapStudent.begin(), mapStudent.end());\n    //等同于mapStudent.clear()\n```\n### 的大小\n\n在往map里面插入了数据，我们怎么知道当前已经插入了多少数据呢，可以用size函数，用法如下：\n\n    int nSize = mapStudent.size();\n\n \n\n### map的基本操作函数：\n\n    C++ maps是一种关联式容器，包含“关键字/值”对\n```cpp\n     begin()         返回指向map头部的迭代器\n\n     clear(）        删除所有元素\n\n     count()         返回指定元素出现的次数\n\n     empty()         如果map为空则返回true\n\n     end()           返回指向map末尾的迭代器\n\n     equal_range()   返回特殊条目的迭代器对\n\n     erase()         删除一个元素\n\n     find()          查找一个元素\n\n     get_allocator() 返回map的配置器\n\n     insert()        插入元素\n\n     key_comp()      返回比较元素key的函数\n\n     lower_bound()   返回键值>=给定元素的第一个位置\n\n     max_size()      返回可以容纳的最大元素个数\n\n     rbegin()        返回一个指向map尾部的逆向迭代器\n\n     rend()          返回一个指向map头部的逆向迭代器\n\n     size()          返回map中元素的个数\n\n     swap()           交换两个map\n\n     upper_bound()    返回键值>给定元素的第一个位置\n\n     value_comp()     返回比较元素value的函数\n```\n\n# hash_map\n \n\nhash_map基于hash table（哈希表）。 哈希表最大的优点，就是把数据的存储和查找消耗的时间大大降低，几乎可以看成是常数时间；而代价仅仅是消耗比较多的内存。然而在当前可利用内存越来越多的情况下，用空间换时间的做法是值得的。另外，编码比较容易也是它的特点之一。\n\n`hash_map`是一个哈希表容器，通常指的是`std::unordered_map`。在C++11标准之后，`std::unordered_map`已经取代了旧的`std::hash_map`。在`std::unordered_map`中，元素的存储位置是由哈希函数计算得出的。\n## 基本原理\n使用一个下标范围比较大的数组来存储元素。可以设计一个函数（哈希函数，也叫做散列函数），使得每个元素的关键字都与一个函数值（即数组下标，hash值）相对应，于是用这个数组单元来存储这个元素；也可以简单的理解为，按照关键字为每一个元素“分类”，然后将这个元素存储在相应“类”所对应的地方，称为桶。\n\n但是，不能够保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了“冲突”，换句话说，就是把不同的元素分在了相同的“类”之中。 总的来说，“直接定址”与“解决冲突”是哈希表的两大特点。\n\nhash_map，首先分配一大片内存，形成许多桶。是利用hash函数，对key进行映射到不同区域（桶）进行保存。其插入过程是：\n\n得到key\n通过hash函数得到hash值\n得到桶号(一般都为hash值对桶数求模)\n存放key和value在桶内。\n其取值过程是:\n\n得到key\n通过hash函数得到hash值\n得到桶号(一般都为hash值对桶数求模)\n比较桶的内部元素是否与key相等，若都不相等，则没有找到。\n取出相等的记录的value。\nhash_map中直接地址用hash函数生成，解决冲突，用比较函数解决。这里可以看出，如果每个桶内部只有一个元素，那么查找的时候只有一次比较。当许多桶内没有值时，许多查询就会更快了(指查不到的时候).\n\n由此可见，要实现哈希表, 和用户相关的是：**hash函数**和**比较函数**。这两个参数刚好是我们在使用hash_map时需要指定的参数。\n\n\n例子\n```cpp\n    #include <hash_map>\n    #include <string>\n    using namespace std;\n    int main(){\n            hash_map<int, string> mymap;\n            mymap[9527]=\"唐伯虎点秋香\";\n            mymap[1000000]=\"百万富翁的生活\";\n            mymap[10000]=\"白领的工资底线\";\n            ...\n            if(mymap.find(10000) != mymap.end()){\n                    ...\n            }\n```\n你没有指定hash函数和比较函数的时候，你会有一个缺省的函数，看看hash_map的声明，你会更加明白。下面是SGI STL的声明：\n```cpp\n    template <class _Key, class _Tp, class _HashFcn = hash<_Key>,\n    class _EqualKey = equal_to<_Key>,\n    class _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) >\n    class hash_map\n    {\n            ...\n    }\n```\n也就是说，在上例中，有以下等同关系：\n```cpp\n    hash_map<int, string> mymap;\n    //等同于:\n    hash_map<int, string, hash<int>, equal_to<int> > mymap;\n```\n## hash_map 的hash函数\nhash< int>到底是什么样子？看看源码:\n```cpp\n    struct hash<int> {\n            size_t operator()(int __x) const { return __x; }\n    };\n```\n原来是个函数对象。在SGI STL中，提供了以下hash函数：\n```cpp\n    struct hash<char*>\n    struct hash<const char*>\n    struct hash<char> \n    struct hash<unsigned char> \n    struct hash<signed char>\n    struct hash<short>\n    struct hash<unsigned short> \n    struct hash<int> \n    struct hash<unsigned int>\n    struct hash<long> \n    struct hash<unsigned long>\n```\n也就是说，如果你的key使用的是以上类型中的一种，你都可以使用缺省的hash函数。当然你自己也可以定义自己的hash函数。对于自定义变量，你只能如此，例如对于string，就必须自定义hash函数。例如：\n```cpp\n    struct str_hash{\n            size_t operator()(const string& str) const\n            {\n                    unsigned long __h = 0;\n                    for (size_t i = 0 ; i < str.size() ; i ++)\n                    __h = 5*__h + str[i];\n                    return size_t(__h);\n            }\n    };\n\n    //如果你希望利用系统定义的字符串hash函数，你可以这样写：\n    struct str_hash{\n            size_t operator()(const string& str) const\n            {\n                    return __stl_hash_string(str.c_str());\n            }\n    };\n```\n在声明自己的哈希函数时要注意以下几点：\n\n1、使用struct，然后重载operator().\n2、返回是size_t\n3、参数是你要hash的key的类型。\n4、函数是const类型的。\n\n现在可以对开头的string 进行哈希化了 . 直接替换成下面的声明即可：\n```cpp\n    map<string, string> namemap; \n    //改为：\n    hash_map<string, string, str_hash> namemap;\n```","slug":"算法题目/STL","published":1,"date":"2024-04-22T13:14:49.158Z","updated":"2024-02-26T07:40:32.653Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0g0012kgg4gu5t5a7z","content":"<h1 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h1><p>map是STL的一个关联容器，它提供一对一的<a href=\"https://so.csdn.net/so/search?q=hash&spm=1001.2101.3001.7020\">hash</a>。</p>\n<p>第一个可以称为关键字(key)，每个关键字只能在map中出现一次；<br>第二个可能称为该关键字的值(value)；</p>\n<p>map以模板(泛型)方式实现，可以存储任意类型的数据，包括使用者自定义的数据类型。Map主要用于资料一对一映射(one-to-one)的情況，map內部的实现自建一颗<a href=\"https://so.csdn.net/so/search?q=%E7%BA%A2%E9%BB%91%E6%A0%91&spm=1001.2101.3001.7020\">红黑树</a>，这颗树具有对数据自动排序的功能。在map内部所有的数据都是有序的，后边我们会见识到有序的好处。比如一个班级中，每个学生的学号跟他的姓名就存在著一对一映射的关系。</p>\n<h2 id=\"map的功能\"><a href=\"#map的功能\" class=\"headerlink\" title=\"map的功能\"></a>map的功能</h2><p>自动建立key － value的对应。key 和 value可以是任意你需要的类型。</p>\n<h2 id=\"使用-map\"><a href=\"#使用-map\" class=\"headerlink\" title=\"使用 map\"></a>使用 map</h2><p>使用map得包含map类所在的头文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;map&gt;  //注意，STL头文件没有扩展名.h</span><br></pre></td></tr></table></figure>\n\n<p>map对象是模板类，需要关键字和存储对象两个模板参数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std:map&lt;int, string&gt; personnel;</span><br></pre></td></tr></table></figure>\n\n<p>这样就定义了一个用int作为索引,并拥有相关联的指向string的指针.</p>\n<p>为了使用方便，可以对模板类进行一下类型定义，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef map&lt;int,CString&gt; UDT_MAP_INT_CSTRING;</span><br><span class=\"line\"></span><br><span class=\"line\">UDT_MAP_INT_CSTRING enumMap;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p>map共提供了6个构造函数，这块涉及到内存分配器这些东西，略过不表，在下面我们将接触到一些map的构造方法，这里要说下的就是，我们通常用如下方法构造一个map：</p>\n<pre><code>map&lt;int, string&gt; mapStudent;\n</code></pre>\n<h3 id=\"插入元素\"><a href=\"#插入元素\" class=\"headerlink\" title=\"插入元素\"></a>插入元素</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个map对象</span></span><br><span class=\"line\">map&lt;<span class=\"type\">int</span>, string&gt; mapStudent;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 第一种 用insert函數插入pair</span></span><br><span class=\"line\">mapStudent.<span class=\"built_in\">insert</span>(<span class=\"built_in\">pair</span>&lt;<span class=\"type\">int</span>, string&gt;(<span class=\"number\">000</span>, <span class=\"string\">&quot;student_zero&quot;</span>));</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 第二种 用insert函数插入value_type数据</span></span><br><span class=\"line\">mapStudent.<span class=\"built_in\">insert</span>(map&lt;<span class=\"type\">int</span>, string&gt;::<span class=\"built_in\">value_type</span>(<span class=\"number\">001</span>, <span class=\"string\">&quot;student_one&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第三种 用&quot;array&quot;方式插入</span></span><br><span class=\"line\">mapStudent[<span class=\"number\">123</span>] = <span class=\"string\">&quot;student_first&quot;</span>;</span><br><span class=\"line\">mapStudent[<span class=\"number\">456</span>] = <span class=\"string\">&quot;student_second&quot;</span>;</span><br></pre></td></tr></table></figure>\n<p> 第一种和第二种在效果上是完成一样的，用insert函数插入数据，在数据的 插入上涉及到集合的唯一性这个概念，即当map中有这个关键字时，insert操作是不能在插入数据的，但是用数组方式就不同了，它可以覆盖以前该关键字对 应的值，用程序说明如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mapStudent.<span class=\"built_in\">insert</span>(map&lt;<span class=\"type\">int</span>, string&gt;::<span class=\"built_in\">value_type</span> (<span class=\"number\">001</span>, <span class=\"string\">&quot;student_one&quot;</span>));</span><br><span class=\"line\"> </span><br><span class=\"line\">mapStudent.<span class=\"built_in\">insert</span>(map&lt;<span class=\"type\">int</span>, string&gt;::<span class=\"built_in\">value_type</span> (<span class=\"number\">001</span>, <span class=\"string\">&quot;student_two&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<p>上面这两条语句执行后，map中001这个关键字对应的值是“student_one”，第二条语句并没有生效。<br> 那么这就涉及到我们怎么知道insert语句是否插入成功的问题了，可以用pair来获得是否插入成功，程序如下</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 构造定义，返回一个pair对象</span></span><br><span class=\"line\"><span class=\"function\">pair&lt;iterator,<span class=\"type\">bool</span>&gt; <span class=\"title\">insert</span> <span class=\"params\">(<span class=\"type\">const</span> value_type&amp; val)</span></span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">pair&lt;map&lt;<span class=\"type\">int</span>, string&gt;::iterator, <span class=\"type\">bool</span>&gt; Insert_Pair;</span><br><span class=\"line\"> </span><br><span class=\"line\">Insert_Pair = mapStudent.<span class=\"built_in\">insert</span>(map&lt;<span class=\"type\">int</span>, string&gt;::<span class=\"built_in\">value_type</span> (<span class=\"number\">001</span>, <span class=\"string\">&quot;student_one&quot;</span>));</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">if</span>(!Insert_Pair.second)</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;&quot;</span>Error insert <span class=\"keyword\">new</span> element<span class=\"string\">&quot; &lt;&lt; endl;</span></span><br></pre></td></tr></table></figure>\n<p>我们通过pair的第二个变量来知道是否插入成功，它的第一个变量返回的是一个map的迭代器，如果插入成功的话Insert_Pair.second应该是true的，否则为false。</p>\n<h3 id=\"查找元素\"><a href=\"#查找元素\" class=\"headerlink\" title=\"查找元素\"></a>查找元素</h3><p>当所查找的关键key出现时，它返回数据所在对象的位置，如果沒有，返回iter与end函数的值相同。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// find 返回迭代器指向当前查找元素的位置否则返回map::end()位置</span></span><br><span class=\"line\">iter = mapStudent.<span class=\"built_in\">find</span>(<span class=\"string\">&quot;123&quot;</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">if</span>(iter != mapStudent.<span class=\"built_in\">end</span>())</span><br><span class=\"line\">       cout&lt;&lt;<span class=\"string\">&quot;Find, the value is&quot;</span>&lt;&lt;iter-&gt;second&lt;&lt;endl;</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">   cout&lt;&lt;<span class=\"string\">&quot;Do not Find&quot;</span>&lt;&lt;endl;</span><br></pre></td></tr></table></figure>\n<h3 id=\"刪除与清空元素\"><a href=\"#刪除与清空元素\" class=\"headerlink\" title=\"刪除与清空元素\"></a>刪除与清空元素</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//迭代器刪除</span></span><br><span class=\"line\">iter = mapStudent.<span class=\"built_in\">find</span>(<span class=\"string\">&quot;123&quot;</span>);</span><br><span class=\"line\">mapStudent.<span class=\"built_in\">erase</span>(iter);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//用关键字刪除</span></span><br><span class=\"line\"><span class=\"type\">int</span> n = mapStudent.<span class=\"built_in\">erase</span>(<span class=\"string\">&quot;123&quot;</span>); <span class=\"comment\">//如果刪除了會返回1，否則返回0</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//用迭代器范围刪除 : 把整个map清空</span></span><br><span class=\"line\">mapStudent.<span class=\"built_in\">erase</span>(mapStudent.<span class=\"built_in\">begin</span>(), mapStudent.<span class=\"built_in\">end</span>());</span><br><span class=\"line\"><span class=\"comment\">//等同于mapStudent.clear()</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"的大小\"><a href=\"#的大小\" class=\"headerlink\" title=\"的大小\"></a>的大小</h3><p>在往map里面插入了数据，我们怎么知道当前已经插入了多少数据呢，可以用size函数，用法如下：</p>\n<pre><code>int nSize = mapStudent.size();\n</code></pre>\n<h3 id=\"map的基本操作函数：\"><a href=\"#map的基本操作函数：\" class=\"headerlink\" title=\"map的基本操作函数：\"></a>map的基本操作函数：</h3><pre><code>C++ maps是一种关联式容器，包含“关键字/值”对\n</code></pre>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">begin</span>()         返回指向map头部的迭代器</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">clear</span>(）        删除所有元素</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">count</span>()         返回指定元素出现的次数</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">empty</span>()         如果map为空则返回<span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">end</span>()           返回指向map末尾的迭代器</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">equal_range</span>()   返回特殊条目的迭代器对</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">erase</span>()         删除一个元素</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">find</span>()          查找一个元素</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">get_allocator</span>() 返回map的配置器</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">insert</span>()        插入元素</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">key_comp</span>()      返回比较元素key的函数</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">lower_bound</span>()   返回键值&gt;=给定元素的第一个位置</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">max_size</span>()      返回可以容纳的最大元素个数</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">rbegin</span>()        返回一个指向map尾部的逆向迭代器</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">rend</span>()          返回一个指向map头部的逆向迭代器</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">size</span>()          返回map中元素的个数</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">swap</span>()           交换两个map</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">upper_bound</span>()    返回键值&gt;给定元素的第一个位置</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">value_comp</span>()     返回比较元素value的函数</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"hash-map\"><a href=\"#hash-map\" class=\"headerlink\" title=\"hash_map\"></a>hash_map</h1><p>hash_map基于hash table（哈希表）。 哈希表最大的优点，就是把数据的存储和查找消耗的时间大大降低，几乎可以看成是常数时间；而代价仅仅是消耗比较多的内存。然而在当前可利用内存越来越多的情况下，用空间换时间的做法是值得的。另外，编码比较容易也是它的特点之一。</p>\n<p><code>hash_map</code>是一个哈希表容器，通常指的是<code>std::unordered_map</code>。在C++11标准之后，<code>std::unordered_map</code>已经取代了旧的<code>std::hash_map</code>。在<code>std::unordered_map</code>中，元素的存储位置是由哈希函数计算得出的。</p>\n<h2 id=\"基本原理\"><a href=\"#基本原理\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h2><p>使用一个下标范围比较大的数组来存储元素。可以设计一个函数（哈希函数，也叫做散列函数），使得每个元素的关键字都与一个函数值（即数组下标，hash值）相对应，于是用这个数组单元来存储这个元素；也可以简单的理解为，按照关键字为每一个元素“分类”，然后将这个元素存储在相应“类”所对应的地方，称为桶。</p>\n<p>但是，不能够保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了“冲突”，换句话说，就是把不同的元素分在了相同的“类”之中。 总的来说，“直接定址”与“解决冲突”是哈希表的两大特点。</p>\n<p>hash_map，首先分配一大片内存，形成许多桶。是利用hash函数，对key进行映射到不同区域（桶）进行保存。其插入过程是：</p>\n<p>得到key<br>通过hash函数得到hash值<br>得到桶号(一般都为hash值对桶数求模)<br>存放key和value在桶内。<br>其取值过程是:</p>\n<p>得到key<br>通过hash函数得到hash值<br>得到桶号(一般都为hash值对桶数求模)<br>比较桶的内部元素是否与key相等，若都不相等，则没有找到。<br>取出相等的记录的value。<br>hash_map中直接地址用hash函数生成，解决冲突，用比较函数解决。这里可以看出，如果每个桶内部只有一个元素，那么查找的时候只有一次比较。当许多桶内没有值时，许多查询就会更快了(指查不到的时候).</p>\n<p>由此可见，要实现哈希表, 和用户相关的是：<strong>hash函数</strong>和<strong>比较函数</strong>。这两个参数刚好是我们在使用hash_map时需要指定的参数。</p>\n<p>例子</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;hash_map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        hash_map&lt;<span class=\"type\">int</span>, string&gt; mymap;</span><br><span class=\"line\">        mymap[<span class=\"number\">9527</span>]=<span class=\"string\">&quot;唐伯虎点秋香&quot;</span>;</span><br><span class=\"line\">        mymap[<span class=\"number\">1000000</span>]=<span class=\"string\">&quot;百万富翁的生活&quot;</span>;</span><br><span class=\"line\">        mymap[<span class=\"number\">10000</span>]=<span class=\"string\">&quot;白领的工资底线&quot;</span>;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(mymap.<span class=\"built_in\">find</span>(<span class=\"number\">10000</span>) != mymap.<span class=\"built_in\">end</span>())&#123;</span><br><span class=\"line\">                ...</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>你没有指定hash函数和比较函数的时候，你会有一个缺省的函数，看看hash_map的声明，你会更加明白。下面是SGI STL的声明：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">_Key</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">_Tp</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">_HashFcn</span> = hash&lt;_Key&gt;,</span><br><span class=\"line\"><span class=\"keyword\">class</span> _EqualKey = equal_to&lt;_Key&gt;,</span><br><span class=\"line\"><span class=\"keyword\">class</span> _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) &gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> hash_map</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也就是说，在上例中，有以下等同关系：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hash_map&lt;<span class=\"type\">int</span>, string&gt; mymap;</span><br><span class=\"line\"><span class=\"comment\">//等同于:</span></span><br><span class=\"line\">hash_map&lt;<span class=\"type\">int</span>, string, hash&lt;<span class=\"type\">int</span>&gt;, equal_to&lt;<span class=\"type\">int</span>&gt; &gt; mymap;</span><br></pre></td></tr></table></figure>\n<h2 id=\"hash-map-的hash函数\"><a href=\"#hash-map-的hash函数\" class=\"headerlink\" title=\"hash_map 的hash函数\"></a>hash_map 的hash函数</h2><p>hash&lt; int&gt;到底是什么样子？看看源码:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">hash</span>&lt;<span class=\"type\">int</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"type\">int</span> __x)</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> __x; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>原来是个函数对象。在SGI STL中，提供了以下hash函数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">hash</span>&lt;<span class=\"type\">char</span>*&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">hash</span>&lt;<span class=\"type\">const</span> <span class=\"type\">char</span>*&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">hash</span>&lt;<span class=\"type\">char</span>&gt; </span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">hash</span>&lt;<span class=\"type\">unsigned</span> <span class=\"type\">char</span>&gt; </span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">hash</span>&lt;<span class=\"type\">signed</span> <span class=\"type\">char</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">hash</span>&lt;<span class=\"type\">short</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">hash</span>&lt;<span class=\"type\">unsigned</span> <span class=\"type\">short</span>&gt; </span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">hash</span>&lt;<span class=\"type\">int</span>&gt; </span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">hash</span>&lt;<span class=\"type\">unsigned</span> <span class=\"type\">int</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">hash</span>&lt;<span class=\"type\">long</span>&gt; </span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">hash</span>&lt;<span class=\"type\">unsigned</span> <span class=\"type\">long</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>也就是说，如果你的key使用的是以上类型中的一种，你都可以使用缺省的hash函数。当然你自己也可以定义自己的hash函数。对于自定义变量，你只能如此，例如对于string，就必须自定义hash函数。例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">str_hash</span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; str)</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">        </span>&#123;</span><br><span class=\"line\">                <span class=\"type\">unsigned</span> <span class=\"type\">long</span> __h = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">0</span> ; i &lt; str.<span class=\"built_in\">size</span>() ; i ++)</span><br><span class=\"line\">                __h = <span class=\"number\">5</span>*__h + str[i];</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"built_in\">size_t</span>(__h);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//如果你希望利用系统定义的字符串hash函数，你可以这样写：</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">str_hash</span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; str)</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">        </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> __stl_hash_string(str.<span class=\"built_in\">c_str</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在声明自己的哈希函数时要注意以下几点：</p>\n<p>1、使用struct，然后重载operator().<br>2、返回是size_t<br>3、参数是你要hash的key的类型。<br>4、函数是const类型的。</p>\n<p>现在可以对开头的string 进行哈希化了 . 直接替换成下面的声明即可：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map&lt;string, string&gt; namemap; </span><br><span class=\"line\"><span class=\"comment\">//改为：</span></span><br><span class=\"line\">hash_map&lt;string, string, str_hash&gt; namemap;</span><br></pre></td></tr></table></figure>","excerpt":"","more":"<h1 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h1><p>map是STL的一个关联容器，它提供一对一的<a href=\"https://so.csdn.net/so/search?q=hash&spm=1001.2101.3001.7020\">hash</a>。</p>\n<p>第一个可以称为关键字(key)，每个关键字只能在map中出现一次；<br>第二个可能称为该关键字的值(value)；</p>\n<p>map以模板(泛型)方式实现，可以存储任意类型的数据，包括使用者自定义的数据类型。Map主要用于资料一对一映射(one-to-one)的情況，map內部的实现自建一颗<a href=\"https://so.csdn.net/so/search?q=%E7%BA%A2%E9%BB%91%E6%A0%91&spm=1001.2101.3001.7020\">红黑树</a>，这颗树具有对数据自动排序的功能。在map内部所有的数据都是有序的，后边我们会见识到有序的好处。比如一个班级中，每个学生的学号跟他的姓名就存在著一对一映射的关系。</p>\n<h2 id=\"map的功能\"><a href=\"#map的功能\" class=\"headerlink\" title=\"map的功能\"></a>map的功能</h2><p>自动建立key － value的对应。key 和 value可以是任意你需要的类型。</p>\n<h2 id=\"使用-map\"><a href=\"#使用-map\" class=\"headerlink\" title=\"使用 map\"></a>使用 map</h2><p>使用map得包含map类所在的头文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;map&gt;  //注意，STL头文件没有扩展名.h</span><br></pre></td></tr></table></figure>\n\n<p>map对象是模板类，需要关键字和存储对象两个模板参数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std:map&lt;int, string&gt; personnel;</span><br></pre></td></tr></table></figure>\n\n<p>这样就定义了一个用int作为索引,并拥有相关联的指向string的指针.</p>\n<p>为了使用方便，可以对模板类进行一下类型定义，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef map&lt;int,CString&gt; UDT_MAP_INT_CSTRING;</span><br><span class=\"line\"></span><br><span class=\"line\">UDT_MAP_INT_CSTRING enumMap;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p>map共提供了6个构造函数，这块涉及到内存分配器这些东西，略过不表，在下面我们将接触到一些map的构造方法，这里要说下的就是，我们通常用如下方法构造一个map：</p>\n<pre><code>map&lt;int, string&gt; mapStudent;\n</code></pre>\n<h3 id=\"插入元素\"><a href=\"#插入元素\" class=\"headerlink\" title=\"插入元素\"></a>插入元素</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个map对象</span></span><br><span class=\"line\">map&lt;<span class=\"type\">int</span>, string&gt; mapStudent;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 第一种 用insert函數插入pair</span></span><br><span class=\"line\">mapStudent.<span class=\"built_in\">insert</span>(<span class=\"built_in\">pair</span>&lt;<span class=\"type\">int</span>, string&gt;(<span class=\"number\">000</span>, <span class=\"string\">&quot;student_zero&quot;</span>));</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 第二种 用insert函数插入value_type数据</span></span><br><span class=\"line\">mapStudent.<span class=\"built_in\">insert</span>(map&lt;<span class=\"type\">int</span>, string&gt;::<span class=\"built_in\">value_type</span>(<span class=\"number\">001</span>, <span class=\"string\">&quot;student_one&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第三种 用&quot;array&quot;方式插入</span></span><br><span class=\"line\">mapStudent[<span class=\"number\">123</span>] = <span class=\"string\">&quot;student_first&quot;</span>;</span><br><span class=\"line\">mapStudent[<span class=\"number\">456</span>] = <span class=\"string\">&quot;student_second&quot;</span>;</span><br></pre></td></tr></table></figure>\n<p> 第一种和第二种在效果上是完成一样的，用insert函数插入数据，在数据的 插入上涉及到集合的唯一性这个概念，即当map中有这个关键字时，insert操作是不能在插入数据的，但是用数组方式就不同了，它可以覆盖以前该关键字对 应的值，用程序说明如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mapStudent.<span class=\"built_in\">insert</span>(map&lt;<span class=\"type\">int</span>, string&gt;::<span class=\"built_in\">value_type</span> (<span class=\"number\">001</span>, <span class=\"string\">&quot;student_one&quot;</span>));</span><br><span class=\"line\"> </span><br><span class=\"line\">mapStudent.<span class=\"built_in\">insert</span>(map&lt;<span class=\"type\">int</span>, string&gt;::<span class=\"built_in\">value_type</span> (<span class=\"number\">001</span>, <span class=\"string\">&quot;student_two&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<p>上面这两条语句执行后，map中001这个关键字对应的值是“student_one”，第二条语句并没有生效。<br> 那么这就涉及到我们怎么知道insert语句是否插入成功的问题了，可以用pair来获得是否插入成功，程序如下</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 构造定义，返回一个pair对象</span></span><br><span class=\"line\"><span class=\"function\">pair&lt;iterator,<span class=\"type\">bool</span>&gt; <span class=\"title\">insert</span> <span class=\"params\">(<span class=\"type\">const</span> value_type&amp; val)</span></span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">pair&lt;map&lt;<span class=\"type\">int</span>, string&gt;::iterator, <span class=\"type\">bool</span>&gt; Insert_Pair;</span><br><span class=\"line\"> </span><br><span class=\"line\">Insert_Pair = mapStudent.<span class=\"built_in\">insert</span>(map&lt;<span class=\"type\">int</span>, string&gt;::<span class=\"built_in\">value_type</span> (<span class=\"number\">001</span>, <span class=\"string\">&quot;student_one&quot;</span>));</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">if</span>(!Insert_Pair.second)</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;&quot;</span>Error insert <span class=\"keyword\">new</span> element<span class=\"string\">&quot; &lt;&lt; endl;</span></span><br></pre></td></tr></table></figure>\n<p>我们通过pair的第二个变量来知道是否插入成功，它的第一个变量返回的是一个map的迭代器，如果插入成功的话Insert_Pair.second应该是true的，否则为false。</p>\n<h3 id=\"查找元素\"><a href=\"#查找元素\" class=\"headerlink\" title=\"查找元素\"></a>查找元素</h3><p>当所查找的关键key出现时，它返回数据所在对象的位置，如果沒有，返回iter与end函数的值相同。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// find 返回迭代器指向当前查找元素的位置否则返回map::end()位置</span></span><br><span class=\"line\">iter = mapStudent.<span class=\"built_in\">find</span>(<span class=\"string\">&quot;123&quot;</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">if</span>(iter != mapStudent.<span class=\"built_in\">end</span>())</span><br><span class=\"line\">       cout&lt;&lt;<span class=\"string\">&quot;Find, the value is&quot;</span>&lt;&lt;iter-&gt;second&lt;&lt;endl;</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">   cout&lt;&lt;<span class=\"string\">&quot;Do not Find&quot;</span>&lt;&lt;endl;</span><br></pre></td></tr></table></figure>\n<h3 id=\"刪除与清空元素\"><a href=\"#刪除与清空元素\" class=\"headerlink\" title=\"刪除与清空元素\"></a>刪除与清空元素</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//迭代器刪除</span></span><br><span class=\"line\">iter = mapStudent.<span class=\"built_in\">find</span>(<span class=\"string\">&quot;123&quot;</span>);</span><br><span class=\"line\">mapStudent.<span class=\"built_in\">erase</span>(iter);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//用关键字刪除</span></span><br><span class=\"line\"><span class=\"type\">int</span> n = mapStudent.<span class=\"built_in\">erase</span>(<span class=\"string\">&quot;123&quot;</span>); <span class=\"comment\">//如果刪除了會返回1，否則返回0</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//用迭代器范围刪除 : 把整个map清空</span></span><br><span class=\"line\">mapStudent.<span class=\"built_in\">erase</span>(mapStudent.<span class=\"built_in\">begin</span>(), mapStudent.<span class=\"built_in\">end</span>());</span><br><span class=\"line\"><span class=\"comment\">//等同于mapStudent.clear()</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"的大小\"><a href=\"#的大小\" class=\"headerlink\" title=\"的大小\"></a>的大小</h3><p>在往map里面插入了数据，我们怎么知道当前已经插入了多少数据呢，可以用size函数，用法如下：</p>\n<pre><code>int nSize = mapStudent.size();\n</code></pre>\n<h3 id=\"map的基本操作函数：\"><a href=\"#map的基本操作函数：\" class=\"headerlink\" title=\"map的基本操作函数：\"></a>map的基本操作函数：</h3><pre><code>C++ maps是一种关联式容器，包含“关键字/值”对\n</code></pre>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">begin</span>()         返回指向map头部的迭代器</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">clear</span>(）        删除所有元素</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">count</span>()         返回指定元素出现的次数</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">empty</span>()         如果map为空则返回<span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">end</span>()           返回指向map末尾的迭代器</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">equal_range</span>()   返回特殊条目的迭代器对</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">erase</span>()         删除一个元素</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">find</span>()          查找一个元素</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">get_allocator</span>() 返回map的配置器</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">insert</span>()        插入元素</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">key_comp</span>()      返回比较元素key的函数</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">lower_bound</span>()   返回键值&gt;=给定元素的第一个位置</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">max_size</span>()      返回可以容纳的最大元素个数</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">rbegin</span>()        返回一个指向map尾部的逆向迭代器</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">rend</span>()          返回一个指向map头部的逆向迭代器</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">size</span>()          返回map中元素的个数</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">swap</span>()           交换两个map</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">upper_bound</span>()    返回键值&gt;给定元素的第一个位置</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">value_comp</span>()     返回比较元素value的函数</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"hash-map\"><a href=\"#hash-map\" class=\"headerlink\" title=\"hash_map\"></a>hash_map</h1><p>hash_map基于hash table（哈希表）。 哈希表最大的优点，就是把数据的存储和查找消耗的时间大大降低，几乎可以看成是常数时间；而代价仅仅是消耗比较多的内存。然而在当前可利用内存越来越多的情况下，用空间换时间的做法是值得的。另外，编码比较容易也是它的特点之一。</p>\n<p><code>hash_map</code>是一个哈希表容器，通常指的是<code>std::unordered_map</code>。在C++11标准之后，<code>std::unordered_map</code>已经取代了旧的<code>std::hash_map</code>。在<code>std::unordered_map</code>中，元素的存储位置是由哈希函数计算得出的。</p>\n<h2 id=\"基本原理\"><a href=\"#基本原理\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h2><p>使用一个下标范围比较大的数组来存储元素。可以设计一个函数（哈希函数，也叫做散列函数），使得每个元素的关键字都与一个函数值（即数组下标，hash值）相对应，于是用这个数组单元来存储这个元素；也可以简单的理解为，按照关键字为每一个元素“分类”，然后将这个元素存储在相应“类”所对应的地方，称为桶。</p>\n<p>但是，不能够保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了“冲突”，换句话说，就是把不同的元素分在了相同的“类”之中。 总的来说，“直接定址”与“解决冲突”是哈希表的两大特点。</p>\n<p>hash_map，首先分配一大片内存，形成许多桶。是利用hash函数，对key进行映射到不同区域（桶）进行保存。其插入过程是：</p>\n<p>得到key<br>通过hash函数得到hash值<br>得到桶号(一般都为hash值对桶数求模)<br>存放key和value在桶内。<br>其取值过程是:</p>\n<p>得到key<br>通过hash函数得到hash值<br>得到桶号(一般都为hash值对桶数求模)<br>比较桶的内部元素是否与key相等，若都不相等，则没有找到。<br>取出相等的记录的value。<br>hash_map中直接地址用hash函数生成，解决冲突，用比较函数解决。这里可以看出，如果每个桶内部只有一个元素，那么查找的时候只有一次比较。当许多桶内没有值时，许多查询就会更快了(指查不到的时候).</p>\n<p>由此可见，要实现哈希表, 和用户相关的是：<strong>hash函数</strong>和<strong>比较函数</strong>。这两个参数刚好是我们在使用hash_map时需要指定的参数。</p>\n<p>例子</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;hash_map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        hash_map&lt;<span class=\"type\">int</span>, string&gt; mymap;</span><br><span class=\"line\">        mymap[<span class=\"number\">9527</span>]=<span class=\"string\">&quot;唐伯虎点秋香&quot;</span>;</span><br><span class=\"line\">        mymap[<span class=\"number\">1000000</span>]=<span class=\"string\">&quot;百万富翁的生活&quot;</span>;</span><br><span class=\"line\">        mymap[<span class=\"number\">10000</span>]=<span class=\"string\">&quot;白领的工资底线&quot;</span>;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(mymap.<span class=\"built_in\">find</span>(<span class=\"number\">10000</span>) != mymap.<span class=\"built_in\">end</span>())&#123;</span><br><span class=\"line\">                ...</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>你没有指定hash函数和比较函数的时候，你会有一个缺省的函数，看看hash_map的声明，你会更加明白。下面是SGI STL的声明：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">_Key</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">_Tp</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">_HashFcn</span> = hash&lt;_Key&gt;,</span><br><span class=\"line\"><span class=\"keyword\">class</span> _EqualKey = equal_to&lt;_Key&gt;,</span><br><span class=\"line\"><span class=\"keyword\">class</span> _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) &gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> hash_map</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也就是说，在上例中，有以下等同关系：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hash_map&lt;<span class=\"type\">int</span>, string&gt; mymap;</span><br><span class=\"line\"><span class=\"comment\">//等同于:</span></span><br><span class=\"line\">hash_map&lt;<span class=\"type\">int</span>, string, hash&lt;<span class=\"type\">int</span>&gt;, equal_to&lt;<span class=\"type\">int</span>&gt; &gt; mymap;</span><br></pre></td></tr></table></figure>\n<h2 id=\"hash-map-的hash函数\"><a href=\"#hash-map-的hash函数\" class=\"headerlink\" title=\"hash_map 的hash函数\"></a>hash_map 的hash函数</h2><p>hash&lt; int&gt;到底是什么样子？看看源码:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">hash</span>&lt;<span class=\"type\">int</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"type\">int</span> __x)</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> __x; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>原来是个函数对象。在SGI STL中，提供了以下hash函数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">hash</span>&lt;<span class=\"type\">char</span>*&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">hash</span>&lt;<span class=\"type\">const</span> <span class=\"type\">char</span>*&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">hash</span>&lt;<span class=\"type\">char</span>&gt; </span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">hash</span>&lt;<span class=\"type\">unsigned</span> <span class=\"type\">char</span>&gt; </span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">hash</span>&lt;<span class=\"type\">signed</span> <span class=\"type\">char</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">hash</span>&lt;<span class=\"type\">short</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">hash</span>&lt;<span class=\"type\">unsigned</span> <span class=\"type\">short</span>&gt; </span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">hash</span>&lt;<span class=\"type\">int</span>&gt; </span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">hash</span>&lt;<span class=\"type\">unsigned</span> <span class=\"type\">int</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">hash</span>&lt;<span class=\"type\">long</span>&gt; </span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">hash</span>&lt;<span class=\"type\">unsigned</span> <span class=\"type\">long</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>也就是说，如果你的key使用的是以上类型中的一种，你都可以使用缺省的hash函数。当然你自己也可以定义自己的hash函数。对于自定义变量，你只能如此，例如对于string，就必须自定义hash函数。例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">str_hash</span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; str)</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">        </span>&#123;</span><br><span class=\"line\">                <span class=\"type\">unsigned</span> <span class=\"type\">long</span> __h = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">0</span> ; i &lt; str.<span class=\"built_in\">size</span>() ; i ++)</span><br><span class=\"line\">                __h = <span class=\"number\">5</span>*__h + str[i];</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"built_in\">size_t</span>(__h);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//如果你希望利用系统定义的字符串hash函数，你可以这样写：</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">str_hash</span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; str)</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">        </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> __stl_hash_string(str.<span class=\"built_in\">c_str</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在声明自己的哈希函数时要注意以下几点：</p>\n<p>1、使用struct，然后重载operator().<br>2、返回是size_t<br>3、参数是你要hash的key的类型。<br>4、函数是const类型的。</p>\n<p>现在可以对开头的string 进行哈希化了 . 直接替换成下面的声明即可：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map&lt;string, string&gt; namemap; </span><br><span class=\"line\"><span class=\"comment\">//改为：</span></span><br><span class=\"line\">hash_map&lt;string, string, str_hash&gt; namemap;</span><br></pre></td></tr></table></figure>"},{"_content":"论文调研旨在找到一个喜欢的方向并且实现小论文撰写，\n# ICDE 2023\n\n## 介绍\n\nICDE-2023共接收论文228篇，录用率在25%左右，研究方向统计如下：\n\n|方向|子方向|论文数量|\n|---|---|---|\n|图与网络|图算法、图处理框架、图数据库、图神经网络、图分析、知识图谱|69|\n|时空、轨迹数据分析||34|\n|AI4DB|基数估计、查询优化、学习索引、NL2SQL、表格推理、工作负载预测、性能调优、数据库嵌入|13|\n|数据库管理|物化视图管理、工作负载分析、事务、死锁检测、数据库安全|8|\n|存储||4|\n|查询、索引优化||18|\n|人工智能|机器学习、深度学习、聚类、强化学习、在线学习|25|\n|流处理|-|9|\n|数据挖掘与分析|数据挖掘、数据压缩、推荐|25|\n|边缘计算、区块链、物联网|-|11|\n|视频处理|-|2|\n|隐私保护、数据安全|-|4|\n|众包|-|6|\n\n## 详情\n\n### 图与网络\n\n|论文|子方向|备注|\n|---|---|---|\n|COCLEP: Contrastive Learning-based Semi-Supervised Community Search|图算法||\n|FASI: FPGA-friendly Subgraph Isomorphism on Massive Graphs|图算法||\n|HGMatch: A Match-by-Hyperedge Framework for Efficient and Parallel Subhypergraph Matching|图算法||\n|Layph: Making Change Propagation Constraint in Incremental Graph Processing by Layering Graph|图算法||\n|LightTraffic: On Optimizing CPU-GPU Data Traffic for Efficient Large-scale Random Walks|图算法||\n|Lumos: Heterogeneity-aware Federated Graph Learning over Decentralized Devices|图算法||\n|PSPC: Efficient Parallel Shortest Path Counting on Large-Scale Graphs|图算法||\n|TDB: Breaking All Hop-Constrained Cycles in Billion-Scale Directed Graphs|图算法||\n|Finer-Grained Engagement in Hypergraphs|图算法||\n|Distributed (α, β)-Core Decomposition over Bipartite Graphs|图算法||\n|Fairness-aware Maximal Biclique Enumeration on Bipartite Graphs|图算法||\n|Index-Based Biclique Percolation Communities Search on Bipartite graphs|图算法||\n|Efficiently Answering Quality Constrained Shortest Distance Queries in Large Graphs|图算法||\n|Verification-Free Approaches to Efficient Locally Densest Subgraph Discovery|图算法||\n|Efficient Maximum Signed Biclique Identification|图算法||\n|Explainable Hyperlink Prediction: A Hypergraph Edit Distance-Based Approach|图算法||\n|Reinforcement Learning Enhanced Weighted Sampling for Accurate Subgraph Counting on Fully Dynamic Graph Streams|图算法||\n|Towards Efficient Shortest Path Counting on Billion-Scale Graphs|图算法||\n|Fair Group Summarization with Graph Patterns|图算法||\n|Top-r keyword-based community search in attributed graphs|图算法||\n|Accelerating k-Core Decomposition by a GPU|图算法||\n|Minimizing the Influence of Misinformation via Vertex Blocking|图算法||\n|Efficiently Sampling and Estimating Hypergraphs By Hybrid Random Walk|图算法||\n|Efficient Multi-GPU Graph Processing with Remote Work Stealing|图算法||\n|Neighborhood Skyline on Graphs: Concepts, Algorithms and Applications|图算法||\n|Finding Top-k Important Edges on Bipartite Graphs: Ego-betweenness Centrality-based Approaches|图算法||\n|VC-dimension and Rademacher Averages of Subgraphs, with Applications to Graph Mining|图算法||\n|Most Probable Densest Subgraphs|图算法||\n|Scalable Algorithms for Densest Subgraph Discovery|图算法||\n|Distributed Near-Maximum Independent Set Maintenance over Large-scale Dynamic Graphs|图算法||\n|Fast Unsupervised Graph Embedding via Graph Zoom Learning|图算法||\n|Wind-Bell Index: Towards Ultra-Fast Relational Query for Graph Databases|图数据库|查询|\n|Hop-Constrained s-t Simple Path Enumeration on Large Dynamic Graphs|图数据库|查询|\n|A Reachability Index for Recursive Label-Concatenated Graph Queries|图数据库|索引|\n|VEND: Vertex Encoding for Edge Nonexistence Determination|图数据库||\n|Extracting Graphs Properties with Semantic Joins|图数据库||\n|Integrating Connection Search in Graph Queries|图数据库|查询|\n|AFaVS: Accurate Yet Fast Version Switching for Graph Processing Systems|图处理系统||\n|FLASH: A Framework for Programming Distributed Graph Processing Algorithms|图处理系统||\n|Partitioner Selection with EASE to Optimize Distributed Graph Processing|图处理系统||\n|Optimizing Graph Partition by Optimal Vertex-Cut: A Holistic Approach|图处理系统|图划分|\n|HyTGraph: GPU-Accelerated Graph Processing with Hybrid Transfer Management|图处理系统||\n|GAMMA: A Graph Pattern Mining Framework for Large Graphs on GPU|图处理系统|图模式挖掘|\n|HyGNN: Drug-Drug Interaction Prediction via Hypergraph Neural Network|图神经网络||\n|Demystifying Bitcoin Address Behavior via Graph Neural Networks|图神经网络||\n|Jointly Attacking Graph Neural Network and its Explanations|图神经网络||\n|Relational Temporal Graph Convolutional Networks for Ranking-Based Stock Prediction|图神经网络||\n|A Bayesian Graph Neural Network for EEG Classification — A Win-Win on Performance and Interpretability|图神经网络||\n|Layer-refined Graph Convolutional Networks for Recommendation|图神经网络||\n|AutoAC: Towards Automated Attribute Completion for Heterogeneous Graph Neural Network|图神经网络||\n|SEIGN: A Simple and Efficient Graph Neural Network for Large Dynamic Graphs|图神经网络||\n|Revisiting Citation Prediction with Cluster-Aware Text-Enhanced Heterogeneous Graph Neural Networks|图神经网络||\n|Towards Higher-order Topological Consistency for Unsupervised Network Alignment|图神经网络||\n|CLDG: Contrastive Learning on Dynamic Graphs|图分析||\n|GALE: Active Adversarial Learning for Erroneous Node Detection in Graphs|图分析||\n|IFCA: Index-Free Community-Aware Reachability Processing Over Large Dynamic Graphs|图分析||\n|Unsupervised Graph Outlier Detection: Problem Revisit, New Insight, and Superior Method|图分析||\n|Efficient and Compact Spreadsheet Formula Graphs|图分析||\n|Inconsistency Detection with Temporal Graph Functional Dependencies|图分析||\n|Keyword-based Socially Tenuous Group Queries|图分析||\n|Community Search: A Meta-Learning Approach|图分析||\n|Dynamic Activation of Clients and Parameters for Federated Learning over Heterogeneous Graphs|图分析||\n|RETIA: Relation-Entity Twin-Interact Aggregation for Temporal Knowledge Graph Extrapolation|知识图谱||\n|Disconnected Emerging Knowledge Graph Oriented Inductive Link Prediction|知识图谱||\n|Relational Message Passing for Fully Inductive Knowledge Graph Completion|知识图谱||\n|MMKGR: Multi-hop Multi-modal Knowledge Graph Reasoning|知识图谱||\n|Robust Attributed Graph Alignment via Joint Structure Learning and Optimal Transpor|知识图谱||\n|Multimodal Biological Knowledge Graph Completion via Triple Co-attention Mechanism|知识图谱||\n|A Holistic Approach for Answering Logical Queries on Knowledge Graphs|知识图谱||\n\n### 时空、轨迹数据分析\n\n|论文|子方向|备注|\n|---|---|---|\n|TSC-AutoML: Meta-learning for automatic Time Series Classification Algorithm Selection|时空数据分析||\n|TSEXPLAIN: Explaining Aggregated Time Series by Surfacing Evolving Contributors|时空数据分析||\n|Towards Long-Term Time-Series Forecasting: Feature, Pattern, and Distribution|时空数据分析||\n|PriSTI: A Conditional Diffusion Framework for Spatiotemporal Imputation|时空数据分析||\n|REncoder: A Space-Time Efficient Range Filter with Local Encoder|时空数据分析||\n|ROI-demand Traffic Prediction: A Pre-train, Query and Fine-tune Framework|时空数据分析||\n|When Spatio-Temporal Meet Wavelets: Disentangled Traffic Forecasting via Efficient Spectral Graph Attention Networks|时空数据分析||\n|Discovering Frequency Bursting Patterns in Temporal Graphs|时空数据分析||\n|Matrix Factorization with Landmarks for Spatial Data|时空数据分析||\n|Uncertainty Quantification for Traffic Forecasting: A Unified Approach|时空数据分析||\n|Extreme-Aware Local-Global Attention for Spatio-Temporal Urban Mobility Learning|时空数据分析||\n|Mining Seasonal Temporal Patterns in Time Series|时空数据分析||\n|A Stitch in Time Saves Nine: Enabling Early Anomaly Detection with Correlation Analysis|时空数据分析||\n|Self-Supervised Spatial-Temporal Bottleneck Attentive Network for Efﬁcient Long-term Trafﬁc Forecasting|时空数据分析||\n|namic Hypergraph Structure Learning for Traffic Flow Forecasting|时空数据分析||\n|Forecasting COVID-19 Dynamics: Clustering, Generalized Spatiotemporal Attention, and Impacts of Mobility and Geographic Proximity|时空数据分析||\n|Double Hierarchical Labeling Shortest Distance Querying in Time-dependent Road Networks|时空数据分析||\n|BERT-Trip: Effective and Scalable Trip Representation using Attentive Contrast Learning|轨迹数据分析||\n|LHMM: A Learning Enhanced HMM Model for Cellular Trajectory Map-matching|轨迹数据分析||\n|Contrastive Trajectory Similarity Learning with Dual-Feature Attention|轨迹数据分析||\n|Online Anomalous Subtrajectory Detection on Road Networks with Deep Reinforcement Learning|轨迹数据分析||\n|Towards Efficient MIT query in Trajectory Data|轨迹数据分析||\n|A Lightweight Framework for Fast Trajectory Simplification|轨迹数据分析||\n|Self-supervised Trajectory Representation Learning with Temporal Regularities and Travel Semantics|轨迹数据分析||\n|RNTrajRec: Road Network Enhanced Trajectory Recovery with Spatial-Temporal Transformer|轨迹数据分析||\n|Collision-Aware Route Planning in Warehouses Made Efficient: A Strip-based Framework|轨迹数据分析||\n|Efficient Public Transport Planning on Roads|轨迹数据分析||\n|Reinforcement Learning based Tree Decomposition for Distance Querying in Road Networks|路网分析||\n|Global Routing Optimization In Road Networks|路网分析||\n|Experimental Evaluation of Indexing Techniques for Shortest Distance Queries on Road Networks|路网分析||\n|Finding Top-k Optimal Routes with Collective Spatial Keywords on Road Networks|路网分析||\n|Data Imputation for Sparse Radio Maps in Indoor Positioning|地理信息分析||\n|Semi-supervised Learning with Network Embedding on Ambient RF Signals for Geofencing Services|地理信息分析||\n|A Contextual Master-Slave Framework on Urban Region Graph for Urban Village Detection|地理信息分析||\n\n### Ai4DB\n\n|论文|子方向|备注|\n|---|---|---|\n|AutoCE: An Accurate and Efficient Model Advisor for Learned Cardinality Estimation|基数估计||\n|Couper: Memory-Efficient Cardinality Estimation under Unbalanced Distribution|基数估计||\n|Dynamic Materialized View Management using Graph Neural Network|查询优化|物化视图、图神经网络|\n|Efficient Deep Ensemble Inference via Query Difficulty-dependent Task Scheduling|查询优化||\n|GAR: A Generate-and-Rank Approach for Natural Language to SQL Translation|NL2SQL||\n|Efficiently Learning Spatial Indices|学习索引||\n|Towards Optimizing Storage Costs on the Cloud|存储||\n|Data Ambiguity Profiling for the Generation of Training Examples|NL2SQL||\n|Towards Explainable Table Interpretation Using Multi-view Explanations|表解释||\n|Toward a Unified Framework for Unsupervised Complex Tabular Reasoning|表格推理||\n|DBAugur: An Adversarial-based Trend Forecasting System for Diversified Workloads|工作负载预测||\n|Active Sampling for Sparse Table by Bayesian Optimization with Adaptive Resolution|性能调优||\n|Stable Tuple Embeddings for Dynamic Databases|数据库嵌入||\n\n### 数据库管理\n\n|论文|子方向|备注|\n|---|---|---|\n|S/C: Speeding up Data Materialization with Bounded Memory|物化视图||\n|Co-Utilizing SIMD and Scalar to Accelerate the Data Analytics Workloads|工作负载分析||\n|Leopard: A Black-Box Approach for Efficiently Verifying Various Isolation Levels|事务||\n|Knock Out 2PC with Practicality Intact: a High-performance and General Distributed Transaction Protocol|事务||\n|Database Deadlock Diagnosis for Large-scale ORM-based Web Applications|死锁检测||\n|LCL: A Lock Chain Length-based Distributed Algorithm for Deadlock Detection and Resolution|死锁检测||\n|Sequence-Oriented DBMS Fuzzing|数据库安全||\n|DBCatcher: A Cloud Database Online Anomaly Detection System based on Indicator Correlatio|数据库安全||\n\n### 存储、LSM Tree\n\n|论文|子方向|备注|\n|---|---|---|\n|ACEing the Bufferpool Management Paradigm for Modern Storage Devices|存储||\n|Redesigning High-Performance LSM-based Key-Value Stores with Persistent CPU Caches|存储||\n|Workload-Aware Log-Structured Merge Key-Value Store for NVM-SSD Hybrid Storage|存储||\n|Real-Time LSM-Trees for HTAP Workloads|LSM Tree|适用于 HTAP 工作负载的实时 LSM 树|\n\n### 查询、索引优化\n\n|论文|子方向|备注|\n|---|---|---|\n|ADAMANT: A Query Executor with Plug-In Interfaces for Easy Co-processor Integration|查询||\n|Skyline Micro-Cluster Query: A Novel and Practical Spatial Query|查询||\n|Ver: View Discovery in the Wild|查询||\n|EulerFD: An Efficient Double-Cycle Approximation of Functional Dependencies|查询||\n|Finding Best Tuple via Error-prone User Interaction|查询||\n|KOIOS: Top-k Semantic Overlap Set Search|查询||\n|Complete Join Reordering for Null-Intolerant Joins|查询||\n|Efficiently Answering Top-k Window Aggregate Queries: Calculating Coverage Number Sequences over Hierarchical Structures|查询||\n|On Explaining Confounding Bias|查询||\n|MetricJoin: Leveraging Metric Properties for Robust Exact Set Similarity Joins|查询||\n|Selecting Sub-tables for Data Exploration|查询||\n|In-Situ Cross-Database Query Processing|查询||\n|These Rows Are Made for Sorting and That’s Just What We’ll Do|查询||\n|JanusAQP: Efficient Partition Tree Maintenance for Dynamic Approximate Query Processing|查询||\n|dLSM: An LSM-Based Index for Memory Disaggregation|索引||\n|Cutting Learned Index into Pieces: An In-depth Inquiry into Updatable Learned Indexes|索引||\n|Indexing for Near-Sorted Data|索引||\n|EEPH: An Efficient Extendible Perfect Hashing for Hybrid PMem-DRAM|索引||\n\n### 人工智能\n\n|论文|子方向|备注|\n|---|---|---|\n|Fed-SC: One-Shot Federated Subspace Clustering over High-Dimensional Data|聚类||\n|Parallel Filtered Graphs for Hierarchical Clustering|聚类||\n|Efficient Augmentation for Imbalanced Deep Learning|深度学习||\n|Pricing Prediction Services for Profit Maximization with Incomplete Information|深度学习||\n|Detection of Groups With Biased Representation in Ranking|深度学习||\n|The Art of Losing to Win: Using Lossy Image Compression to Improve Data Loading in Deep Learning Pipelines|深度学习||\n|Opponent-aware Order Pricing towards Hub-oriented Mobility Services|深度学习||\n|Rotary: A Resource Arbitration Framework for Progressive Iterative Analytics|深度学习||\n|Sudowoodo: Contrastive Self-supervised Learning for Multi-purpose Data Integration and Preparation|深度学习||\n|ENLD: Efficient Noisy Label Detection for Incremental Datasets in Data Lake ENLD：数据湖中增量数据集的高效噪声标签检测|深度学习||\n|Improving Progressive Retrieval for HPC Scientific Data using Deep Neural Network|深度学习||\n|Lightweight-Yet-Efficient: Revitalizing Ball-Tree for Point-to-Hyperplane Nearest Neighbor Search|机器学习||\n|Automatic Feasibility Study via Data Quality Analysis for ML: A Case-Study on Label Noise|机器学习||\n|A Hierarchical Approach to Anomalous Subgroup Discovery|机器学习||\n|Metam: Goal-Oriented Data Discovery|机器学习||\n|Dynamic Shapley Value Computation|机器学习||\n|SK-Gradient: Efficient Communication for Distributed Machine Learning with Data Sketch|机器学习|分布式机器学习|\n|Distribution-Regularized Federated Learning on Non-IID Data|机器学习|分布式机器学习|\n|Orchestrating Large-Scale SpGEMMs using Dynamic Block Distribution and Data Transfer Minimization on Heterogeneous Systems|机器学习|分布式机器学习|\n|Enhancing Decentralized Federated Learning for Non-IID Data on Heterogenous Devices|机器学习|分布式机器学习|\n|Toward Efficient Automated Feature Engineering|特征工程||\n|PA-FEAT: Fast Feature Selection for Structured Data via Progress-Aware Multi-Task Deep Reinforcement Learning|强化学习||\n|Discovering Editing Rules by Deep Reinforcement Learning|强化学习||\n|Schema Matching using Pre-Trained Language Models|NLP||\n|Online Pricing Strategy Achieving Vanishing Regret for Shipping Container Pricing with Limited Inventory|在线学习||\n\n### 流处理\n\n|论文|子方向|备注|\n|---|---|---|\n|CompressStreamDB: Fine-Grained Adaptive Stream Processing without Decompression|流处理||\n|HistSketch: A Compact Data Structure for Accurate Per-Key Distribution Monitoring|流处理||\n|HyperCalm Sketch: One-Pass Mining Periodic Batches in Data Streams|流处理||\n|RADAR: Reactive Concept Drift Management with Robust Variational Inference for Evolving IoT Data Streams|流处理||\n|SASPAR: Shared Adaptive Stream Partitioning|流处理||\n|SketchConf: A Framework for Automatic Sketch Configuration|流处理||\n|Parallelizing Stream Compression for IoT Applications on Asymmetric Multicores|流处理||\n|Globally Aware Contextual Embeddings for Named Entity Recognition in Social Media Streams|流处理||\n|Finding Simplex Items in Data Streams|流处理||\n\n### 数据分析与挖掘\n\n|论文|子方向|备注|\n|---|---|---|\n|IndiBits: Incremental Discovery of Relaxed Functional Dependencies using Bitwise Similarity|数据挖掘||\n|UADB: Unsupervised Anomaly Detection Booster|数据挖掘||\n|Learn to Explore: on Bootstrapping Interactive Data Exploration with Meta-learning|数据挖掘||\n|Efficient Parallel Mining of High-utility Itemsets on Multicore Processors|数据挖掘||\n|Benchmarking Filtering Techniques for Entity Resolution|数据挖掘||\n|Voting-based Opinion Maximization|数据挖掘||\n|Interactive Search with Mixed Attributes|数据挖掘||\n|Planning Data Poisoning Attacks on Heterogeneous Recommender Systems in a Multiplayer Setting|数据挖掘||\n|A Feature-Driven Fixed-Ratio Lossy Compression Framework for Real-World Scientific Datasets|数据压缩||\n|Neural Node Matching for Multi-Target Cross Domain Recommendation|推荐||\n|Incremental Learning for Multi-Interest Sequential Recommendation|推荐||\n|Disentangled Graph Social Recommendation|推荐||\n|Group Buying Recommendation Model Based on Multi-task Learning|推荐|多任务学习|\n|Probabilistic Majority Rule-Based Group Recommendation|推荐||\n|Sequential Recommendation with User Causal Behavior Discovery|推荐||\n|Towards Capacity-Aware Broker Matching: From Recommendation to Assignment|推荐||\n|Visualization Recommendation Through Visual Relation Learning and Visual Preference Learning|推荐||\n|Personalized Diversification for Neural Re-ranking in Recommendation|推荐||\n|A Competition-Aware Approach to Accurate TV Show Recommendation|推荐||\n|Intent-aware Multi-source Contrastive Alignment for Tag-enhanced Recommendation|推荐||\n|Instant Representation Learning for Recommendation over Large Dynamic Graphs|推荐||\n|A Generic Reinforced Explainable Framework with Knowledge Graph for Session-based Recommendation|推荐||\n|Contrastive Enhanced Slide Filter Mixer for Sequential Recommendation|推荐||\n|Bayesian Negative Sampling for Recommendation|推荐||\n|Influential Recommender System|推荐||\n\n### 边缘计算、区块链、物联网\n\n|论文|子方向|备注|\n|---|---|---|\n|EdgeNN: Efficient Neural Network Inference for CPU-GPU Integrated Edge Devices|边缘计算||\n|FedKNOW: Federated Continual Learning with Signature Task Knowledge Integration at Edge|边缘计算||\n|Reliable Transactions in Serverless-Edge Architecture|边缘计算||\n|Ziziphus: Scalable Data Management Across Byzantine Edge Servers|边缘计算||\n|Saguaro: An Edge Computing-Enabled Hierarchical Permissioned Blockchain|边缘计算 、区块链||\n|SChain: Scalable Concurrency over Flexible Permissioned Blockchain|区块链||\n|TxAllo: Dynamic Transaction Allocation in Sharded Blockchain Systems|区块链||\n|On Sharding Across Heterogeneous Blockchains|区块链||\n|Scaling Blockchain Consensus via a Robust Shared Mempool|区块链||\n|Non-Blocking Raft for High Throughput IoT Data|物联网||\n|Federated IoT Interaction Vulnerability Analysis|物联网|漏洞分析|\n\n### 视频处理\n\n|论文|子方向|备注|\n|---|---|---|\n|Marshalling Model Inference In Video Streams|视频处理||\n|Track Merging for Effective Video Query Processing|视频处理||\n\n### 隐私保护\n\n|论文|子方向|备注|\n|---|---|---|\n|Dynamic Private Task Assignment under Differential Privacy|隐私保护||\n|Differential Aggregation against General Colluding Attackers|隐私保护||\n|KVSAgg: Secure Aggregation of Distributed Key-Value Sets|隐私保护||\n|PrivNUD: Effective Range Query Processing under Local Differential Privacy|隐私保护||\n\n### 众包\n\n|论文|子方向|备注|\n|---|---|---|\n|Air-Ground Spatial Crowdsourcing with UAV Carriers by Geometric Graph Convolutional Multi-Agent Deep Reinforcement Learning|众包||\n|Efficient Cross Dynamic Task Assignment in Spatial Crowdsourcing|众包||\n|Batch-Based Cooperative Task Assignment in Spatial Crowdsourcing|众包||\n|Exploring both Individuality and Cooperation for Air-Ground Spatial Crowdsourcing by Multi-Agent Deep Reinforcement Learning|众包||\n|Hierarchical Crowdsourcing for Data Labeling with Heterogeneous Crowd|众包||\n|Learning from Noisy Crowd Labels with Logics 从喧闹的人群标签中学习逻辑|众包||\n\n# 密码生成\n## 介绍\n关于口令生成的方向调研\n## 个人总结\n[[方向：密码生成]]\n## 安全一流会议\nS&P、CCS、NDSS、USENIX Conference、IEEE tDSC\n## 详情\n| 论文                                                                                                                                                                                                                                                                                                                                                                        | 时间   | 级别       | 笔记                            |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---- | -------- | ----------------------------- |\n| GENPass: A General Deep Learning Model for Password Guessing with PCFG Rules and Adversarial Generation                                                                                                                                                                                                                                                                   | 2018 |          |                               |\n| [PassGAN: A Deep Learning Approach to Password Guessing](https://link.springer.com/chapter/10.1007/978-3-030-21568-2_11)<br>[代码](https://github.com/brannondorsey/PassGAN)<br>[改进代码](https://github.com/ponedo/rnnPassGAN-password-cracking)                                                                                                                              | 2019 |          | [[PassGAN]]                   |\n| [Recurrent gans password cracker for iot password security enhancement](https://www.mdpi.com/1424-8220/20/11/3106)                                                                                                                                                                                                                                                        | 2019 |          |                               |\n| [Research on Password Cracking Technology Based on Improved Transformer](https://iopscience.iop.org/article/10.1088/1742-6596/1631/1/012161/pdf)                                                                                                                                                                                                                          | 2020 |          | [[Pass improved Transformer]] |\n| [Generating optimized guessing candidates toward better password cracking from multi-dictionaries using relativistic GAN](https://www.mdpi.com/2076-3417/10/20/7306)                                                                                                                                                                                                      | 2020 | 三区       | [[REDPACK]]                   |\n| [Densegan: A password **guessing model based** on **densenet** and **passgan**](https://link.springer.com/chapter/10.1007/978-3-030-93206-0_18)                                                                                                                                                                                                                           | 2021 |          |                               |\n| [Dynamic Markov Model: Password Guessing Using Probability Adjustment](https://www.mdpi.com/2076-3417/11/10/4607)                                                                                                                                                                                                                                                         | 2021 | C        |                               |\n| [A large-scale analysis of the semantic password model and linguistic patterns in passwords](https://dl.acm.org/doi/abs/10.1145/3448608)综述                                                                                                                                                                                                                                | 2021 | B        | [[语义密码模型和密码语言模式分析]]           |\n| [LPG–PCFG: an improved probabilistic context-free grammar to hit low-probability passwords](https://www.mdpi.com/1424-8220/22/12/4604)                                                                                                                                                                                                                                    | 2022 | C        |                               |\n| [On deep learning in password guessing, a survey](https://arxiv.org/abs/2208.10413)                                                                                                                                                                                                                                                                                       | 2022 | C        |                               |\n| [GNPassGAN: improved generative adversarial networks for trawling offline password guessing](https://ieeexplore.ieee.org/abstract/document/9799343/)                                                                                                                                                                                                                      | 2022 | A        | [[GNPassGAN]]                 |\n| [PassDiff: A New Approach for Password Guessing Using Diffusion Model](https://link.springer.com/chapter/10.1007/978-981-99-9239-3_3)[阅读](https://books.google.co.jp/books?hl=zh-CN&lr&id=NjvsEAAAQBAJ&oi=fnd&pg=PA29&ots=MFKPmtXK-9&sig=Ea5MEWjfUDxwHsZPvrnk1jdnHo0&redir_esc=y&pli=1#v=onepage&q&f=false)<br>[代码](https://github.com/madaan/minimal-text-diffusion)<br> | 2023 |          | [[PassDiff]]                  |\n| [OneRuleToFindThem: Efficient Automated Generation of Password Cracking](https://dl.acm.org/doi/abs/10.5555/3636988.3637019)<br>自动生成密码规则                                                                                                                                                                                                                                  | 2023 |          |                               |\n| [A Systematic Review on Password Guessing Tasks](https://www.mdpi.com/1099-4300/25/9/1303)<br>密码生成的系统综述                                                                                                                                                                                                                                                                   | 2023 |          | [[AReview]]                   |\n| [Adaptive password guessing: learning language, nationality and dataset](https://link.springer.com/article/10.1007/s12243-023-00969-4)<br>自适应密码猜测                                                                                                                                                                                                                         | 2023 | 4区       |                               |\n| [SE# PCFG: Semantically Enhanced PCFG for Password Analysis and Cracking](https://arxiv.org/abs/2306.06824)<br>密码分析和破解语义的增强                                                                                                                                                                                                                                               | 2023 |          |                               |\n| [PassGPT: Password Modeling and (Guided) Generation with Large Language](https://arxiv.org/abs/2306.01545)                                                                                                                                                                                                                                                                | 2023 |          | [[PassGPT]]                   |\n| [A New Targeted Online Password Guessing Algorithm Based on Old Password](https://ieeexplore.ieee.org/abstract/document/10152712/)                                                                                                                                                                                                                                        | 2023 | B        |                               |\n| [Improving real-world password guessing attacks via bi-directional transformers](https://www.usenix.org/conference/usenixsecurity23/presentation/xu-ming)                                                                                                                                                                                                                 | 2023 | A        | [[PassBERT]]                  |\n| [Password and passphrase guessing with recurrent neural networks](https://link.springer.com/article/10.1007/s10796-022-10325-x)                                                                                                                                                                                                                                           | 2023 | (JCR:Q2) | [[Pass_RNN]]                  |\n| [Password guessing using random forest](https://www.usenix.org/system/files/sec23fall-prepub-183-wang-ding.pdf)<br>随机森林<br>[代码](https://github.com/PadishahIII/RFGuess)                                                                                                                                                                                                   | 2023 | A        | [[PASS_RF]]                   |\n| [PGTCN: A novel password-guessing model based on temporal convolution](https://www.sciencedirect.com/science/article/pii/S1084804523000115)                                                                                                                                                                                                                               | 2023 | C        |                               |\n| [Search-based Ordered Password Generation of Autoregressive Neural Networks](https://arxiv.org/abs/2403.09954)                                                                                                                                                                                                                                                            | 2024 | C        |                               |\n| [_GuessFuse_: Hybrid Password Guessing with Multi-View](https://ieeexplore.ieee.org/abstract/document/10466588/)                                                                                                                                                                                                                                                          | 2024 | A        | [[GuessFuse]]                 |\n\n\n\n\n## A Two-Decade Retrospective Analysis of a University’s Vulnerability to Attacks Exploiting Reused Passwords\n\n凭据猜测攻击通常会利用在用户在线帐户中重复使用的密码。为了了解组织如何更好地保护用户，我们回顾性分析了我们大学二十年来遭受凭据猜测攻击的脆弱性。给定一份大学用户名列表，我们从数百个网站和十几个大型泄露事件汇编中搜索了两个数据泄露事件中的匹配项。在破解哈希密码并调整猜测后，我们成功猜测了 32.0% 与数据泄露中的大学电子邮件地址匹配的帐户的密码，以及 6.5% 与用户名（但不一定是域名）匹配的帐户的密码。这些帐户中的许多帐户在被泄露的数据泄露后多年仍然容易受到攻击，并且在泄露中逐字发现的密码被利用的可能性（即观察到可疑的帐户活动）几乎是经过调整的猜测的四倍。超过 70 种不同的数据泄露和各种用户名匹配策略引导了正确的猜测。在对我们猜测密码的 40 名用户进行的调查中，许多用户没有意识到他们的大学帐户存在风险，或者他们的凭据已被泄露。对我们大学密码重用的分析为组织保护帐户提供了务实的建议。\n##  参考文章\n[使用 RNN(LSTMs) 生成密码](https://medium.com/@gsurma/password-cracker-generating-passwords-with-recurrent-neural-networks-lstms-9583714a3310)：[代码不全](https://github.com/gsurma/password_cracker)\n\n（1）\n（2）Generative Adversarial Networks can crack your password!\n（3）Password Cracker - Generating Passwords\n\n\n","source":"_posts/研究方向/方向调研.md","raw":"论文调研旨在找到一个喜欢的方向并且实现小论文撰写，\n# ICDE 2023\n\n## 介绍\n\nICDE-2023共接收论文228篇，录用率在25%左右，研究方向统计如下：\n\n|方向|子方向|论文数量|\n|---|---|---|\n|图与网络|图算法、图处理框架、图数据库、图神经网络、图分析、知识图谱|69|\n|时空、轨迹数据分析||34|\n|AI4DB|基数估计、查询优化、学习索引、NL2SQL、表格推理、工作负载预测、性能调优、数据库嵌入|13|\n|数据库管理|物化视图管理、工作负载分析、事务、死锁检测、数据库安全|8|\n|存储||4|\n|查询、索引优化||18|\n|人工智能|机器学习、深度学习、聚类、强化学习、在线学习|25|\n|流处理|-|9|\n|数据挖掘与分析|数据挖掘、数据压缩、推荐|25|\n|边缘计算、区块链、物联网|-|11|\n|视频处理|-|2|\n|隐私保护、数据安全|-|4|\n|众包|-|6|\n\n## 详情\n\n### 图与网络\n\n|论文|子方向|备注|\n|---|---|---|\n|COCLEP: Contrastive Learning-based Semi-Supervised Community Search|图算法||\n|FASI: FPGA-friendly Subgraph Isomorphism on Massive Graphs|图算法||\n|HGMatch: A Match-by-Hyperedge Framework for Efficient and Parallel Subhypergraph Matching|图算法||\n|Layph: Making Change Propagation Constraint in Incremental Graph Processing by Layering Graph|图算法||\n|LightTraffic: On Optimizing CPU-GPU Data Traffic for Efficient Large-scale Random Walks|图算法||\n|Lumos: Heterogeneity-aware Federated Graph Learning over Decentralized Devices|图算法||\n|PSPC: Efficient Parallel Shortest Path Counting on Large-Scale Graphs|图算法||\n|TDB: Breaking All Hop-Constrained Cycles in Billion-Scale Directed Graphs|图算法||\n|Finer-Grained Engagement in Hypergraphs|图算法||\n|Distributed (α, β)-Core Decomposition over Bipartite Graphs|图算法||\n|Fairness-aware Maximal Biclique Enumeration on Bipartite Graphs|图算法||\n|Index-Based Biclique Percolation Communities Search on Bipartite graphs|图算法||\n|Efficiently Answering Quality Constrained Shortest Distance Queries in Large Graphs|图算法||\n|Verification-Free Approaches to Efficient Locally Densest Subgraph Discovery|图算法||\n|Efficient Maximum Signed Biclique Identification|图算法||\n|Explainable Hyperlink Prediction: A Hypergraph Edit Distance-Based Approach|图算法||\n|Reinforcement Learning Enhanced Weighted Sampling for Accurate Subgraph Counting on Fully Dynamic Graph Streams|图算法||\n|Towards Efficient Shortest Path Counting on Billion-Scale Graphs|图算法||\n|Fair Group Summarization with Graph Patterns|图算法||\n|Top-r keyword-based community search in attributed graphs|图算法||\n|Accelerating k-Core Decomposition by a GPU|图算法||\n|Minimizing the Influence of Misinformation via Vertex Blocking|图算法||\n|Efficiently Sampling and Estimating Hypergraphs By Hybrid Random Walk|图算法||\n|Efficient Multi-GPU Graph Processing with Remote Work Stealing|图算法||\n|Neighborhood Skyline on Graphs: Concepts, Algorithms and Applications|图算法||\n|Finding Top-k Important Edges on Bipartite Graphs: Ego-betweenness Centrality-based Approaches|图算法||\n|VC-dimension and Rademacher Averages of Subgraphs, with Applications to Graph Mining|图算法||\n|Most Probable Densest Subgraphs|图算法||\n|Scalable Algorithms for Densest Subgraph Discovery|图算法||\n|Distributed Near-Maximum Independent Set Maintenance over Large-scale Dynamic Graphs|图算法||\n|Fast Unsupervised Graph Embedding via Graph Zoom Learning|图算法||\n|Wind-Bell Index: Towards Ultra-Fast Relational Query for Graph Databases|图数据库|查询|\n|Hop-Constrained s-t Simple Path Enumeration on Large Dynamic Graphs|图数据库|查询|\n|A Reachability Index for Recursive Label-Concatenated Graph Queries|图数据库|索引|\n|VEND: Vertex Encoding for Edge Nonexistence Determination|图数据库||\n|Extracting Graphs Properties with Semantic Joins|图数据库||\n|Integrating Connection Search in Graph Queries|图数据库|查询|\n|AFaVS: Accurate Yet Fast Version Switching for Graph Processing Systems|图处理系统||\n|FLASH: A Framework for Programming Distributed Graph Processing Algorithms|图处理系统||\n|Partitioner Selection with EASE to Optimize Distributed Graph Processing|图处理系统||\n|Optimizing Graph Partition by Optimal Vertex-Cut: A Holistic Approach|图处理系统|图划分|\n|HyTGraph: GPU-Accelerated Graph Processing with Hybrid Transfer Management|图处理系统||\n|GAMMA: A Graph Pattern Mining Framework for Large Graphs on GPU|图处理系统|图模式挖掘|\n|HyGNN: Drug-Drug Interaction Prediction via Hypergraph Neural Network|图神经网络||\n|Demystifying Bitcoin Address Behavior via Graph Neural Networks|图神经网络||\n|Jointly Attacking Graph Neural Network and its Explanations|图神经网络||\n|Relational Temporal Graph Convolutional Networks for Ranking-Based Stock Prediction|图神经网络||\n|A Bayesian Graph Neural Network for EEG Classification — A Win-Win on Performance and Interpretability|图神经网络||\n|Layer-refined Graph Convolutional Networks for Recommendation|图神经网络||\n|AutoAC: Towards Automated Attribute Completion for Heterogeneous Graph Neural Network|图神经网络||\n|SEIGN: A Simple and Efficient Graph Neural Network for Large Dynamic Graphs|图神经网络||\n|Revisiting Citation Prediction with Cluster-Aware Text-Enhanced Heterogeneous Graph Neural Networks|图神经网络||\n|Towards Higher-order Topological Consistency for Unsupervised Network Alignment|图神经网络||\n|CLDG: Contrastive Learning on Dynamic Graphs|图分析||\n|GALE: Active Adversarial Learning for Erroneous Node Detection in Graphs|图分析||\n|IFCA: Index-Free Community-Aware Reachability Processing Over Large Dynamic Graphs|图分析||\n|Unsupervised Graph Outlier Detection: Problem Revisit, New Insight, and Superior Method|图分析||\n|Efficient and Compact Spreadsheet Formula Graphs|图分析||\n|Inconsistency Detection with Temporal Graph Functional Dependencies|图分析||\n|Keyword-based Socially Tenuous Group Queries|图分析||\n|Community Search: A Meta-Learning Approach|图分析||\n|Dynamic Activation of Clients and Parameters for Federated Learning over Heterogeneous Graphs|图分析||\n|RETIA: Relation-Entity Twin-Interact Aggregation for Temporal Knowledge Graph Extrapolation|知识图谱||\n|Disconnected Emerging Knowledge Graph Oriented Inductive Link Prediction|知识图谱||\n|Relational Message Passing for Fully Inductive Knowledge Graph Completion|知识图谱||\n|MMKGR: Multi-hop Multi-modal Knowledge Graph Reasoning|知识图谱||\n|Robust Attributed Graph Alignment via Joint Structure Learning and Optimal Transpor|知识图谱||\n|Multimodal Biological Knowledge Graph Completion via Triple Co-attention Mechanism|知识图谱||\n|A Holistic Approach for Answering Logical Queries on Knowledge Graphs|知识图谱||\n\n### 时空、轨迹数据分析\n\n|论文|子方向|备注|\n|---|---|---|\n|TSC-AutoML: Meta-learning for automatic Time Series Classification Algorithm Selection|时空数据分析||\n|TSEXPLAIN: Explaining Aggregated Time Series by Surfacing Evolving Contributors|时空数据分析||\n|Towards Long-Term Time-Series Forecasting: Feature, Pattern, and Distribution|时空数据分析||\n|PriSTI: A Conditional Diffusion Framework for Spatiotemporal Imputation|时空数据分析||\n|REncoder: A Space-Time Efficient Range Filter with Local Encoder|时空数据分析||\n|ROI-demand Traffic Prediction: A Pre-train, Query and Fine-tune Framework|时空数据分析||\n|When Spatio-Temporal Meet Wavelets: Disentangled Traffic Forecasting via Efficient Spectral Graph Attention Networks|时空数据分析||\n|Discovering Frequency Bursting Patterns in Temporal Graphs|时空数据分析||\n|Matrix Factorization with Landmarks for Spatial Data|时空数据分析||\n|Uncertainty Quantification for Traffic Forecasting: A Unified Approach|时空数据分析||\n|Extreme-Aware Local-Global Attention for Spatio-Temporal Urban Mobility Learning|时空数据分析||\n|Mining Seasonal Temporal Patterns in Time Series|时空数据分析||\n|A Stitch in Time Saves Nine: Enabling Early Anomaly Detection with Correlation Analysis|时空数据分析||\n|Self-Supervised Spatial-Temporal Bottleneck Attentive Network for Efﬁcient Long-term Trafﬁc Forecasting|时空数据分析||\n|namic Hypergraph Structure Learning for Traffic Flow Forecasting|时空数据分析||\n|Forecasting COVID-19 Dynamics: Clustering, Generalized Spatiotemporal Attention, and Impacts of Mobility and Geographic Proximity|时空数据分析||\n|Double Hierarchical Labeling Shortest Distance Querying in Time-dependent Road Networks|时空数据分析||\n|BERT-Trip: Effective and Scalable Trip Representation using Attentive Contrast Learning|轨迹数据分析||\n|LHMM: A Learning Enhanced HMM Model for Cellular Trajectory Map-matching|轨迹数据分析||\n|Contrastive Trajectory Similarity Learning with Dual-Feature Attention|轨迹数据分析||\n|Online Anomalous Subtrajectory Detection on Road Networks with Deep Reinforcement Learning|轨迹数据分析||\n|Towards Efficient MIT query in Trajectory Data|轨迹数据分析||\n|A Lightweight Framework for Fast Trajectory Simplification|轨迹数据分析||\n|Self-supervised Trajectory Representation Learning with Temporal Regularities and Travel Semantics|轨迹数据分析||\n|RNTrajRec: Road Network Enhanced Trajectory Recovery with Spatial-Temporal Transformer|轨迹数据分析||\n|Collision-Aware Route Planning in Warehouses Made Efficient: A Strip-based Framework|轨迹数据分析||\n|Efficient Public Transport Planning on Roads|轨迹数据分析||\n|Reinforcement Learning based Tree Decomposition for Distance Querying in Road Networks|路网分析||\n|Global Routing Optimization In Road Networks|路网分析||\n|Experimental Evaluation of Indexing Techniques for Shortest Distance Queries on Road Networks|路网分析||\n|Finding Top-k Optimal Routes with Collective Spatial Keywords on Road Networks|路网分析||\n|Data Imputation for Sparse Radio Maps in Indoor Positioning|地理信息分析||\n|Semi-supervised Learning with Network Embedding on Ambient RF Signals for Geofencing Services|地理信息分析||\n|A Contextual Master-Slave Framework on Urban Region Graph for Urban Village Detection|地理信息分析||\n\n### Ai4DB\n\n|论文|子方向|备注|\n|---|---|---|\n|AutoCE: An Accurate and Efficient Model Advisor for Learned Cardinality Estimation|基数估计||\n|Couper: Memory-Efficient Cardinality Estimation under Unbalanced Distribution|基数估计||\n|Dynamic Materialized View Management using Graph Neural Network|查询优化|物化视图、图神经网络|\n|Efficient Deep Ensemble Inference via Query Difficulty-dependent Task Scheduling|查询优化||\n|GAR: A Generate-and-Rank Approach for Natural Language to SQL Translation|NL2SQL||\n|Efficiently Learning Spatial Indices|学习索引||\n|Towards Optimizing Storage Costs on the Cloud|存储||\n|Data Ambiguity Profiling for the Generation of Training Examples|NL2SQL||\n|Towards Explainable Table Interpretation Using Multi-view Explanations|表解释||\n|Toward a Unified Framework for Unsupervised Complex Tabular Reasoning|表格推理||\n|DBAugur: An Adversarial-based Trend Forecasting System for Diversified Workloads|工作负载预测||\n|Active Sampling for Sparse Table by Bayesian Optimization with Adaptive Resolution|性能调优||\n|Stable Tuple Embeddings for Dynamic Databases|数据库嵌入||\n\n### 数据库管理\n\n|论文|子方向|备注|\n|---|---|---|\n|S/C: Speeding up Data Materialization with Bounded Memory|物化视图||\n|Co-Utilizing SIMD and Scalar to Accelerate the Data Analytics Workloads|工作负载分析||\n|Leopard: A Black-Box Approach for Efficiently Verifying Various Isolation Levels|事务||\n|Knock Out 2PC with Practicality Intact: a High-performance and General Distributed Transaction Protocol|事务||\n|Database Deadlock Diagnosis for Large-scale ORM-based Web Applications|死锁检测||\n|LCL: A Lock Chain Length-based Distributed Algorithm for Deadlock Detection and Resolution|死锁检测||\n|Sequence-Oriented DBMS Fuzzing|数据库安全||\n|DBCatcher: A Cloud Database Online Anomaly Detection System based on Indicator Correlatio|数据库安全||\n\n### 存储、LSM Tree\n\n|论文|子方向|备注|\n|---|---|---|\n|ACEing the Bufferpool Management Paradigm for Modern Storage Devices|存储||\n|Redesigning High-Performance LSM-based Key-Value Stores with Persistent CPU Caches|存储||\n|Workload-Aware Log-Structured Merge Key-Value Store for NVM-SSD Hybrid Storage|存储||\n|Real-Time LSM-Trees for HTAP Workloads|LSM Tree|适用于 HTAP 工作负载的实时 LSM 树|\n\n### 查询、索引优化\n\n|论文|子方向|备注|\n|---|---|---|\n|ADAMANT: A Query Executor with Plug-In Interfaces for Easy Co-processor Integration|查询||\n|Skyline Micro-Cluster Query: A Novel and Practical Spatial Query|查询||\n|Ver: View Discovery in the Wild|查询||\n|EulerFD: An Efficient Double-Cycle Approximation of Functional Dependencies|查询||\n|Finding Best Tuple via Error-prone User Interaction|查询||\n|KOIOS: Top-k Semantic Overlap Set Search|查询||\n|Complete Join Reordering for Null-Intolerant Joins|查询||\n|Efficiently Answering Top-k Window Aggregate Queries: Calculating Coverage Number Sequences over Hierarchical Structures|查询||\n|On Explaining Confounding Bias|查询||\n|MetricJoin: Leveraging Metric Properties for Robust Exact Set Similarity Joins|查询||\n|Selecting Sub-tables for Data Exploration|查询||\n|In-Situ Cross-Database Query Processing|查询||\n|These Rows Are Made for Sorting and That’s Just What We’ll Do|查询||\n|JanusAQP: Efficient Partition Tree Maintenance for Dynamic Approximate Query Processing|查询||\n|dLSM: An LSM-Based Index for Memory Disaggregation|索引||\n|Cutting Learned Index into Pieces: An In-depth Inquiry into Updatable Learned Indexes|索引||\n|Indexing for Near-Sorted Data|索引||\n|EEPH: An Efficient Extendible Perfect Hashing for Hybrid PMem-DRAM|索引||\n\n### 人工智能\n\n|论文|子方向|备注|\n|---|---|---|\n|Fed-SC: One-Shot Federated Subspace Clustering over High-Dimensional Data|聚类||\n|Parallel Filtered Graphs for Hierarchical Clustering|聚类||\n|Efficient Augmentation for Imbalanced Deep Learning|深度学习||\n|Pricing Prediction Services for Profit Maximization with Incomplete Information|深度学习||\n|Detection of Groups With Biased Representation in Ranking|深度学习||\n|The Art of Losing to Win: Using Lossy Image Compression to Improve Data Loading in Deep Learning Pipelines|深度学习||\n|Opponent-aware Order Pricing towards Hub-oriented Mobility Services|深度学习||\n|Rotary: A Resource Arbitration Framework for Progressive Iterative Analytics|深度学习||\n|Sudowoodo: Contrastive Self-supervised Learning for Multi-purpose Data Integration and Preparation|深度学习||\n|ENLD: Efficient Noisy Label Detection for Incremental Datasets in Data Lake ENLD：数据湖中增量数据集的高效噪声标签检测|深度学习||\n|Improving Progressive Retrieval for HPC Scientific Data using Deep Neural Network|深度学习||\n|Lightweight-Yet-Efficient: Revitalizing Ball-Tree for Point-to-Hyperplane Nearest Neighbor Search|机器学习||\n|Automatic Feasibility Study via Data Quality Analysis for ML: A Case-Study on Label Noise|机器学习||\n|A Hierarchical Approach to Anomalous Subgroup Discovery|机器学习||\n|Metam: Goal-Oriented Data Discovery|机器学习||\n|Dynamic Shapley Value Computation|机器学习||\n|SK-Gradient: Efficient Communication for Distributed Machine Learning with Data Sketch|机器学习|分布式机器学习|\n|Distribution-Regularized Federated Learning on Non-IID Data|机器学习|分布式机器学习|\n|Orchestrating Large-Scale SpGEMMs using Dynamic Block Distribution and Data Transfer Minimization on Heterogeneous Systems|机器学习|分布式机器学习|\n|Enhancing Decentralized Federated Learning for Non-IID Data on Heterogenous Devices|机器学习|分布式机器学习|\n|Toward Efficient Automated Feature Engineering|特征工程||\n|PA-FEAT: Fast Feature Selection for Structured Data via Progress-Aware Multi-Task Deep Reinforcement Learning|强化学习||\n|Discovering Editing Rules by Deep Reinforcement Learning|强化学习||\n|Schema Matching using Pre-Trained Language Models|NLP||\n|Online Pricing Strategy Achieving Vanishing Regret for Shipping Container Pricing with Limited Inventory|在线学习||\n\n### 流处理\n\n|论文|子方向|备注|\n|---|---|---|\n|CompressStreamDB: Fine-Grained Adaptive Stream Processing without Decompression|流处理||\n|HistSketch: A Compact Data Structure for Accurate Per-Key Distribution Monitoring|流处理||\n|HyperCalm Sketch: One-Pass Mining Periodic Batches in Data Streams|流处理||\n|RADAR: Reactive Concept Drift Management with Robust Variational Inference for Evolving IoT Data Streams|流处理||\n|SASPAR: Shared Adaptive Stream Partitioning|流处理||\n|SketchConf: A Framework for Automatic Sketch Configuration|流处理||\n|Parallelizing Stream Compression for IoT Applications on Asymmetric Multicores|流处理||\n|Globally Aware Contextual Embeddings for Named Entity Recognition in Social Media Streams|流处理||\n|Finding Simplex Items in Data Streams|流处理||\n\n### 数据分析与挖掘\n\n|论文|子方向|备注|\n|---|---|---|\n|IndiBits: Incremental Discovery of Relaxed Functional Dependencies using Bitwise Similarity|数据挖掘||\n|UADB: Unsupervised Anomaly Detection Booster|数据挖掘||\n|Learn to Explore: on Bootstrapping Interactive Data Exploration with Meta-learning|数据挖掘||\n|Efficient Parallel Mining of High-utility Itemsets on Multicore Processors|数据挖掘||\n|Benchmarking Filtering Techniques for Entity Resolution|数据挖掘||\n|Voting-based Opinion Maximization|数据挖掘||\n|Interactive Search with Mixed Attributes|数据挖掘||\n|Planning Data Poisoning Attacks on Heterogeneous Recommender Systems in a Multiplayer Setting|数据挖掘||\n|A Feature-Driven Fixed-Ratio Lossy Compression Framework for Real-World Scientific Datasets|数据压缩||\n|Neural Node Matching for Multi-Target Cross Domain Recommendation|推荐||\n|Incremental Learning for Multi-Interest Sequential Recommendation|推荐||\n|Disentangled Graph Social Recommendation|推荐||\n|Group Buying Recommendation Model Based on Multi-task Learning|推荐|多任务学习|\n|Probabilistic Majority Rule-Based Group Recommendation|推荐||\n|Sequential Recommendation with User Causal Behavior Discovery|推荐||\n|Towards Capacity-Aware Broker Matching: From Recommendation to Assignment|推荐||\n|Visualization Recommendation Through Visual Relation Learning and Visual Preference Learning|推荐||\n|Personalized Diversification for Neural Re-ranking in Recommendation|推荐||\n|A Competition-Aware Approach to Accurate TV Show Recommendation|推荐||\n|Intent-aware Multi-source Contrastive Alignment for Tag-enhanced Recommendation|推荐||\n|Instant Representation Learning for Recommendation over Large Dynamic Graphs|推荐||\n|A Generic Reinforced Explainable Framework with Knowledge Graph for Session-based Recommendation|推荐||\n|Contrastive Enhanced Slide Filter Mixer for Sequential Recommendation|推荐||\n|Bayesian Negative Sampling for Recommendation|推荐||\n|Influential Recommender System|推荐||\n\n### 边缘计算、区块链、物联网\n\n|论文|子方向|备注|\n|---|---|---|\n|EdgeNN: Efficient Neural Network Inference for CPU-GPU Integrated Edge Devices|边缘计算||\n|FedKNOW: Federated Continual Learning with Signature Task Knowledge Integration at Edge|边缘计算||\n|Reliable Transactions in Serverless-Edge Architecture|边缘计算||\n|Ziziphus: Scalable Data Management Across Byzantine Edge Servers|边缘计算||\n|Saguaro: An Edge Computing-Enabled Hierarchical Permissioned Blockchain|边缘计算 、区块链||\n|SChain: Scalable Concurrency over Flexible Permissioned Blockchain|区块链||\n|TxAllo: Dynamic Transaction Allocation in Sharded Blockchain Systems|区块链||\n|On Sharding Across Heterogeneous Blockchains|区块链||\n|Scaling Blockchain Consensus via a Robust Shared Mempool|区块链||\n|Non-Blocking Raft for High Throughput IoT Data|物联网||\n|Federated IoT Interaction Vulnerability Analysis|物联网|漏洞分析|\n\n### 视频处理\n\n|论文|子方向|备注|\n|---|---|---|\n|Marshalling Model Inference In Video Streams|视频处理||\n|Track Merging for Effective Video Query Processing|视频处理||\n\n### 隐私保护\n\n|论文|子方向|备注|\n|---|---|---|\n|Dynamic Private Task Assignment under Differential Privacy|隐私保护||\n|Differential Aggregation against General Colluding Attackers|隐私保护||\n|KVSAgg: Secure Aggregation of Distributed Key-Value Sets|隐私保护||\n|PrivNUD: Effective Range Query Processing under Local Differential Privacy|隐私保护||\n\n### 众包\n\n|论文|子方向|备注|\n|---|---|---|\n|Air-Ground Spatial Crowdsourcing with UAV Carriers by Geometric Graph Convolutional Multi-Agent Deep Reinforcement Learning|众包||\n|Efficient Cross Dynamic Task Assignment in Spatial Crowdsourcing|众包||\n|Batch-Based Cooperative Task Assignment in Spatial Crowdsourcing|众包||\n|Exploring both Individuality and Cooperation for Air-Ground Spatial Crowdsourcing by Multi-Agent Deep Reinforcement Learning|众包||\n|Hierarchical Crowdsourcing for Data Labeling with Heterogeneous Crowd|众包||\n|Learning from Noisy Crowd Labels with Logics 从喧闹的人群标签中学习逻辑|众包||\n\n# 密码生成\n## 介绍\n关于口令生成的方向调研\n## 个人总结\n[[方向：密码生成]]\n## 安全一流会议\nS&P、CCS、NDSS、USENIX Conference、IEEE tDSC\n## 详情\n| 论文                                                                                                                                                                                                                                                                                                                                                                        | 时间   | 级别       | 笔记                            |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---- | -------- | ----------------------------- |\n| GENPass: A General Deep Learning Model for Password Guessing with PCFG Rules and Adversarial Generation                                                                                                                                                                                                                                                                   | 2018 |          |                               |\n| [PassGAN: A Deep Learning Approach to Password Guessing](https://link.springer.com/chapter/10.1007/978-3-030-21568-2_11)<br>[代码](https://github.com/brannondorsey/PassGAN)<br>[改进代码](https://github.com/ponedo/rnnPassGAN-password-cracking)                                                                                                                              | 2019 |          | [[PassGAN]]                   |\n| [Recurrent gans password cracker for iot password security enhancement](https://www.mdpi.com/1424-8220/20/11/3106)                                                                                                                                                                                                                                                        | 2019 |          |                               |\n| [Research on Password Cracking Technology Based on Improved Transformer](https://iopscience.iop.org/article/10.1088/1742-6596/1631/1/012161/pdf)                                                                                                                                                                                                                          | 2020 |          | [[Pass improved Transformer]] |\n| [Generating optimized guessing candidates toward better password cracking from multi-dictionaries using relativistic GAN](https://www.mdpi.com/2076-3417/10/20/7306)                                                                                                                                                                                                      | 2020 | 三区       | [[REDPACK]]                   |\n| [Densegan: A password **guessing model based** on **densenet** and **passgan**](https://link.springer.com/chapter/10.1007/978-3-030-93206-0_18)                                                                                                                                                                                                                           | 2021 |          |                               |\n| [Dynamic Markov Model: Password Guessing Using Probability Adjustment](https://www.mdpi.com/2076-3417/11/10/4607)                                                                                                                                                                                                                                                         | 2021 | C        |                               |\n| [A large-scale analysis of the semantic password model and linguistic patterns in passwords](https://dl.acm.org/doi/abs/10.1145/3448608)综述                                                                                                                                                                                                                                | 2021 | B        | [[语义密码模型和密码语言模式分析]]           |\n| [LPG–PCFG: an improved probabilistic context-free grammar to hit low-probability passwords](https://www.mdpi.com/1424-8220/22/12/4604)                                                                                                                                                                                                                                    | 2022 | C        |                               |\n| [On deep learning in password guessing, a survey](https://arxiv.org/abs/2208.10413)                                                                                                                                                                                                                                                                                       | 2022 | C        |                               |\n| [GNPassGAN: improved generative adversarial networks for trawling offline password guessing](https://ieeexplore.ieee.org/abstract/document/9799343/)                                                                                                                                                                                                                      | 2022 | A        | [[GNPassGAN]]                 |\n| [PassDiff: A New Approach for Password Guessing Using Diffusion Model](https://link.springer.com/chapter/10.1007/978-981-99-9239-3_3)[阅读](https://books.google.co.jp/books?hl=zh-CN&lr&id=NjvsEAAAQBAJ&oi=fnd&pg=PA29&ots=MFKPmtXK-9&sig=Ea5MEWjfUDxwHsZPvrnk1jdnHo0&redir_esc=y&pli=1#v=onepage&q&f=false)<br>[代码](https://github.com/madaan/minimal-text-diffusion)<br> | 2023 |          | [[PassDiff]]                  |\n| [OneRuleToFindThem: Efficient Automated Generation of Password Cracking](https://dl.acm.org/doi/abs/10.5555/3636988.3637019)<br>自动生成密码规则                                                                                                                                                                                                                                  | 2023 |          |                               |\n| [A Systematic Review on Password Guessing Tasks](https://www.mdpi.com/1099-4300/25/9/1303)<br>密码生成的系统综述                                                                                                                                                                                                                                                                   | 2023 |          | [[AReview]]                   |\n| [Adaptive password guessing: learning language, nationality and dataset](https://link.springer.com/article/10.1007/s12243-023-00969-4)<br>自适应密码猜测                                                                                                                                                                                                                         | 2023 | 4区       |                               |\n| [SE# PCFG: Semantically Enhanced PCFG for Password Analysis and Cracking](https://arxiv.org/abs/2306.06824)<br>密码分析和破解语义的增强                                                                                                                                                                                                                                               | 2023 |          |                               |\n| [PassGPT: Password Modeling and (Guided) Generation with Large Language](https://arxiv.org/abs/2306.01545)                                                                                                                                                                                                                                                                | 2023 |          | [[PassGPT]]                   |\n| [A New Targeted Online Password Guessing Algorithm Based on Old Password](https://ieeexplore.ieee.org/abstract/document/10152712/)                                                                                                                                                                                                                                        | 2023 | B        |                               |\n| [Improving real-world password guessing attacks via bi-directional transformers](https://www.usenix.org/conference/usenixsecurity23/presentation/xu-ming)                                                                                                                                                                                                                 | 2023 | A        | [[PassBERT]]                  |\n| [Password and passphrase guessing with recurrent neural networks](https://link.springer.com/article/10.1007/s10796-022-10325-x)                                                                                                                                                                                                                                           | 2023 | (JCR:Q2) | [[Pass_RNN]]                  |\n| [Password guessing using random forest](https://www.usenix.org/system/files/sec23fall-prepub-183-wang-ding.pdf)<br>随机森林<br>[代码](https://github.com/PadishahIII/RFGuess)                                                                                                                                                                                                   | 2023 | A        | [[PASS_RF]]                   |\n| [PGTCN: A novel password-guessing model based on temporal convolution](https://www.sciencedirect.com/science/article/pii/S1084804523000115)                                                                                                                                                                                                                               | 2023 | C        |                               |\n| [Search-based Ordered Password Generation of Autoregressive Neural Networks](https://arxiv.org/abs/2403.09954)                                                                                                                                                                                                                                                            | 2024 | C        |                               |\n| [_GuessFuse_: Hybrid Password Guessing with Multi-View](https://ieeexplore.ieee.org/abstract/document/10466588/)                                                                                                                                                                                                                                                          | 2024 | A        | [[GuessFuse]]                 |\n\n\n\n\n## A Two-Decade Retrospective Analysis of a University’s Vulnerability to Attacks Exploiting Reused Passwords\n\n凭据猜测攻击通常会利用在用户在线帐户中重复使用的密码。为了了解组织如何更好地保护用户，我们回顾性分析了我们大学二十年来遭受凭据猜测攻击的脆弱性。给定一份大学用户名列表，我们从数百个网站和十几个大型泄露事件汇编中搜索了两个数据泄露事件中的匹配项。在破解哈希密码并调整猜测后，我们成功猜测了 32.0% 与数据泄露中的大学电子邮件地址匹配的帐户的密码，以及 6.5% 与用户名（但不一定是域名）匹配的帐户的密码。这些帐户中的许多帐户在被泄露的数据泄露后多年仍然容易受到攻击，并且在泄露中逐字发现的密码被利用的可能性（即观察到可疑的帐户活动）几乎是经过调整的猜测的四倍。超过 70 种不同的数据泄露和各种用户名匹配策略引导了正确的猜测。在对我们猜测密码的 40 名用户进行的调查中，许多用户没有意识到他们的大学帐户存在风险，或者他们的凭据已被泄露。对我们大学密码重用的分析为组织保护帐户提供了务实的建议。\n##  参考文章\n[使用 RNN(LSTMs) 生成密码](https://medium.com/@gsurma/password-cracker-generating-passwords-with-recurrent-neural-networks-lstms-9583714a3310)：[代码不全](https://github.com/gsurma/password_cracker)\n\n（1）\n（2）Generative Adversarial Networks can crack your password!\n（3）Password Cracker - Generating Passwords\n\n\n","slug":"研究方向/方向调研","published":1,"date":"2024-04-22T13:14:49.292Z","updated":"2024-04-18T01:44:37.390Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0g0013kgg4cbqr6kl8","content":"<p>论文调研旨在找到一个喜欢的方向并且实现小论文撰写，</p>\n<h1 id=\"ICDE-2023\"><a href=\"#ICDE-2023\" class=\"headerlink\" title=\"ICDE 2023\"></a>ICDE 2023</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>ICDE-2023共接收论文228篇，录用率在25%左右，研究方向统计如下：</p>\n<table>\n<thead>\n<tr>\n<th>方向</th>\n<th>子方向</th>\n<th>论文数量</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>图与网络</td>\n<td>图算法、图处理框架、图数据库、图神经网络、图分析、知识图谱</td>\n<td>69</td>\n</tr>\n<tr>\n<td>时空、轨迹数据分析</td>\n<td></td>\n<td>34</td>\n</tr>\n<tr>\n<td>AI4DB</td>\n<td>基数估计、查询优化、学习索引、NL2SQL、表格推理、工作负载预测、性能调优、数据库嵌入</td>\n<td>13</td>\n</tr>\n<tr>\n<td>数据库管理</td>\n<td>物化视图管理、工作负载分析、事务、死锁检测、数据库安全</td>\n<td>8</td>\n</tr>\n<tr>\n<td>存储</td>\n<td></td>\n<td>4</td>\n</tr>\n<tr>\n<td>查询、索引优化</td>\n<td></td>\n<td>18</td>\n</tr>\n<tr>\n<td>人工智能</td>\n<td>机器学习、深度学习、聚类、强化学习、在线学习</td>\n<td>25</td>\n</tr>\n<tr>\n<td>流处理</td>\n<td>-</td>\n<td>9</td>\n</tr>\n<tr>\n<td>数据挖掘与分析</td>\n<td>数据挖掘、数据压缩、推荐</td>\n<td>25</td>\n</tr>\n<tr>\n<td>边缘计算、区块链、物联网</td>\n<td>-</td>\n<td>11</td>\n</tr>\n<tr>\n<td>视频处理</td>\n<td>-</td>\n<td>2</td>\n</tr>\n<tr>\n<td>隐私保护、数据安全</td>\n<td>-</td>\n<td>4</td>\n</tr>\n<tr>\n<td>众包</td>\n<td>-</td>\n<td>6</td>\n</tr>\n</tbody></table>\n<h2 id=\"详情\"><a href=\"#详情\" class=\"headerlink\" title=\"详情\"></a>详情</h2><h3 id=\"图与网络\"><a href=\"#图与网络\" class=\"headerlink\" title=\"图与网络\"></a>图与网络</h3><table>\n<thead>\n<tr>\n<th>论文</th>\n<th>子方向</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>COCLEP: Contrastive Learning-based Semi-Supervised Community Search</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>FASI: FPGA-friendly Subgraph Isomorphism on Massive Graphs</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>HGMatch: A Match-by-Hyperedge Framework for Efficient and Parallel Subhypergraph Matching</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Layph: Making Change Propagation Constraint in Incremental Graph Processing by Layering Graph</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>LightTraffic: On Optimizing CPU-GPU Data Traffic for Efficient Large-scale Random Walks</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Lumos: Heterogeneity-aware Federated Graph Learning over Decentralized Devices</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>PSPC: Efficient Parallel Shortest Path Counting on Large-Scale Graphs</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>TDB: Breaking All Hop-Constrained Cycles in Billion-Scale Directed Graphs</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Finer-Grained Engagement in Hypergraphs</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Distributed (α, β)-Core Decomposition over Bipartite Graphs</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Fairness-aware Maximal Biclique Enumeration on Bipartite Graphs</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Index-Based Biclique Percolation Communities Search on Bipartite graphs</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Efficiently Answering Quality Constrained Shortest Distance Queries in Large Graphs</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Verification-Free Approaches to Efficient Locally Densest Subgraph Discovery</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Efficient Maximum Signed Biclique Identification</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Explainable Hyperlink Prediction: A Hypergraph Edit Distance-Based Approach</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Reinforcement Learning Enhanced Weighted Sampling for Accurate Subgraph Counting on Fully Dynamic Graph Streams</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Towards Efficient Shortest Path Counting on Billion-Scale Graphs</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Fair Group Summarization with Graph Patterns</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Top-r keyword-based community search in attributed graphs</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Accelerating k-Core Decomposition by a GPU</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Minimizing the Influence of Misinformation via Vertex Blocking</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Efficiently Sampling and Estimating Hypergraphs By Hybrid Random Walk</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Efficient Multi-GPU Graph Processing with Remote Work Stealing</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Neighborhood Skyline on Graphs: Concepts, Algorithms and Applications</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Finding Top-k Important Edges on Bipartite Graphs: Ego-betweenness Centrality-based Approaches</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>VC-dimension and Rademacher Averages of Subgraphs, with Applications to Graph Mining</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Most Probable Densest Subgraphs</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Scalable Algorithms for Densest Subgraph Discovery</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Distributed Near-Maximum Independent Set Maintenance over Large-scale Dynamic Graphs</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Fast Unsupervised Graph Embedding via Graph Zoom Learning</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Wind-Bell Index: Towards Ultra-Fast Relational Query for Graph Databases</td>\n<td>图数据库</td>\n<td>查询</td>\n</tr>\n<tr>\n<td>Hop-Constrained s-t Simple Path Enumeration on Large Dynamic Graphs</td>\n<td>图数据库</td>\n<td>查询</td>\n</tr>\n<tr>\n<td>A Reachability Index for Recursive Label-Concatenated Graph Queries</td>\n<td>图数据库</td>\n<td>索引</td>\n</tr>\n<tr>\n<td>VEND: Vertex Encoding for Edge Nonexistence Determination</td>\n<td>图数据库</td>\n<td></td>\n</tr>\n<tr>\n<td>Extracting Graphs Properties with Semantic Joins</td>\n<td>图数据库</td>\n<td></td>\n</tr>\n<tr>\n<td>Integrating Connection Search in Graph Queries</td>\n<td>图数据库</td>\n<td>查询</td>\n</tr>\n<tr>\n<td>AFaVS: Accurate Yet Fast Version Switching for Graph Processing Systems</td>\n<td>图处理系统</td>\n<td></td>\n</tr>\n<tr>\n<td>FLASH: A Framework for Programming Distributed Graph Processing Algorithms</td>\n<td>图处理系统</td>\n<td></td>\n</tr>\n<tr>\n<td>Partitioner Selection with EASE to Optimize Distributed Graph Processing</td>\n<td>图处理系统</td>\n<td></td>\n</tr>\n<tr>\n<td>Optimizing Graph Partition by Optimal Vertex-Cut: A Holistic Approach</td>\n<td>图处理系统</td>\n<td>图划分</td>\n</tr>\n<tr>\n<td>HyTGraph: GPU-Accelerated Graph Processing with Hybrid Transfer Management</td>\n<td>图处理系统</td>\n<td></td>\n</tr>\n<tr>\n<td>GAMMA: A Graph Pattern Mining Framework for Large Graphs on GPU</td>\n<td>图处理系统</td>\n<td>图模式挖掘</td>\n</tr>\n<tr>\n<td>HyGNN: Drug-Drug Interaction Prediction via Hypergraph Neural Network</td>\n<td>图神经网络</td>\n<td></td>\n</tr>\n<tr>\n<td>Demystifying Bitcoin Address Behavior via Graph Neural Networks</td>\n<td>图神经网络</td>\n<td></td>\n</tr>\n<tr>\n<td>Jointly Attacking Graph Neural Network and its Explanations</td>\n<td>图神经网络</td>\n<td></td>\n</tr>\n<tr>\n<td>Relational Temporal Graph Convolutional Networks for Ranking-Based Stock Prediction</td>\n<td>图神经网络</td>\n<td></td>\n</tr>\n<tr>\n<td>A Bayesian Graph Neural Network for EEG Classification — A Win-Win on Performance and Interpretability</td>\n<td>图神经网络</td>\n<td></td>\n</tr>\n<tr>\n<td>Layer-refined Graph Convolutional Networks for Recommendation</td>\n<td>图神经网络</td>\n<td></td>\n</tr>\n<tr>\n<td>AutoAC: Towards Automated Attribute Completion for Heterogeneous Graph Neural Network</td>\n<td>图神经网络</td>\n<td></td>\n</tr>\n<tr>\n<td>SEIGN: A Simple and Efficient Graph Neural Network for Large Dynamic Graphs</td>\n<td>图神经网络</td>\n<td></td>\n</tr>\n<tr>\n<td>Revisiting Citation Prediction with Cluster-Aware Text-Enhanced Heterogeneous Graph Neural Networks</td>\n<td>图神经网络</td>\n<td></td>\n</tr>\n<tr>\n<td>Towards Higher-order Topological Consistency for Unsupervised Network Alignment</td>\n<td>图神经网络</td>\n<td></td>\n</tr>\n<tr>\n<td>CLDG: Contrastive Learning on Dynamic Graphs</td>\n<td>图分析</td>\n<td></td>\n</tr>\n<tr>\n<td>GALE: Active Adversarial Learning for Erroneous Node Detection in Graphs</td>\n<td>图分析</td>\n<td></td>\n</tr>\n<tr>\n<td>IFCA: Index-Free Community-Aware Reachability Processing Over Large Dynamic Graphs</td>\n<td>图分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Unsupervised Graph Outlier Detection: Problem Revisit, New Insight, and Superior Method</td>\n<td>图分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Efficient and Compact Spreadsheet Formula Graphs</td>\n<td>图分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Inconsistency Detection with Temporal Graph Functional Dependencies</td>\n<td>图分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Keyword-based Socially Tenuous Group Queries</td>\n<td>图分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Community Search: A Meta-Learning Approach</td>\n<td>图分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Dynamic Activation of Clients and Parameters for Federated Learning over Heterogeneous Graphs</td>\n<td>图分析</td>\n<td></td>\n</tr>\n<tr>\n<td>RETIA: Relation-Entity Twin-Interact Aggregation for Temporal Knowledge Graph Extrapolation</td>\n<td>知识图谱</td>\n<td></td>\n</tr>\n<tr>\n<td>Disconnected Emerging Knowledge Graph Oriented Inductive Link Prediction</td>\n<td>知识图谱</td>\n<td></td>\n</tr>\n<tr>\n<td>Relational Message Passing for Fully Inductive Knowledge Graph Completion</td>\n<td>知识图谱</td>\n<td></td>\n</tr>\n<tr>\n<td>MMKGR: Multi-hop Multi-modal Knowledge Graph Reasoning</td>\n<td>知识图谱</td>\n<td></td>\n</tr>\n<tr>\n<td>Robust Attributed Graph Alignment via Joint Structure Learning and Optimal Transpor</td>\n<td>知识图谱</td>\n<td></td>\n</tr>\n<tr>\n<td>Multimodal Biological Knowledge Graph Completion via Triple Co-attention Mechanism</td>\n<td>知识图谱</td>\n<td></td>\n</tr>\n<tr>\n<td>A Holistic Approach for Answering Logical Queries on Knowledge Graphs</td>\n<td>知识图谱</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"时空、轨迹数据分析\"><a href=\"#时空、轨迹数据分析\" class=\"headerlink\" title=\"时空、轨迹数据分析\"></a>时空、轨迹数据分析</h3><table>\n<thead>\n<tr>\n<th>论文</th>\n<th>子方向</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>TSC-AutoML: Meta-learning for automatic Time Series Classification Algorithm Selection</td>\n<td>时空数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>TSEXPLAIN: Explaining Aggregated Time Series by Surfacing Evolving Contributors</td>\n<td>时空数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Towards Long-Term Time-Series Forecasting: Feature, Pattern, and Distribution</td>\n<td>时空数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>PriSTI: A Conditional Diffusion Framework for Spatiotemporal Imputation</td>\n<td>时空数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>REncoder: A Space-Time Efficient Range Filter with Local Encoder</td>\n<td>时空数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>ROI-demand Traffic Prediction: A Pre-train, Query and Fine-tune Framework</td>\n<td>时空数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>When Spatio-Temporal Meet Wavelets: Disentangled Traffic Forecasting via Efficient Spectral Graph Attention Networks</td>\n<td>时空数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Discovering Frequency Bursting Patterns in Temporal Graphs</td>\n<td>时空数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Matrix Factorization with Landmarks for Spatial Data</td>\n<td>时空数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Uncertainty Quantification for Traffic Forecasting: A Unified Approach</td>\n<td>时空数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Extreme-Aware Local-Global Attention for Spatio-Temporal Urban Mobility Learning</td>\n<td>时空数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Mining Seasonal Temporal Patterns in Time Series</td>\n<td>时空数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>A Stitch in Time Saves Nine: Enabling Early Anomaly Detection with Correlation Analysis</td>\n<td>时空数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Self-Supervised Spatial-Temporal Bottleneck Attentive Network for Efﬁcient Long-term Trafﬁc Forecasting</td>\n<td>时空数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>namic Hypergraph Structure Learning for Traffic Flow Forecasting</td>\n<td>时空数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Forecasting COVID-19 Dynamics: Clustering, Generalized Spatiotemporal Attention, and Impacts of Mobility and Geographic Proximity</td>\n<td>时空数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Double Hierarchical Labeling Shortest Distance Querying in Time-dependent Road Networks</td>\n<td>时空数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>BERT-Trip: Effective and Scalable Trip Representation using Attentive Contrast Learning</td>\n<td>轨迹数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>LHMM: A Learning Enhanced HMM Model for Cellular Trajectory Map-matching</td>\n<td>轨迹数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Contrastive Trajectory Similarity Learning with Dual-Feature Attention</td>\n<td>轨迹数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Online Anomalous Subtrajectory Detection on Road Networks with Deep Reinforcement Learning</td>\n<td>轨迹数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Towards Efficient MIT query in Trajectory Data</td>\n<td>轨迹数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>A Lightweight Framework for Fast Trajectory Simplification</td>\n<td>轨迹数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Self-supervised Trajectory Representation Learning with Temporal Regularities and Travel Semantics</td>\n<td>轨迹数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>RNTrajRec: Road Network Enhanced Trajectory Recovery with Spatial-Temporal Transformer</td>\n<td>轨迹数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Collision-Aware Route Planning in Warehouses Made Efficient: A Strip-based Framework</td>\n<td>轨迹数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Efficient Public Transport Planning on Roads</td>\n<td>轨迹数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Reinforcement Learning based Tree Decomposition for Distance Querying in Road Networks</td>\n<td>路网分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Global Routing Optimization In Road Networks</td>\n<td>路网分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Experimental Evaluation of Indexing Techniques for Shortest Distance Queries on Road Networks</td>\n<td>路网分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Finding Top-k Optimal Routes with Collective Spatial Keywords on Road Networks</td>\n<td>路网分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Data Imputation for Sparse Radio Maps in Indoor Positioning</td>\n<td>地理信息分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Semi-supervised Learning with Network Embedding on Ambient RF Signals for Geofencing Services</td>\n<td>地理信息分析</td>\n<td></td>\n</tr>\n<tr>\n<td>A Contextual Master-Slave Framework on Urban Region Graph for Urban Village Detection</td>\n<td>地理信息分析</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"Ai4DB\"><a href=\"#Ai4DB\" class=\"headerlink\" title=\"Ai4DB\"></a>Ai4DB</h3><table>\n<thead>\n<tr>\n<th>论文</th>\n<th>子方向</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AutoCE: An Accurate and Efficient Model Advisor for Learned Cardinality Estimation</td>\n<td>基数估计</td>\n<td></td>\n</tr>\n<tr>\n<td>Couper: Memory-Efficient Cardinality Estimation under Unbalanced Distribution</td>\n<td>基数估计</td>\n<td></td>\n</tr>\n<tr>\n<td>Dynamic Materialized View Management using Graph Neural Network</td>\n<td>查询优化</td>\n<td>物化视图、图神经网络</td>\n</tr>\n<tr>\n<td>Efficient Deep Ensemble Inference via Query Difficulty-dependent Task Scheduling</td>\n<td>查询优化</td>\n<td></td>\n</tr>\n<tr>\n<td>GAR: A Generate-and-Rank Approach for Natural Language to SQL Translation</td>\n<td>NL2SQL</td>\n<td></td>\n</tr>\n<tr>\n<td>Efficiently Learning Spatial Indices</td>\n<td>学习索引</td>\n<td></td>\n</tr>\n<tr>\n<td>Towards Optimizing Storage Costs on the Cloud</td>\n<td>存储</td>\n<td></td>\n</tr>\n<tr>\n<td>Data Ambiguity Profiling for the Generation of Training Examples</td>\n<td>NL2SQL</td>\n<td></td>\n</tr>\n<tr>\n<td>Towards Explainable Table Interpretation Using Multi-view Explanations</td>\n<td>表解释</td>\n<td></td>\n</tr>\n<tr>\n<td>Toward a Unified Framework for Unsupervised Complex Tabular Reasoning</td>\n<td>表格推理</td>\n<td></td>\n</tr>\n<tr>\n<td>DBAugur: An Adversarial-based Trend Forecasting System for Diversified Workloads</td>\n<td>工作负载预测</td>\n<td></td>\n</tr>\n<tr>\n<td>Active Sampling for Sparse Table by Bayesian Optimization with Adaptive Resolution</td>\n<td>性能调优</td>\n<td></td>\n</tr>\n<tr>\n<td>Stable Tuple Embeddings for Dynamic Databases</td>\n<td>数据库嵌入</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"数据库管理\"><a href=\"#数据库管理\" class=\"headerlink\" title=\"数据库管理\"></a>数据库管理</h3><table>\n<thead>\n<tr>\n<th>论文</th>\n<th>子方向</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>S&#x2F;C: Speeding up Data Materialization with Bounded Memory</td>\n<td>物化视图</td>\n<td></td>\n</tr>\n<tr>\n<td>Co-Utilizing SIMD and Scalar to Accelerate the Data Analytics Workloads</td>\n<td>工作负载分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Leopard: A Black-Box Approach for Efficiently Verifying Various Isolation Levels</td>\n<td>事务</td>\n<td></td>\n</tr>\n<tr>\n<td>Knock Out 2PC with Practicality Intact: a High-performance and General Distributed Transaction Protocol</td>\n<td>事务</td>\n<td></td>\n</tr>\n<tr>\n<td>Database Deadlock Diagnosis for Large-scale ORM-based Web Applications</td>\n<td>死锁检测</td>\n<td></td>\n</tr>\n<tr>\n<td>LCL: A Lock Chain Length-based Distributed Algorithm for Deadlock Detection and Resolution</td>\n<td>死锁检测</td>\n<td></td>\n</tr>\n<tr>\n<td>Sequence-Oriented DBMS Fuzzing</td>\n<td>数据库安全</td>\n<td></td>\n</tr>\n<tr>\n<td>DBCatcher: A Cloud Database Online Anomaly Detection System based on Indicator Correlatio</td>\n<td>数据库安全</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"存储、LSM-Tree\"><a href=\"#存储、LSM-Tree\" class=\"headerlink\" title=\"存储、LSM Tree\"></a>存储、LSM Tree</h3><table>\n<thead>\n<tr>\n<th>论文</th>\n<th>子方向</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ACEing the Bufferpool Management Paradigm for Modern Storage Devices</td>\n<td>存储</td>\n<td></td>\n</tr>\n<tr>\n<td>Redesigning High-Performance LSM-based Key-Value Stores with Persistent CPU Caches</td>\n<td>存储</td>\n<td></td>\n</tr>\n<tr>\n<td>Workload-Aware Log-Structured Merge Key-Value Store for NVM-SSD Hybrid Storage</td>\n<td>存储</td>\n<td></td>\n</tr>\n<tr>\n<td>Real-Time LSM-Trees for HTAP Workloads</td>\n<td>LSM Tree</td>\n<td>适用于 HTAP 工作负载的实时 LSM 树</td>\n</tr>\n</tbody></table>\n<h3 id=\"查询、索引优化\"><a href=\"#查询、索引优化\" class=\"headerlink\" title=\"查询、索引优化\"></a>查询、索引优化</h3><table>\n<thead>\n<tr>\n<th>论文</th>\n<th>子方向</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ADAMANT: A Query Executor with Plug-In Interfaces for Easy Co-processor Integration</td>\n<td>查询</td>\n<td></td>\n</tr>\n<tr>\n<td>Skyline Micro-Cluster Query: A Novel and Practical Spatial Query</td>\n<td>查询</td>\n<td></td>\n</tr>\n<tr>\n<td>Ver: View Discovery in the Wild</td>\n<td>查询</td>\n<td></td>\n</tr>\n<tr>\n<td>EulerFD: An Efficient Double-Cycle Approximation of Functional Dependencies</td>\n<td>查询</td>\n<td></td>\n</tr>\n<tr>\n<td>Finding Best Tuple via Error-prone User Interaction</td>\n<td>查询</td>\n<td></td>\n</tr>\n<tr>\n<td>KOIOS: Top-k Semantic Overlap Set Search</td>\n<td>查询</td>\n<td></td>\n</tr>\n<tr>\n<td>Complete Join Reordering for Null-Intolerant Joins</td>\n<td>查询</td>\n<td></td>\n</tr>\n<tr>\n<td>Efficiently Answering Top-k Window Aggregate Queries: Calculating Coverage Number Sequences over Hierarchical Structures</td>\n<td>查询</td>\n<td></td>\n</tr>\n<tr>\n<td>On Explaining Confounding Bias</td>\n<td>查询</td>\n<td></td>\n</tr>\n<tr>\n<td>MetricJoin: Leveraging Metric Properties for Robust Exact Set Similarity Joins</td>\n<td>查询</td>\n<td></td>\n</tr>\n<tr>\n<td>Selecting Sub-tables for Data Exploration</td>\n<td>查询</td>\n<td></td>\n</tr>\n<tr>\n<td>In-Situ Cross-Database Query Processing</td>\n<td>查询</td>\n<td></td>\n</tr>\n<tr>\n<td>These Rows Are Made for Sorting and That’s Just What We’ll Do</td>\n<td>查询</td>\n<td></td>\n</tr>\n<tr>\n<td>JanusAQP: Efficient Partition Tree Maintenance for Dynamic Approximate Query Processing</td>\n<td>查询</td>\n<td></td>\n</tr>\n<tr>\n<td>dLSM: An LSM-Based Index for Memory Disaggregation</td>\n<td>索引</td>\n<td></td>\n</tr>\n<tr>\n<td>Cutting Learned Index into Pieces: An In-depth Inquiry into Updatable Learned Indexes</td>\n<td>索引</td>\n<td></td>\n</tr>\n<tr>\n<td>Indexing for Near-Sorted Data</td>\n<td>索引</td>\n<td></td>\n</tr>\n<tr>\n<td>EEPH: An Efficient Extendible Perfect Hashing for Hybrid PMem-DRAM</td>\n<td>索引</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"人工智能\"><a href=\"#人工智能\" class=\"headerlink\" title=\"人工智能\"></a>人工智能</h3><table>\n<thead>\n<tr>\n<th>论文</th>\n<th>子方向</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Fed-SC: One-Shot Federated Subspace Clustering over High-Dimensional Data</td>\n<td>聚类</td>\n<td></td>\n</tr>\n<tr>\n<td>Parallel Filtered Graphs for Hierarchical Clustering</td>\n<td>聚类</td>\n<td></td>\n</tr>\n<tr>\n<td>Efficient Augmentation for Imbalanced Deep Learning</td>\n<td>深度学习</td>\n<td></td>\n</tr>\n<tr>\n<td>Pricing Prediction Services for Profit Maximization with Incomplete Information</td>\n<td>深度学习</td>\n<td></td>\n</tr>\n<tr>\n<td>Detection of Groups With Biased Representation in Ranking</td>\n<td>深度学习</td>\n<td></td>\n</tr>\n<tr>\n<td>The Art of Losing to Win: Using Lossy Image Compression to Improve Data Loading in Deep Learning Pipelines</td>\n<td>深度学习</td>\n<td></td>\n</tr>\n<tr>\n<td>Opponent-aware Order Pricing towards Hub-oriented Mobility Services</td>\n<td>深度学习</td>\n<td></td>\n</tr>\n<tr>\n<td>Rotary: A Resource Arbitration Framework for Progressive Iterative Analytics</td>\n<td>深度学习</td>\n<td></td>\n</tr>\n<tr>\n<td>Sudowoodo: Contrastive Self-supervised Learning for Multi-purpose Data Integration and Preparation</td>\n<td>深度学习</td>\n<td></td>\n</tr>\n<tr>\n<td>ENLD: Efficient Noisy Label Detection for Incremental Datasets in Data Lake ENLD：数据湖中增量数据集的高效噪声标签检测</td>\n<td>深度学习</td>\n<td></td>\n</tr>\n<tr>\n<td>Improving Progressive Retrieval for HPC Scientific Data using Deep Neural Network</td>\n<td>深度学习</td>\n<td></td>\n</tr>\n<tr>\n<td>Lightweight-Yet-Efficient: Revitalizing Ball-Tree for Point-to-Hyperplane Nearest Neighbor Search</td>\n<td>机器学习</td>\n<td></td>\n</tr>\n<tr>\n<td>Automatic Feasibility Study via Data Quality Analysis for ML: A Case-Study on Label Noise</td>\n<td>机器学习</td>\n<td></td>\n</tr>\n<tr>\n<td>A Hierarchical Approach to Anomalous Subgroup Discovery</td>\n<td>机器学习</td>\n<td></td>\n</tr>\n<tr>\n<td>Metam: Goal-Oriented Data Discovery</td>\n<td>机器学习</td>\n<td></td>\n</tr>\n<tr>\n<td>Dynamic Shapley Value Computation</td>\n<td>机器学习</td>\n<td></td>\n</tr>\n<tr>\n<td>SK-Gradient: Efficient Communication for Distributed Machine Learning with Data Sketch</td>\n<td>机器学习</td>\n<td>分布式机器学习</td>\n</tr>\n<tr>\n<td>Distribution-Regularized Federated Learning on Non-IID Data</td>\n<td>机器学习</td>\n<td>分布式机器学习</td>\n</tr>\n<tr>\n<td>Orchestrating Large-Scale SpGEMMs using Dynamic Block Distribution and Data Transfer Minimization on Heterogeneous Systems</td>\n<td>机器学习</td>\n<td>分布式机器学习</td>\n</tr>\n<tr>\n<td>Enhancing Decentralized Federated Learning for Non-IID Data on Heterogenous Devices</td>\n<td>机器学习</td>\n<td>分布式机器学习</td>\n</tr>\n<tr>\n<td>Toward Efficient Automated Feature Engineering</td>\n<td>特征工程</td>\n<td></td>\n</tr>\n<tr>\n<td>PA-FEAT: Fast Feature Selection for Structured Data via Progress-Aware Multi-Task Deep Reinforcement Learning</td>\n<td>强化学习</td>\n<td></td>\n</tr>\n<tr>\n<td>Discovering Editing Rules by Deep Reinforcement Learning</td>\n<td>强化学习</td>\n<td></td>\n</tr>\n<tr>\n<td>Schema Matching using Pre-Trained Language Models</td>\n<td>NLP</td>\n<td></td>\n</tr>\n<tr>\n<td>Online Pricing Strategy Achieving Vanishing Regret for Shipping Container Pricing with Limited Inventory</td>\n<td>在线学习</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"流处理\"><a href=\"#流处理\" class=\"headerlink\" title=\"流处理\"></a>流处理</h3><table>\n<thead>\n<tr>\n<th>论文</th>\n<th>子方向</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CompressStreamDB: Fine-Grained Adaptive Stream Processing without Decompression</td>\n<td>流处理</td>\n<td></td>\n</tr>\n<tr>\n<td>HistSketch: A Compact Data Structure for Accurate Per-Key Distribution Monitoring</td>\n<td>流处理</td>\n<td></td>\n</tr>\n<tr>\n<td>HyperCalm Sketch: One-Pass Mining Periodic Batches in Data Streams</td>\n<td>流处理</td>\n<td></td>\n</tr>\n<tr>\n<td>RADAR: Reactive Concept Drift Management with Robust Variational Inference for Evolving IoT Data Streams</td>\n<td>流处理</td>\n<td></td>\n</tr>\n<tr>\n<td>SASPAR: Shared Adaptive Stream Partitioning</td>\n<td>流处理</td>\n<td></td>\n</tr>\n<tr>\n<td>SketchConf: A Framework for Automatic Sketch Configuration</td>\n<td>流处理</td>\n<td></td>\n</tr>\n<tr>\n<td>Parallelizing Stream Compression for IoT Applications on Asymmetric Multicores</td>\n<td>流处理</td>\n<td></td>\n</tr>\n<tr>\n<td>Globally Aware Contextual Embeddings for Named Entity Recognition in Social Media Streams</td>\n<td>流处理</td>\n<td></td>\n</tr>\n<tr>\n<td>Finding Simplex Items in Data Streams</td>\n<td>流处理</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"数据分析与挖掘\"><a href=\"#数据分析与挖掘\" class=\"headerlink\" title=\"数据分析与挖掘\"></a>数据分析与挖掘</h3><table>\n<thead>\n<tr>\n<th>论文</th>\n<th>子方向</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>IndiBits: Incremental Discovery of Relaxed Functional Dependencies using Bitwise Similarity</td>\n<td>数据挖掘</td>\n<td></td>\n</tr>\n<tr>\n<td>UADB: Unsupervised Anomaly Detection Booster</td>\n<td>数据挖掘</td>\n<td></td>\n</tr>\n<tr>\n<td>Learn to Explore: on Bootstrapping Interactive Data Exploration with Meta-learning</td>\n<td>数据挖掘</td>\n<td></td>\n</tr>\n<tr>\n<td>Efficient Parallel Mining of High-utility Itemsets on Multicore Processors</td>\n<td>数据挖掘</td>\n<td></td>\n</tr>\n<tr>\n<td>Benchmarking Filtering Techniques for Entity Resolution</td>\n<td>数据挖掘</td>\n<td></td>\n</tr>\n<tr>\n<td>Voting-based Opinion Maximization</td>\n<td>数据挖掘</td>\n<td></td>\n</tr>\n<tr>\n<td>Interactive Search with Mixed Attributes</td>\n<td>数据挖掘</td>\n<td></td>\n</tr>\n<tr>\n<td>Planning Data Poisoning Attacks on Heterogeneous Recommender Systems in a Multiplayer Setting</td>\n<td>数据挖掘</td>\n<td></td>\n</tr>\n<tr>\n<td>A Feature-Driven Fixed-Ratio Lossy Compression Framework for Real-World Scientific Datasets</td>\n<td>数据压缩</td>\n<td></td>\n</tr>\n<tr>\n<td>Neural Node Matching for Multi-Target Cross Domain Recommendation</td>\n<td>推荐</td>\n<td></td>\n</tr>\n<tr>\n<td>Incremental Learning for Multi-Interest Sequential Recommendation</td>\n<td>推荐</td>\n<td></td>\n</tr>\n<tr>\n<td>Disentangled Graph Social Recommendation</td>\n<td>推荐</td>\n<td></td>\n</tr>\n<tr>\n<td>Group Buying Recommendation Model Based on Multi-task Learning</td>\n<td>推荐</td>\n<td>多任务学习</td>\n</tr>\n<tr>\n<td>Probabilistic Majority Rule-Based Group Recommendation</td>\n<td>推荐</td>\n<td></td>\n</tr>\n<tr>\n<td>Sequential Recommendation with User Causal Behavior Discovery</td>\n<td>推荐</td>\n<td></td>\n</tr>\n<tr>\n<td>Towards Capacity-Aware Broker Matching: From Recommendation to Assignment</td>\n<td>推荐</td>\n<td></td>\n</tr>\n<tr>\n<td>Visualization Recommendation Through Visual Relation Learning and Visual Preference Learning</td>\n<td>推荐</td>\n<td></td>\n</tr>\n<tr>\n<td>Personalized Diversification for Neural Re-ranking in Recommendation</td>\n<td>推荐</td>\n<td></td>\n</tr>\n<tr>\n<td>A Competition-Aware Approach to Accurate TV Show Recommendation</td>\n<td>推荐</td>\n<td></td>\n</tr>\n<tr>\n<td>Intent-aware Multi-source Contrastive Alignment for Tag-enhanced Recommendation</td>\n<td>推荐</td>\n<td></td>\n</tr>\n<tr>\n<td>Instant Representation Learning for Recommendation over Large Dynamic Graphs</td>\n<td>推荐</td>\n<td></td>\n</tr>\n<tr>\n<td>A Generic Reinforced Explainable Framework with Knowledge Graph for Session-based Recommendation</td>\n<td>推荐</td>\n<td></td>\n</tr>\n<tr>\n<td>Contrastive Enhanced Slide Filter Mixer for Sequential Recommendation</td>\n<td>推荐</td>\n<td></td>\n</tr>\n<tr>\n<td>Bayesian Negative Sampling for Recommendation</td>\n<td>推荐</td>\n<td></td>\n</tr>\n<tr>\n<td>Influential Recommender System</td>\n<td>推荐</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"边缘计算、区块链、物联网\"><a href=\"#边缘计算、区块链、物联网\" class=\"headerlink\" title=\"边缘计算、区块链、物联网\"></a>边缘计算、区块链、物联网</h3><table>\n<thead>\n<tr>\n<th>论文</th>\n<th>子方向</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>EdgeNN: Efficient Neural Network Inference for CPU-GPU Integrated Edge Devices</td>\n<td>边缘计算</td>\n<td></td>\n</tr>\n<tr>\n<td>FedKNOW: Federated Continual Learning with Signature Task Knowledge Integration at Edge</td>\n<td>边缘计算</td>\n<td></td>\n</tr>\n<tr>\n<td>Reliable Transactions in Serverless-Edge Architecture</td>\n<td>边缘计算</td>\n<td></td>\n</tr>\n<tr>\n<td>Ziziphus: Scalable Data Management Across Byzantine Edge Servers</td>\n<td>边缘计算</td>\n<td></td>\n</tr>\n<tr>\n<td>Saguaro: An Edge Computing-Enabled Hierarchical Permissioned Blockchain</td>\n<td>边缘计算 、区块链</td>\n<td></td>\n</tr>\n<tr>\n<td>SChain: Scalable Concurrency over Flexible Permissioned Blockchain</td>\n<td>区块链</td>\n<td></td>\n</tr>\n<tr>\n<td>TxAllo: Dynamic Transaction Allocation in Sharded Blockchain Systems</td>\n<td>区块链</td>\n<td></td>\n</tr>\n<tr>\n<td>On Sharding Across Heterogeneous Blockchains</td>\n<td>区块链</td>\n<td></td>\n</tr>\n<tr>\n<td>Scaling Blockchain Consensus via a Robust Shared Mempool</td>\n<td>区块链</td>\n<td></td>\n</tr>\n<tr>\n<td>Non-Blocking Raft for High Throughput IoT Data</td>\n<td>物联网</td>\n<td></td>\n</tr>\n<tr>\n<td>Federated IoT Interaction Vulnerability Analysis</td>\n<td>物联网</td>\n<td>漏洞分析</td>\n</tr>\n</tbody></table>\n<h3 id=\"视频处理\"><a href=\"#视频处理\" class=\"headerlink\" title=\"视频处理\"></a>视频处理</h3><table>\n<thead>\n<tr>\n<th>论文</th>\n<th>子方向</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Marshalling Model Inference In Video Streams</td>\n<td>视频处理</td>\n<td></td>\n</tr>\n<tr>\n<td>Track Merging for Effective Video Query Processing</td>\n<td>视频处理</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"隐私保护\"><a href=\"#隐私保护\" class=\"headerlink\" title=\"隐私保护\"></a>隐私保护</h3><table>\n<thead>\n<tr>\n<th>论文</th>\n<th>子方向</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Dynamic Private Task Assignment under Differential Privacy</td>\n<td>隐私保护</td>\n<td></td>\n</tr>\n<tr>\n<td>Differential Aggregation against General Colluding Attackers</td>\n<td>隐私保护</td>\n<td></td>\n</tr>\n<tr>\n<td>KVSAgg: Secure Aggregation of Distributed Key-Value Sets</td>\n<td>隐私保护</td>\n<td></td>\n</tr>\n<tr>\n<td>PrivNUD: Effective Range Query Processing under Local Differential Privacy</td>\n<td>隐私保护</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"众包\"><a href=\"#众包\" class=\"headerlink\" title=\"众包\"></a>众包</h3><table>\n<thead>\n<tr>\n<th>论文</th>\n<th>子方向</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Air-Ground Spatial Crowdsourcing with UAV Carriers by Geometric Graph Convolutional Multi-Agent Deep Reinforcement Learning</td>\n<td>众包</td>\n<td></td>\n</tr>\n<tr>\n<td>Efficient Cross Dynamic Task Assignment in Spatial Crowdsourcing</td>\n<td>众包</td>\n<td></td>\n</tr>\n<tr>\n<td>Batch-Based Cooperative Task Assignment in Spatial Crowdsourcing</td>\n<td>众包</td>\n<td></td>\n</tr>\n<tr>\n<td>Exploring both Individuality and Cooperation for Air-Ground Spatial Crowdsourcing by Multi-Agent Deep Reinforcement Learning</td>\n<td>众包</td>\n<td></td>\n</tr>\n<tr>\n<td>Hierarchical Crowdsourcing for Data Labeling with Heterogeneous Crowd</td>\n<td>众包</td>\n<td></td>\n</tr>\n<tr>\n<td>Learning from Noisy Crowd Labels with Logics 从喧闹的人群标签中学习逻辑</td>\n<td>众包</td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"密码生成\"><a href=\"#密码生成\" class=\"headerlink\" title=\"密码生成\"></a>密码生成</h1><h2 id=\"介绍-1\"><a href=\"#介绍-1\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>关于口令生成的方向调研</p>\n<h2 id=\"个人总结\"><a href=\"#个人总结\" class=\"headerlink\" title=\"个人总结\"></a>个人总结</h2><p>[[方向：密码生成]]</p>\n<h2 id=\"安全一流会议\"><a href=\"#安全一流会议\" class=\"headerlink\" title=\"安全一流会议\"></a>安全一流会议</h2><p>S&amp;P、CCS、NDSS、USENIX Conference、IEEE tDSC</p>\n<h2 id=\"详情-1\"><a href=\"#详情-1\" class=\"headerlink\" title=\"详情\"></a>详情</h2><table>\n<thead>\n<tr>\n<th>论文</th>\n<th>时间</th>\n<th>级别</th>\n<th>笔记</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>GENPass: A General Deep Learning Model for Password Guessing with PCFG Rules and Adversarial Generation</td>\n<td>2018</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://link.springer.com/chapter/10.1007/978-3-030-21568-2_11\">PassGAN: A Deep Learning Approach to Password Guessing</a><br><a href=\"https://github.com/brannondorsey/PassGAN\">代码</a><br><a href=\"https://github.com/ponedo/rnnPassGAN-password-cracking\">改进代码</a></td>\n<td>2019</td>\n<td></td>\n<td>[[PassGAN]]</td>\n</tr>\n<tr>\n<td><a href=\"https://www.mdpi.com/1424-8220/20/11/3106\">Recurrent gans password cracker for iot password security enhancement</a></td>\n<td>2019</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://iopscience.iop.org/article/10.1088/1742-6596/1631/1/012161/pdf\">Research on Password Cracking Technology Based on Improved Transformer</a></td>\n<td>2020</td>\n<td></td>\n<td>[[Pass improved Transformer]]</td>\n</tr>\n<tr>\n<td><a href=\"https://www.mdpi.com/2076-3417/10/20/7306\">Generating optimized guessing candidates toward better password cracking from multi-dictionaries using relativistic GAN</a></td>\n<td>2020</td>\n<td>三区</td>\n<td>[[REDPACK]]</td>\n</tr>\n<tr>\n<td><a href=\"https://link.springer.com/chapter/10.1007/978-3-030-93206-0_18\">Densegan: A password <strong>guessing model based</strong> on <strong>densenet</strong> and <strong>passgan</strong></a></td>\n<td>2021</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://www.mdpi.com/2076-3417/11/10/4607\">Dynamic Markov Model: Password Guessing Using Probability Adjustment</a></td>\n<td>2021</td>\n<td>C</td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://dl.acm.org/doi/abs/10.1145/3448608\">A large-scale analysis of the semantic password model and linguistic patterns in passwords</a>综述</td>\n<td>2021</td>\n<td>B</td>\n<td>[[语义密码模型和密码语言模式分析]]</td>\n</tr>\n<tr>\n<td><a href=\"https://www.mdpi.com/1424-8220/22/12/4604\">LPG–PCFG: an improved probabilistic context-free grammar to hit low-probability passwords</a></td>\n<td>2022</td>\n<td>C</td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://arxiv.org/abs/2208.10413\">On deep learning in password guessing, a survey</a></td>\n<td>2022</td>\n<td>C</td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://ieeexplore.ieee.org/abstract/document/9799343/\">GNPassGAN: improved generative adversarial networks for trawling offline password guessing</a></td>\n<td>2022</td>\n<td>A</td>\n<td>[[GNPassGAN]]</td>\n</tr>\n<tr>\n<td><a href=\"https://link.springer.com/chapter/10.1007/978-981-99-9239-3_3\">PassDiff: A New Approach for Password Guessing Using Diffusion Model</a><a href=\"https://books.google.co.jp/books?hl=zh-CN&lr&id=NjvsEAAAQBAJ&oi=fnd&pg=PA29&ots=MFKPmtXK-9&sig=Ea5MEWjfUDxwHsZPvrnk1jdnHo0&redir_esc=y&pli=1#v=onepage&q&f=false\">阅读</a><br><a href=\"https://github.com/madaan/minimal-text-diffusion\">代码</a><br></td>\n<td>2023</td>\n<td></td>\n<td>[[PassDiff]]</td>\n</tr>\n<tr>\n<td><a href=\"https://dl.acm.org/doi/abs/10.5555/3636988.3637019\">OneRuleToFindThem: Efficient Automated Generation of Password Cracking</a><br>自动生成密码规则</td>\n<td>2023</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://www.mdpi.com/1099-4300/25/9/1303\">A Systematic Review on Password Guessing Tasks</a><br>密码生成的系统综述</td>\n<td>2023</td>\n<td></td>\n<td>[[AReview]]</td>\n</tr>\n<tr>\n<td><a href=\"https://link.springer.com/article/10.1007/s12243-023-00969-4\">Adaptive password guessing: learning language, nationality and dataset</a><br>自适应密码猜测</td>\n<td>2023</td>\n<td>4区</td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://arxiv.org/abs/2306.06824\">SE# PCFG: Semantically Enhanced PCFG for Password Analysis and Cracking</a><br>密码分析和破解语义的增强</td>\n<td>2023</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://arxiv.org/abs/2306.01545\">PassGPT: Password Modeling and (Guided) Generation with Large Language</a></td>\n<td>2023</td>\n<td></td>\n<td>[[PassGPT]]</td>\n</tr>\n<tr>\n<td><a href=\"https://ieeexplore.ieee.org/abstract/document/10152712/\">A New Targeted Online Password Guessing Algorithm Based on Old Password</a></td>\n<td>2023</td>\n<td>B</td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://www.usenix.org/conference/usenixsecurity23/presentation/xu-ming\">Improving real-world password guessing attacks via bi-directional transformers</a></td>\n<td>2023</td>\n<td>A</td>\n<td>[[PassBERT]]</td>\n</tr>\n<tr>\n<td><a href=\"https://link.springer.com/article/10.1007/s10796-022-10325-x\">Password and passphrase guessing with recurrent neural networks</a></td>\n<td>2023</td>\n<td>(JCR:Q2)</td>\n<td>[[Pass_RNN]]</td>\n</tr>\n<tr>\n<td><a href=\"https://www.usenix.org/system/files/sec23fall-prepub-183-wang-ding.pdf\">Password guessing using random forest</a><br>随机森林<br><a href=\"https://github.com/PadishahIII/RFGuess\">代码</a></td>\n<td>2023</td>\n<td>A</td>\n<td>[[PASS_RF]]</td>\n</tr>\n<tr>\n<td><a href=\"https://www.sciencedirect.com/science/article/pii/S1084804523000115\">PGTCN: A novel password-guessing model based on temporal convolution</a></td>\n<td>2023</td>\n<td>C</td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://arxiv.org/abs/2403.09954\">Search-based Ordered Password Generation of Autoregressive Neural Networks</a></td>\n<td>2024</td>\n<td>C</td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://ieeexplore.ieee.org/abstract/document/10466588/\"><em>GuessFuse</em>: Hybrid Password Guessing with Multi-View</a></td>\n<td>2024</td>\n<td>A</td>\n<td>[[GuessFuse]]</td>\n</tr>\n</tbody></table>\n<h2 id=\"A-Two-Decade-Retrospective-Analysis-of-a-University’s-Vulnerability-to-Attacks-Exploiting-Reused-Passwords\"><a href=\"#A-Two-Decade-Retrospective-Analysis-of-a-University’s-Vulnerability-to-Attacks-Exploiting-Reused-Passwords\" class=\"headerlink\" title=\"A Two-Decade Retrospective Analysis of a University’s Vulnerability to Attacks Exploiting Reused Passwords\"></a>A Two-Decade Retrospective Analysis of a University’s Vulnerability to Attacks Exploiting Reused Passwords</h2><p>凭据猜测攻击通常会利用在用户在线帐户中重复使用的密码。为了了解组织如何更好地保护用户，我们回顾性分析了我们大学二十年来遭受凭据猜测攻击的脆弱性。给定一份大学用户名列表，我们从数百个网站和十几个大型泄露事件汇编中搜索了两个数据泄露事件中的匹配项。在破解哈希密码并调整猜测后，我们成功猜测了 32.0% 与数据泄露中的大学电子邮件地址匹配的帐户的密码，以及 6.5% 与用户名（但不一定是域名）匹配的帐户的密码。这些帐户中的许多帐户在被泄露的数据泄露后多年仍然容易受到攻击，并且在泄露中逐字发现的密码被利用的可能性（即观察到可疑的帐户活动）几乎是经过调整的猜测的四倍。超过 70 种不同的数据泄露和各种用户名匹配策略引导了正确的猜测。在对我们猜测密码的 40 名用户进行的调查中，许多用户没有意识到他们的大学帐户存在风险，或者他们的凭据已被泄露。对我们大学密码重用的分析为组织保护帐户提供了务实的建议。</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://medium.com/@gsurma/password-cracker-generating-passwords-with-recurrent-neural-networks-lstms-9583714a3310\">使用 RNN(LSTMs) 生成密码</a>：<a href=\"https://github.com/gsurma/password_cracker\">代码不全</a></p>\n<p>（1）<br>（2）Generative Adversarial Networks can crack your password!<br>（3）Password Cracker - Generating Passwords</p>\n","excerpt":"","more":"<p>论文调研旨在找到一个喜欢的方向并且实现小论文撰写，</p>\n<h1 id=\"ICDE-2023\"><a href=\"#ICDE-2023\" class=\"headerlink\" title=\"ICDE 2023\"></a>ICDE 2023</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>ICDE-2023共接收论文228篇，录用率在25%左右，研究方向统计如下：</p>\n<table>\n<thead>\n<tr>\n<th>方向</th>\n<th>子方向</th>\n<th>论文数量</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>图与网络</td>\n<td>图算法、图处理框架、图数据库、图神经网络、图分析、知识图谱</td>\n<td>69</td>\n</tr>\n<tr>\n<td>时空、轨迹数据分析</td>\n<td></td>\n<td>34</td>\n</tr>\n<tr>\n<td>AI4DB</td>\n<td>基数估计、查询优化、学习索引、NL2SQL、表格推理、工作负载预测、性能调优、数据库嵌入</td>\n<td>13</td>\n</tr>\n<tr>\n<td>数据库管理</td>\n<td>物化视图管理、工作负载分析、事务、死锁检测、数据库安全</td>\n<td>8</td>\n</tr>\n<tr>\n<td>存储</td>\n<td></td>\n<td>4</td>\n</tr>\n<tr>\n<td>查询、索引优化</td>\n<td></td>\n<td>18</td>\n</tr>\n<tr>\n<td>人工智能</td>\n<td>机器学习、深度学习、聚类、强化学习、在线学习</td>\n<td>25</td>\n</tr>\n<tr>\n<td>流处理</td>\n<td>-</td>\n<td>9</td>\n</tr>\n<tr>\n<td>数据挖掘与分析</td>\n<td>数据挖掘、数据压缩、推荐</td>\n<td>25</td>\n</tr>\n<tr>\n<td>边缘计算、区块链、物联网</td>\n<td>-</td>\n<td>11</td>\n</tr>\n<tr>\n<td>视频处理</td>\n<td>-</td>\n<td>2</td>\n</tr>\n<tr>\n<td>隐私保护、数据安全</td>\n<td>-</td>\n<td>4</td>\n</tr>\n<tr>\n<td>众包</td>\n<td>-</td>\n<td>6</td>\n</tr>\n</tbody></table>\n<h2 id=\"详情\"><a href=\"#详情\" class=\"headerlink\" title=\"详情\"></a>详情</h2><h3 id=\"图与网络\"><a href=\"#图与网络\" class=\"headerlink\" title=\"图与网络\"></a>图与网络</h3><table>\n<thead>\n<tr>\n<th>论文</th>\n<th>子方向</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>COCLEP: Contrastive Learning-based Semi-Supervised Community Search</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>FASI: FPGA-friendly Subgraph Isomorphism on Massive Graphs</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>HGMatch: A Match-by-Hyperedge Framework for Efficient and Parallel Subhypergraph Matching</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Layph: Making Change Propagation Constraint in Incremental Graph Processing by Layering Graph</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>LightTraffic: On Optimizing CPU-GPU Data Traffic for Efficient Large-scale Random Walks</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Lumos: Heterogeneity-aware Federated Graph Learning over Decentralized Devices</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>PSPC: Efficient Parallel Shortest Path Counting on Large-Scale Graphs</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>TDB: Breaking All Hop-Constrained Cycles in Billion-Scale Directed Graphs</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Finer-Grained Engagement in Hypergraphs</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Distributed (α, β)-Core Decomposition over Bipartite Graphs</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Fairness-aware Maximal Biclique Enumeration on Bipartite Graphs</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Index-Based Biclique Percolation Communities Search on Bipartite graphs</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Efficiently Answering Quality Constrained Shortest Distance Queries in Large Graphs</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Verification-Free Approaches to Efficient Locally Densest Subgraph Discovery</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Efficient Maximum Signed Biclique Identification</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Explainable Hyperlink Prediction: A Hypergraph Edit Distance-Based Approach</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Reinforcement Learning Enhanced Weighted Sampling for Accurate Subgraph Counting on Fully Dynamic Graph Streams</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Towards Efficient Shortest Path Counting on Billion-Scale Graphs</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Fair Group Summarization with Graph Patterns</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Top-r keyword-based community search in attributed graphs</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Accelerating k-Core Decomposition by a GPU</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Minimizing the Influence of Misinformation via Vertex Blocking</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Efficiently Sampling and Estimating Hypergraphs By Hybrid Random Walk</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Efficient Multi-GPU Graph Processing with Remote Work Stealing</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Neighborhood Skyline on Graphs: Concepts, Algorithms and Applications</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Finding Top-k Important Edges on Bipartite Graphs: Ego-betweenness Centrality-based Approaches</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>VC-dimension and Rademacher Averages of Subgraphs, with Applications to Graph Mining</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Most Probable Densest Subgraphs</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Scalable Algorithms for Densest Subgraph Discovery</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Distributed Near-Maximum Independent Set Maintenance over Large-scale Dynamic Graphs</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Fast Unsupervised Graph Embedding via Graph Zoom Learning</td>\n<td>图算法</td>\n<td></td>\n</tr>\n<tr>\n<td>Wind-Bell Index: Towards Ultra-Fast Relational Query for Graph Databases</td>\n<td>图数据库</td>\n<td>查询</td>\n</tr>\n<tr>\n<td>Hop-Constrained s-t Simple Path Enumeration on Large Dynamic Graphs</td>\n<td>图数据库</td>\n<td>查询</td>\n</tr>\n<tr>\n<td>A Reachability Index for Recursive Label-Concatenated Graph Queries</td>\n<td>图数据库</td>\n<td>索引</td>\n</tr>\n<tr>\n<td>VEND: Vertex Encoding for Edge Nonexistence Determination</td>\n<td>图数据库</td>\n<td></td>\n</tr>\n<tr>\n<td>Extracting Graphs Properties with Semantic Joins</td>\n<td>图数据库</td>\n<td></td>\n</tr>\n<tr>\n<td>Integrating Connection Search in Graph Queries</td>\n<td>图数据库</td>\n<td>查询</td>\n</tr>\n<tr>\n<td>AFaVS: Accurate Yet Fast Version Switching for Graph Processing Systems</td>\n<td>图处理系统</td>\n<td></td>\n</tr>\n<tr>\n<td>FLASH: A Framework for Programming Distributed Graph Processing Algorithms</td>\n<td>图处理系统</td>\n<td></td>\n</tr>\n<tr>\n<td>Partitioner Selection with EASE to Optimize Distributed Graph Processing</td>\n<td>图处理系统</td>\n<td></td>\n</tr>\n<tr>\n<td>Optimizing Graph Partition by Optimal Vertex-Cut: A Holistic Approach</td>\n<td>图处理系统</td>\n<td>图划分</td>\n</tr>\n<tr>\n<td>HyTGraph: GPU-Accelerated Graph Processing with Hybrid Transfer Management</td>\n<td>图处理系统</td>\n<td></td>\n</tr>\n<tr>\n<td>GAMMA: A Graph Pattern Mining Framework for Large Graphs on GPU</td>\n<td>图处理系统</td>\n<td>图模式挖掘</td>\n</tr>\n<tr>\n<td>HyGNN: Drug-Drug Interaction Prediction via Hypergraph Neural Network</td>\n<td>图神经网络</td>\n<td></td>\n</tr>\n<tr>\n<td>Demystifying Bitcoin Address Behavior via Graph Neural Networks</td>\n<td>图神经网络</td>\n<td></td>\n</tr>\n<tr>\n<td>Jointly Attacking Graph Neural Network and its Explanations</td>\n<td>图神经网络</td>\n<td></td>\n</tr>\n<tr>\n<td>Relational Temporal Graph Convolutional Networks for Ranking-Based Stock Prediction</td>\n<td>图神经网络</td>\n<td></td>\n</tr>\n<tr>\n<td>A Bayesian Graph Neural Network for EEG Classification — A Win-Win on Performance and Interpretability</td>\n<td>图神经网络</td>\n<td></td>\n</tr>\n<tr>\n<td>Layer-refined Graph Convolutional Networks for Recommendation</td>\n<td>图神经网络</td>\n<td></td>\n</tr>\n<tr>\n<td>AutoAC: Towards Automated Attribute Completion for Heterogeneous Graph Neural Network</td>\n<td>图神经网络</td>\n<td></td>\n</tr>\n<tr>\n<td>SEIGN: A Simple and Efficient Graph Neural Network for Large Dynamic Graphs</td>\n<td>图神经网络</td>\n<td></td>\n</tr>\n<tr>\n<td>Revisiting Citation Prediction with Cluster-Aware Text-Enhanced Heterogeneous Graph Neural Networks</td>\n<td>图神经网络</td>\n<td></td>\n</tr>\n<tr>\n<td>Towards Higher-order Topological Consistency for Unsupervised Network Alignment</td>\n<td>图神经网络</td>\n<td></td>\n</tr>\n<tr>\n<td>CLDG: Contrastive Learning on Dynamic Graphs</td>\n<td>图分析</td>\n<td></td>\n</tr>\n<tr>\n<td>GALE: Active Adversarial Learning for Erroneous Node Detection in Graphs</td>\n<td>图分析</td>\n<td></td>\n</tr>\n<tr>\n<td>IFCA: Index-Free Community-Aware Reachability Processing Over Large Dynamic Graphs</td>\n<td>图分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Unsupervised Graph Outlier Detection: Problem Revisit, New Insight, and Superior Method</td>\n<td>图分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Efficient and Compact Spreadsheet Formula Graphs</td>\n<td>图分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Inconsistency Detection with Temporal Graph Functional Dependencies</td>\n<td>图分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Keyword-based Socially Tenuous Group Queries</td>\n<td>图分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Community Search: A Meta-Learning Approach</td>\n<td>图分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Dynamic Activation of Clients and Parameters for Federated Learning over Heterogeneous Graphs</td>\n<td>图分析</td>\n<td></td>\n</tr>\n<tr>\n<td>RETIA: Relation-Entity Twin-Interact Aggregation for Temporal Knowledge Graph Extrapolation</td>\n<td>知识图谱</td>\n<td></td>\n</tr>\n<tr>\n<td>Disconnected Emerging Knowledge Graph Oriented Inductive Link Prediction</td>\n<td>知识图谱</td>\n<td></td>\n</tr>\n<tr>\n<td>Relational Message Passing for Fully Inductive Knowledge Graph Completion</td>\n<td>知识图谱</td>\n<td></td>\n</tr>\n<tr>\n<td>MMKGR: Multi-hop Multi-modal Knowledge Graph Reasoning</td>\n<td>知识图谱</td>\n<td></td>\n</tr>\n<tr>\n<td>Robust Attributed Graph Alignment via Joint Structure Learning and Optimal Transpor</td>\n<td>知识图谱</td>\n<td></td>\n</tr>\n<tr>\n<td>Multimodal Biological Knowledge Graph Completion via Triple Co-attention Mechanism</td>\n<td>知识图谱</td>\n<td></td>\n</tr>\n<tr>\n<td>A Holistic Approach for Answering Logical Queries on Knowledge Graphs</td>\n<td>知识图谱</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"时空、轨迹数据分析\"><a href=\"#时空、轨迹数据分析\" class=\"headerlink\" title=\"时空、轨迹数据分析\"></a>时空、轨迹数据分析</h3><table>\n<thead>\n<tr>\n<th>论文</th>\n<th>子方向</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>TSC-AutoML: Meta-learning for automatic Time Series Classification Algorithm Selection</td>\n<td>时空数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>TSEXPLAIN: Explaining Aggregated Time Series by Surfacing Evolving Contributors</td>\n<td>时空数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Towards Long-Term Time-Series Forecasting: Feature, Pattern, and Distribution</td>\n<td>时空数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>PriSTI: A Conditional Diffusion Framework for Spatiotemporal Imputation</td>\n<td>时空数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>REncoder: A Space-Time Efficient Range Filter with Local Encoder</td>\n<td>时空数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>ROI-demand Traffic Prediction: A Pre-train, Query and Fine-tune Framework</td>\n<td>时空数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>When Spatio-Temporal Meet Wavelets: Disentangled Traffic Forecasting via Efficient Spectral Graph Attention Networks</td>\n<td>时空数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Discovering Frequency Bursting Patterns in Temporal Graphs</td>\n<td>时空数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Matrix Factorization with Landmarks for Spatial Data</td>\n<td>时空数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Uncertainty Quantification for Traffic Forecasting: A Unified Approach</td>\n<td>时空数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Extreme-Aware Local-Global Attention for Spatio-Temporal Urban Mobility Learning</td>\n<td>时空数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Mining Seasonal Temporal Patterns in Time Series</td>\n<td>时空数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>A Stitch in Time Saves Nine: Enabling Early Anomaly Detection with Correlation Analysis</td>\n<td>时空数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Self-Supervised Spatial-Temporal Bottleneck Attentive Network for Efﬁcient Long-term Trafﬁc Forecasting</td>\n<td>时空数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>namic Hypergraph Structure Learning for Traffic Flow Forecasting</td>\n<td>时空数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Forecasting COVID-19 Dynamics: Clustering, Generalized Spatiotemporal Attention, and Impacts of Mobility and Geographic Proximity</td>\n<td>时空数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Double Hierarchical Labeling Shortest Distance Querying in Time-dependent Road Networks</td>\n<td>时空数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>BERT-Trip: Effective and Scalable Trip Representation using Attentive Contrast Learning</td>\n<td>轨迹数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>LHMM: A Learning Enhanced HMM Model for Cellular Trajectory Map-matching</td>\n<td>轨迹数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Contrastive Trajectory Similarity Learning with Dual-Feature Attention</td>\n<td>轨迹数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Online Anomalous Subtrajectory Detection on Road Networks with Deep Reinforcement Learning</td>\n<td>轨迹数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Towards Efficient MIT query in Trajectory Data</td>\n<td>轨迹数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>A Lightweight Framework for Fast Trajectory Simplification</td>\n<td>轨迹数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Self-supervised Trajectory Representation Learning with Temporal Regularities and Travel Semantics</td>\n<td>轨迹数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>RNTrajRec: Road Network Enhanced Trajectory Recovery with Spatial-Temporal Transformer</td>\n<td>轨迹数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Collision-Aware Route Planning in Warehouses Made Efficient: A Strip-based Framework</td>\n<td>轨迹数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Efficient Public Transport Planning on Roads</td>\n<td>轨迹数据分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Reinforcement Learning based Tree Decomposition for Distance Querying in Road Networks</td>\n<td>路网分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Global Routing Optimization In Road Networks</td>\n<td>路网分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Experimental Evaluation of Indexing Techniques for Shortest Distance Queries on Road Networks</td>\n<td>路网分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Finding Top-k Optimal Routes with Collective Spatial Keywords on Road Networks</td>\n<td>路网分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Data Imputation for Sparse Radio Maps in Indoor Positioning</td>\n<td>地理信息分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Semi-supervised Learning with Network Embedding on Ambient RF Signals for Geofencing Services</td>\n<td>地理信息分析</td>\n<td></td>\n</tr>\n<tr>\n<td>A Contextual Master-Slave Framework on Urban Region Graph for Urban Village Detection</td>\n<td>地理信息分析</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"Ai4DB\"><a href=\"#Ai4DB\" class=\"headerlink\" title=\"Ai4DB\"></a>Ai4DB</h3><table>\n<thead>\n<tr>\n<th>论文</th>\n<th>子方向</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AutoCE: An Accurate and Efficient Model Advisor for Learned Cardinality Estimation</td>\n<td>基数估计</td>\n<td></td>\n</tr>\n<tr>\n<td>Couper: Memory-Efficient Cardinality Estimation under Unbalanced Distribution</td>\n<td>基数估计</td>\n<td></td>\n</tr>\n<tr>\n<td>Dynamic Materialized View Management using Graph Neural Network</td>\n<td>查询优化</td>\n<td>物化视图、图神经网络</td>\n</tr>\n<tr>\n<td>Efficient Deep Ensemble Inference via Query Difficulty-dependent Task Scheduling</td>\n<td>查询优化</td>\n<td></td>\n</tr>\n<tr>\n<td>GAR: A Generate-and-Rank Approach for Natural Language to SQL Translation</td>\n<td>NL2SQL</td>\n<td></td>\n</tr>\n<tr>\n<td>Efficiently Learning Spatial Indices</td>\n<td>学习索引</td>\n<td></td>\n</tr>\n<tr>\n<td>Towards Optimizing Storage Costs on the Cloud</td>\n<td>存储</td>\n<td></td>\n</tr>\n<tr>\n<td>Data Ambiguity Profiling for the Generation of Training Examples</td>\n<td>NL2SQL</td>\n<td></td>\n</tr>\n<tr>\n<td>Towards Explainable Table Interpretation Using Multi-view Explanations</td>\n<td>表解释</td>\n<td></td>\n</tr>\n<tr>\n<td>Toward a Unified Framework for Unsupervised Complex Tabular Reasoning</td>\n<td>表格推理</td>\n<td></td>\n</tr>\n<tr>\n<td>DBAugur: An Adversarial-based Trend Forecasting System for Diversified Workloads</td>\n<td>工作负载预测</td>\n<td></td>\n</tr>\n<tr>\n<td>Active Sampling for Sparse Table by Bayesian Optimization with Adaptive Resolution</td>\n<td>性能调优</td>\n<td></td>\n</tr>\n<tr>\n<td>Stable Tuple Embeddings for Dynamic Databases</td>\n<td>数据库嵌入</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"数据库管理\"><a href=\"#数据库管理\" class=\"headerlink\" title=\"数据库管理\"></a>数据库管理</h3><table>\n<thead>\n<tr>\n<th>论文</th>\n<th>子方向</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>S&#x2F;C: Speeding up Data Materialization with Bounded Memory</td>\n<td>物化视图</td>\n<td></td>\n</tr>\n<tr>\n<td>Co-Utilizing SIMD and Scalar to Accelerate the Data Analytics Workloads</td>\n<td>工作负载分析</td>\n<td></td>\n</tr>\n<tr>\n<td>Leopard: A Black-Box Approach for Efficiently Verifying Various Isolation Levels</td>\n<td>事务</td>\n<td></td>\n</tr>\n<tr>\n<td>Knock Out 2PC with Practicality Intact: a High-performance and General Distributed Transaction Protocol</td>\n<td>事务</td>\n<td></td>\n</tr>\n<tr>\n<td>Database Deadlock Diagnosis for Large-scale ORM-based Web Applications</td>\n<td>死锁检测</td>\n<td></td>\n</tr>\n<tr>\n<td>LCL: A Lock Chain Length-based Distributed Algorithm for Deadlock Detection and Resolution</td>\n<td>死锁检测</td>\n<td></td>\n</tr>\n<tr>\n<td>Sequence-Oriented DBMS Fuzzing</td>\n<td>数据库安全</td>\n<td></td>\n</tr>\n<tr>\n<td>DBCatcher: A Cloud Database Online Anomaly Detection System based on Indicator Correlatio</td>\n<td>数据库安全</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"存储、LSM-Tree\"><a href=\"#存储、LSM-Tree\" class=\"headerlink\" title=\"存储、LSM Tree\"></a>存储、LSM Tree</h3><table>\n<thead>\n<tr>\n<th>论文</th>\n<th>子方向</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ACEing the Bufferpool Management Paradigm for Modern Storage Devices</td>\n<td>存储</td>\n<td></td>\n</tr>\n<tr>\n<td>Redesigning High-Performance LSM-based Key-Value Stores with Persistent CPU Caches</td>\n<td>存储</td>\n<td></td>\n</tr>\n<tr>\n<td>Workload-Aware Log-Structured Merge Key-Value Store for NVM-SSD Hybrid Storage</td>\n<td>存储</td>\n<td></td>\n</tr>\n<tr>\n<td>Real-Time LSM-Trees for HTAP Workloads</td>\n<td>LSM Tree</td>\n<td>适用于 HTAP 工作负载的实时 LSM 树</td>\n</tr>\n</tbody></table>\n<h3 id=\"查询、索引优化\"><a href=\"#查询、索引优化\" class=\"headerlink\" title=\"查询、索引优化\"></a>查询、索引优化</h3><table>\n<thead>\n<tr>\n<th>论文</th>\n<th>子方向</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ADAMANT: A Query Executor with Plug-In Interfaces for Easy Co-processor Integration</td>\n<td>查询</td>\n<td></td>\n</tr>\n<tr>\n<td>Skyline Micro-Cluster Query: A Novel and Practical Spatial Query</td>\n<td>查询</td>\n<td></td>\n</tr>\n<tr>\n<td>Ver: View Discovery in the Wild</td>\n<td>查询</td>\n<td></td>\n</tr>\n<tr>\n<td>EulerFD: An Efficient Double-Cycle Approximation of Functional Dependencies</td>\n<td>查询</td>\n<td></td>\n</tr>\n<tr>\n<td>Finding Best Tuple via Error-prone User Interaction</td>\n<td>查询</td>\n<td></td>\n</tr>\n<tr>\n<td>KOIOS: Top-k Semantic Overlap Set Search</td>\n<td>查询</td>\n<td></td>\n</tr>\n<tr>\n<td>Complete Join Reordering for Null-Intolerant Joins</td>\n<td>查询</td>\n<td></td>\n</tr>\n<tr>\n<td>Efficiently Answering Top-k Window Aggregate Queries: Calculating Coverage Number Sequences over Hierarchical Structures</td>\n<td>查询</td>\n<td></td>\n</tr>\n<tr>\n<td>On Explaining Confounding Bias</td>\n<td>查询</td>\n<td></td>\n</tr>\n<tr>\n<td>MetricJoin: Leveraging Metric Properties for Robust Exact Set Similarity Joins</td>\n<td>查询</td>\n<td></td>\n</tr>\n<tr>\n<td>Selecting Sub-tables for Data Exploration</td>\n<td>查询</td>\n<td></td>\n</tr>\n<tr>\n<td>In-Situ Cross-Database Query Processing</td>\n<td>查询</td>\n<td></td>\n</tr>\n<tr>\n<td>These Rows Are Made for Sorting and That’s Just What We’ll Do</td>\n<td>查询</td>\n<td></td>\n</tr>\n<tr>\n<td>JanusAQP: Efficient Partition Tree Maintenance for Dynamic Approximate Query Processing</td>\n<td>查询</td>\n<td></td>\n</tr>\n<tr>\n<td>dLSM: An LSM-Based Index for Memory Disaggregation</td>\n<td>索引</td>\n<td></td>\n</tr>\n<tr>\n<td>Cutting Learned Index into Pieces: An In-depth Inquiry into Updatable Learned Indexes</td>\n<td>索引</td>\n<td></td>\n</tr>\n<tr>\n<td>Indexing for Near-Sorted Data</td>\n<td>索引</td>\n<td></td>\n</tr>\n<tr>\n<td>EEPH: An Efficient Extendible Perfect Hashing for Hybrid PMem-DRAM</td>\n<td>索引</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"人工智能\"><a href=\"#人工智能\" class=\"headerlink\" title=\"人工智能\"></a>人工智能</h3><table>\n<thead>\n<tr>\n<th>论文</th>\n<th>子方向</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Fed-SC: One-Shot Federated Subspace Clustering over High-Dimensional Data</td>\n<td>聚类</td>\n<td></td>\n</tr>\n<tr>\n<td>Parallel Filtered Graphs for Hierarchical Clustering</td>\n<td>聚类</td>\n<td></td>\n</tr>\n<tr>\n<td>Efficient Augmentation for Imbalanced Deep Learning</td>\n<td>深度学习</td>\n<td></td>\n</tr>\n<tr>\n<td>Pricing Prediction Services for Profit Maximization with Incomplete Information</td>\n<td>深度学习</td>\n<td></td>\n</tr>\n<tr>\n<td>Detection of Groups With Biased Representation in Ranking</td>\n<td>深度学习</td>\n<td></td>\n</tr>\n<tr>\n<td>The Art of Losing to Win: Using Lossy Image Compression to Improve Data Loading in Deep Learning Pipelines</td>\n<td>深度学习</td>\n<td></td>\n</tr>\n<tr>\n<td>Opponent-aware Order Pricing towards Hub-oriented Mobility Services</td>\n<td>深度学习</td>\n<td></td>\n</tr>\n<tr>\n<td>Rotary: A Resource Arbitration Framework for Progressive Iterative Analytics</td>\n<td>深度学习</td>\n<td></td>\n</tr>\n<tr>\n<td>Sudowoodo: Contrastive Self-supervised Learning for Multi-purpose Data Integration and Preparation</td>\n<td>深度学习</td>\n<td></td>\n</tr>\n<tr>\n<td>ENLD: Efficient Noisy Label Detection for Incremental Datasets in Data Lake ENLD：数据湖中增量数据集的高效噪声标签检测</td>\n<td>深度学习</td>\n<td></td>\n</tr>\n<tr>\n<td>Improving Progressive Retrieval for HPC Scientific Data using Deep Neural Network</td>\n<td>深度学习</td>\n<td></td>\n</tr>\n<tr>\n<td>Lightweight-Yet-Efficient: Revitalizing Ball-Tree for Point-to-Hyperplane Nearest Neighbor Search</td>\n<td>机器学习</td>\n<td></td>\n</tr>\n<tr>\n<td>Automatic Feasibility Study via Data Quality Analysis for ML: A Case-Study on Label Noise</td>\n<td>机器学习</td>\n<td></td>\n</tr>\n<tr>\n<td>A Hierarchical Approach to Anomalous Subgroup Discovery</td>\n<td>机器学习</td>\n<td></td>\n</tr>\n<tr>\n<td>Metam: Goal-Oriented Data Discovery</td>\n<td>机器学习</td>\n<td></td>\n</tr>\n<tr>\n<td>Dynamic Shapley Value Computation</td>\n<td>机器学习</td>\n<td></td>\n</tr>\n<tr>\n<td>SK-Gradient: Efficient Communication for Distributed Machine Learning with Data Sketch</td>\n<td>机器学习</td>\n<td>分布式机器学习</td>\n</tr>\n<tr>\n<td>Distribution-Regularized Federated Learning on Non-IID Data</td>\n<td>机器学习</td>\n<td>分布式机器学习</td>\n</tr>\n<tr>\n<td>Orchestrating Large-Scale SpGEMMs using Dynamic Block Distribution and Data Transfer Minimization on Heterogeneous Systems</td>\n<td>机器学习</td>\n<td>分布式机器学习</td>\n</tr>\n<tr>\n<td>Enhancing Decentralized Federated Learning for Non-IID Data on Heterogenous Devices</td>\n<td>机器学习</td>\n<td>分布式机器学习</td>\n</tr>\n<tr>\n<td>Toward Efficient Automated Feature Engineering</td>\n<td>特征工程</td>\n<td></td>\n</tr>\n<tr>\n<td>PA-FEAT: Fast Feature Selection for Structured Data via Progress-Aware Multi-Task Deep Reinforcement Learning</td>\n<td>强化学习</td>\n<td></td>\n</tr>\n<tr>\n<td>Discovering Editing Rules by Deep Reinforcement Learning</td>\n<td>强化学习</td>\n<td></td>\n</tr>\n<tr>\n<td>Schema Matching using Pre-Trained Language Models</td>\n<td>NLP</td>\n<td></td>\n</tr>\n<tr>\n<td>Online Pricing Strategy Achieving Vanishing Regret for Shipping Container Pricing with Limited Inventory</td>\n<td>在线学习</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"流处理\"><a href=\"#流处理\" class=\"headerlink\" title=\"流处理\"></a>流处理</h3><table>\n<thead>\n<tr>\n<th>论文</th>\n<th>子方向</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CompressStreamDB: Fine-Grained Adaptive Stream Processing without Decompression</td>\n<td>流处理</td>\n<td></td>\n</tr>\n<tr>\n<td>HistSketch: A Compact Data Structure for Accurate Per-Key Distribution Monitoring</td>\n<td>流处理</td>\n<td></td>\n</tr>\n<tr>\n<td>HyperCalm Sketch: One-Pass Mining Periodic Batches in Data Streams</td>\n<td>流处理</td>\n<td></td>\n</tr>\n<tr>\n<td>RADAR: Reactive Concept Drift Management with Robust Variational Inference for Evolving IoT Data Streams</td>\n<td>流处理</td>\n<td></td>\n</tr>\n<tr>\n<td>SASPAR: Shared Adaptive Stream Partitioning</td>\n<td>流处理</td>\n<td></td>\n</tr>\n<tr>\n<td>SketchConf: A Framework for Automatic Sketch Configuration</td>\n<td>流处理</td>\n<td></td>\n</tr>\n<tr>\n<td>Parallelizing Stream Compression for IoT Applications on Asymmetric Multicores</td>\n<td>流处理</td>\n<td></td>\n</tr>\n<tr>\n<td>Globally Aware Contextual Embeddings for Named Entity Recognition in Social Media Streams</td>\n<td>流处理</td>\n<td></td>\n</tr>\n<tr>\n<td>Finding Simplex Items in Data Streams</td>\n<td>流处理</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"数据分析与挖掘\"><a href=\"#数据分析与挖掘\" class=\"headerlink\" title=\"数据分析与挖掘\"></a>数据分析与挖掘</h3><table>\n<thead>\n<tr>\n<th>论文</th>\n<th>子方向</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>IndiBits: Incremental Discovery of Relaxed Functional Dependencies using Bitwise Similarity</td>\n<td>数据挖掘</td>\n<td></td>\n</tr>\n<tr>\n<td>UADB: Unsupervised Anomaly Detection Booster</td>\n<td>数据挖掘</td>\n<td></td>\n</tr>\n<tr>\n<td>Learn to Explore: on Bootstrapping Interactive Data Exploration with Meta-learning</td>\n<td>数据挖掘</td>\n<td></td>\n</tr>\n<tr>\n<td>Efficient Parallel Mining of High-utility Itemsets on Multicore Processors</td>\n<td>数据挖掘</td>\n<td></td>\n</tr>\n<tr>\n<td>Benchmarking Filtering Techniques for Entity Resolution</td>\n<td>数据挖掘</td>\n<td></td>\n</tr>\n<tr>\n<td>Voting-based Opinion Maximization</td>\n<td>数据挖掘</td>\n<td></td>\n</tr>\n<tr>\n<td>Interactive Search with Mixed Attributes</td>\n<td>数据挖掘</td>\n<td></td>\n</tr>\n<tr>\n<td>Planning Data Poisoning Attacks on Heterogeneous Recommender Systems in a Multiplayer Setting</td>\n<td>数据挖掘</td>\n<td></td>\n</tr>\n<tr>\n<td>A Feature-Driven Fixed-Ratio Lossy Compression Framework for Real-World Scientific Datasets</td>\n<td>数据压缩</td>\n<td></td>\n</tr>\n<tr>\n<td>Neural Node Matching for Multi-Target Cross Domain Recommendation</td>\n<td>推荐</td>\n<td></td>\n</tr>\n<tr>\n<td>Incremental Learning for Multi-Interest Sequential Recommendation</td>\n<td>推荐</td>\n<td></td>\n</tr>\n<tr>\n<td>Disentangled Graph Social Recommendation</td>\n<td>推荐</td>\n<td></td>\n</tr>\n<tr>\n<td>Group Buying Recommendation Model Based on Multi-task Learning</td>\n<td>推荐</td>\n<td>多任务学习</td>\n</tr>\n<tr>\n<td>Probabilistic Majority Rule-Based Group Recommendation</td>\n<td>推荐</td>\n<td></td>\n</tr>\n<tr>\n<td>Sequential Recommendation with User Causal Behavior Discovery</td>\n<td>推荐</td>\n<td></td>\n</tr>\n<tr>\n<td>Towards Capacity-Aware Broker Matching: From Recommendation to Assignment</td>\n<td>推荐</td>\n<td></td>\n</tr>\n<tr>\n<td>Visualization Recommendation Through Visual Relation Learning and Visual Preference Learning</td>\n<td>推荐</td>\n<td></td>\n</tr>\n<tr>\n<td>Personalized Diversification for Neural Re-ranking in Recommendation</td>\n<td>推荐</td>\n<td></td>\n</tr>\n<tr>\n<td>A Competition-Aware Approach to Accurate TV Show Recommendation</td>\n<td>推荐</td>\n<td></td>\n</tr>\n<tr>\n<td>Intent-aware Multi-source Contrastive Alignment for Tag-enhanced Recommendation</td>\n<td>推荐</td>\n<td></td>\n</tr>\n<tr>\n<td>Instant Representation Learning for Recommendation over Large Dynamic Graphs</td>\n<td>推荐</td>\n<td></td>\n</tr>\n<tr>\n<td>A Generic Reinforced Explainable Framework with Knowledge Graph for Session-based Recommendation</td>\n<td>推荐</td>\n<td></td>\n</tr>\n<tr>\n<td>Contrastive Enhanced Slide Filter Mixer for Sequential Recommendation</td>\n<td>推荐</td>\n<td></td>\n</tr>\n<tr>\n<td>Bayesian Negative Sampling for Recommendation</td>\n<td>推荐</td>\n<td></td>\n</tr>\n<tr>\n<td>Influential Recommender System</td>\n<td>推荐</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"边缘计算、区块链、物联网\"><a href=\"#边缘计算、区块链、物联网\" class=\"headerlink\" title=\"边缘计算、区块链、物联网\"></a>边缘计算、区块链、物联网</h3><table>\n<thead>\n<tr>\n<th>论文</th>\n<th>子方向</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>EdgeNN: Efficient Neural Network Inference for CPU-GPU Integrated Edge Devices</td>\n<td>边缘计算</td>\n<td></td>\n</tr>\n<tr>\n<td>FedKNOW: Federated Continual Learning with Signature Task Knowledge Integration at Edge</td>\n<td>边缘计算</td>\n<td></td>\n</tr>\n<tr>\n<td>Reliable Transactions in Serverless-Edge Architecture</td>\n<td>边缘计算</td>\n<td></td>\n</tr>\n<tr>\n<td>Ziziphus: Scalable Data Management Across Byzantine Edge Servers</td>\n<td>边缘计算</td>\n<td></td>\n</tr>\n<tr>\n<td>Saguaro: An Edge Computing-Enabled Hierarchical Permissioned Blockchain</td>\n<td>边缘计算 、区块链</td>\n<td></td>\n</tr>\n<tr>\n<td>SChain: Scalable Concurrency over Flexible Permissioned Blockchain</td>\n<td>区块链</td>\n<td></td>\n</tr>\n<tr>\n<td>TxAllo: Dynamic Transaction Allocation in Sharded Blockchain Systems</td>\n<td>区块链</td>\n<td></td>\n</tr>\n<tr>\n<td>On Sharding Across Heterogeneous Blockchains</td>\n<td>区块链</td>\n<td></td>\n</tr>\n<tr>\n<td>Scaling Blockchain Consensus via a Robust Shared Mempool</td>\n<td>区块链</td>\n<td></td>\n</tr>\n<tr>\n<td>Non-Blocking Raft for High Throughput IoT Data</td>\n<td>物联网</td>\n<td></td>\n</tr>\n<tr>\n<td>Federated IoT Interaction Vulnerability Analysis</td>\n<td>物联网</td>\n<td>漏洞分析</td>\n</tr>\n</tbody></table>\n<h3 id=\"视频处理\"><a href=\"#视频处理\" class=\"headerlink\" title=\"视频处理\"></a>视频处理</h3><table>\n<thead>\n<tr>\n<th>论文</th>\n<th>子方向</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Marshalling Model Inference In Video Streams</td>\n<td>视频处理</td>\n<td></td>\n</tr>\n<tr>\n<td>Track Merging for Effective Video Query Processing</td>\n<td>视频处理</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"隐私保护\"><a href=\"#隐私保护\" class=\"headerlink\" title=\"隐私保护\"></a>隐私保护</h3><table>\n<thead>\n<tr>\n<th>论文</th>\n<th>子方向</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Dynamic Private Task Assignment under Differential Privacy</td>\n<td>隐私保护</td>\n<td></td>\n</tr>\n<tr>\n<td>Differential Aggregation against General Colluding Attackers</td>\n<td>隐私保护</td>\n<td></td>\n</tr>\n<tr>\n<td>KVSAgg: Secure Aggregation of Distributed Key-Value Sets</td>\n<td>隐私保护</td>\n<td></td>\n</tr>\n<tr>\n<td>PrivNUD: Effective Range Query Processing under Local Differential Privacy</td>\n<td>隐私保护</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"众包\"><a href=\"#众包\" class=\"headerlink\" title=\"众包\"></a>众包</h3><table>\n<thead>\n<tr>\n<th>论文</th>\n<th>子方向</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Air-Ground Spatial Crowdsourcing with UAV Carriers by Geometric Graph Convolutional Multi-Agent Deep Reinforcement Learning</td>\n<td>众包</td>\n<td></td>\n</tr>\n<tr>\n<td>Efficient Cross Dynamic Task Assignment in Spatial Crowdsourcing</td>\n<td>众包</td>\n<td></td>\n</tr>\n<tr>\n<td>Batch-Based Cooperative Task Assignment in Spatial Crowdsourcing</td>\n<td>众包</td>\n<td></td>\n</tr>\n<tr>\n<td>Exploring both Individuality and Cooperation for Air-Ground Spatial Crowdsourcing by Multi-Agent Deep Reinforcement Learning</td>\n<td>众包</td>\n<td></td>\n</tr>\n<tr>\n<td>Hierarchical Crowdsourcing for Data Labeling with Heterogeneous Crowd</td>\n<td>众包</td>\n<td></td>\n</tr>\n<tr>\n<td>Learning from Noisy Crowd Labels with Logics 从喧闹的人群标签中学习逻辑</td>\n<td>众包</td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"密码生成\"><a href=\"#密码生成\" class=\"headerlink\" title=\"密码生成\"></a>密码生成</h1><h2 id=\"介绍-1\"><a href=\"#介绍-1\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>关于口令生成的方向调研</p>\n<h2 id=\"个人总结\"><a href=\"#个人总结\" class=\"headerlink\" title=\"个人总结\"></a>个人总结</h2><p>[[方向：密码生成]]</p>\n<h2 id=\"安全一流会议\"><a href=\"#安全一流会议\" class=\"headerlink\" title=\"安全一流会议\"></a>安全一流会议</h2><p>S&amp;P、CCS、NDSS、USENIX Conference、IEEE tDSC</p>\n<h2 id=\"详情-1\"><a href=\"#详情-1\" class=\"headerlink\" title=\"详情\"></a>详情</h2><table>\n<thead>\n<tr>\n<th>论文</th>\n<th>时间</th>\n<th>级别</th>\n<th>笔记</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>GENPass: A General Deep Learning Model for Password Guessing with PCFG Rules and Adversarial Generation</td>\n<td>2018</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://link.springer.com/chapter/10.1007/978-3-030-21568-2_11\">PassGAN: A Deep Learning Approach to Password Guessing</a><br><a href=\"https://github.com/brannondorsey/PassGAN\">代码</a><br><a href=\"https://github.com/ponedo/rnnPassGAN-password-cracking\">改进代码</a></td>\n<td>2019</td>\n<td></td>\n<td>[[PassGAN]]</td>\n</tr>\n<tr>\n<td><a href=\"https://www.mdpi.com/1424-8220/20/11/3106\">Recurrent gans password cracker for iot password security enhancement</a></td>\n<td>2019</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://iopscience.iop.org/article/10.1088/1742-6596/1631/1/012161/pdf\">Research on Password Cracking Technology Based on Improved Transformer</a></td>\n<td>2020</td>\n<td></td>\n<td>[[Pass improved Transformer]]</td>\n</tr>\n<tr>\n<td><a href=\"https://www.mdpi.com/2076-3417/10/20/7306\">Generating optimized guessing candidates toward better password cracking from multi-dictionaries using relativistic GAN</a></td>\n<td>2020</td>\n<td>三区</td>\n<td>[[REDPACK]]</td>\n</tr>\n<tr>\n<td><a href=\"https://link.springer.com/chapter/10.1007/978-3-030-93206-0_18\">Densegan: A password <strong>guessing model based</strong> on <strong>densenet</strong> and <strong>passgan</strong></a></td>\n<td>2021</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://www.mdpi.com/2076-3417/11/10/4607\">Dynamic Markov Model: Password Guessing Using Probability Adjustment</a></td>\n<td>2021</td>\n<td>C</td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://dl.acm.org/doi/abs/10.1145/3448608\">A large-scale analysis of the semantic password model and linguistic patterns in passwords</a>综述</td>\n<td>2021</td>\n<td>B</td>\n<td>[[语义密码模型和密码语言模式分析]]</td>\n</tr>\n<tr>\n<td><a href=\"https://www.mdpi.com/1424-8220/22/12/4604\">LPG–PCFG: an improved probabilistic context-free grammar to hit low-probability passwords</a></td>\n<td>2022</td>\n<td>C</td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://arxiv.org/abs/2208.10413\">On deep learning in password guessing, a survey</a></td>\n<td>2022</td>\n<td>C</td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://ieeexplore.ieee.org/abstract/document/9799343/\">GNPassGAN: improved generative adversarial networks for trawling offline password guessing</a></td>\n<td>2022</td>\n<td>A</td>\n<td>[[GNPassGAN]]</td>\n</tr>\n<tr>\n<td><a href=\"https://link.springer.com/chapter/10.1007/978-981-99-9239-3_3\">PassDiff: A New Approach for Password Guessing Using Diffusion Model</a><a href=\"https://books.google.co.jp/books?hl=zh-CN&lr&id=NjvsEAAAQBAJ&oi=fnd&pg=PA29&ots=MFKPmtXK-9&sig=Ea5MEWjfUDxwHsZPvrnk1jdnHo0&redir_esc=y&pli=1#v=onepage&q&f=false\">阅读</a><br><a href=\"https://github.com/madaan/minimal-text-diffusion\">代码</a><br></td>\n<td>2023</td>\n<td></td>\n<td>[[PassDiff]]</td>\n</tr>\n<tr>\n<td><a href=\"https://dl.acm.org/doi/abs/10.5555/3636988.3637019\">OneRuleToFindThem: Efficient Automated Generation of Password Cracking</a><br>自动生成密码规则</td>\n<td>2023</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://www.mdpi.com/1099-4300/25/9/1303\">A Systematic Review on Password Guessing Tasks</a><br>密码生成的系统综述</td>\n<td>2023</td>\n<td></td>\n<td>[[AReview]]</td>\n</tr>\n<tr>\n<td><a href=\"https://link.springer.com/article/10.1007/s12243-023-00969-4\">Adaptive password guessing: learning language, nationality and dataset</a><br>自适应密码猜测</td>\n<td>2023</td>\n<td>4区</td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://arxiv.org/abs/2306.06824\">SE# PCFG: Semantically Enhanced PCFG for Password Analysis and Cracking</a><br>密码分析和破解语义的增强</td>\n<td>2023</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://arxiv.org/abs/2306.01545\">PassGPT: Password Modeling and (Guided) Generation with Large Language</a></td>\n<td>2023</td>\n<td></td>\n<td>[[PassGPT]]</td>\n</tr>\n<tr>\n<td><a href=\"https://ieeexplore.ieee.org/abstract/document/10152712/\">A New Targeted Online Password Guessing Algorithm Based on Old Password</a></td>\n<td>2023</td>\n<td>B</td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://www.usenix.org/conference/usenixsecurity23/presentation/xu-ming\">Improving real-world password guessing attacks via bi-directional transformers</a></td>\n<td>2023</td>\n<td>A</td>\n<td>[[PassBERT]]</td>\n</tr>\n<tr>\n<td><a href=\"https://link.springer.com/article/10.1007/s10796-022-10325-x\">Password and passphrase guessing with recurrent neural networks</a></td>\n<td>2023</td>\n<td>(JCR:Q2)</td>\n<td>[[Pass_RNN]]</td>\n</tr>\n<tr>\n<td><a href=\"https://www.usenix.org/system/files/sec23fall-prepub-183-wang-ding.pdf\">Password guessing using random forest</a><br>随机森林<br><a href=\"https://github.com/PadishahIII/RFGuess\">代码</a></td>\n<td>2023</td>\n<td>A</td>\n<td>[[PASS_RF]]</td>\n</tr>\n<tr>\n<td><a href=\"https://www.sciencedirect.com/science/article/pii/S1084804523000115\">PGTCN: A novel password-guessing model based on temporal convolution</a></td>\n<td>2023</td>\n<td>C</td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://arxiv.org/abs/2403.09954\">Search-based Ordered Password Generation of Autoregressive Neural Networks</a></td>\n<td>2024</td>\n<td>C</td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://ieeexplore.ieee.org/abstract/document/10466588/\"><em>GuessFuse</em>: Hybrid Password Guessing with Multi-View</a></td>\n<td>2024</td>\n<td>A</td>\n<td>[[GuessFuse]]</td>\n</tr>\n</tbody></table>\n<h2 id=\"A-Two-Decade-Retrospective-Analysis-of-a-University’s-Vulnerability-to-Attacks-Exploiting-Reused-Passwords\"><a href=\"#A-Two-Decade-Retrospective-Analysis-of-a-University’s-Vulnerability-to-Attacks-Exploiting-Reused-Passwords\" class=\"headerlink\" title=\"A Two-Decade Retrospective Analysis of a University’s Vulnerability to Attacks Exploiting Reused Passwords\"></a>A Two-Decade Retrospective Analysis of a University’s Vulnerability to Attacks Exploiting Reused Passwords</h2><p>凭据猜测攻击通常会利用在用户在线帐户中重复使用的密码。为了了解组织如何更好地保护用户，我们回顾性分析了我们大学二十年来遭受凭据猜测攻击的脆弱性。给定一份大学用户名列表，我们从数百个网站和十几个大型泄露事件汇编中搜索了两个数据泄露事件中的匹配项。在破解哈希密码并调整猜测后，我们成功猜测了 32.0% 与数据泄露中的大学电子邮件地址匹配的帐户的密码，以及 6.5% 与用户名（但不一定是域名）匹配的帐户的密码。这些帐户中的许多帐户在被泄露的数据泄露后多年仍然容易受到攻击，并且在泄露中逐字发现的密码被利用的可能性（即观察到可疑的帐户活动）几乎是经过调整的猜测的四倍。超过 70 种不同的数据泄露和各种用户名匹配策略引导了正确的猜测。在对我们猜测密码的 40 名用户进行的调查中，许多用户没有意识到他们的大学帐户存在风险，或者他们的凭据已被泄露。对我们大学密码重用的分析为组织保护帐户提供了务实的建议。</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://medium.com/@gsurma/password-cracker-generating-passwords-with-recurrent-neural-networks-lstms-9583714a3310\">使用 RNN(LSTMs) 生成密码</a>：<a href=\"https://github.com/gsurma/password_cracker\">代码不全</a></p>\n<p>（1）<br>（2）Generative Adversarial Networks can crack your password!<br>（3）Password Cracker - Generating Passwords</p>\n"},{"_content":"\n## 两数之和\n\n### 关键\n两两匹配，且只匹配一次，\n\n### 方法1\n#### 思路\n两次for循环，计算每两个之间的和\n#### 空间复杂度\n1\n#### 时间复杂度\n$n^2$\n\n\n### 方法2\n#### 思路\n先排序，再遍历\n#### 没有意义\n\n\n### 方法3\n#### 思路\n用哈希，只遍历一次。\n#### 时间复杂度\nn\n#### 空间复杂度\nn\n\n","source":"_posts/算法题目/问题分析.md","raw":"\n## 两数之和\n\n### 关键\n两两匹配，且只匹配一次，\n\n### 方法1\n#### 思路\n两次for循环，计算每两个之间的和\n#### 空间复杂度\n1\n#### 时间复杂度\n$n^2$\n\n\n### 方法2\n#### 思路\n先排序，再遍历\n#### 没有意义\n\n\n### 方法3\n#### 思路\n用哈希，只遍历一次。\n#### 时间复杂度\nn\n#### 空间复杂度\nn\n\n","slug":"算法题目/问题分析","published":1,"date":"2024-04-22T13:14:49.158Z","updated":"2024-02-26T06:46:49.166Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0g0014kgg4ftib6lwf","content":"<h2 id=\"两数之和\"><a href=\"#两数之和\" class=\"headerlink\" title=\"两数之和\"></a>两数之和</h2><h3 id=\"关键\"><a href=\"#关键\" class=\"headerlink\" title=\"关键\"></a>关键</h3><p>两两匹配，且只匹配一次，</p>\n<h3 id=\"方法1\"><a href=\"#方法1\" class=\"headerlink\" title=\"方法1\"></a>方法1</h3><h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><p>两次for循环，计算每两个之间的和</p>\n<h4 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h4><p>1</p>\n<h4 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h4><p>$n^2$</p>\n<h3 id=\"方法2\"><a href=\"#方法2\" class=\"headerlink\" title=\"方法2\"></a>方法2</h3><h4 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h4><p>先排序，再遍历</p>\n<h4 id=\"没有意义\"><a href=\"#没有意义\" class=\"headerlink\" title=\"没有意义\"></a>没有意义</h4><h3 id=\"方法3\"><a href=\"#方法3\" class=\"headerlink\" title=\"方法3\"></a>方法3</h3><h4 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h4><p>用哈希，只遍历一次。</p>\n<h4 id=\"时间复杂度-1\"><a href=\"#时间复杂度-1\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h4><p>n</p>\n<h4 id=\"空间复杂度-1\"><a href=\"#空间复杂度-1\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h4><p>n</p>\n","excerpt":"","more":"<h2 id=\"两数之和\"><a href=\"#两数之和\" class=\"headerlink\" title=\"两数之和\"></a>两数之和</h2><h3 id=\"关键\"><a href=\"#关键\" class=\"headerlink\" title=\"关键\"></a>关键</h3><p>两两匹配，且只匹配一次，</p>\n<h3 id=\"方法1\"><a href=\"#方法1\" class=\"headerlink\" title=\"方法1\"></a>方法1</h3><h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><p>两次for循环，计算每两个之间的和</p>\n<h4 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h4><p>1</p>\n<h4 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h4><p>$n^2$</p>\n<h3 id=\"方法2\"><a href=\"#方法2\" class=\"headerlink\" title=\"方法2\"></a>方法2</h3><h4 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h4><p>先排序，再遍历</p>\n<h4 id=\"没有意义\"><a href=\"#没有意义\" class=\"headerlink\" title=\"没有意义\"></a>没有意义</h4><h3 id=\"方法3\"><a href=\"#方法3\" class=\"headerlink\" title=\"方法3\"></a>方法3</h3><h4 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h4><p>用哈希，只遍历一次。</p>\n<h4 id=\"时间复杂度-1\"><a href=\"#时间复杂度-1\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h4><p>n</p>\n<h4 id=\"空间复杂度-1\"><a href=\"#空间复杂度-1\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h4><p>n</p>\n"},{"title":"Englislearning","_content":"\n| 单词             | 词性         | 翻译            | 关联                                |     |\n| -------------- | ---------- | ------------- | --------------------------------- | --- |\n| concatenate    | v. \\| adj. | 连接            | n. concatenation<br>              |     |\n| leet           | n          | 民事法庭          |                                   |     |\n| laborious      | adj.       | 费力的；艰难的       |                                   |     |\n| novel          | n.<br>adj. | 小说；<br>新奇的    | a novel approach                  |     |\n| promising      | adj.       | 有希望的；有前途的     |                                   |     |\n| thereof        | adj.       | 它的；           | variants thereof: 它的变体            |     |\n| heuristics     | adj.       | 启发式的          |                                   |     |\n| hypothesize    | v.         | 假设假定；         | 来自 hypothesis：假说                  |     |\n| density        | n.         | 密度            |                                   |     |\n| mimic          | n.v.adj.   | 模仿            |                                   |     |\n| discriminative | adj.       | 有判别能力的        | criminative：使负罪的                  |     |\n| overwhlming    | adj        | 势不可挡的         | the overwhelming majority of：绝大多数 |     |\n| tradeoff       | n.         | 公平交易，折衷       |                                   | 权衡  |\n| nuisance       | v.         | 干扰            |                                   |     |\n| inception      | n.         | 开端，创始         |                                   |     |\n| instantiate    | n.         | 实例化           |                                   |     |\n| residual       | adj.<br>n. | 残余的，残留的；残余，残渣 |                                   |     |\n| approximate    | v.         | 估计；逼近         |                                   |     |\n| intractable    | adj.       | 棘手的           |                                   |     |\n| integral       | n.         | 积分            |                                   |     |\n| truncation     | n.         | 截断            |                                   |     |\n| consecutive    | adj.       | 连续的           |                                   |     |\n| premise        | n.         | 前提            |                                   |     |\n| elapse         | v.         | 消逝，流逝         |                                   |     |\n| invocation     | n.         | 调用，启用         |                                   |     |\n| pending        | adj.       | 悬而未决的，即将发生的   |                                   |     |\n","source":"_posts/英语学习/英语单词.md","raw":"---\ntitle: Englislearning\n---\n\n| 单词             | 词性         | 翻译            | 关联                                |     |\n| -------------- | ---------- | ------------- | --------------------------------- | --- |\n| concatenate    | v. \\| adj. | 连接            | n. concatenation<br>              |     |\n| leet           | n          | 民事法庭          |                                   |     |\n| laborious      | adj.       | 费力的；艰难的       |                                   |     |\n| novel          | n.<br>adj. | 小说；<br>新奇的    | a novel approach                  |     |\n| promising      | adj.       | 有希望的；有前途的     |                                   |     |\n| thereof        | adj.       | 它的；           | variants thereof: 它的变体            |     |\n| heuristics     | adj.       | 启发式的          |                                   |     |\n| hypothesize    | v.         | 假设假定；         | 来自 hypothesis：假说                  |     |\n| density        | n.         | 密度            |                                   |     |\n| mimic          | n.v.adj.   | 模仿            |                                   |     |\n| discriminative | adj.       | 有判别能力的        | criminative：使负罪的                  |     |\n| overwhlming    | adj        | 势不可挡的         | the overwhelming majority of：绝大多数 |     |\n| tradeoff       | n.         | 公平交易，折衷       |                                   | 权衡  |\n| nuisance       | v.         | 干扰            |                                   |     |\n| inception      | n.         | 开端，创始         |                                   |     |\n| instantiate    | n.         | 实例化           |                                   |     |\n| residual       | adj.<br>n. | 残余的，残留的；残余，残渣 |                                   |     |\n| approximate    | v.         | 估计；逼近         |                                   |     |\n| intractable    | adj.       | 棘手的           |                                   |     |\n| integral       | n.         | 积分            |                                   |     |\n| truncation     | n.         | 截断            |                                   |     |\n| consecutive    | adj.       | 连续的           |                                   |     |\n| premise        | n.         | 前提            |                                   |     |\n| elapse         | v.         | 消逝，流逝         |                                   |     |\n| invocation     | n.         | 调用，启用         |                                   |     |\n| pending        | adj.       | 悬而未决的，即将发生的   |                                   |     |\n","slug":"英语学习/英语单词","published":1,"date":"2024-04-22T13:14:49.345Z","updated":"2024-04-22T13:45:13.976Z","comments":1,"layout":"post","photos":[],"_id":"clvbspf0g0015kgg4ducs0bia","content":"<table>\n<thead>\n<tr>\n<th>单词</th>\n<th>词性</th>\n<th>翻译</th>\n<th>关联</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>concatenate</td>\n<td>v. | adj.</td>\n<td>连接</td>\n<td>n. concatenation<br></td>\n<td></td>\n</tr>\n<tr>\n<td>leet</td>\n<td>n</td>\n<td>民事法庭</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>laborious</td>\n<td>adj.</td>\n<td>费力的；艰难的</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>novel</td>\n<td>n.<br>adj.</td>\n<td>小说；<br>新奇的</td>\n<td>a novel approach</td>\n<td></td>\n</tr>\n<tr>\n<td>promising</td>\n<td>adj.</td>\n<td>有希望的；有前途的</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>thereof</td>\n<td>adj.</td>\n<td>它的；</td>\n<td>variants thereof: 它的变体</td>\n<td></td>\n</tr>\n<tr>\n<td>heuristics</td>\n<td>adj.</td>\n<td>启发式的</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>hypothesize</td>\n<td>v.</td>\n<td>假设假定；</td>\n<td>来自 hypothesis：假说</td>\n<td></td>\n</tr>\n<tr>\n<td>density</td>\n<td>n.</td>\n<td>密度</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>mimic</td>\n<td>n.v.adj.</td>\n<td>模仿</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>discriminative</td>\n<td>adj.</td>\n<td>有判别能力的</td>\n<td>criminative：使负罪的</td>\n<td></td>\n</tr>\n<tr>\n<td>overwhlming</td>\n<td>adj</td>\n<td>势不可挡的</td>\n<td>the overwhelming majority of：绝大多数</td>\n<td></td>\n</tr>\n<tr>\n<td>tradeoff</td>\n<td>n.</td>\n<td>公平交易，折衷</td>\n<td></td>\n<td>权衡</td>\n</tr>\n<tr>\n<td>nuisance</td>\n<td>v.</td>\n<td>干扰</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>inception</td>\n<td>n.</td>\n<td>开端，创始</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>instantiate</td>\n<td>n.</td>\n<td>实例化</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>residual</td>\n<td>adj.<br>n.</td>\n<td>残余的，残留的；残余，残渣</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>approximate</td>\n<td>v.</td>\n<td>估计；逼近</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>intractable</td>\n<td>adj.</td>\n<td>棘手的</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>integral</td>\n<td>n.</td>\n<td>积分</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>truncation</td>\n<td>n.</td>\n<td>截断</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>consecutive</td>\n<td>adj.</td>\n<td>连续的</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>premise</td>\n<td>n.</td>\n<td>前提</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>elapse</td>\n<td>v.</td>\n<td>消逝，流逝</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>invocation</td>\n<td>n.</td>\n<td>调用，启用</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>pending</td>\n<td>adj.</td>\n<td>悬而未决的，即将发生的</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n","excerpt":"","more":"<table>\n<thead>\n<tr>\n<th>单词</th>\n<th>词性</th>\n<th>翻译</th>\n<th>关联</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>concatenate</td>\n<td>v. | adj.</td>\n<td>连接</td>\n<td>n. concatenation<br></td>\n<td></td>\n</tr>\n<tr>\n<td>leet</td>\n<td>n</td>\n<td>民事法庭</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>laborious</td>\n<td>adj.</td>\n<td>费力的；艰难的</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>novel</td>\n<td>n.<br>adj.</td>\n<td>小说；<br>新奇的</td>\n<td>a novel approach</td>\n<td></td>\n</tr>\n<tr>\n<td>promising</td>\n<td>adj.</td>\n<td>有希望的；有前途的</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>thereof</td>\n<td>adj.</td>\n<td>它的；</td>\n<td>variants thereof: 它的变体</td>\n<td></td>\n</tr>\n<tr>\n<td>heuristics</td>\n<td>adj.</td>\n<td>启发式的</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>hypothesize</td>\n<td>v.</td>\n<td>假设假定；</td>\n<td>来自 hypothesis：假说</td>\n<td></td>\n</tr>\n<tr>\n<td>density</td>\n<td>n.</td>\n<td>密度</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>mimic</td>\n<td>n.v.adj.</td>\n<td>模仿</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>discriminative</td>\n<td>adj.</td>\n<td>有判别能力的</td>\n<td>criminative：使负罪的</td>\n<td></td>\n</tr>\n<tr>\n<td>overwhlming</td>\n<td>adj</td>\n<td>势不可挡的</td>\n<td>the overwhelming majority of：绝大多数</td>\n<td></td>\n</tr>\n<tr>\n<td>tradeoff</td>\n<td>n.</td>\n<td>公平交易，折衷</td>\n<td></td>\n<td>权衡</td>\n</tr>\n<tr>\n<td>nuisance</td>\n<td>v.</td>\n<td>干扰</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>inception</td>\n<td>n.</td>\n<td>开端，创始</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>instantiate</td>\n<td>n.</td>\n<td>实例化</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>residual</td>\n<td>adj.<br>n.</td>\n<td>残余的，残留的；残余，残渣</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>approximate</td>\n<td>v.</td>\n<td>估计；逼近</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>intractable</td>\n<td>adj.</td>\n<td>棘手的</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>integral</td>\n<td>n.</td>\n<td>积分</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>truncation</td>\n<td>n.</td>\n<td>截断</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>consecutive</td>\n<td>adj.</td>\n<td>连续的</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>premise</td>\n<td>n.</td>\n<td>前提</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>elapse</td>\n<td>v.</td>\n<td>消逝，流逝</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>invocation</td>\n<td>n.</td>\n<td>调用，启用</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>pending</td>\n<td>adj.</td>\n<td>悬而未决的，即将发生的</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n"},{"_content":"| 短语 | 含义 | 用法 |\n| ---- | ---- | ---- |\n| At its core | 其核心是 | At its core, our idea is to do sth. |\n| in (stark) contrast with sth | 和..形成鲜明对比 |  |\n| in a way  | 在某种程度上 |  |\n|  |  |  |\n","source":"_posts/英语学习/英语短语.md","raw":"| 短语 | 含义 | 用法 |\n| ---- | ---- | ---- |\n| At its core | 其核心是 | At its core, our idea is to do sth. |\n| in (stark) contrast with sth | 和..形成鲜明对比 |  |\n| in a way  | 在某种程度上 |  |\n|  |  |  |\n","slug":"英语学习/英语短语","published":1,"date":"2024-04-22T13:14:49.345Z","updated":"2024-02-21T11:29:52.023Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0h0016kgg4dtgcb8lx","content":"<table>\n<thead>\n<tr>\n<th>短语</th>\n<th>含义</th>\n<th>用法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>At its core</td>\n<td>其核心是</td>\n<td>At its core, our idea is to do sth.</td>\n</tr>\n<tr>\n<td>in (stark) contrast with sth</td>\n<td>和..形成鲜明对比</td>\n<td></td>\n</tr>\n<tr>\n<td>in a way</td>\n<td>在某种程度上</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n","excerpt":"","more":"<table>\n<thead>\n<tr>\n<th>短语</th>\n<th>含义</th>\n<th>用法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>At its core</td>\n<td>其核心是</td>\n<td>At its core, our idea is to do sth.</td>\n</tr>\n<tr>\n<td>in (stark) contrast with sth</td>\n<td>和..形成鲜明对比</td>\n<td></td>\n</tr>\n<tr>\n<td>in a way</td>\n<td>在某种程度上</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n"},{"_content":"[[英语单词]]\n\n[[英语短语]]","source":"_posts/英语学习/英语学习.md","raw":"[[英语单词]]\n\n[[英语短语]]","slug":"英语学习/英语学习","published":1,"date":"2024-04-22T13:14:49.345Z","updated":"2024-02-21T09:36:09.329Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0h0017kgg4987qb5q6","content":"<p>[[英语单词]]</p>\n<p>[[英语短语]]</p>\n","excerpt":"","more":"<p>[[英语单词]]</p>\n<p>[[英语短语]]</p>\n"},{"_content":"# 关于AI\nAI\n大模型\n通用但不好用\n大但不强\n成本还很高\n不找到好的商业闭环\n谁给你钱烧到AGI？\n","source":"_posts/认知社会/careall.md","raw":"# 关于AI\nAI\n大模型\n通用但不好用\n大但不强\n成本还很高\n不找到好的商业闭环\n谁给你钱烧到AGI？\n","slug":"认知社会/careall","published":1,"date":"2024-04-22T13:14:49.041Z","updated":"2024-04-12T07:34:50.240Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0h0018kgg4112ng5jm","content":"<h1 id=\"关于AI\"><a href=\"#关于AI\" class=\"headerlink\" title=\"关于AI\"></a>关于AI</h1><p>AI<br>大模型<br>通用但不好用<br>大但不强<br>成本还很高<br>不找到好的商业闭环<br>谁给你钱烧到AGI？</p>\n","excerpt":"","more":"<h1 id=\"关于AI\"><a href=\"#关于AI\" class=\"headerlink\" title=\"关于AI\"></a>关于AI</h1><p>AI<br>大模型<br>通用但不好用<br>大但不强<br>成本还很高<br>不找到好的商业闭环<br>谁给你钱烧到AGI？</p>\n"},{"_content":"知道它的目的，规划自己的行为\n\n先适合，在选择进不进\n\n核心价值观\n\n基础+收集岗位信息\n\n穷人最球多巴胺，富人追求内啡肽。\n\n\n感觉自己思考问题的方式有问题，现在有点太在乎别人的看法，在乎别人对别人的看法。\n换种思考方式。。。。。。。。。。\n\n\n你做过哪些 sql 优化。","source":"_posts/认知社会/caremyself.md","raw":"知道它的目的，规划自己的行为\n\n先适合，在选择进不进\n\n核心价值观\n\n基础+收集岗位信息\n\n穷人最球多巴胺，富人追求内啡肽。\n\n\n感觉自己思考问题的方式有问题，现在有点太在乎别人的看法，在乎别人对别人的看法。\n换种思考方式。。。。。。。。。。\n\n\n你做过哪些 sql 优化。","slug":"认知社会/caremyself","published":1,"date":"2024-04-22T13:14:49.042Z","updated":"2024-04-21T05:17:57.177Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0h0019kgg41278fhmj","content":"<p>知道它的目的，规划自己的行为</p>\n<p>先适合，在选择进不进</p>\n<p>核心价值观</p>\n<p>基础+收集岗位信息</p>\n<p>穷人最球多巴胺，富人追求内啡肽。</p>\n<p>感觉自己思考问题的方式有问题，现在有点太在乎别人的看法，在乎别人对别人的看法。<br>换种思考方式。。。。。。。。。。</p>\n<p>你做过哪些 sql 优化。</p>\n","excerpt":"","more":"<p>知道它的目的，规划自己的行为</p>\n<p>先适合，在选择进不进</p>\n<p>核心价值观</p>\n<p>基础+收集岗位信息</p>\n<p>穷人最球多巴胺，富人追求内啡肽。</p>\n<p>感觉自己思考问题的方式有问题，现在有点太在乎别人的看法，在乎别人对别人的看法。<br>换种思考方式。。。。。。。。。。</p>\n<p>你做过哪些 sql 优化。</p>\n"},{"_content":"随着5G技术的全球部署和应用，6G技术的研究和探索已经悄然启动。预计6G将在2030年前后商用，带来比5G更高的速度、更低的延迟和更广泛的连接能力。6G不仅仅是速度的飞跃，它还将引入新的技术和架构，以支持更加智能、互联的世界。第6代移动通信技术（6G）是继5G之后的下一代通信技术，其研究和应用正处于探索阶段。\n\n### 国内外研究与应用现状\n\n总体来看，6G技术的研究和应用展现出了蓬勃的发展态势，不同国家和地区在推动6G技术进步方面各有侧重，共同构建了一个多元化、互联互通的6G研发生态。随着技术的不断突破和国际合作的深入，6G技术的未来将更加光明，预计将为人类社会带来更加广泛和深远的影响。\n\n随着全球对6G技术研究的深入，不同国家和地区在推进6G技术方面展现出了各自的特色和优势。在全球覆盖、频谱效率提升、能量效率优化、智能控制水平增强以及安全性方面，各研究机构和企业正通过前沿技术探索，共同推动6G技术的进步。\n\n#### 国内研究与应用\n\n中国在6G的研究和开发方面显著领先，不仅在全球专利申请量上占据重要地位，而且在关键技术研究上取得了突破。中国的研究机构和企业正致力于解决6G技术中的核心问题，如通过新型材料和设计提升信号在高频段的传播效率，开发低功耗设备和算法以提高能量效率，以及利用人工智能技术增强网络的自主管理能力和安全性。此外，中国政府也大力支持6G技术的研发，发布了多项政策和计划，旨在建立完善的6G研发和测试环境，加速6G技术的商业化进程。\n\n#### 国际研究与应用\n\n在国际上，芬兰的6G旗舰项目是6G研究的典范，它汇集了学术界和工业界的力量，共同探索6G的未来。该项目不仅关注技术层面的创新，如太赫兹通信、量子通信技术等，还着眼于6G可能带来的社会变革，比如智能交通、智慧城市和数字健康等应用场景。美国、欧盟、日本和韩国等也都在积极推进6G研究，这些地区的研究计划通常强调开放性和国际合作，旨在建立全球统一的6G标准和生态系统。\n\n#### 专利和标准化工作\n\n在6G的研究和开发过程中，专利和标准化工作是不可忽视的方面。全球专利申请量的增加反映了国际社会对6G技术的高度重视和活跃的研发态势。中国在专利申请方面的领先地位显示了其在6G技术研发方面的强大动力和潜力。同时，国际电信联盟（ITU）、3GPP等国际标准化组织已开始讨论6G的标准化问题，旨在促进全球6G技术的统一和互操作性，确保6G技术的健康发展和广泛应用。\n\n### 采用的技术手段\n\n6G将使用太赫兹通信技术，这是其最大的优点之一，因为太赫兹频段具有大带宽和高传输速率的特点，非常适合未来高带宽业务场景。此外，6G还将利用卫星通信、无人机通信、地面通信和海上通信，实现\"太空-空中-地面-海洋\"一体化网络。这些技术手段的结合，将为6G提供更广泛的覆盖范围和更低的成本。\n\n### 发展方向和挑战\n\n6G的发展方向包括智慧连接、深度连接、全息连接和泛在连接。这些方向共同构成了6G总体愿景，即\"一念天地，万物随心\"。然而，实现这一愿景面临诸多挑战，包括峰值吞吐量、更高能效、随时随地的连接等技术需求。此外，6G极致体验需求挑战以及技术进步，共同驱动了对核心技术研究和国际标准制定的需求。\n\n#### 技术需求挑战\n- **峰值吞吐量**：为了支持全息通信等高带宽应用，6G网络需要实现Tbps级别的数据传输速度，这要求开发更高效的信号处理和数据传输技术。\n- **更高能效**：随着网络速度的提升和连接设备数量的增加，如何在保证性能的同时降低能耗成为一大挑战，这需要研发新的能效优化技术和低功耗硬件。\n- **随时随地的连接**：实现深度连接和泛在连接的愿景，需要克服复杂环境下的信号传播问题，开发新的通信技术和设备。\n#### 极致体验需求挑战\n\n为了满足用户对于极致体验的需求，6G网络必须提供几乎零延迟的实时响应和高度可靠的连接，这对网络架构和技术实现提出了更高要求。\n#### 核心技术研究和国际标准制定\n\n实现6G愿景还需要在核心技术上取得突破，包括但不限于太赫兹通信、量子通信、人工智能、分布式网络架构等。同时，为了确保6G技术的全球兼容和互操作性，开展国际标准的制定工作至关重要，需要国际社会的共同努力和协作。\n\n### 基于5G的应用场景设计\n\n基于5G/6G技术的卫星互联网一体化安全研究提出了未来5G/6G卫星互联网发展及业务应用场景的设计思路。例如，可以设计一个基于5G/6G技术的智能交通系统，该系统通过集成卫星通信、无人机通信等技术手段，实现全球范围内的实时交通监控和管理。在这个场景中，5G/6G技术能够提供高速的数据传输速率和低时延，确保交通管理系统能够快速响应各种紧急情况，从而提高交通安全性和效率。\n\n\n#### 6G技术在提升频谱效率和能量效率方面的最新研究进展\n\n6G技术在提升频谱效率和能量效率方面的最新研究进展主要体现在以下几个方面：\n\n1. **太赫兹通信技术**：太赫兹波段的利用是6G技术发展的一个重要方向。中国航天科工二院二十五所完成了国内首次太赫兹轨道角动量的实时无线传输通信实验，这为6G通信提供了新的技术支持，有助于缓解太赫兹波段频谱资源不足的问题。此外，太赫兹量子级联激光器和单行载流子光电探测器等关键技术的发展，也为6G技术的应用提供了可能。\n\n2. **智能超表面技术**：智能超表面技术被用于通信系统中，以增强覆盖并显著提升网络传输速率、信号覆盖以及能量效率。通过对无线传播环境的主动定制，可以根据所需无线功能进行调整，如减小电磁污染等。\n    \n3. **超大规模多输入多输出（MIMO）技术**：6G研发在超大规模MIMO技术方面取得了重要进展，这一技术能够有效提升频谱效率和网络容量。\n    \n4. **通感一体技术和内生AI通信**：6G技术的发展还包括了感知和通信的原生集成，无需额外的频谱和网络投资，每个移动终端、每个基站都能实现更高效的通信。同时，内生AI通信技术的应用也是6G研究的一个重点，这些技术的进步有助于提高通信效率和降低能耗。\n    \n6G技术在提升频谱效率和能量效率方面的最新研究进展主要包括太赫兹通信技术的应用、智能超表面技术的开发、超大规模MIMO技术的突破以及通感一体技术和内生AI通信技术的发展。这些技术的进步不仅能够提高通信的速度和质量，还能够降低能耗，对于未来的通信网络具有重要意义。\n\n#### 太赫兹通信技术在6G中的具体应用案例\n\n太赫兹通信技术在6G中的具体应用案例主要包括以下几个方面：\n\n1. **无人机网络**：太赫兹频段被设想用于无人机网络，作为6G非地面网络的预期用例之一。这包括监测和监视等应用场景。\n    \n2. **全息通信、微小尺寸通信、超大容量数据回传、短距超高速传输**：由于太赫兹频段具有超大带宽的频谱资源，支持超大速率的无线通信，因此在这些场景中有望得到应用。\n    \n3. **安全检测**：太赫兹波对很多非极性物质有很强的穿透能力，可以进行远距离探测和高分辨率的成像。这表明太赫兹技术在安全检测方面也有潜在的应用价值。\n    \n4. **小型化、3D立体成像、太赫兹质谱检测、太赫兹组网、移动性研究**：华为6G研究团队将持续推进对太赫兹通感一体化技术的研究和验证，这些研究方向包括小型化、3D立体成像、太赫兹质谱检测、太赫兹组网以及移动性等方面。\n    \n5. **无通线超宽带通信场景**：太赫兹通信技术将与其他低频段网络融合组网，广泛应用于地面的各种无通线超宽带通信场景，并将搭载卫星、无人机、飞艇等平台，作为替代方案。\n    \n\n太赫兹通信技术在6G中的应用案例涵盖了无人机网络、全息通信、微小尺寸通信、安全检测、小型化研究、3D立体成像、太赫兹质谱检测、太赫兹组网、移动性研究以及无通线超宽带通信等多个领域。\n\n#### 目前全球范围内6G技术研发的主要国家或组织以及主要贡献\n\n目前全球范围内6G技术研发的主要国家或组织包括中国、美国、日本等。他们的主要贡献如下：\n\n1. **中国**：中国在6G技术研发方面具有全球领先的战略布局和推进组织。自2019年起，中国建立了完善的6G推进组织，由工信部牵头成立中国IMT-2030（6G）推进组，旨在加强国际合作交流和技术研发。此外，江苏紫金山实验室宣布在太赫兹频段取得了全球最快的数据传输速度，标志着中国在6G技术上的重大进展。\n    \n2. **美国**：美国希望通过建立6G战略路线图、推动相关政策及预算、以及全球推广6G技术和服务来确立其在6G时代的领导地位。美国还通过了三项通信法案，以促进未来网络的发展。\n    \n3. **日本**：日本是全球率先出台6G国家战略的国家之一。2020年4月和6月，日本相继发布了全球首个以6G作为国家发展目标和倡议的综合战略计划纲要和路线图，提出了具体的实施目标，包括在2025年实现6G关键技术突破、2030年正式启用6G网络等。\n    \n\n这些国家或组织在6G技术研发方面的贡献主要体现在战略规划、技术研发、国际合作以及政策支持等方面。中国通过建立推进组织和取得技术突破展现了其在全球6G技术研发中的领先地位；美国则通过制定通信法案和推动政策预算来争取在6G时代的领导地位；而日本则通过出台国家战略和设定具体目标来推动本国6G技术的发展。\n\n#### 6G技术面临的最大技术挑战以及如何应对\n\n6G技术面临的最大技术挑战主要包括网络架构重建、关键应用挖潜、降低功耗等方面。此外，还有毫米波/太赫兹通信、空天地融合移动通信技术等前沿原创性技术的加强需求。为了应对这些挑战，目前的研究方向主要集中在加速6G无线、网络、安全等核心技术的产业化，以实现6G网络能力的跨越式发展来服务未来业务需求。同时，注重创新保障、产业支撑、扩大内需、人才保障，支持创新生态构建，形成6G发展的良好环境。此外，6G的研究还着重于探讨更高速率、更低时延、更大规模连接的技术目标，以及可能对6G产生重要影响的关键技术，如太赫兹通信、人工智能等。通过这些研究方向的努力，旨在推动6G技术的发展，以满足未来市场发展趋势和网络与业务需求。\n\n#### 基于5G/6G技术的智能交通系统设计思路及其潜在应用场景\n\n基于5G/6G技术的智能交通系统设计思路主要围绕利用先进的通信技术来提升交通系统的智能化水平，包括但不限于车路协同、自动驾驶、实时数据处理和分析等方面。具体来说，5G技术通过其高速率、低时延和大连接的特点，为智能交通系统提供了强大的支持。例如，5G可以实现智能网联车路协同系统，通过融合人、车、路、站台信息，打造新型智慧交通。此外，5G还能够支持应急联动，确保运行服务的安全。\n\n对于6G技术，虽然目前尚未广泛应用，但其潜在的应用场景包括全功能自动驾驶、高精度定位和高分辨率感知等。6G技术的研究重点在于提供更高速率、更低时延和更大容量的通信服务，这对于实现更高级别的自动驾驶和车联网系统至关重要。例如，6G赋能下的智能车联网系统将覆盖全域感知，这将极大促进智能交通系统的智能化发展。\n\n基于5G/6G技术的智能交通系统设计思路主要包括利用5G的高速率、低时延和大连接特性来支持智能网联车路协同系统，以及探索6G技术在全功能自动驾驶、高精度定位和高分辨率感知等方面的应用潜力。这些设计思路不仅能够提升交通系统的效率和安全性，还能够为未来的智能交通系统发展奠定基础。\n\n\n### 参考来源\n[1. [PDF] 2023年中国6G产业研究报告](https://pdf.dfcfw.com/pdf/H3_AP202305081586350769_1.pdf?1683579595000.pdf) [2023-05-08]\n\n[2. 目前 6g 技术在国内外的研究进展如何？ - 知乎](https://www.zhihu.com/question/267453362)\n\n[3. 6G：典型应用、关键技术与面临挑战](https://www.infocomm-journal.com/wlw/article/2022/2096-3750/2096-3750-6-1-00029.shtml)\n\n[4. 中兴通讯：6g移动通信网络愿景、挑战与关键技术 - 知乎](https://zhuanlan.zhihu.com/p/80139984)\n\n[5. 基于5G/6G技术的卫星互联网一体化安全研究](https://www.secrss.com/articles/56284) [2023-07-04]\n\n[6. 长篇综述 | 6G：天地无疆，万物无界_澎湃号·湃客_澎湃新闻-The Paper](https://www.thepaper.cn/newsDetail_forward_12424079)\n\n[7. [PDF] 6G 全球进展与发展展望白皮书 - 电子与信息学报](https://jeit.ac.cn/fileDZYXXXB_ONLY/cms/news/info/2021/06/fe6ef854d986465c88a0fe2e1b2e6de2/(0508)%E8%B5%9B%E8%BF%AA%E7%99%BD%E7%9A%AE%E4%B9%A6%EF%BC%9A%E3%80%8A6G%E5%85%A8%E7%90%83%E8%BF%9B%E5%B1%95%E4%B8%8E%E5%8F%91%E5%B1%95%E5%B1%95%E6%9C%9B%E7%99%BD%E7%9A%AE%E4%B9%A6%E3%80%8B.pdf)\n\n[8. 畅想6g时代!业内专家长篇综述：6g最新进展及未来发展趋势 - 知乎](https://zhuanlan.zhihu.com/p/337586644)\n\n[9. 中国信科陈山枝谈6G的三大挑战与三大突破](https://finance.sina.cn/tech/2023-07-03/detail-imyzkmwx2024200.d.html) [2023-07-03]\n\n[10. 权威专家解读：5G融合应用走深向实为6G发展夯实应用基础 - 数智](https://5gai.cctv.com/2023/12/11/ARTITV7eZ9OxdwnLpgPa3LqB231211.shtml) [2023-12-11]","source":"_posts/课程作业/6G技术发展报告.md","raw":"随着5G技术的全球部署和应用，6G技术的研究和探索已经悄然启动。预计6G将在2030年前后商用，带来比5G更高的速度、更低的延迟和更广泛的连接能力。6G不仅仅是速度的飞跃，它还将引入新的技术和架构，以支持更加智能、互联的世界。第6代移动通信技术（6G）是继5G之后的下一代通信技术，其研究和应用正处于探索阶段。\n\n### 国内外研究与应用现状\n\n总体来看，6G技术的研究和应用展现出了蓬勃的发展态势，不同国家和地区在推动6G技术进步方面各有侧重，共同构建了一个多元化、互联互通的6G研发生态。随着技术的不断突破和国际合作的深入，6G技术的未来将更加光明，预计将为人类社会带来更加广泛和深远的影响。\n\n随着全球对6G技术研究的深入，不同国家和地区在推进6G技术方面展现出了各自的特色和优势。在全球覆盖、频谱效率提升、能量效率优化、智能控制水平增强以及安全性方面，各研究机构和企业正通过前沿技术探索，共同推动6G技术的进步。\n\n#### 国内研究与应用\n\n中国在6G的研究和开发方面显著领先，不仅在全球专利申请量上占据重要地位，而且在关键技术研究上取得了突破。中国的研究机构和企业正致力于解决6G技术中的核心问题，如通过新型材料和设计提升信号在高频段的传播效率，开发低功耗设备和算法以提高能量效率，以及利用人工智能技术增强网络的自主管理能力和安全性。此外，中国政府也大力支持6G技术的研发，发布了多项政策和计划，旨在建立完善的6G研发和测试环境，加速6G技术的商业化进程。\n\n#### 国际研究与应用\n\n在国际上，芬兰的6G旗舰项目是6G研究的典范，它汇集了学术界和工业界的力量，共同探索6G的未来。该项目不仅关注技术层面的创新，如太赫兹通信、量子通信技术等，还着眼于6G可能带来的社会变革，比如智能交通、智慧城市和数字健康等应用场景。美国、欧盟、日本和韩国等也都在积极推进6G研究，这些地区的研究计划通常强调开放性和国际合作，旨在建立全球统一的6G标准和生态系统。\n\n#### 专利和标准化工作\n\n在6G的研究和开发过程中，专利和标准化工作是不可忽视的方面。全球专利申请量的增加反映了国际社会对6G技术的高度重视和活跃的研发态势。中国在专利申请方面的领先地位显示了其在6G技术研发方面的强大动力和潜力。同时，国际电信联盟（ITU）、3GPP等国际标准化组织已开始讨论6G的标准化问题，旨在促进全球6G技术的统一和互操作性，确保6G技术的健康发展和广泛应用。\n\n### 采用的技术手段\n\n6G将使用太赫兹通信技术，这是其最大的优点之一，因为太赫兹频段具有大带宽和高传输速率的特点，非常适合未来高带宽业务场景。此外，6G还将利用卫星通信、无人机通信、地面通信和海上通信，实现\"太空-空中-地面-海洋\"一体化网络。这些技术手段的结合，将为6G提供更广泛的覆盖范围和更低的成本。\n\n### 发展方向和挑战\n\n6G的发展方向包括智慧连接、深度连接、全息连接和泛在连接。这些方向共同构成了6G总体愿景，即\"一念天地，万物随心\"。然而，实现这一愿景面临诸多挑战，包括峰值吞吐量、更高能效、随时随地的连接等技术需求。此外，6G极致体验需求挑战以及技术进步，共同驱动了对核心技术研究和国际标准制定的需求。\n\n#### 技术需求挑战\n- **峰值吞吐量**：为了支持全息通信等高带宽应用，6G网络需要实现Tbps级别的数据传输速度，这要求开发更高效的信号处理和数据传输技术。\n- **更高能效**：随着网络速度的提升和连接设备数量的增加，如何在保证性能的同时降低能耗成为一大挑战，这需要研发新的能效优化技术和低功耗硬件。\n- **随时随地的连接**：实现深度连接和泛在连接的愿景，需要克服复杂环境下的信号传播问题，开发新的通信技术和设备。\n#### 极致体验需求挑战\n\n为了满足用户对于极致体验的需求，6G网络必须提供几乎零延迟的实时响应和高度可靠的连接，这对网络架构和技术实现提出了更高要求。\n#### 核心技术研究和国际标准制定\n\n实现6G愿景还需要在核心技术上取得突破，包括但不限于太赫兹通信、量子通信、人工智能、分布式网络架构等。同时，为了确保6G技术的全球兼容和互操作性，开展国际标准的制定工作至关重要，需要国际社会的共同努力和协作。\n\n### 基于5G的应用场景设计\n\n基于5G/6G技术的卫星互联网一体化安全研究提出了未来5G/6G卫星互联网发展及业务应用场景的设计思路。例如，可以设计一个基于5G/6G技术的智能交通系统，该系统通过集成卫星通信、无人机通信等技术手段，实现全球范围内的实时交通监控和管理。在这个场景中，5G/6G技术能够提供高速的数据传输速率和低时延，确保交通管理系统能够快速响应各种紧急情况，从而提高交通安全性和效率。\n\n\n#### 6G技术在提升频谱效率和能量效率方面的最新研究进展\n\n6G技术在提升频谱效率和能量效率方面的最新研究进展主要体现在以下几个方面：\n\n1. **太赫兹通信技术**：太赫兹波段的利用是6G技术发展的一个重要方向。中国航天科工二院二十五所完成了国内首次太赫兹轨道角动量的实时无线传输通信实验，这为6G通信提供了新的技术支持，有助于缓解太赫兹波段频谱资源不足的问题。此外，太赫兹量子级联激光器和单行载流子光电探测器等关键技术的发展，也为6G技术的应用提供了可能。\n\n2. **智能超表面技术**：智能超表面技术被用于通信系统中，以增强覆盖并显著提升网络传输速率、信号覆盖以及能量效率。通过对无线传播环境的主动定制，可以根据所需无线功能进行调整，如减小电磁污染等。\n    \n3. **超大规模多输入多输出（MIMO）技术**：6G研发在超大规模MIMO技术方面取得了重要进展，这一技术能够有效提升频谱效率和网络容量。\n    \n4. **通感一体技术和内生AI通信**：6G技术的发展还包括了感知和通信的原生集成，无需额外的频谱和网络投资，每个移动终端、每个基站都能实现更高效的通信。同时，内生AI通信技术的应用也是6G研究的一个重点，这些技术的进步有助于提高通信效率和降低能耗。\n    \n6G技术在提升频谱效率和能量效率方面的最新研究进展主要包括太赫兹通信技术的应用、智能超表面技术的开发、超大规模MIMO技术的突破以及通感一体技术和内生AI通信技术的发展。这些技术的进步不仅能够提高通信的速度和质量，还能够降低能耗，对于未来的通信网络具有重要意义。\n\n#### 太赫兹通信技术在6G中的具体应用案例\n\n太赫兹通信技术在6G中的具体应用案例主要包括以下几个方面：\n\n1. **无人机网络**：太赫兹频段被设想用于无人机网络，作为6G非地面网络的预期用例之一。这包括监测和监视等应用场景。\n    \n2. **全息通信、微小尺寸通信、超大容量数据回传、短距超高速传输**：由于太赫兹频段具有超大带宽的频谱资源，支持超大速率的无线通信，因此在这些场景中有望得到应用。\n    \n3. **安全检测**：太赫兹波对很多非极性物质有很强的穿透能力，可以进行远距离探测和高分辨率的成像。这表明太赫兹技术在安全检测方面也有潜在的应用价值。\n    \n4. **小型化、3D立体成像、太赫兹质谱检测、太赫兹组网、移动性研究**：华为6G研究团队将持续推进对太赫兹通感一体化技术的研究和验证，这些研究方向包括小型化、3D立体成像、太赫兹质谱检测、太赫兹组网以及移动性等方面。\n    \n5. **无通线超宽带通信场景**：太赫兹通信技术将与其他低频段网络融合组网，广泛应用于地面的各种无通线超宽带通信场景，并将搭载卫星、无人机、飞艇等平台，作为替代方案。\n    \n\n太赫兹通信技术在6G中的应用案例涵盖了无人机网络、全息通信、微小尺寸通信、安全检测、小型化研究、3D立体成像、太赫兹质谱检测、太赫兹组网、移动性研究以及无通线超宽带通信等多个领域。\n\n#### 目前全球范围内6G技术研发的主要国家或组织以及主要贡献\n\n目前全球范围内6G技术研发的主要国家或组织包括中国、美国、日本等。他们的主要贡献如下：\n\n1. **中国**：中国在6G技术研发方面具有全球领先的战略布局和推进组织。自2019年起，中国建立了完善的6G推进组织，由工信部牵头成立中国IMT-2030（6G）推进组，旨在加强国际合作交流和技术研发。此外，江苏紫金山实验室宣布在太赫兹频段取得了全球最快的数据传输速度，标志着中国在6G技术上的重大进展。\n    \n2. **美国**：美国希望通过建立6G战略路线图、推动相关政策及预算、以及全球推广6G技术和服务来确立其在6G时代的领导地位。美国还通过了三项通信法案，以促进未来网络的发展。\n    \n3. **日本**：日本是全球率先出台6G国家战略的国家之一。2020年4月和6月，日本相继发布了全球首个以6G作为国家发展目标和倡议的综合战略计划纲要和路线图，提出了具体的实施目标，包括在2025年实现6G关键技术突破、2030年正式启用6G网络等。\n    \n\n这些国家或组织在6G技术研发方面的贡献主要体现在战略规划、技术研发、国际合作以及政策支持等方面。中国通过建立推进组织和取得技术突破展现了其在全球6G技术研发中的领先地位；美国则通过制定通信法案和推动政策预算来争取在6G时代的领导地位；而日本则通过出台国家战略和设定具体目标来推动本国6G技术的发展。\n\n#### 6G技术面临的最大技术挑战以及如何应对\n\n6G技术面临的最大技术挑战主要包括网络架构重建、关键应用挖潜、降低功耗等方面。此外，还有毫米波/太赫兹通信、空天地融合移动通信技术等前沿原创性技术的加强需求。为了应对这些挑战，目前的研究方向主要集中在加速6G无线、网络、安全等核心技术的产业化，以实现6G网络能力的跨越式发展来服务未来业务需求。同时，注重创新保障、产业支撑、扩大内需、人才保障，支持创新生态构建，形成6G发展的良好环境。此外，6G的研究还着重于探讨更高速率、更低时延、更大规模连接的技术目标，以及可能对6G产生重要影响的关键技术，如太赫兹通信、人工智能等。通过这些研究方向的努力，旨在推动6G技术的发展，以满足未来市场发展趋势和网络与业务需求。\n\n#### 基于5G/6G技术的智能交通系统设计思路及其潜在应用场景\n\n基于5G/6G技术的智能交通系统设计思路主要围绕利用先进的通信技术来提升交通系统的智能化水平，包括但不限于车路协同、自动驾驶、实时数据处理和分析等方面。具体来说，5G技术通过其高速率、低时延和大连接的特点，为智能交通系统提供了强大的支持。例如，5G可以实现智能网联车路协同系统，通过融合人、车、路、站台信息，打造新型智慧交通。此外，5G还能够支持应急联动，确保运行服务的安全。\n\n对于6G技术，虽然目前尚未广泛应用，但其潜在的应用场景包括全功能自动驾驶、高精度定位和高分辨率感知等。6G技术的研究重点在于提供更高速率、更低时延和更大容量的通信服务，这对于实现更高级别的自动驾驶和车联网系统至关重要。例如，6G赋能下的智能车联网系统将覆盖全域感知，这将极大促进智能交通系统的智能化发展。\n\n基于5G/6G技术的智能交通系统设计思路主要包括利用5G的高速率、低时延和大连接特性来支持智能网联车路协同系统，以及探索6G技术在全功能自动驾驶、高精度定位和高分辨率感知等方面的应用潜力。这些设计思路不仅能够提升交通系统的效率和安全性，还能够为未来的智能交通系统发展奠定基础。\n\n\n### 参考来源\n[1. [PDF] 2023年中国6G产业研究报告](https://pdf.dfcfw.com/pdf/H3_AP202305081586350769_1.pdf?1683579595000.pdf) [2023-05-08]\n\n[2. 目前 6g 技术在国内外的研究进展如何？ - 知乎](https://www.zhihu.com/question/267453362)\n\n[3. 6G：典型应用、关键技术与面临挑战](https://www.infocomm-journal.com/wlw/article/2022/2096-3750/2096-3750-6-1-00029.shtml)\n\n[4. 中兴通讯：6g移动通信网络愿景、挑战与关键技术 - 知乎](https://zhuanlan.zhihu.com/p/80139984)\n\n[5. 基于5G/6G技术的卫星互联网一体化安全研究](https://www.secrss.com/articles/56284) [2023-07-04]\n\n[6. 长篇综述 | 6G：天地无疆，万物无界_澎湃号·湃客_澎湃新闻-The Paper](https://www.thepaper.cn/newsDetail_forward_12424079)\n\n[7. [PDF] 6G 全球进展与发展展望白皮书 - 电子与信息学报](https://jeit.ac.cn/fileDZYXXXB_ONLY/cms/news/info/2021/06/fe6ef854d986465c88a0fe2e1b2e6de2/(0508)%E8%B5%9B%E8%BF%AA%E7%99%BD%E7%9A%AE%E4%B9%A6%EF%BC%9A%E3%80%8A6G%E5%85%A8%E7%90%83%E8%BF%9B%E5%B1%95%E4%B8%8E%E5%8F%91%E5%B1%95%E5%B1%95%E6%9C%9B%E7%99%BD%E7%9A%AE%E4%B9%A6%E3%80%8B.pdf)\n\n[8. 畅想6g时代!业内专家长篇综述：6g最新进展及未来发展趋势 - 知乎](https://zhuanlan.zhihu.com/p/337586644)\n\n[9. 中国信科陈山枝谈6G的三大挑战与三大突破](https://finance.sina.cn/tech/2023-07-03/detail-imyzkmwx2024200.d.html) [2023-07-03]\n\n[10. 权威专家解读：5G融合应用走深向实为6G发展夯实应用基础 - 数智](https://5gai.cctv.com/2023/12/11/ARTITV7eZ9OxdwnLpgPa3LqB231211.shtml) [2023-12-11]","slug":"课程作业/6G技术发展报告","published":1,"date":"2024-04-22T13:14:48.794Z","updated":"2024-03-11T07:00:02.171Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0h001akgg4cb206rw2","content":"<p>随着5G技术的全球部署和应用，6G技术的研究和探索已经悄然启动。预计6G将在2030年前后商用，带来比5G更高的速度、更低的延迟和更广泛的连接能力。6G不仅仅是速度的飞跃，它还将引入新的技术和架构，以支持更加智能、互联的世界。第6代移动通信技术（6G）是继5G之后的下一代通信技术，其研究和应用正处于探索阶段。</p>\n<h3 id=\"国内外研究与应用现状\"><a href=\"#国内外研究与应用现状\" class=\"headerlink\" title=\"国内外研究与应用现状\"></a>国内外研究与应用现状</h3><p>总体来看，6G技术的研究和应用展现出了蓬勃的发展态势，不同国家和地区在推动6G技术进步方面各有侧重，共同构建了一个多元化、互联互通的6G研发生态。随着技术的不断突破和国际合作的深入，6G技术的未来将更加光明，预计将为人类社会带来更加广泛和深远的影响。</p>\n<p>随着全球对6G技术研究的深入，不同国家和地区在推进6G技术方面展现出了各自的特色和优势。在全球覆盖、频谱效率提升、能量效率优化、智能控制水平增强以及安全性方面，各研究机构和企业正通过前沿技术探索，共同推动6G技术的进步。</p>\n<h4 id=\"国内研究与应用\"><a href=\"#国内研究与应用\" class=\"headerlink\" title=\"国内研究与应用\"></a>国内研究与应用</h4><p>中国在6G的研究和开发方面显著领先，不仅在全球专利申请量上占据重要地位，而且在关键技术研究上取得了突破。中国的研究机构和企业正致力于解决6G技术中的核心问题，如通过新型材料和设计提升信号在高频段的传播效率，开发低功耗设备和算法以提高能量效率，以及利用人工智能技术增强网络的自主管理能力和安全性。此外，中国政府也大力支持6G技术的研发，发布了多项政策和计划，旨在建立完善的6G研发和测试环境，加速6G技术的商业化进程。</p>\n<h4 id=\"国际研究与应用\"><a href=\"#国际研究与应用\" class=\"headerlink\" title=\"国际研究与应用\"></a>国际研究与应用</h4><p>在国际上，芬兰的6G旗舰项目是6G研究的典范，它汇集了学术界和工业界的力量，共同探索6G的未来。该项目不仅关注技术层面的创新，如太赫兹通信、量子通信技术等，还着眼于6G可能带来的社会变革，比如智能交通、智慧城市和数字健康等应用场景。美国、欧盟、日本和韩国等也都在积极推进6G研究，这些地区的研究计划通常强调开放性和国际合作，旨在建立全球统一的6G标准和生态系统。</p>\n<h4 id=\"专利和标准化工作\"><a href=\"#专利和标准化工作\" class=\"headerlink\" title=\"专利和标准化工作\"></a>专利和标准化工作</h4><p>在6G的研究和开发过程中，专利和标准化工作是不可忽视的方面。全球专利申请量的增加反映了国际社会对6G技术的高度重视和活跃的研发态势。中国在专利申请方面的领先地位显示了其在6G技术研发方面的强大动力和潜力。同时，国际电信联盟（ITU）、3GPP等国际标准化组织已开始讨论6G的标准化问题，旨在促进全球6G技术的统一和互操作性，确保6G技术的健康发展和广泛应用。</p>\n<h3 id=\"采用的技术手段\"><a href=\"#采用的技术手段\" class=\"headerlink\" title=\"采用的技术手段\"></a>采用的技术手段</h3><p>6G将使用太赫兹通信技术，这是其最大的优点之一，因为太赫兹频段具有大带宽和高传输速率的特点，非常适合未来高带宽业务场景。此外，6G还将利用卫星通信、无人机通信、地面通信和海上通信，实现”太空-空中-地面-海洋”一体化网络。这些技术手段的结合，将为6G提供更广泛的覆盖范围和更低的成本。</p>\n<h3 id=\"发展方向和挑战\"><a href=\"#发展方向和挑战\" class=\"headerlink\" title=\"发展方向和挑战\"></a>发展方向和挑战</h3><p>6G的发展方向包括智慧连接、深度连接、全息连接和泛在连接。这些方向共同构成了6G总体愿景，即”一念天地，万物随心”。然而，实现这一愿景面临诸多挑战，包括峰值吞吐量、更高能效、随时随地的连接等技术需求。此外，6G极致体验需求挑战以及技术进步，共同驱动了对核心技术研究和国际标准制定的需求。</p>\n<h4 id=\"技术需求挑战\"><a href=\"#技术需求挑战\" class=\"headerlink\" title=\"技术需求挑战\"></a>技术需求挑战</h4><ul>\n<li><strong>峰值吞吐量</strong>：为了支持全息通信等高带宽应用，6G网络需要实现Tbps级别的数据传输速度，这要求开发更高效的信号处理和数据传输技术。</li>\n<li><strong>更高能效</strong>：随着网络速度的提升和连接设备数量的增加，如何在保证性能的同时降低能耗成为一大挑战，这需要研发新的能效优化技术和低功耗硬件。</li>\n<li><strong>随时随地的连接</strong>：实现深度连接和泛在连接的愿景，需要克服复杂环境下的信号传播问题，开发新的通信技术和设备。</li>\n</ul>\n<h4 id=\"极致体验需求挑战\"><a href=\"#极致体验需求挑战\" class=\"headerlink\" title=\"极致体验需求挑战\"></a>极致体验需求挑战</h4><p>为了满足用户对于极致体验的需求，6G网络必须提供几乎零延迟的实时响应和高度可靠的连接，这对网络架构和技术实现提出了更高要求。</p>\n<h4 id=\"核心技术研究和国际标准制定\"><a href=\"#核心技术研究和国际标准制定\" class=\"headerlink\" title=\"核心技术研究和国际标准制定\"></a>核心技术研究和国际标准制定</h4><p>实现6G愿景还需要在核心技术上取得突破，包括但不限于太赫兹通信、量子通信、人工智能、分布式网络架构等。同时，为了确保6G技术的全球兼容和互操作性，开展国际标准的制定工作至关重要，需要国际社会的共同努力和协作。</p>\n<h3 id=\"基于5G的应用场景设计\"><a href=\"#基于5G的应用场景设计\" class=\"headerlink\" title=\"基于5G的应用场景设计\"></a>基于5G的应用场景设计</h3><p>基于5G&#x2F;6G技术的卫星互联网一体化安全研究提出了未来5G&#x2F;6G卫星互联网发展及业务应用场景的设计思路。例如，可以设计一个基于5G&#x2F;6G技术的智能交通系统，该系统通过集成卫星通信、无人机通信等技术手段，实现全球范围内的实时交通监控和管理。在这个场景中，5G&#x2F;6G技术能够提供高速的数据传输速率和低时延，确保交通管理系统能够快速响应各种紧急情况，从而提高交通安全性和效率。</p>\n<h4 id=\"6G技术在提升频谱效率和能量效率方面的最新研究进展\"><a href=\"#6G技术在提升频谱效率和能量效率方面的最新研究进展\" class=\"headerlink\" title=\"6G技术在提升频谱效率和能量效率方面的最新研究进展\"></a>6G技术在提升频谱效率和能量效率方面的最新研究进展</h4><p>6G技术在提升频谱效率和能量效率方面的最新研究进展主要体现在以下几个方面：</p>\n<ol>\n<li><p><strong>太赫兹通信技术</strong>：太赫兹波段的利用是6G技术发展的一个重要方向。中国航天科工二院二十五所完成了国内首次太赫兹轨道角动量的实时无线传输通信实验，这为6G通信提供了新的技术支持，有助于缓解太赫兹波段频谱资源不足的问题。此外，太赫兹量子级联激光器和单行载流子光电探测器等关键技术的发展，也为6G技术的应用提供了可能。</p>\n</li>\n<li><p><strong>智能超表面技术</strong>：智能超表面技术被用于通信系统中，以增强覆盖并显著提升网络传输速率、信号覆盖以及能量效率。通过对无线传播环境的主动定制，可以根据所需无线功能进行调整，如减小电磁污染等。</p>\n</li>\n<li><p><strong>超大规模多输入多输出（MIMO）技术</strong>：6G研发在超大规模MIMO技术方面取得了重要进展，这一技术能够有效提升频谱效率和网络容量。</p>\n</li>\n<li><p><strong>通感一体技术和内生AI通信</strong>：6G技术的发展还包括了感知和通信的原生集成，无需额外的频谱和网络投资，每个移动终端、每个基站都能实现更高效的通信。同时，内生AI通信技术的应用也是6G研究的一个重点，这些技术的进步有助于提高通信效率和降低能耗。</p>\n</li>\n</ol>\n<p>6G技术在提升频谱效率和能量效率方面的最新研究进展主要包括太赫兹通信技术的应用、智能超表面技术的开发、超大规模MIMO技术的突破以及通感一体技术和内生AI通信技术的发展。这些技术的进步不仅能够提高通信的速度和质量，还能够降低能耗，对于未来的通信网络具有重要意义。</p>\n<h4 id=\"太赫兹通信技术在6G中的具体应用案例\"><a href=\"#太赫兹通信技术在6G中的具体应用案例\" class=\"headerlink\" title=\"太赫兹通信技术在6G中的具体应用案例\"></a>太赫兹通信技术在6G中的具体应用案例</h4><p>太赫兹通信技术在6G中的具体应用案例主要包括以下几个方面：</p>\n<ol>\n<li><p><strong>无人机网络</strong>：太赫兹频段被设想用于无人机网络，作为6G非地面网络的预期用例之一。这包括监测和监视等应用场景。</p>\n</li>\n<li><p><strong>全息通信、微小尺寸通信、超大容量数据回传、短距超高速传输</strong>：由于太赫兹频段具有超大带宽的频谱资源，支持超大速率的无线通信，因此在这些场景中有望得到应用。</p>\n</li>\n<li><p><strong>安全检测</strong>：太赫兹波对很多非极性物质有很强的穿透能力，可以进行远距离探测和高分辨率的成像。这表明太赫兹技术在安全检测方面也有潜在的应用价值。</p>\n</li>\n<li><p><strong>小型化、3D立体成像、太赫兹质谱检测、太赫兹组网、移动性研究</strong>：华为6G研究团队将持续推进对太赫兹通感一体化技术的研究和验证，这些研究方向包括小型化、3D立体成像、太赫兹质谱检测、太赫兹组网以及移动性等方面。</p>\n</li>\n<li><p><strong>无通线超宽带通信场景</strong>：太赫兹通信技术将与其他低频段网络融合组网，广泛应用于地面的各种无通线超宽带通信场景，并将搭载卫星、无人机、飞艇等平台，作为替代方案。</p>\n</li>\n</ol>\n<p>太赫兹通信技术在6G中的应用案例涵盖了无人机网络、全息通信、微小尺寸通信、安全检测、小型化研究、3D立体成像、太赫兹质谱检测、太赫兹组网、移动性研究以及无通线超宽带通信等多个领域。</p>\n<h4 id=\"目前全球范围内6G技术研发的主要国家或组织以及主要贡献\"><a href=\"#目前全球范围内6G技术研发的主要国家或组织以及主要贡献\" class=\"headerlink\" title=\"目前全球范围内6G技术研发的主要国家或组织以及主要贡献\"></a>目前全球范围内6G技术研发的主要国家或组织以及主要贡献</h4><p>目前全球范围内6G技术研发的主要国家或组织包括中国、美国、日本等。他们的主要贡献如下：</p>\n<ol>\n<li><p><strong>中国</strong>：中国在6G技术研发方面具有全球领先的战略布局和推进组织。自2019年起，中国建立了完善的6G推进组织，由工信部牵头成立中国IMT-2030（6G）推进组，旨在加强国际合作交流和技术研发。此外，江苏紫金山实验室宣布在太赫兹频段取得了全球最快的数据传输速度，标志着中国在6G技术上的重大进展。</p>\n</li>\n<li><p><strong>美国</strong>：美国希望通过建立6G战略路线图、推动相关政策及预算、以及全球推广6G技术和服务来确立其在6G时代的领导地位。美国还通过了三项通信法案，以促进未来网络的发展。</p>\n</li>\n<li><p><strong>日本</strong>：日本是全球率先出台6G国家战略的国家之一。2020年4月和6月，日本相继发布了全球首个以6G作为国家发展目标和倡议的综合战略计划纲要和路线图，提出了具体的实施目标，包括在2025年实现6G关键技术突破、2030年正式启用6G网络等。</p>\n</li>\n</ol>\n<p>这些国家或组织在6G技术研发方面的贡献主要体现在战略规划、技术研发、国际合作以及政策支持等方面。中国通过建立推进组织和取得技术突破展现了其在全球6G技术研发中的领先地位；美国则通过制定通信法案和推动政策预算来争取在6G时代的领导地位；而日本则通过出台国家战略和设定具体目标来推动本国6G技术的发展。</p>\n<h4 id=\"6G技术面临的最大技术挑战以及如何应对\"><a href=\"#6G技术面临的最大技术挑战以及如何应对\" class=\"headerlink\" title=\"6G技术面临的最大技术挑战以及如何应对\"></a>6G技术面临的最大技术挑战以及如何应对</h4><p>6G技术面临的最大技术挑战主要包括网络架构重建、关键应用挖潜、降低功耗等方面。此外，还有毫米波&#x2F;太赫兹通信、空天地融合移动通信技术等前沿原创性技术的加强需求。为了应对这些挑战，目前的研究方向主要集中在加速6G无线、网络、安全等核心技术的产业化，以实现6G网络能力的跨越式发展来服务未来业务需求。同时，注重创新保障、产业支撑、扩大内需、人才保障，支持创新生态构建，形成6G发展的良好环境。此外，6G的研究还着重于探讨更高速率、更低时延、更大规模连接的技术目标，以及可能对6G产生重要影响的关键技术，如太赫兹通信、人工智能等。通过这些研究方向的努力，旨在推动6G技术的发展，以满足未来市场发展趋势和网络与业务需求。</p>\n<h4 id=\"基于5G-6G技术的智能交通系统设计思路及其潜在应用场景\"><a href=\"#基于5G-6G技术的智能交通系统设计思路及其潜在应用场景\" class=\"headerlink\" title=\"基于5G&#x2F;6G技术的智能交通系统设计思路及其潜在应用场景\"></a>基于5G&#x2F;6G技术的智能交通系统设计思路及其潜在应用场景</h4><p>基于5G&#x2F;6G技术的智能交通系统设计思路主要围绕利用先进的通信技术来提升交通系统的智能化水平，包括但不限于车路协同、自动驾驶、实时数据处理和分析等方面。具体来说，5G技术通过其高速率、低时延和大连接的特点，为智能交通系统提供了强大的支持。例如，5G可以实现智能网联车路协同系统，通过融合人、车、路、站台信息，打造新型智慧交通。此外，5G还能够支持应急联动，确保运行服务的安全。</p>\n<p>对于6G技术，虽然目前尚未广泛应用，但其潜在的应用场景包括全功能自动驾驶、高精度定位和高分辨率感知等。6G技术的研究重点在于提供更高速率、更低时延和更大容量的通信服务，这对于实现更高级别的自动驾驶和车联网系统至关重要。例如，6G赋能下的智能车联网系统将覆盖全域感知，这将极大促进智能交通系统的智能化发展。</p>\n<p>基于5G&#x2F;6G技术的智能交通系统设计思路主要包括利用5G的高速率、低时延和大连接特性来支持智能网联车路协同系统，以及探索6G技术在全功能自动驾驶、高精度定位和高分辨率感知等方面的应用潜力。这些设计思路不仅能够提升交通系统的效率和安全性，还能够为未来的智能交通系统发展奠定基础。</p>\n<h3 id=\"参考来源\"><a href=\"#参考来源\" class=\"headerlink\" title=\"参考来源\"></a>参考来源</h3><p><a href=\"https://pdf.dfcfw.com/pdf/H3_AP202305081586350769_1.pdf?1683579595000.pdf\">1. [PDF] 2023年中国6G产业研究报告</a> [2023-05-08]</p>\n<p><a href=\"https://www.zhihu.com/question/267453362\">2. 目前 6g 技术在国内外的研究进展如何？ - 知乎</a></p>\n<p><a href=\"https://www.infocomm-journal.com/wlw/article/2022/2096-3750/2096-3750-6-1-00029.shtml\">3. 6G：典型应用、关键技术与面临挑战</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/80139984\">4. 中兴通讯：6g移动通信网络愿景、挑战与关键技术 - 知乎</a></p>\n<p><a href=\"https://www.secrss.com/articles/56284\">5. 基于5G&#x2F;6G技术的卫星互联网一体化安全研究</a> [2023-07-04]</p>\n<p><a href=\"https://www.thepaper.cn/newsDetail_forward_12424079\">6. 长篇综述 | 6G：天地无疆，万物无界_澎湃号·湃客_澎湃新闻-The Paper</a></p>\n<p><a href=\"https://jeit.ac.cn/fileDZYXXXB_ONLY/cms/news/info/2021/06/fe6ef854d986465c88a0fe2e1b2e6de2/(0508)%E8%B5%9B%E8%BF%AA%E7%99%BD%E7%9A%AE%E4%B9%A6%EF%BC%9A%E3%80%8A6G%E5%85%A8%E7%90%83%E8%BF%9B%E5%B1%95%E4%B8%8E%E5%8F%91%E5%B1%95%E5%B1%95%E6%9C%9B%E7%99%BD%E7%9A%AE%E4%B9%A6%E3%80%8B.pdf\">7. [PDF] 6G 全球进展与发展展望白皮书 - 电子与信息学报</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/337586644\">8. 畅想6g时代!业内专家长篇综述：6g最新进展及未来发展趋势 - 知乎</a></p>\n<p><a href=\"https://finance.sina.cn/tech/2023-07-03/detail-imyzkmwx2024200.d.html\">9. 中国信科陈山枝谈6G的三大挑战与三大突破</a> [2023-07-03]</p>\n<p><a href=\"https://5gai.cctv.com/2023/12/11/ARTITV7eZ9OxdwnLpgPa3LqB231211.shtml\">10. 权威专家解读：5G融合应用走深向实为6G发展夯实应用基础 - 数智</a> [2023-12-11]</p>\n","excerpt":"","more":"<p>随着5G技术的全球部署和应用，6G技术的研究和探索已经悄然启动。预计6G将在2030年前后商用，带来比5G更高的速度、更低的延迟和更广泛的连接能力。6G不仅仅是速度的飞跃，它还将引入新的技术和架构，以支持更加智能、互联的世界。第6代移动通信技术（6G）是继5G之后的下一代通信技术，其研究和应用正处于探索阶段。</p>\n<h3 id=\"国内外研究与应用现状\"><a href=\"#国内外研究与应用现状\" class=\"headerlink\" title=\"国内外研究与应用现状\"></a>国内外研究与应用现状</h3><p>总体来看，6G技术的研究和应用展现出了蓬勃的发展态势，不同国家和地区在推动6G技术进步方面各有侧重，共同构建了一个多元化、互联互通的6G研发生态。随着技术的不断突破和国际合作的深入，6G技术的未来将更加光明，预计将为人类社会带来更加广泛和深远的影响。</p>\n<p>随着全球对6G技术研究的深入，不同国家和地区在推进6G技术方面展现出了各自的特色和优势。在全球覆盖、频谱效率提升、能量效率优化、智能控制水平增强以及安全性方面，各研究机构和企业正通过前沿技术探索，共同推动6G技术的进步。</p>\n<h4 id=\"国内研究与应用\"><a href=\"#国内研究与应用\" class=\"headerlink\" title=\"国内研究与应用\"></a>国内研究与应用</h4><p>中国在6G的研究和开发方面显著领先，不仅在全球专利申请量上占据重要地位，而且在关键技术研究上取得了突破。中国的研究机构和企业正致力于解决6G技术中的核心问题，如通过新型材料和设计提升信号在高频段的传播效率，开发低功耗设备和算法以提高能量效率，以及利用人工智能技术增强网络的自主管理能力和安全性。此外，中国政府也大力支持6G技术的研发，发布了多项政策和计划，旨在建立完善的6G研发和测试环境，加速6G技术的商业化进程。</p>\n<h4 id=\"国际研究与应用\"><a href=\"#国际研究与应用\" class=\"headerlink\" title=\"国际研究与应用\"></a>国际研究与应用</h4><p>在国际上，芬兰的6G旗舰项目是6G研究的典范，它汇集了学术界和工业界的力量，共同探索6G的未来。该项目不仅关注技术层面的创新，如太赫兹通信、量子通信技术等，还着眼于6G可能带来的社会变革，比如智能交通、智慧城市和数字健康等应用场景。美国、欧盟、日本和韩国等也都在积极推进6G研究，这些地区的研究计划通常强调开放性和国际合作，旨在建立全球统一的6G标准和生态系统。</p>\n<h4 id=\"专利和标准化工作\"><a href=\"#专利和标准化工作\" class=\"headerlink\" title=\"专利和标准化工作\"></a>专利和标准化工作</h4><p>在6G的研究和开发过程中，专利和标准化工作是不可忽视的方面。全球专利申请量的增加反映了国际社会对6G技术的高度重视和活跃的研发态势。中国在专利申请方面的领先地位显示了其在6G技术研发方面的强大动力和潜力。同时，国际电信联盟（ITU）、3GPP等国际标准化组织已开始讨论6G的标准化问题，旨在促进全球6G技术的统一和互操作性，确保6G技术的健康发展和广泛应用。</p>\n<h3 id=\"采用的技术手段\"><a href=\"#采用的技术手段\" class=\"headerlink\" title=\"采用的技术手段\"></a>采用的技术手段</h3><p>6G将使用太赫兹通信技术，这是其最大的优点之一，因为太赫兹频段具有大带宽和高传输速率的特点，非常适合未来高带宽业务场景。此外，6G还将利用卫星通信、无人机通信、地面通信和海上通信，实现”太空-空中-地面-海洋”一体化网络。这些技术手段的结合，将为6G提供更广泛的覆盖范围和更低的成本。</p>\n<h3 id=\"发展方向和挑战\"><a href=\"#发展方向和挑战\" class=\"headerlink\" title=\"发展方向和挑战\"></a>发展方向和挑战</h3><p>6G的发展方向包括智慧连接、深度连接、全息连接和泛在连接。这些方向共同构成了6G总体愿景，即”一念天地，万物随心”。然而，实现这一愿景面临诸多挑战，包括峰值吞吐量、更高能效、随时随地的连接等技术需求。此外，6G极致体验需求挑战以及技术进步，共同驱动了对核心技术研究和国际标准制定的需求。</p>\n<h4 id=\"技术需求挑战\"><a href=\"#技术需求挑战\" class=\"headerlink\" title=\"技术需求挑战\"></a>技术需求挑战</h4><ul>\n<li><strong>峰值吞吐量</strong>：为了支持全息通信等高带宽应用，6G网络需要实现Tbps级别的数据传输速度，这要求开发更高效的信号处理和数据传输技术。</li>\n<li><strong>更高能效</strong>：随着网络速度的提升和连接设备数量的增加，如何在保证性能的同时降低能耗成为一大挑战，这需要研发新的能效优化技术和低功耗硬件。</li>\n<li><strong>随时随地的连接</strong>：实现深度连接和泛在连接的愿景，需要克服复杂环境下的信号传播问题，开发新的通信技术和设备。</li>\n</ul>\n<h4 id=\"极致体验需求挑战\"><a href=\"#极致体验需求挑战\" class=\"headerlink\" title=\"极致体验需求挑战\"></a>极致体验需求挑战</h4><p>为了满足用户对于极致体验的需求，6G网络必须提供几乎零延迟的实时响应和高度可靠的连接，这对网络架构和技术实现提出了更高要求。</p>\n<h4 id=\"核心技术研究和国际标准制定\"><a href=\"#核心技术研究和国际标准制定\" class=\"headerlink\" title=\"核心技术研究和国际标准制定\"></a>核心技术研究和国际标准制定</h4><p>实现6G愿景还需要在核心技术上取得突破，包括但不限于太赫兹通信、量子通信、人工智能、分布式网络架构等。同时，为了确保6G技术的全球兼容和互操作性，开展国际标准的制定工作至关重要，需要国际社会的共同努力和协作。</p>\n<h3 id=\"基于5G的应用场景设计\"><a href=\"#基于5G的应用场景设计\" class=\"headerlink\" title=\"基于5G的应用场景设计\"></a>基于5G的应用场景设计</h3><p>基于5G&#x2F;6G技术的卫星互联网一体化安全研究提出了未来5G&#x2F;6G卫星互联网发展及业务应用场景的设计思路。例如，可以设计一个基于5G&#x2F;6G技术的智能交通系统，该系统通过集成卫星通信、无人机通信等技术手段，实现全球范围内的实时交通监控和管理。在这个场景中，5G&#x2F;6G技术能够提供高速的数据传输速率和低时延，确保交通管理系统能够快速响应各种紧急情况，从而提高交通安全性和效率。</p>\n<h4 id=\"6G技术在提升频谱效率和能量效率方面的最新研究进展\"><a href=\"#6G技术在提升频谱效率和能量效率方面的最新研究进展\" class=\"headerlink\" title=\"6G技术在提升频谱效率和能量效率方面的最新研究进展\"></a>6G技术在提升频谱效率和能量效率方面的最新研究进展</h4><p>6G技术在提升频谱效率和能量效率方面的最新研究进展主要体现在以下几个方面：</p>\n<ol>\n<li><p><strong>太赫兹通信技术</strong>：太赫兹波段的利用是6G技术发展的一个重要方向。中国航天科工二院二十五所完成了国内首次太赫兹轨道角动量的实时无线传输通信实验，这为6G通信提供了新的技术支持，有助于缓解太赫兹波段频谱资源不足的问题。此外，太赫兹量子级联激光器和单行载流子光电探测器等关键技术的发展，也为6G技术的应用提供了可能。</p>\n</li>\n<li><p><strong>智能超表面技术</strong>：智能超表面技术被用于通信系统中，以增强覆盖并显著提升网络传输速率、信号覆盖以及能量效率。通过对无线传播环境的主动定制，可以根据所需无线功能进行调整，如减小电磁污染等。</p>\n</li>\n<li><p><strong>超大规模多输入多输出（MIMO）技术</strong>：6G研发在超大规模MIMO技术方面取得了重要进展，这一技术能够有效提升频谱效率和网络容量。</p>\n</li>\n<li><p><strong>通感一体技术和内生AI通信</strong>：6G技术的发展还包括了感知和通信的原生集成，无需额外的频谱和网络投资，每个移动终端、每个基站都能实现更高效的通信。同时，内生AI通信技术的应用也是6G研究的一个重点，这些技术的进步有助于提高通信效率和降低能耗。</p>\n</li>\n</ol>\n<p>6G技术在提升频谱效率和能量效率方面的最新研究进展主要包括太赫兹通信技术的应用、智能超表面技术的开发、超大规模MIMO技术的突破以及通感一体技术和内生AI通信技术的发展。这些技术的进步不仅能够提高通信的速度和质量，还能够降低能耗，对于未来的通信网络具有重要意义。</p>\n<h4 id=\"太赫兹通信技术在6G中的具体应用案例\"><a href=\"#太赫兹通信技术在6G中的具体应用案例\" class=\"headerlink\" title=\"太赫兹通信技术在6G中的具体应用案例\"></a>太赫兹通信技术在6G中的具体应用案例</h4><p>太赫兹通信技术在6G中的具体应用案例主要包括以下几个方面：</p>\n<ol>\n<li><p><strong>无人机网络</strong>：太赫兹频段被设想用于无人机网络，作为6G非地面网络的预期用例之一。这包括监测和监视等应用场景。</p>\n</li>\n<li><p><strong>全息通信、微小尺寸通信、超大容量数据回传、短距超高速传输</strong>：由于太赫兹频段具有超大带宽的频谱资源，支持超大速率的无线通信，因此在这些场景中有望得到应用。</p>\n</li>\n<li><p><strong>安全检测</strong>：太赫兹波对很多非极性物质有很强的穿透能力，可以进行远距离探测和高分辨率的成像。这表明太赫兹技术在安全检测方面也有潜在的应用价值。</p>\n</li>\n<li><p><strong>小型化、3D立体成像、太赫兹质谱检测、太赫兹组网、移动性研究</strong>：华为6G研究团队将持续推进对太赫兹通感一体化技术的研究和验证，这些研究方向包括小型化、3D立体成像、太赫兹质谱检测、太赫兹组网以及移动性等方面。</p>\n</li>\n<li><p><strong>无通线超宽带通信场景</strong>：太赫兹通信技术将与其他低频段网络融合组网，广泛应用于地面的各种无通线超宽带通信场景，并将搭载卫星、无人机、飞艇等平台，作为替代方案。</p>\n</li>\n</ol>\n<p>太赫兹通信技术在6G中的应用案例涵盖了无人机网络、全息通信、微小尺寸通信、安全检测、小型化研究、3D立体成像、太赫兹质谱检测、太赫兹组网、移动性研究以及无通线超宽带通信等多个领域。</p>\n<h4 id=\"目前全球范围内6G技术研发的主要国家或组织以及主要贡献\"><a href=\"#目前全球范围内6G技术研发的主要国家或组织以及主要贡献\" class=\"headerlink\" title=\"目前全球范围内6G技术研发的主要国家或组织以及主要贡献\"></a>目前全球范围内6G技术研发的主要国家或组织以及主要贡献</h4><p>目前全球范围内6G技术研发的主要国家或组织包括中国、美国、日本等。他们的主要贡献如下：</p>\n<ol>\n<li><p><strong>中国</strong>：中国在6G技术研发方面具有全球领先的战略布局和推进组织。自2019年起，中国建立了完善的6G推进组织，由工信部牵头成立中国IMT-2030（6G）推进组，旨在加强国际合作交流和技术研发。此外，江苏紫金山实验室宣布在太赫兹频段取得了全球最快的数据传输速度，标志着中国在6G技术上的重大进展。</p>\n</li>\n<li><p><strong>美国</strong>：美国希望通过建立6G战略路线图、推动相关政策及预算、以及全球推广6G技术和服务来确立其在6G时代的领导地位。美国还通过了三项通信法案，以促进未来网络的发展。</p>\n</li>\n<li><p><strong>日本</strong>：日本是全球率先出台6G国家战略的国家之一。2020年4月和6月，日本相继发布了全球首个以6G作为国家发展目标和倡议的综合战略计划纲要和路线图，提出了具体的实施目标，包括在2025年实现6G关键技术突破、2030年正式启用6G网络等。</p>\n</li>\n</ol>\n<p>这些国家或组织在6G技术研发方面的贡献主要体现在战略规划、技术研发、国际合作以及政策支持等方面。中国通过建立推进组织和取得技术突破展现了其在全球6G技术研发中的领先地位；美国则通过制定通信法案和推动政策预算来争取在6G时代的领导地位；而日本则通过出台国家战略和设定具体目标来推动本国6G技术的发展。</p>\n<h4 id=\"6G技术面临的最大技术挑战以及如何应对\"><a href=\"#6G技术面临的最大技术挑战以及如何应对\" class=\"headerlink\" title=\"6G技术面临的最大技术挑战以及如何应对\"></a>6G技术面临的最大技术挑战以及如何应对</h4><p>6G技术面临的最大技术挑战主要包括网络架构重建、关键应用挖潜、降低功耗等方面。此外，还有毫米波&#x2F;太赫兹通信、空天地融合移动通信技术等前沿原创性技术的加强需求。为了应对这些挑战，目前的研究方向主要集中在加速6G无线、网络、安全等核心技术的产业化，以实现6G网络能力的跨越式发展来服务未来业务需求。同时，注重创新保障、产业支撑、扩大内需、人才保障，支持创新生态构建，形成6G发展的良好环境。此外，6G的研究还着重于探讨更高速率、更低时延、更大规模连接的技术目标，以及可能对6G产生重要影响的关键技术，如太赫兹通信、人工智能等。通过这些研究方向的努力，旨在推动6G技术的发展，以满足未来市场发展趋势和网络与业务需求。</p>\n<h4 id=\"基于5G-6G技术的智能交通系统设计思路及其潜在应用场景\"><a href=\"#基于5G-6G技术的智能交通系统设计思路及其潜在应用场景\" class=\"headerlink\" title=\"基于5G&#x2F;6G技术的智能交通系统设计思路及其潜在应用场景\"></a>基于5G&#x2F;6G技术的智能交通系统设计思路及其潜在应用场景</h4><p>基于5G&#x2F;6G技术的智能交通系统设计思路主要围绕利用先进的通信技术来提升交通系统的智能化水平，包括但不限于车路协同、自动驾驶、实时数据处理和分析等方面。具体来说，5G技术通过其高速率、低时延和大连接的特点，为智能交通系统提供了强大的支持。例如，5G可以实现智能网联车路协同系统，通过融合人、车、路、站台信息，打造新型智慧交通。此外，5G还能够支持应急联动，确保运行服务的安全。</p>\n<p>对于6G技术，虽然目前尚未广泛应用，但其潜在的应用场景包括全功能自动驾驶、高精度定位和高分辨率感知等。6G技术的研究重点在于提供更高速率、更低时延和更大容量的通信服务，这对于实现更高级别的自动驾驶和车联网系统至关重要。例如，6G赋能下的智能车联网系统将覆盖全域感知，这将极大促进智能交通系统的智能化发展。</p>\n<p>基于5G&#x2F;6G技术的智能交通系统设计思路主要包括利用5G的高速率、低时延和大连接特性来支持智能网联车路协同系统，以及探索6G技术在全功能自动驾驶、高精度定位和高分辨率感知等方面的应用潜力。这些设计思路不仅能够提升交通系统的效率和安全性，还能够为未来的智能交通系统发展奠定基础。</p>\n<h3 id=\"参考来源\"><a href=\"#参考来源\" class=\"headerlink\" title=\"参考来源\"></a>参考来源</h3><p><a href=\"https://pdf.dfcfw.com/pdf/H3_AP202305081586350769_1.pdf?1683579595000.pdf\">1. [PDF] 2023年中国6G产业研究报告</a> [2023-05-08]</p>\n<p><a href=\"https://www.zhihu.com/question/267453362\">2. 目前 6g 技术在国内外的研究进展如何？ - 知乎</a></p>\n<p><a href=\"https://www.infocomm-journal.com/wlw/article/2022/2096-3750/2096-3750-6-1-00029.shtml\">3. 6G：典型应用、关键技术与面临挑战</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/80139984\">4. 中兴通讯：6g移动通信网络愿景、挑战与关键技术 - 知乎</a></p>\n<p><a href=\"https://www.secrss.com/articles/56284\">5. 基于5G&#x2F;6G技术的卫星互联网一体化安全研究</a> [2023-07-04]</p>\n<p><a href=\"https://www.thepaper.cn/newsDetail_forward_12424079\">6. 长篇综述 | 6G：天地无疆，万物无界_澎湃号·湃客_澎湃新闻-The Paper</a></p>\n<p><a href=\"https://jeit.ac.cn/fileDZYXXXB_ONLY/cms/news/info/2021/06/fe6ef854d986465c88a0fe2e1b2e6de2/(0508)%E8%B5%9B%E8%BF%AA%E7%99%BD%E7%9A%AE%E4%B9%A6%EF%BC%9A%E3%80%8A6G%E5%85%A8%E7%90%83%E8%BF%9B%E5%B1%95%E4%B8%8E%E5%8F%91%E5%B1%95%E5%B1%95%E6%9C%9B%E7%99%BD%E7%9A%AE%E4%B9%A6%E3%80%8B.pdf\">7. [PDF] 6G 全球进展与发展展望白皮书 - 电子与信息学报</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/337586644\">8. 畅想6g时代!业内专家长篇综述：6g最新进展及未来发展趋势 - 知乎</a></p>\n<p><a href=\"https://finance.sina.cn/tech/2023-07-03/detail-imyzkmwx2024200.d.html\">9. 中国信科陈山枝谈6G的三大挑战与三大突破</a> [2023-07-03]</p>\n<p><a href=\"https://5gai.cctv.com/2023/12/11/ARTITV7eZ9OxdwnLpgPa3LqB231211.shtml\">10. 权威专家解读：5G融合应用走深向实为6G发展夯实应用基础 - 数智</a> [2023-12-11]</p>\n"},{"_content":"多视图混合密码猜测\n# 摘要\n\n1. 集合多种模型进行密码猜测（也称为混合密码猜测），从而更好地捕获真实破解者的破解能力\n2. 问题提出：为什么整合模型会有效果，如何整合模型还没有研究，\n3. 本文从多视图学习的概念中汲取灵感：\n\t1. 将各种密码猜测模型生成的猜测列表视为数据的多个视图。\n\t2. 通过对这些密码猜测列表的分析发现了混合密码猜测模型能增强破解能力的原因：\n\t\t1. 集成更多元的视图可以覆盖更广泛的异构密码特征。\n\t\t2. 并提供更详细的有效密码信息分布。\n4. 提出了一种新的密码猜测框架：GuessFuse \n\t1. 采用多视图子集提取模块和分段分割选择模块，从多个猜测列表中准确提取和重组有效密码。\n5. 在 六个大型数据集中证明了 GuessFuse 的有效性。\n\t1. 通过组合两个（或五个）猜测列表，GuessFuse 在 107 个猜测中比其最重要的同行平均高出 11.00% ∼ 59.62%（或 4.70% ∼ 17.66%）\n\n# 引言\n1. 密码使用频繁\n2. 密码破解器的性能是密码强度估计器的一个设计标准。\n3. 密码猜测分类：数据驱动和基于规则。当前主要是数据驱动方法效果更好。\n\t1. PCFG [6] 对具有简单结构的密码（例如，passsword123）产生更好的猜测性能\n\t2. 马尔可夫模型 [22] 对于具有上下文相关特征的密码（例如，1qaz2wsx）更有效。\n4. 但是现实世界的破解专家能力大于单一的模型能力。\n5. 混合密码猜测的研究在初级阶段。\n\t1. [16]通过并行应用多个密码猜测模型，设计了一个 Minauto 指标作为混合密码猜测的上限。\n\t2. 一些研究[29]-[33]试图在结构层面整合特定模型的优点（例如，分别在密码结构层面和字符串层面应用PCFG模型和马尔可夫模型进行密码猜测[29]） 。\n\t3.  另一方面，一些研究[32]、[34]实验性地组合来自不同密码猜测模型的多个猜测列表，以实现更准确的密码猜测。\n6. 然而，上述方法要么集成了两种特定的密码猜测模型，要么简单地组合猜测列表，而不是从机制上解决这个问题。未能有效利用多种异构密码猜测模型的优势。\n7.  更重要的是，据我们所知，为什么集成多个密码猜测模型可以增强破解能力尚未得到满意的答案。\n8. 我们将各种密码猜测模型生成的猜测列表视为数据的多个视图。 通过对多个猜测列表组合的深入分析，我们揭示了混合密码猜测能够增强破解能力的关键原因。\n9.  同时我们还发现多个视图之间的子集中的密码也遵循Zipf定律。\n\n基于这些关键发现，我们提出了一种基于多视图学习的混合密码猜测框架，名为 GuessFuse。 GuessFuse 可根据以下工作流程从巨大的密码空间中实现准确的密码猜测结果。\n1. GuessFuse 首先使用单独的密码猜测模型（例如 PCFG 和马尔可夫模型）生成多个密码猜测列表。 \n2. 然后，使用多视图子集提取方法提取多个猜测列表之间的相交和互补子集。\n3. 接下来，GuessFuse 根据幂律将子集分割成密码段。 \n4. 大量的实验表明，GuessFuse 的性能优于同类产品，并且能够有效地整合多种密码猜测模型的优点。\n5. 我们还将 GuessFuse 应用于 PSM 进行更广泛的比较分析。 我们发现 Minauto指标低估了某些密码的强度，从而降低了密码设置的可用性。 使用 GuessFuse 可以解决这个问题。\n# 准备工作\n\n## 相关研究\n1. 密码破解方式概述\n2. 密码强度指标 minauto ， 但Minauto指标只是理论上的上限，并行使用多个密码猜测模型比使用单个模型需要多数倍的猜测次数，与实际猜测场景的要求不一致。\n3. 混合密码猜测模型提出但是处于起步阶段。 根据集成对象的划分，现有的混合密码猜测方法可以分为模型架构级别的集成和猜测列表级别的集成。\n\t1. 模型架构级别：\n\t\t1. 2018 年，Zhang 等人。 [29]提出了一种称为 SPSR 的混合密码猜测模型。 SPSR将PCFG模型[6]应用于密码结构层，将马尔可夫链模型[22]应用于密码字符串层。 \n\t\t2. 同年，他们还提出了SPRNN模型[30]，该模型结合了结构划分和双向长短期记忆递归神经网络（BiLSTM）。 \n\t\t3. 与 SPRNN 相反，Xia 等人。 [31]提出了另一种混合密码猜测模型，称为 PL。 PL采用PCFG模型[6]进行密码字符串层解构，并采用LSTM模型[15]进行结构层建模。 \n\t\t这些双重方法有效地利用了两种密码猜测模型在不同密码分析粒度层的优势。 然而，这些模型架构级别的集成需要有针对性的定制，限制了它们集成更广泛的密码猜测模型的能力。\n\t2. 猜测列表级别：\n\t\t1. 2021 年，王等人。 [32]平均组合多个密码猜测列表并对输出进行重复数据删除。 他们发现，将密码猜测模型与明显不同的密码生成策略（例如RNN模型[39]和PCFG模型[6]）相结合可以有效提高破解成功率。 \n\t\t2. 2022 年，帕里什等人。 [34]对训练集中的密码进行去重，并按密码频率降序排序，生成猜测列表。 他们将其定义为“身份猜测者”。 他们发现，将模型生成的多个猜测列表与 Identity Guesser 相结合，可以显着提高破解成功率。 \n\t\t不过，这两项研究仅在猜测清单层面进行了初步尝试。 同等地组合猜测列表并不能准确地从每个猜测模型中提取有效部分。\n\t\t3. 2022 年，Han 等人。 [33]介绍了一种称为 hyPassGu 的混合猜测框架。 hyPassGu 通过限制每个模型生成目标类型的密码并分别确定猜测次数，利用 PCFG 和马尔可夫模型的优势。 尽管声称 hyPassGu 可以应用于 PCFG 和马尔可夫之外的其他模型，但它需要先了解模型的架构及其目标密码类型。 因此，它不能直接应用于其他模型。 另外，hyPassGu根据密码的结构特征将密码粗略地分为两类，导致有效密码大量流失。 因此，hyPassGu的破解成功率低于单个模型，仅略优于限制特定类型密码生成的模型。\n4. 关键问题仍然没有令人满意的答案：\n\t（1）什么有助于提高混合密码猜测的破解能力？ \n\t（2）如何有效发挥多种不同模型的优势？ 本文重点解决这些问题。\n\n## 密码猜测场景\n\n**数据驱动的密码猜测模型 + 拖网猜测 + 混合密码猜测**\n1. 攻击者首先根据泄露的数据集构建密码猜测模型；\n2. 然后使用模型生成猜测；\n3. 最后尝试使用猜测破解所有目标密码。 \n\n虽然基于规则的密码猜测工具[20]、[21]也可用于混合密码猜测，但这些工具仍然依赖于目标数据集分布的先验知识来增强密码猜测的有效性。\n\n注意：\n拖网场景可以进一步分为站内场景和跨站场景。 虽然跨站密码猜测场景较为真实，但攻击者一般以掌握目标数据的部分分布信息为前提来猜测密码。\n因此，为了更好地描述混合密码猜测的概念，我们将站点内拖网场景中的密码猜测任务形式化。\n**形式化**：一些符号表示，某个猜测密码成功破解了目标系统的多少个密码\n\n## 多视角学习\n多视图学习的概念与混合密码猜测的概念非常吻合。 多视图学习引入了一个函数来对特定视图进行建模，并联合优化所有函数以利用相同输入数据的冗余视图，从而提高学习性能[40]。 \n在更高层次上，多视图学习构建多个单一视图并评估它们的表现，然后设计功能来组合这些视图以改善学习成果。\n同样，混合密码猜测旨在通过利用从不同角度分析数据的多个模型来提高密码猜测的有效性。 因此，多视图学习可以用于解决在混合密码猜测中集成各种密码猜测模型的优势的挑战。\n\n徐等人。 [41]提出多视图学习基于两个关键原则有效地利用多种视图：\n1. 共识和互补。 共识原则旨在最大限度地达成不同观点之间的一致。 \n2. 互补原则指出，每种观点都可能包含其他观点所不存在的独特知识。 通过有效利用多种观点的共识和互补性，可以实现对数据的全面、准确的描述。 \n在本文中，我们基于这些原理探索混合密码猜测。\n\n\n## 数据集\n使用包含 5400 万个纯文本密码的 6 个数据集（参见表 I）。 \n其中，三个数据集来自英文网站，三个数据集来自中文网站，涵盖六种不同的服务类型。 \n数据源的多样性有助于减少我们分析中的偏差。 由于我们所有的数据集都可以在互联网上公开获取，因此这项工作的结果是可重复的。\n![[Pasted image 20240418173807.png]]\n\n### 数据清洗\n原始数据集包含异常情况，例如未解密的哈希字符串、不可能由用户生成的过长密码以及包含不符合标准密码策略的不可打印字符的密码。 因此，我们首先对数据集进行数据清洗。 我们删除包含 95 个可打印 ASCII 字符之外的字符的密码，并删除长度 > 30 的密码。这种数据清理策略在现有的密码猜测文献中也很流行 [24]、[26]、[42]。\n\n### 道德考虑\n尽管我们使用的数据集是公开的，并广泛用于密码猜测研究 [8]、[27]、[32]–[34]，但这些数据集包含敏感的个人信息。 因此，我们仅分析密码数据的分布特征，并报告汇总的统计信息。 我们不会将任何数据用于学术研究以外的目的，因此不会增加受影响个人的风险。\n\n## 密码猜测模型\n采用了四种领先的密码猜测模型（例如 Markov、PCFG、FLA 和 RFGuess）。\n\n为了减轻其他因素对分析结果的影响，我们重点关注站内密码猜测场景。 这种情况被认为是理想的，因为训练集和测试集具有相同的数据分布，确保了我们分析的一致性。\n\n我们从数据集中随机抽取大小为 $10^6$ 的子集作为测试集，而其余数据用作训练集。 我们发现结果对于基于此测试集大小的分析来说足够稳定。 这一现象与论文[9]、[43]、[44]一致。 用于生成猜测列表的每个模型的设置如下：\n 1）PCFG。 我们使用了 PCFG 模型 [6] 的 4.0 版，该模型可以在 GitHub 网站上找到。 该模型的语法包括六个段类别：字母A、数字D、其他字符O、键盘D、特殊字符串X和年份Y。\n 2）Markov。 我们选择 4 阶马尔可夫模型，并采用[26]中使用的拉普拉斯平滑和结束符号正则化来生成猜测。 \n 3）FLA。 我们利用了 GitHub 网站上提供的 FLA 开源代码2，并遵循[15]中指定的推荐参数。 我们训练了一个由三个 LSTM 层组成的模型，每层有 128 个单元和两个密集层，总共 20 个 epoch。 \n 4）RFGuess。 参考[24]，我们训练了一个有 30 棵决策树的随机森林。 其叶子节点的最小数量为10，特征的最大比例为80%，其余为scikit-learn框架的默认值[45]。\n\n\n\n# 分析\n\n 本节通过多视角分析，依次解决以下问题：\n\t（1）混合密码猜测能够提高破解能力的关键原因是什么？\n\t（2）使用猜测列表进​​行混合密码猜测可以获得什么好处？\n## 混合密码猜测的本质\n### 数据集比较\n我们通过比较每个模型生成的猜测列表来展示密码猜测模型之间的差异\n![[Pasted image 20240418204958.png]]\n1. PCFG 模型生成的猜测列表包括诸如 “dearbook123456” 和 “DEARBOOK” 之类的密码，这表明偏向于生成包含常见短语和简单结构的密码。 \n2. Markov 模型生成的猜测列表包含 “woshili” 和 “1989123” 等密码，反映了基于密码内字符相关性进行猜测的偏见。\n3. RFGuess 模型的猜测列表包括诸如 “1234567” 和 “1234567}” 之类的密码，表明了将常见短语与各种特征相结合的趋势。 \n4. FLA 模型与马尔可夫模型类似，会生成一个包含 “45665456” 和 “qwqwqwqww” 等密码的猜测列表，显示出其对密码中顺序上下文一致性的偏见。 然而，FLA 模型生成的猜测列表也与马尔可夫模型不同。\n5. 中心区域还有“dearbook”、“12345678”等密码。 它表明，尽管每个模型都有独特的偏见，但他们已经就某些密码达成了共识。 这些密码可能很常用，并且很容易被各种模型预测到。\n\n### 为什么需要混合\n猜测列表中的相似点和差异强调，即使基于相同的数据集，现有的密码猜测模型也可以生成包含不同密码特征的猜测列表。\n\n本质上，密码猜测模型是根据用户设置易受攻击密码的行为而设计的。通过准确识别和匹配这些弱密码的特征，模型就可以生成破戒律很高的猜测列表。然而，由于用户密码设置行为的异构多样性[42]。即使像 PCFG 这样的已经涵盖了各种弱密码特征的模型（参见第II-E节），也无法在有限的猜测次数内完全覆盖所有特征 。 利用多种具有不同偏差的密码猜测模型的组合，可以更全面地识别和匹配密码特征，从而提高密码猜测的性能。\n\n### 怎么混合\n1. 在模型的结构层面上利用多个异构密码猜测模型是相当具有挑战性的，并且不适用于新提出的密码猜测模型（例如RFGuess），这背离了使用多个异构模型的最初想法。\n2. 密码猜测模型最终会生成猜测列表。 鉴于多视图学习对于混合密码猜测的天然适用性（参见第 II-C 节），我们将密码猜测模型生成的猜测列表视为数据的多个视图。\n\t1.  在多视图学习领域，直观的是，集成多个不同视图来分析和处理数据可以产生更全面的信息，从而提高学习模型的性能。 这个概念也适用于混合密码猜测。 \n\t2. 我们用一个示意性的解释来描述这一点。 \n\t\t![[Pasted image 20240418211929.png]]\n\t3. 如图3所示，不同的密码猜测模型生成的猜测列表{G1，G2，G3，····，Gl}可以覆盖测试集T的不同部分。假设混合密码猜测方法H可以有效地提取出测试集T的不同部分。 从{G1,G2,G3,····,Gl}中覆盖T的密码，生成优化猜测列表eG。 \n\t4. 组合的猜测列表越多，测试集的覆盖范围就越大，从而产生更好的破解能力。 \n\t5. 请注意，图 3 中描绘的示意图可能并不通用，因为猜测列表中的密码通常存在重叠。 然而，组合更多猜测列表可以覆盖更多测试集的因果关系是普遍存在的。 我们将通过下面的分析来证明这一点。\n\n## 多视图集成的优点\n依据：\n1. 大量实验已经证实，我们所描述的结果在六个数据集中得到一致观察，从而证实了它们的普遍性\n2. 以 CSDN 数据集生成的 top $10^6$ 密码猜测列表为例。\n3. \n实验：\n定量特征分析：\n对组合猜测列表的统计特征进行定量比较，以证明多视图集成带来的猜测有效性。\n1. 将每个模型生成的猜测列表以相同的大小组合起来，并对它们进行重复数据删除，然后将结果与单个猜测列表进​​行比较。\n\t例如，在比较大小为 $10^3$ 的猜测列表时，我们结合 PCFG 和马尔可夫模型生成的前 $10^3$ 个猜测，删除任何重复的密码。 输出被定义为两个视图集成。 \n\t请注意，这种组合策略与 Minauto 指标 [16] 的计算相同，并不反映现实场景 ( Minauto 指标是一个理论上的上限，代表了每个密码被所有密码猜测模型破解所需的最小猜测次数。然而，在实际的密码猜测场景中，使用多个密码猜测模型并行进行猜测需要的次数是单个模型的数倍，这与实际需求不一致)。\n\t\n2. 我们的目的只是证明通过跨多个视图的特征量化来增强密码破解能力的可行性。\n\t![[Pasted image 20240419151949.png]]\n\t密码结构 Struct：基于 PCFG 算法来分析猜测列表中的密码结构的数量。 例如，如果猜测列表包含 “dearbook134”、“dearbook309” 和 “123dearbook” 等密码，则它包含两种类型的密码结构： “A8D3” 和 “D3A8”。\n\t有效密码比例 Effect：有效密码/猜测列表大小。猜测列表中的密码如果能够与测试集中的密码匹配，则认为该密码有效。\n\t破解成功率 $Min_{auto}$\n\t唯一密码比例 Uniq：唯一密码/单个单个猜测列表 \n\t\n\n3. 结果：\n\t1. Effect 和  $Min_{auto}$ 说明了多视图集成所带来的猜测有效性的提高。\n\t2. Uniq 和 struct 说明通过集成多个视图实现的多样性的增强。整合更多元的观点可以增加猜测的多样性，覆盖更多的密码特征，从而提高密码猜测的有效性\n\n有效的密码分析：\n问题：组合多个猜测列表会产生许多独特的密码，其大小远远超过单个猜测列表的大小。 如果全部用于最后的破解，会导致破解次数消耗过多。\n![[Pasted image 20240419155303.png]]\n幸运的是，图4（a）表明，当猜测数量增长到大约 $4×10^4$ 时，组合多个猜测列表的有效密码数量开始低于单个猜测列表的大小（an注：从一个数据集中选择 100 比 四个数据集中每个选择 25 个效率高）。\n在这种情况下，通过选择这些有效密码中的一部分，即使优化后的猜测列表大小小于单个猜测列表的大小，猜测的成功率仍然可以达到多视图集成的 Minauto 指标。（an注：此时单猜测列表 和 多猜测列表分母增加相同大小时， 单猜测列表的分子增加的多，论文描述的意思是减少了 多猜测列表分母增加的个数，有点偷换概念的意思）\n\n\n在了解测试集的前提下，我们假设了一种最优的混合密码猜测方法，该方法可以有效地整合多个猜测列表以产生优化的猜测列表。 此混合密码猜测方法生成的优化猜测列表包含每个猜测列表中最有效的密码。 如果猜测的密码在测试集中破解频率最高的密码，则认为该密码具有最高的效率。 例如，在整合大小为103的猜测列表时，我们首先对猜测的密码进行去重，并将其与测试集进行比较，计算每个猜测的密码可以破解的测试密码的数量。 然后，我们按照破解次数降序选择猜测的密码，并将其添加到最佳猜测列表中，直到最佳猜测列表的大小也达到103。我们将最佳猜测列表的破解成功率与最佳猜测列表的破解成功率进行比较。 由单一密码猜测模型生成的猜测列表（见图4（b））。 如图 4（b）所示，当猜测数 < 4 × 104 时，与 PCFG 模型相比，整合两视图的最优猜测列表的破解成功率平均提高了 1.3%，整合三视图的破解成功率平均提高了 1.3%。 2.6%，整合四视图增长了2.8%。 尽管有效密码的数量超过了单个猜测列表的大小，但选择效率最高的部分同等大小的猜测密码仍然可以增强破解能力。 \n\n上述结果表明，从多个视图中准确提取有效密码是进行有效混合密码猜测的关键。\n\n\n多视图子集分析：\n目的：为了找到从多个视图中提取有效密码的有效方法，我们对多个视图之间的子集进行了分析。\n手段：对不同模型生成的相同大小的猜测列表进​​行集合运算，以获得相交和互补的子集。\n![[Pasted image 20240419165944.png]]\n\n\n我们分析了集成不同数量的视图时多视图子集的变化（见图 5）。 如图 5 所示，集成两个视图生成三个子集，三个视图集成生成七个子集，四个视图集成生成 15 个子集。 此外，随着集成视图数量的增加，每个子集中有效密码的分布变得更加集中。 相交子集中有效密码的比例（中间红色数值表示）随着集成视图的增加而增加。 在基于CSDN数据集的实验中，融合两个视图时，相交子集中有效密码的比例为51.51%。 当集成三视图时，这一比例增加了 21.0%，而当集成四视图时，这一比例又增加了 3.9%。 这些结果表明，集成多个视图可以提供有关有效密码分发的增量信息。 随着更多视图的整合，增量信息增多，有效密码的分布更加集中。\n\n![[Pasted image 20240419170332.png]]\n\n\n\n我们继续分析有效密码在各个子集中的分布。 目前，当我们仅通过集合运算提取猜测列表中的相交和互补子集时，子集中的密码不包括顺序。 因此，我们通过分析不同大小的猜测列表中子集的平均破解成功率来评估子集中有效密码的分布（见图7）。 为了便于表示，我们用图6来表示每个平均破解成功率所代表的子集。 具体来说，我们使用 4 位二进制代码来命名每个子集，其中每个位代表密码在特定模型生成的猜测列表中的出现，从左到右分别为：PCFG、FLA、Markov 和 RFGuess。 例如，“1000”表示该子集中的密码仅出现在PCFG猜测列表中。\n\n![[Pasted image 20240419170602.png]]\n\n如图7所示，相交子集“1111”的整体破解效率明显优于其他子集。 然而，相交子集中的密码的后半部分并不优于其他子集中的密码的前半部分。 例如，相交子集“1111”在101次猜测中的平均破解成功率为3.57×10−6，而互补子集“0010”在101次猜测中的平均破解成功率为2.61×10−5。 有趣的是，子集的平均破解成功率与单个猜测列表的大小呈现近似线性关系。 当我们将 15 条曲线作为一个整体来考虑时，这一点变得更加明显。 这可能符合密码中的 Zipf 定律 [46]。 我们使用PDFZipf模型[46]拟合数据：logfr = logC − s · logr，其中fr和r分别对应于平均破解成功率和单个猜测列表的大小。 如表III所示，C ε [-3.55，-0.85]和s ε [-0.92，-0.63]是常数。 拟合的 RMSE 在 [0.08, 0.24] 范围内。\n\n这种现象有助于在混合密码猜测中利用多种密码猜测模型的优势。 尽管密码分布中的齐普夫定律通常用于解释用户设置密码的行为，但也有研究 [33]、[47] 通过分析密码猜测模型中齐普夫定律的存在来改进密码猜测模型。 在我们的例子中，齐普夫定律表明，猜测密码的效率随着密码在子集中的排名降序而下降。 换句话说，子集中排名较高的密码被认为具有较高的破解效率。\n\n\n\n\n\n\n\n# 密码结构\n\n密码结构（Struct.）的数量是通过对猜测列表中的密码进行分析和统计得出的。具体来说，密码结构是指密码中的字符排列方式，例如\"A8D3\"或\"D3A8\"。在文中，作者使用PCFG算法对密码结构进行分析，通过猜测列表中的密码来确定不同类型的密码结构的数量。通过对密码结构的数量进行统计分析，可以评估多视图整合对密码破解能力的提升效果。这些统计特征表明，整合更多不同的视图可以增加猜测的多样性，覆盖更多的密码特征，从而提高口令猜测的有效性。\n\n# Minauto\n类似于一个破解成功率。\n\n\n# 多视图提取模块的工作原理是什么？\n\n多视图提取模块的工作原理是从多个猜测列表中提取交集和补集密码，以生成多视图子集。该模块首先根据输入的猜测列表数量生成多个子集，并为每个子集分配逻辑标签。然后，根据排名，模块按照密码的逻辑规则将密码分别添加到交集子集或补集子集中。最终，该模块输出维护的多视图子集，其中包含了有效密码的信息。这一过程有助于准确地从多个视图中提取和重新组织有效密码。\n\n# 分割选择模块的作用是什么？\n\n分割选择模块的作用是进一步细化每个子集，根据幂律间隔将其分割成多个密码片段。该模块利用幂律分布间隔序列来将输入的子集分割成更细粒度的密码片段。然后，该模块利用验证集来评估这些密码片段的破解效率，具体来说，该模块计算这些密码片段的平均破解成功率。最终，该模块重新组织有效的密码片段，生成最终的优化猜测列表。\n","source":"_posts/论文笔记/GuessFuse.md","raw":"多视图混合密码猜测\n# 摘要\n\n1. 集合多种模型进行密码猜测（也称为混合密码猜测），从而更好地捕获真实破解者的破解能力\n2. 问题提出：为什么整合模型会有效果，如何整合模型还没有研究，\n3. 本文从多视图学习的概念中汲取灵感：\n\t1. 将各种密码猜测模型生成的猜测列表视为数据的多个视图。\n\t2. 通过对这些密码猜测列表的分析发现了混合密码猜测模型能增强破解能力的原因：\n\t\t1. 集成更多元的视图可以覆盖更广泛的异构密码特征。\n\t\t2. 并提供更详细的有效密码信息分布。\n4. 提出了一种新的密码猜测框架：GuessFuse \n\t1. 采用多视图子集提取模块和分段分割选择模块，从多个猜测列表中准确提取和重组有效密码。\n5. 在 六个大型数据集中证明了 GuessFuse 的有效性。\n\t1. 通过组合两个（或五个）猜测列表，GuessFuse 在 107 个猜测中比其最重要的同行平均高出 11.00% ∼ 59.62%（或 4.70% ∼ 17.66%）\n\n# 引言\n1. 密码使用频繁\n2. 密码破解器的性能是密码强度估计器的一个设计标准。\n3. 密码猜测分类：数据驱动和基于规则。当前主要是数据驱动方法效果更好。\n\t1. PCFG [6] 对具有简单结构的密码（例如，passsword123）产生更好的猜测性能\n\t2. 马尔可夫模型 [22] 对于具有上下文相关特征的密码（例如，1qaz2wsx）更有效。\n4. 但是现实世界的破解专家能力大于单一的模型能力。\n5. 混合密码猜测的研究在初级阶段。\n\t1. [16]通过并行应用多个密码猜测模型，设计了一个 Minauto 指标作为混合密码猜测的上限。\n\t2. 一些研究[29]-[33]试图在结构层面整合特定模型的优点（例如，分别在密码结构层面和字符串层面应用PCFG模型和马尔可夫模型进行密码猜测[29]） 。\n\t3.  另一方面，一些研究[32]、[34]实验性地组合来自不同密码猜测模型的多个猜测列表，以实现更准确的密码猜测。\n6. 然而，上述方法要么集成了两种特定的密码猜测模型，要么简单地组合猜测列表，而不是从机制上解决这个问题。未能有效利用多种异构密码猜测模型的优势。\n7.  更重要的是，据我们所知，为什么集成多个密码猜测模型可以增强破解能力尚未得到满意的答案。\n8. 我们将各种密码猜测模型生成的猜测列表视为数据的多个视图。 通过对多个猜测列表组合的深入分析，我们揭示了混合密码猜测能够增强破解能力的关键原因。\n9.  同时我们还发现多个视图之间的子集中的密码也遵循Zipf定律。\n\n基于这些关键发现，我们提出了一种基于多视图学习的混合密码猜测框架，名为 GuessFuse。 GuessFuse 可根据以下工作流程从巨大的密码空间中实现准确的密码猜测结果。\n1. GuessFuse 首先使用单独的密码猜测模型（例如 PCFG 和马尔可夫模型）生成多个密码猜测列表。 \n2. 然后，使用多视图子集提取方法提取多个猜测列表之间的相交和互补子集。\n3. 接下来，GuessFuse 根据幂律将子集分割成密码段。 \n4. 大量的实验表明，GuessFuse 的性能优于同类产品，并且能够有效地整合多种密码猜测模型的优点。\n5. 我们还将 GuessFuse 应用于 PSM 进行更广泛的比较分析。 我们发现 Minauto指标低估了某些密码的强度，从而降低了密码设置的可用性。 使用 GuessFuse 可以解决这个问题。\n# 准备工作\n\n## 相关研究\n1. 密码破解方式概述\n2. 密码强度指标 minauto ， 但Minauto指标只是理论上的上限，并行使用多个密码猜测模型比使用单个模型需要多数倍的猜测次数，与实际猜测场景的要求不一致。\n3. 混合密码猜测模型提出但是处于起步阶段。 根据集成对象的划分，现有的混合密码猜测方法可以分为模型架构级别的集成和猜测列表级别的集成。\n\t1. 模型架构级别：\n\t\t1. 2018 年，Zhang 等人。 [29]提出了一种称为 SPSR 的混合密码猜测模型。 SPSR将PCFG模型[6]应用于密码结构层，将马尔可夫链模型[22]应用于密码字符串层。 \n\t\t2. 同年，他们还提出了SPRNN模型[30]，该模型结合了结构划分和双向长短期记忆递归神经网络（BiLSTM）。 \n\t\t3. 与 SPRNN 相反，Xia 等人。 [31]提出了另一种混合密码猜测模型，称为 PL。 PL采用PCFG模型[6]进行密码字符串层解构，并采用LSTM模型[15]进行结构层建模。 \n\t\t这些双重方法有效地利用了两种密码猜测模型在不同密码分析粒度层的优势。 然而，这些模型架构级别的集成需要有针对性的定制，限制了它们集成更广泛的密码猜测模型的能力。\n\t2. 猜测列表级别：\n\t\t1. 2021 年，王等人。 [32]平均组合多个密码猜测列表并对输出进行重复数据删除。 他们发现，将密码猜测模型与明显不同的密码生成策略（例如RNN模型[39]和PCFG模型[6]）相结合可以有效提高破解成功率。 \n\t\t2. 2022 年，帕里什等人。 [34]对训练集中的密码进行去重，并按密码频率降序排序，生成猜测列表。 他们将其定义为“身份猜测者”。 他们发现，将模型生成的多个猜测列表与 Identity Guesser 相结合，可以显着提高破解成功率。 \n\t\t不过，这两项研究仅在猜测清单层面进行了初步尝试。 同等地组合猜测列表并不能准确地从每个猜测模型中提取有效部分。\n\t\t3. 2022 年，Han 等人。 [33]介绍了一种称为 hyPassGu 的混合猜测框架。 hyPassGu 通过限制每个模型生成目标类型的密码并分别确定猜测次数，利用 PCFG 和马尔可夫模型的优势。 尽管声称 hyPassGu 可以应用于 PCFG 和马尔可夫之外的其他模型，但它需要先了解模型的架构及其目标密码类型。 因此，它不能直接应用于其他模型。 另外，hyPassGu根据密码的结构特征将密码粗略地分为两类，导致有效密码大量流失。 因此，hyPassGu的破解成功率低于单个模型，仅略优于限制特定类型密码生成的模型。\n4. 关键问题仍然没有令人满意的答案：\n\t（1）什么有助于提高混合密码猜测的破解能力？ \n\t（2）如何有效发挥多种不同模型的优势？ 本文重点解决这些问题。\n\n## 密码猜测场景\n\n**数据驱动的密码猜测模型 + 拖网猜测 + 混合密码猜测**\n1. 攻击者首先根据泄露的数据集构建密码猜测模型；\n2. 然后使用模型生成猜测；\n3. 最后尝试使用猜测破解所有目标密码。 \n\n虽然基于规则的密码猜测工具[20]、[21]也可用于混合密码猜测，但这些工具仍然依赖于目标数据集分布的先验知识来增强密码猜测的有效性。\n\n注意：\n拖网场景可以进一步分为站内场景和跨站场景。 虽然跨站密码猜测场景较为真实，但攻击者一般以掌握目标数据的部分分布信息为前提来猜测密码。\n因此，为了更好地描述混合密码猜测的概念，我们将站点内拖网场景中的密码猜测任务形式化。\n**形式化**：一些符号表示，某个猜测密码成功破解了目标系统的多少个密码\n\n## 多视角学习\n多视图学习的概念与混合密码猜测的概念非常吻合。 多视图学习引入了一个函数来对特定视图进行建模，并联合优化所有函数以利用相同输入数据的冗余视图，从而提高学习性能[40]。 \n在更高层次上，多视图学习构建多个单一视图并评估它们的表现，然后设计功能来组合这些视图以改善学习成果。\n同样，混合密码猜测旨在通过利用从不同角度分析数据的多个模型来提高密码猜测的有效性。 因此，多视图学习可以用于解决在混合密码猜测中集成各种密码猜测模型的优势的挑战。\n\n徐等人。 [41]提出多视图学习基于两个关键原则有效地利用多种视图：\n1. 共识和互补。 共识原则旨在最大限度地达成不同观点之间的一致。 \n2. 互补原则指出，每种观点都可能包含其他观点所不存在的独特知识。 通过有效利用多种观点的共识和互补性，可以实现对数据的全面、准确的描述。 \n在本文中，我们基于这些原理探索混合密码猜测。\n\n\n## 数据集\n使用包含 5400 万个纯文本密码的 6 个数据集（参见表 I）。 \n其中，三个数据集来自英文网站，三个数据集来自中文网站，涵盖六种不同的服务类型。 \n数据源的多样性有助于减少我们分析中的偏差。 由于我们所有的数据集都可以在互联网上公开获取，因此这项工作的结果是可重复的。\n![[Pasted image 20240418173807.png]]\n\n### 数据清洗\n原始数据集包含异常情况，例如未解密的哈希字符串、不可能由用户生成的过长密码以及包含不符合标准密码策略的不可打印字符的密码。 因此，我们首先对数据集进行数据清洗。 我们删除包含 95 个可打印 ASCII 字符之外的字符的密码，并删除长度 > 30 的密码。这种数据清理策略在现有的密码猜测文献中也很流行 [24]、[26]、[42]。\n\n### 道德考虑\n尽管我们使用的数据集是公开的，并广泛用于密码猜测研究 [8]、[27]、[32]–[34]，但这些数据集包含敏感的个人信息。 因此，我们仅分析密码数据的分布特征，并报告汇总的统计信息。 我们不会将任何数据用于学术研究以外的目的，因此不会增加受影响个人的风险。\n\n## 密码猜测模型\n采用了四种领先的密码猜测模型（例如 Markov、PCFG、FLA 和 RFGuess）。\n\n为了减轻其他因素对分析结果的影响，我们重点关注站内密码猜测场景。 这种情况被认为是理想的，因为训练集和测试集具有相同的数据分布，确保了我们分析的一致性。\n\n我们从数据集中随机抽取大小为 $10^6$ 的子集作为测试集，而其余数据用作训练集。 我们发现结果对于基于此测试集大小的分析来说足够稳定。 这一现象与论文[9]、[43]、[44]一致。 用于生成猜测列表的每个模型的设置如下：\n 1）PCFG。 我们使用了 PCFG 模型 [6] 的 4.0 版，该模型可以在 GitHub 网站上找到。 该模型的语法包括六个段类别：字母A、数字D、其他字符O、键盘D、特殊字符串X和年份Y。\n 2）Markov。 我们选择 4 阶马尔可夫模型，并采用[26]中使用的拉普拉斯平滑和结束符号正则化来生成猜测。 \n 3）FLA。 我们利用了 GitHub 网站上提供的 FLA 开源代码2，并遵循[15]中指定的推荐参数。 我们训练了一个由三个 LSTM 层组成的模型，每层有 128 个单元和两个密集层，总共 20 个 epoch。 \n 4）RFGuess。 参考[24]，我们训练了一个有 30 棵决策树的随机森林。 其叶子节点的最小数量为10，特征的最大比例为80%，其余为scikit-learn框架的默认值[45]。\n\n\n\n# 分析\n\n 本节通过多视角分析，依次解决以下问题：\n\t（1）混合密码猜测能够提高破解能力的关键原因是什么？\n\t（2）使用猜测列表进​​行混合密码猜测可以获得什么好处？\n## 混合密码猜测的本质\n### 数据集比较\n我们通过比较每个模型生成的猜测列表来展示密码猜测模型之间的差异\n![[Pasted image 20240418204958.png]]\n1. PCFG 模型生成的猜测列表包括诸如 “dearbook123456” 和 “DEARBOOK” 之类的密码，这表明偏向于生成包含常见短语和简单结构的密码。 \n2. Markov 模型生成的猜测列表包含 “woshili” 和 “1989123” 等密码，反映了基于密码内字符相关性进行猜测的偏见。\n3. RFGuess 模型的猜测列表包括诸如 “1234567” 和 “1234567}” 之类的密码，表明了将常见短语与各种特征相结合的趋势。 \n4. FLA 模型与马尔可夫模型类似，会生成一个包含 “45665456” 和 “qwqwqwqww” 等密码的猜测列表，显示出其对密码中顺序上下文一致性的偏见。 然而，FLA 模型生成的猜测列表也与马尔可夫模型不同。\n5. 中心区域还有“dearbook”、“12345678”等密码。 它表明，尽管每个模型都有独特的偏见，但他们已经就某些密码达成了共识。 这些密码可能很常用，并且很容易被各种模型预测到。\n\n### 为什么需要混合\n猜测列表中的相似点和差异强调，即使基于相同的数据集，现有的密码猜测模型也可以生成包含不同密码特征的猜测列表。\n\n本质上，密码猜测模型是根据用户设置易受攻击密码的行为而设计的。通过准确识别和匹配这些弱密码的特征，模型就可以生成破戒律很高的猜测列表。然而，由于用户密码设置行为的异构多样性[42]。即使像 PCFG 这样的已经涵盖了各种弱密码特征的模型（参见第II-E节），也无法在有限的猜测次数内完全覆盖所有特征 。 利用多种具有不同偏差的密码猜测模型的组合，可以更全面地识别和匹配密码特征，从而提高密码猜测的性能。\n\n### 怎么混合\n1. 在模型的结构层面上利用多个异构密码猜测模型是相当具有挑战性的，并且不适用于新提出的密码猜测模型（例如RFGuess），这背离了使用多个异构模型的最初想法。\n2. 密码猜测模型最终会生成猜测列表。 鉴于多视图学习对于混合密码猜测的天然适用性（参见第 II-C 节），我们将密码猜测模型生成的猜测列表视为数据的多个视图。\n\t1.  在多视图学习领域，直观的是，集成多个不同视图来分析和处理数据可以产生更全面的信息，从而提高学习模型的性能。 这个概念也适用于混合密码猜测。 \n\t2. 我们用一个示意性的解释来描述这一点。 \n\t\t![[Pasted image 20240418211929.png]]\n\t3. 如图3所示，不同的密码猜测模型生成的猜测列表{G1，G2，G3，····，Gl}可以覆盖测试集T的不同部分。假设混合密码猜测方法H可以有效地提取出测试集T的不同部分。 从{G1,G2,G3,····,Gl}中覆盖T的密码，生成优化猜测列表eG。 \n\t4. 组合的猜测列表越多，测试集的覆盖范围就越大，从而产生更好的破解能力。 \n\t5. 请注意，图 3 中描绘的示意图可能并不通用，因为猜测列表中的密码通常存在重叠。 然而，组合更多猜测列表可以覆盖更多测试集的因果关系是普遍存在的。 我们将通过下面的分析来证明这一点。\n\n## 多视图集成的优点\n依据：\n1. 大量实验已经证实，我们所描述的结果在六个数据集中得到一致观察，从而证实了它们的普遍性\n2. 以 CSDN 数据集生成的 top $10^6$ 密码猜测列表为例。\n3. \n实验：\n定量特征分析：\n对组合猜测列表的统计特征进行定量比较，以证明多视图集成带来的猜测有效性。\n1. 将每个模型生成的猜测列表以相同的大小组合起来，并对它们进行重复数据删除，然后将结果与单个猜测列表进​​行比较。\n\t例如，在比较大小为 $10^3$ 的猜测列表时，我们结合 PCFG 和马尔可夫模型生成的前 $10^3$ 个猜测，删除任何重复的密码。 输出被定义为两个视图集成。 \n\t请注意，这种组合策略与 Minauto 指标 [16] 的计算相同，并不反映现实场景 ( Minauto 指标是一个理论上的上限，代表了每个密码被所有密码猜测模型破解所需的最小猜测次数。然而，在实际的密码猜测场景中，使用多个密码猜测模型并行进行猜测需要的次数是单个模型的数倍，这与实际需求不一致)。\n\t\n2. 我们的目的只是证明通过跨多个视图的特征量化来增强密码破解能力的可行性。\n\t![[Pasted image 20240419151949.png]]\n\t密码结构 Struct：基于 PCFG 算法来分析猜测列表中的密码结构的数量。 例如，如果猜测列表包含 “dearbook134”、“dearbook309” 和 “123dearbook” 等密码，则它包含两种类型的密码结构： “A8D3” 和 “D3A8”。\n\t有效密码比例 Effect：有效密码/猜测列表大小。猜测列表中的密码如果能够与测试集中的密码匹配，则认为该密码有效。\n\t破解成功率 $Min_{auto}$\n\t唯一密码比例 Uniq：唯一密码/单个单个猜测列表 \n\t\n\n3. 结果：\n\t1. Effect 和  $Min_{auto}$ 说明了多视图集成所带来的猜测有效性的提高。\n\t2. Uniq 和 struct 说明通过集成多个视图实现的多样性的增强。整合更多元的观点可以增加猜测的多样性，覆盖更多的密码特征，从而提高密码猜测的有效性\n\n有效的密码分析：\n问题：组合多个猜测列表会产生许多独特的密码，其大小远远超过单个猜测列表的大小。 如果全部用于最后的破解，会导致破解次数消耗过多。\n![[Pasted image 20240419155303.png]]\n幸运的是，图4（a）表明，当猜测数量增长到大约 $4×10^4$ 时，组合多个猜测列表的有效密码数量开始低于单个猜测列表的大小（an注：从一个数据集中选择 100 比 四个数据集中每个选择 25 个效率高）。\n在这种情况下，通过选择这些有效密码中的一部分，即使优化后的猜测列表大小小于单个猜测列表的大小，猜测的成功率仍然可以达到多视图集成的 Minauto 指标。（an注：此时单猜测列表 和 多猜测列表分母增加相同大小时， 单猜测列表的分子增加的多，论文描述的意思是减少了 多猜测列表分母增加的个数，有点偷换概念的意思）\n\n\n在了解测试集的前提下，我们假设了一种最优的混合密码猜测方法，该方法可以有效地整合多个猜测列表以产生优化的猜测列表。 此混合密码猜测方法生成的优化猜测列表包含每个猜测列表中最有效的密码。 如果猜测的密码在测试集中破解频率最高的密码，则认为该密码具有最高的效率。 例如，在整合大小为103的猜测列表时，我们首先对猜测的密码进行去重，并将其与测试集进行比较，计算每个猜测的密码可以破解的测试密码的数量。 然后，我们按照破解次数降序选择猜测的密码，并将其添加到最佳猜测列表中，直到最佳猜测列表的大小也达到103。我们将最佳猜测列表的破解成功率与最佳猜测列表的破解成功率进行比较。 由单一密码猜测模型生成的猜测列表（见图4（b））。 如图 4（b）所示，当猜测数 < 4 × 104 时，与 PCFG 模型相比，整合两视图的最优猜测列表的破解成功率平均提高了 1.3%，整合三视图的破解成功率平均提高了 1.3%。 2.6%，整合四视图增长了2.8%。 尽管有效密码的数量超过了单个猜测列表的大小，但选择效率最高的部分同等大小的猜测密码仍然可以增强破解能力。 \n\n上述结果表明，从多个视图中准确提取有效密码是进行有效混合密码猜测的关键。\n\n\n多视图子集分析：\n目的：为了找到从多个视图中提取有效密码的有效方法，我们对多个视图之间的子集进行了分析。\n手段：对不同模型生成的相同大小的猜测列表进​​行集合运算，以获得相交和互补的子集。\n![[Pasted image 20240419165944.png]]\n\n\n我们分析了集成不同数量的视图时多视图子集的变化（见图 5）。 如图 5 所示，集成两个视图生成三个子集，三个视图集成生成七个子集，四个视图集成生成 15 个子集。 此外，随着集成视图数量的增加，每个子集中有效密码的分布变得更加集中。 相交子集中有效密码的比例（中间红色数值表示）随着集成视图的增加而增加。 在基于CSDN数据集的实验中，融合两个视图时，相交子集中有效密码的比例为51.51%。 当集成三视图时，这一比例增加了 21.0%，而当集成四视图时，这一比例又增加了 3.9%。 这些结果表明，集成多个视图可以提供有关有效密码分发的增量信息。 随着更多视图的整合，增量信息增多，有效密码的分布更加集中。\n\n![[Pasted image 20240419170332.png]]\n\n\n\n我们继续分析有效密码在各个子集中的分布。 目前，当我们仅通过集合运算提取猜测列表中的相交和互补子集时，子集中的密码不包括顺序。 因此，我们通过分析不同大小的猜测列表中子集的平均破解成功率来评估子集中有效密码的分布（见图7）。 为了便于表示，我们用图6来表示每个平均破解成功率所代表的子集。 具体来说，我们使用 4 位二进制代码来命名每个子集，其中每个位代表密码在特定模型生成的猜测列表中的出现，从左到右分别为：PCFG、FLA、Markov 和 RFGuess。 例如，“1000”表示该子集中的密码仅出现在PCFG猜测列表中。\n\n![[Pasted image 20240419170602.png]]\n\n如图7所示，相交子集“1111”的整体破解效率明显优于其他子集。 然而，相交子集中的密码的后半部分并不优于其他子集中的密码的前半部分。 例如，相交子集“1111”在101次猜测中的平均破解成功率为3.57×10−6，而互补子集“0010”在101次猜测中的平均破解成功率为2.61×10−5。 有趣的是，子集的平均破解成功率与单个猜测列表的大小呈现近似线性关系。 当我们将 15 条曲线作为一个整体来考虑时，这一点变得更加明显。 这可能符合密码中的 Zipf 定律 [46]。 我们使用PDFZipf模型[46]拟合数据：logfr = logC − s · logr，其中fr和r分别对应于平均破解成功率和单个猜测列表的大小。 如表III所示，C ε [-3.55，-0.85]和s ε [-0.92，-0.63]是常数。 拟合的 RMSE 在 [0.08, 0.24] 范围内。\n\n这种现象有助于在混合密码猜测中利用多种密码猜测模型的优势。 尽管密码分布中的齐普夫定律通常用于解释用户设置密码的行为，但也有研究 [33]、[47] 通过分析密码猜测模型中齐普夫定律的存在来改进密码猜测模型。 在我们的例子中，齐普夫定律表明，猜测密码的效率随着密码在子集中的排名降序而下降。 换句话说，子集中排名较高的密码被认为具有较高的破解效率。\n\n\n\n\n\n\n\n# 密码结构\n\n密码结构（Struct.）的数量是通过对猜测列表中的密码进行分析和统计得出的。具体来说，密码结构是指密码中的字符排列方式，例如\"A8D3\"或\"D3A8\"。在文中，作者使用PCFG算法对密码结构进行分析，通过猜测列表中的密码来确定不同类型的密码结构的数量。通过对密码结构的数量进行统计分析，可以评估多视图整合对密码破解能力的提升效果。这些统计特征表明，整合更多不同的视图可以增加猜测的多样性，覆盖更多的密码特征，从而提高口令猜测的有效性。\n\n# Minauto\n类似于一个破解成功率。\n\n\n# 多视图提取模块的工作原理是什么？\n\n多视图提取模块的工作原理是从多个猜测列表中提取交集和补集密码，以生成多视图子集。该模块首先根据输入的猜测列表数量生成多个子集，并为每个子集分配逻辑标签。然后，根据排名，模块按照密码的逻辑规则将密码分别添加到交集子集或补集子集中。最终，该模块输出维护的多视图子集，其中包含了有效密码的信息。这一过程有助于准确地从多个视图中提取和重新组织有效密码。\n\n# 分割选择模块的作用是什么？\n\n分割选择模块的作用是进一步细化每个子集，根据幂律间隔将其分割成多个密码片段。该模块利用幂律分布间隔序列来将输入的子集分割成更细粒度的密码片段。然后，该模块利用验证集来评估这些密码片段的破解效率，具体来说，该模块计算这些密码片段的平均破解成功率。最终，该模块重新组织有效的密码片段，生成最终的优化猜测列表。\n","slug":"论文笔记/GuessFuse","published":1,"date":"2024-04-22T13:14:48.835Z","updated":"2024-04-19T09:08:47.126Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0i001bkgg488221yr7","content":"<p>多视图混合密码猜测</p>\n<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><ol>\n<li>集合多种模型进行密码猜测（也称为混合密码猜测），从而更好地捕获真实破解者的破解能力</li>\n<li>问题提出：为什么整合模型会有效果，如何整合模型还没有研究，</li>\n<li>本文从多视图学习的概念中汲取灵感：<ol>\n<li>将各种密码猜测模型生成的猜测列表视为数据的多个视图。</li>\n<li>通过对这些密码猜测列表的分析发现了混合密码猜测模型能增强破解能力的原因：<ol>\n<li>集成更多元的视图可以覆盖更广泛的异构密码特征。</li>\n<li>并提供更详细的有效密码信息分布。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>提出了一种新的密码猜测框架：GuessFuse <ol>\n<li>采用多视图子集提取模块和分段分割选择模块，从多个猜测列表中准确提取和重组有效密码。</li>\n</ol>\n</li>\n<li>在 六个大型数据集中证明了 GuessFuse 的有效性。<ol>\n<li>通过组合两个（或五个）猜测列表，GuessFuse 在 107 个猜测中比其最重要的同行平均高出 11.00% ∼ 59.62%（或 4.70% ∼ 17.66%）</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><ol>\n<li>密码使用频繁</li>\n<li>密码破解器的性能是密码强度估计器的一个设计标准。</li>\n<li>密码猜测分类：数据驱动和基于规则。当前主要是数据驱动方法效果更好。<ol>\n<li>PCFG [6] 对具有简单结构的密码（例如，passsword123）产生更好的猜测性能</li>\n<li>马尔可夫模型 [22] 对于具有上下文相关特征的密码（例如，1qaz2wsx）更有效。</li>\n</ol>\n</li>\n<li>但是现实世界的破解专家能力大于单一的模型能力。</li>\n<li>混合密码猜测的研究在初级阶段。<ol>\n<li>[16]通过并行应用多个密码猜测模型，设计了一个 Minauto 指标作为混合密码猜测的上限。</li>\n<li>一些研究[29]-[33]试图在结构层面整合特定模型的优点（例如，分别在密码结构层面和字符串层面应用PCFG模型和马尔可夫模型进行密码猜测[29]） 。</li>\n<li> 另一方面，一些研究[32]、[34]实验性地组合来自不同密码猜测模型的多个猜测列表，以实现更准确的密码猜测。</li>\n</ol>\n</li>\n<li>然而，上述方法要么集成了两种特定的密码猜测模型，要么简单地组合猜测列表，而不是从机制上解决这个问题。未能有效利用多种异构密码猜测模型的优势。</li>\n<li> 更重要的是，据我们所知，为什么集成多个密码猜测模型可以增强破解能力尚未得到满意的答案。</li>\n<li>我们将各种密码猜测模型生成的猜测列表视为数据的多个视图。 通过对多个猜测列表组合的深入分析，我们揭示了混合密码猜测能够增强破解能力的关键原因。</li>\n<li> 同时我们还发现多个视图之间的子集中的密码也遵循Zipf定律。</li>\n</ol>\n<p>基于这些关键发现，我们提出了一种基于多视图学习的混合密码猜测框架，名为 GuessFuse。 GuessFuse 可根据以下工作流程从巨大的密码空间中实现准确的密码猜测结果。</p>\n<ol>\n<li>GuessFuse 首先使用单独的密码猜测模型（例如 PCFG 和马尔可夫模型）生成多个密码猜测列表。 </li>\n<li>然后，使用多视图子集提取方法提取多个猜测列表之间的相交和互补子集。</li>\n<li>接下来，GuessFuse 根据幂律将子集分割成密码段。 </li>\n<li>大量的实验表明，GuessFuse 的性能优于同类产品，并且能够有效地整合多种密码猜测模型的优点。</li>\n<li>我们还将 GuessFuse 应用于 PSM 进行更广泛的比较分析。 我们发现 Minauto指标低估了某些密码的强度，从而降低了密码设置的可用性。 使用 GuessFuse 可以解决这个问题。</li>\n</ol>\n<h1 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h1><h2 id=\"相关研究\"><a href=\"#相关研究\" class=\"headerlink\" title=\"相关研究\"></a>相关研究</h2><ol>\n<li>密码破解方式概述</li>\n<li>密码强度指标 minauto ， 但Minauto指标只是理论上的上限，并行使用多个密码猜测模型比使用单个模型需要多数倍的猜测次数，与实际猜测场景的要求不一致。</li>\n<li>混合密码猜测模型提出但是处于起步阶段。 根据集成对象的划分，现有的混合密码猜测方法可以分为模型架构级别的集成和猜测列表级别的集成。<ol>\n<li>模型架构级别：<ol>\n<li>2018 年，Zhang 等人。 [29]提出了一种称为 SPSR 的混合密码猜测模型。 SPSR将PCFG模型[6]应用于密码结构层，将马尔可夫链模型[22]应用于密码字符串层。 </li>\n<li>同年，他们还提出了SPRNN模型[30]，该模型结合了结构划分和双向长短期记忆递归神经网络（BiLSTM）。 </li>\n<li>与 SPRNN 相反，Xia 等人。 [31]提出了另一种混合密码猜测模型，称为 PL。 PL采用PCFG模型[6]进行密码字符串层解构，并采用LSTM模型[15]进行结构层建模。<br> 这些双重方法有效地利用了两种密码猜测模型在不同密码分析粒度层的优势。 然而，这些模型架构级别的集成需要有针对性的定制，限制了它们集成更广泛的密码猜测模型的能力。</li>\n</ol>\n</li>\n<li>猜测列表级别：<ol>\n<li>2021 年，王等人。 [32]平均组合多个密码猜测列表并对输出进行重复数据删除。 他们发现，将密码猜测模型与明显不同的密码生成策略（例如RNN模型[39]和PCFG模型[6]）相结合可以有效提高破解成功率。 </li>\n<li>2022 年，帕里什等人。 [34]对训练集中的密码进行去重，并按密码频率降序排序，生成猜测列表。 他们将其定义为“身份猜测者”。 他们发现，将模型生成的多个猜测列表与 Identity Guesser 相结合，可以显着提高破解成功率。<br> 不过，这两项研究仅在猜测清单层面进行了初步尝试。 同等地组合猜测列表并不能准确地从每个猜测模型中提取有效部分。</li>\n<li>2022 年，Han 等人。 [33]介绍了一种称为 hyPassGu 的混合猜测框架。 hyPassGu 通过限制每个模型生成目标类型的密码并分别确定猜测次数，利用 PCFG 和马尔可夫模型的优势。 尽管声称 hyPassGu 可以应用于 PCFG 和马尔可夫之外的其他模型，但它需要先了解模型的架构及其目标密码类型。 因此，它不能直接应用于其他模型。 另外，hyPassGu根据密码的结构特征将密码粗略地分为两类，导致有效密码大量流失。 因此，hyPassGu的破解成功率低于单个模型，仅略优于限制特定类型密码生成的模型。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>关键问题仍然没有令人满意的答案：<br> （1）什么有助于提高混合密码猜测的破解能力？<br> （2）如何有效发挥多种不同模型的优势？ 本文重点解决这些问题。</li>\n</ol>\n<h2 id=\"密码猜测场景\"><a href=\"#密码猜测场景\" class=\"headerlink\" title=\"密码猜测场景\"></a>密码猜测场景</h2><p><strong>数据驱动的密码猜测模型 + 拖网猜测 + 混合密码猜测</strong></p>\n<ol>\n<li>攻击者首先根据泄露的数据集构建密码猜测模型；</li>\n<li>然后使用模型生成猜测；</li>\n<li>最后尝试使用猜测破解所有目标密码。</li>\n</ol>\n<p>虽然基于规则的密码猜测工具[20]、[21]也可用于混合密码猜测，但这些工具仍然依赖于目标数据集分布的先验知识来增强密码猜测的有效性。</p>\n<p>注意：<br>拖网场景可以进一步分为站内场景和跨站场景。 虽然跨站密码猜测场景较为真实，但攻击者一般以掌握目标数据的部分分布信息为前提来猜测密码。<br>因此，为了更好地描述混合密码猜测的概念，我们将站点内拖网场景中的密码猜测任务形式化。<br><strong>形式化</strong>：一些符号表示，某个猜测密码成功破解了目标系统的多少个密码</p>\n<h2 id=\"多视角学习\"><a href=\"#多视角学习\" class=\"headerlink\" title=\"多视角学习\"></a>多视角学习</h2><p>多视图学习的概念与混合密码猜测的概念非常吻合。 多视图学习引入了一个函数来对特定视图进行建模，并联合优化所有函数以利用相同输入数据的冗余视图，从而提高学习性能[40]。<br>在更高层次上，多视图学习构建多个单一视图并评估它们的表现，然后设计功能来组合这些视图以改善学习成果。<br>同样，混合密码猜测旨在通过利用从不同角度分析数据的多个模型来提高密码猜测的有效性。 因此，多视图学习可以用于解决在混合密码猜测中集成各种密码猜测模型的优势的挑战。</p>\n<p>徐等人。 [41]提出多视图学习基于两个关键原则有效地利用多种视图：</p>\n<ol>\n<li>共识和互补。 共识原则旨在最大限度地达成不同观点之间的一致。 </li>\n<li>互补原则指出，每种观点都可能包含其他观点所不存在的独特知识。 通过有效利用多种观点的共识和互补性，可以实现对数据的全面、准确的描述。<br>在本文中，我们基于这些原理探索混合密码猜测。</li>\n</ol>\n<h2 id=\"数据集\"><a href=\"#数据集\" class=\"headerlink\" title=\"数据集\"></a>数据集</h2><p>使用包含 5400 万个纯文本密码的 6 个数据集（参见表 I）。<br>其中，三个数据集来自英文网站，三个数据集来自中文网站，涵盖六种不同的服务类型。<br>数据源的多样性有助于减少我们分析中的偏差。 由于我们所有的数据集都可以在互联网上公开获取，因此这项工作的结果是可重复的。<br>![[Pasted image 20240418173807.png]]</p>\n<h3 id=\"数据清洗\"><a href=\"#数据清洗\" class=\"headerlink\" title=\"数据清洗\"></a>数据清洗</h3><p>原始数据集包含异常情况，例如未解密的哈希字符串、不可能由用户生成的过长密码以及包含不符合标准密码策略的不可打印字符的密码。 因此，我们首先对数据集进行数据清洗。 我们删除包含 95 个可打印 ASCII 字符之外的字符的密码，并删除长度 &gt; 30 的密码。这种数据清理策略在现有的密码猜测文献中也很流行 [24]、[26]、[42]。</p>\n<h3 id=\"道德考虑\"><a href=\"#道德考虑\" class=\"headerlink\" title=\"道德考虑\"></a>道德考虑</h3><p>尽管我们使用的数据集是公开的，并广泛用于密码猜测研究 [8]、[27]、[32]–[34]，但这些数据集包含敏感的个人信息。 因此，我们仅分析密码数据的分布特征，并报告汇总的统计信息。 我们不会将任何数据用于学术研究以外的目的，因此不会增加受影响个人的风险。</p>\n<h2 id=\"密码猜测模型\"><a href=\"#密码猜测模型\" class=\"headerlink\" title=\"密码猜测模型\"></a>密码猜测模型</h2><p>采用了四种领先的密码猜测模型（例如 Markov、PCFG、FLA 和 RFGuess）。</p>\n<p>为了减轻其他因素对分析结果的影响，我们重点关注站内密码猜测场景。 这种情况被认为是理想的，因为训练集和测试集具有相同的数据分布，确保了我们分析的一致性。</p>\n<p>我们从数据集中随机抽取大小为 $10^6$ 的子集作为测试集，而其余数据用作训练集。 我们发现结果对于基于此测试集大小的分析来说足够稳定。 这一现象与论文[9]、[43]、[44]一致。 用于生成猜测列表的每个模型的设置如下：<br> 1）PCFG。 我们使用了 PCFG 模型 [6] 的 4.0 版，该模型可以在 GitHub 网站上找到。 该模型的语法包括六个段类别：字母A、数字D、其他字符O、键盘D、特殊字符串X和年份Y。<br> 2）Markov。 我们选择 4 阶马尔可夫模型，并采用[26]中使用的拉普拉斯平滑和结束符号正则化来生成猜测。<br> 3）FLA。 我们利用了 GitHub 网站上提供的 FLA 开源代码2，并遵循[15]中指定的推荐参数。 我们训练了一个由三个 LSTM 层组成的模型，每层有 128 个单元和两个密集层，总共 20 个 epoch。<br> 4）RFGuess。 参考[24]，我们训练了一个有 30 棵决策树的随机森林。 其叶子节点的最小数量为10，特征的最大比例为80%，其余为scikit-learn框架的默认值[45]。</p>\n<h1 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h1><p> 本节通过多视角分析，依次解决以下问题：<br>    （1）混合密码猜测能够提高破解能力的关键原因是什么？<br>    （2）使用猜测列表进​​行混合密码猜测可以获得什么好处？</p>\n<h2 id=\"混合密码猜测的本质\"><a href=\"#混合密码猜测的本质\" class=\"headerlink\" title=\"混合密码猜测的本质\"></a>混合密码猜测的本质</h2><h3 id=\"数据集比较\"><a href=\"#数据集比较\" class=\"headerlink\" title=\"数据集比较\"></a>数据集比较</h3><p>我们通过比较每个模型生成的猜测列表来展示密码猜测模型之间的差异<br>![[Pasted image 20240418204958.png]]</p>\n<ol>\n<li>PCFG 模型生成的猜测列表包括诸如 “dearbook123456” 和 “DEARBOOK” 之类的密码，这表明偏向于生成包含常见短语和简单结构的密码。 </li>\n<li>Markov 模型生成的猜测列表包含 “woshili” 和 “1989123” 等密码，反映了基于密码内字符相关性进行猜测的偏见。</li>\n<li>RFGuess 模型的猜测列表包括诸如 “1234567” 和 “1234567}” 之类的密码，表明了将常见短语与各种特征相结合的趋势。 </li>\n<li>FLA 模型与马尔可夫模型类似，会生成一个包含 “45665456” 和 “qwqwqwqww” 等密码的猜测列表，显示出其对密码中顺序上下文一致性的偏见。 然而，FLA 模型生成的猜测列表也与马尔可夫模型不同。</li>\n<li>中心区域还有“dearbook”、“12345678”等密码。 它表明，尽管每个模型都有独特的偏见，但他们已经就某些密码达成了共识。 这些密码可能很常用，并且很容易被各种模型预测到。</li>\n</ol>\n<h3 id=\"为什么需要混合\"><a href=\"#为什么需要混合\" class=\"headerlink\" title=\"为什么需要混合\"></a>为什么需要混合</h3><p>猜测列表中的相似点和差异强调，即使基于相同的数据集，现有的密码猜测模型也可以生成包含不同密码特征的猜测列表。</p>\n<p>本质上，密码猜测模型是根据用户设置易受攻击密码的行为而设计的。通过准确识别和匹配这些弱密码的特征，模型就可以生成破戒律很高的猜测列表。然而，由于用户密码设置行为的异构多样性[42]。即使像 PCFG 这样的已经涵盖了各种弱密码特征的模型（参见第II-E节），也无法在有限的猜测次数内完全覆盖所有特征 。 利用多种具有不同偏差的密码猜测模型的组合，可以更全面地识别和匹配密码特征，从而提高密码猜测的性能。</p>\n<h3 id=\"怎么混合\"><a href=\"#怎么混合\" class=\"headerlink\" title=\"怎么混合\"></a>怎么混合</h3><ol>\n<li>在模型的结构层面上利用多个异构密码猜测模型是相当具有挑战性的，并且不适用于新提出的密码猜测模型（例如RFGuess），这背离了使用多个异构模型的最初想法。</li>\n<li>密码猜测模型最终会生成猜测列表。 鉴于多视图学习对于混合密码猜测的天然适用性（参见第 II-C 节），我们将密码猜测模型生成的猜测列表视为数据的多个视图。<ol>\n<li> 在多视图学习领域，直观的是，集成多个不同视图来分析和处理数据可以产生更全面的信息，从而提高学习模型的性能。 这个概念也适用于混合密码猜测。 </li>\n<li>我们用一个示意性的解释来描述这一点。<br> ![[Pasted image 20240418211929.png]]</li>\n<li>如图3所示，不同的密码猜测模型生成的猜测列表{G1，G2，G3，····，Gl}可以覆盖测试集T的不同部分。假设混合密码猜测方法H可以有效地提取出测试集T的不同部分。 从{G1,G2,G3,····,Gl}中覆盖T的密码，生成优化猜测列表eG。 </li>\n<li>组合的猜测列表越多，测试集的覆盖范围就越大，从而产生更好的破解能力。 </li>\n<li>请注意，图 3 中描绘的示意图可能并不通用，因为猜测列表中的密码通常存在重叠。 然而，组合更多猜测列表可以覆盖更多测试集的因果关系是普遍存在的。 我们将通过下面的分析来证明这一点。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"多视图集成的优点\"><a href=\"#多视图集成的优点\" class=\"headerlink\" title=\"多视图集成的优点\"></a>多视图集成的优点</h2><p>依据：</p>\n<ol>\n<li><p>大量实验已经证实，我们所描述的结果在六个数据集中得到一致观察，从而证实了它们的普遍性</p>\n</li>\n<li><p>以 CSDN 数据集生成的 top $10^6$ 密码猜测列表为例。</p>\n</li>\n<li><p>实验：<br>定量特征分析：<br>对组合猜测列表的统计特征进行定量比较，以证明多视图集成带来的猜测有效性。</p>\n</li>\n<li><p>将每个模型生成的猜测列表以相同的大小组合起来，并对它们进行重复数据删除，然后将结果与单个猜测列表进​​行比较。<br> 例如，在比较大小为 $10^3$ 的猜测列表时，我们结合 PCFG 和马尔可夫模型生成的前 $10^3$ 个猜测，删除任何重复的密码。 输出被定义为两个视图集成。<br> 请注意，这种组合策略与 Minauto 指标 [16] 的计算相同，并不反映现实场景 ( Minauto 指标是一个理论上的上限，代表了每个密码被所有密码猜测模型破解所需的最小猜测次数。然而，在实际的密码猜测场景中，使用多个密码猜测模型并行进行猜测需要的次数是单个模型的数倍，这与实际需求不一致)。</p>\n</li>\n<li><p>我们的目的只是证明通过跨多个视图的特征量化来增强密码破解能力的可行性。<br> ![[Pasted image 20240419151949.png]]<br> 密码结构 Struct：基于 PCFG 算法来分析猜测列表中的密码结构的数量。 例如，如果猜测列表包含 “dearbook134”、“dearbook309” 和 “123dearbook” 等密码，则它包含两种类型的密码结构： “A8D3” 和 “D3A8”。<br> 有效密码比例 Effect：有效密码&#x2F;猜测列表大小。猜测列表中的密码如果能够与测试集中的密码匹配，则认为该密码有效。<br> 破解成功率 $Min_{auto}$<br> 唯一密码比例 Uniq：唯一密码&#x2F;单个单个猜测列表 </p>\n</li>\n<li><p>结果：</p>\n<ol>\n<li>Effect 和  $Min_{auto}$ 说明了多视图集成所带来的猜测有效性的提高。</li>\n<li>Uniq 和 struct 说明通过集成多个视图实现的多样性的增强。整合更多元的观点可以增加猜测的多样性，覆盖更多的密码特征，从而提高密码猜测的有效性</li>\n</ol>\n</li>\n</ol>\n<p>有效的密码分析：<br>问题：组合多个猜测列表会产生许多独特的密码，其大小远远超过单个猜测列表的大小。 如果全部用于最后的破解，会导致破解次数消耗过多。<br>![[Pasted image 20240419155303.png]]<br>幸运的是，图4（a）表明，当猜测数量增长到大约 $4×10^4$ 时，组合多个猜测列表的有效密码数量开始低于单个猜测列表的大小（an注：从一个数据集中选择 100 比 四个数据集中每个选择 25 个效率高）。<br>在这种情况下，通过选择这些有效密码中的一部分，即使优化后的猜测列表大小小于单个猜测列表的大小，猜测的成功率仍然可以达到多视图集成的 Minauto 指标。（an注：此时单猜测列表 和 多猜测列表分母增加相同大小时， 单猜测列表的分子增加的多，论文描述的意思是减少了 多猜测列表分母增加的个数，有点偷换概念的意思）</p>\n<p>在了解测试集的前提下，我们假设了一种最优的混合密码猜测方法，该方法可以有效地整合多个猜测列表以产生优化的猜测列表。 此混合密码猜测方法生成的优化猜测列表包含每个猜测列表中最有效的密码。 如果猜测的密码在测试集中破解频率最高的密码，则认为该密码具有最高的效率。 例如，在整合大小为103的猜测列表时，我们首先对猜测的密码进行去重，并将其与测试集进行比较，计算每个猜测的密码可以破解的测试密码的数量。 然后，我们按照破解次数降序选择猜测的密码，并将其添加到最佳猜测列表中，直到最佳猜测列表的大小也达到103。我们将最佳猜测列表的破解成功率与最佳猜测列表的破解成功率进行比较。 由单一密码猜测模型生成的猜测列表（见图4（b））。 如图 4（b）所示，当猜测数 &lt; 4 × 104 时，与 PCFG 模型相比，整合两视图的最优猜测列表的破解成功率平均提高了 1.3%，整合三视图的破解成功率平均提高了 1.3%。 2.6%，整合四视图增长了2.8%。 尽管有效密码的数量超过了单个猜测列表的大小，但选择效率最高的部分同等大小的猜测密码仍然可以增强破解能力。 </p>\n<p>上述结果表明，从多个视图中准确提取有效密码是进行有效混合密码猜测的关键。</p>\n<p>多视图子集分析：<br>目的：为了找到从多个视图中提取有效密码的有效方法，我们对多个视图之间的子集进行了分析。<br>手段：对不同模型生成的相同大小的猜测列表进​​行集合运算，以获得相交和互补的子集。<br>![[Pasted image 20240419165944.png]]</p>\n<p>我们分析了集成不同数量的视图时多视图子集的变化（见图 5）。 如图 5 所示，集成两个视图生成三个子集，三个视图集成生成七个子集，四个视图集成生成 15 个子集。 此外，随着集成视图数量的增加，每个子集中有效密码的分布变得更加集中。 相交子集中有效密码的比例（中间红色数值表示）随着集成视图的增加而增加。 在基于CSDN数据集的实验中，融合两个视图时，相交子集中有效密码的比例为51.51%。 当集成三视图时，这一比例增加了 21.0%，而当集成四视图时，这一比例又增加了 3.9%。 这些结果表明，集成多个视图可以提供有关有效密码分发的增量信息。 随着更多视图的整合，增量信息增多，有效密码的分布更加集中。</p>\n<p>![[Pasted image 20240419170332.png]]</p>\n<p>我们继续分析有效密码在各个子集中的分布。 目前，当我们仅通过集合运算提取猜测列表中的相交和互补子集时，子集中的密码不包括顺序。 因此，我们通过分析不同大小的猜测列表中子集的平均破解成功率来评估子集中有效密码的分布（见图7）。 为了便于表示，我们用图6来表示每个平均破解成功率所代表的子集。 具体来说，我们使用 4 位二进制代码来命名每个子集，其中每个位代表密码在特定模型生成的猜测列表中的出现，从左到右分别为：PCFG、FLA、Markov 和 RFGuess。 例如，“1000”表示该子集中的密码仅出现在PCFG猜测列表中。</p>\n<p>![[Pasted image 20240419170602.png]]</p>\n<p>如图7所示，相交子集“1111”的整体破解效率明显优于其他子集。 然而，相交子集中的密码的后半部分并不优于其他子集中的密码的前半部分。 例如，相交子集“1111”在101次猜测中的平均破解成功率为3.57×10−6，而互补子集“0010”在101次猜测中的平均破解成功率为2.61×10−5。 有趣的是，子集的平均破解成功率与单个猜测列表的大小呈现近似线性关系。 当我们将 15 条曲线作为一个整体来考虑时，这一点变得更加明显。 这可能符合密码中的 Zipf 定律 [46]。 我们使用PDFZipf模型[46]拟合数据：logfr &#x3D; logC − s · logr，其中fr和r分别对应于平均破解成功率和单个猜测列表的大小。 如表III所示，C ε [-3.55，-0.85]和s ε [-0.92，-0.63]是常数。 拟合的 RMSE 在 [0.08, 0.24] 范围内。</p>\n<p>这种现象有助于在混合密码猜测中利用多种密码猜测模型的优势。 尽管密码分布中的齐普夫定律通常用于解释用户设置密码的行为，但也有研究 [33]、[47] 通过分析密码猜测模型中齐普夫定律的存在来改进密码猜测模型。 在我们的例子中，齐普夫定律表明，猜测密码的效率随着密码在子集中的排名降序而下降。 换句话说，子集中排名较高的密码被认为具有较高的破解效率。</p>\n<h1 id=\"密码结构\"><a href=\"#密码结构\" class=\"headerlink\" title=\"密码结构\"></a>密码结构</h1><p>密码结构（Struct.）的数量是通过对猜测列表中的密码进行分析和统计得出的。具体来说，密码结构是指密码中的字符排列方式，例如”A8D3”或”D3A8”。在文中，作者使用PCFG算法对密码结构进行分析，通过猜测列表中的密码来确定不同类型的密码结构的数量。通过对密码结构的数量进行统计分析，可以评估多视图整合对密码破解能力的提升效果。这些统计特征表明，整合更多不同的视图可以增加猜测的多样性，覆盖更多的密码特征，从而提高口令猜测的有效性。</p>\n<h1 id=\"Minauto\"><a href=\"#Minauto\" class=\"headerlink\" title=\"Minauto\"></a>Minauto</h1><p>类似于一个破解成功率。</p>\n<h1 id=\"多视图提取模块的工作原理是什么？\"><a href=\"#多视图提取模块的工作原理是什么？\" class=\"headerlink\" title=\"多视图提取模块的工作原理是什么？\"></a>多视图提取模块的工作原理是什么？</h1><p>多视图提取模块的工作原理是从多个猜测列表中提取交集和补集密码，以生成多视图子集。该模块首先根据输入的猜测列表数量生成多个子集，并为每个子集分配逻辑标签。然后，根据排名，模块按照密码的逻辑规则将密码分别添加到交集子集或补集子集中。最终，该模块输出维护的多视图子集，其中包含了有效密码的信息。这一过程有助于准确地从多个视图中提取和重新组织有效密码。</p>\n<h1 id=\"分割选择模块的作用是什么？\"><a href=\"#分割选择模块的作用是什么？\" class=\"headerlink\" title=\"分割选择模块的作用是什么？\"></a>分割选择模块的作用是什么？</h1><p>分割选择模块的作用是进一步细化每个子集，根据幂律间隔将其分割成多个密码片段。该模块利用幂律分布间隔序列来将输入的子集分割成更细粒度的密码片段。然后，该模块利用验证集来评估这些密码片段的破解效率，具体来说，该模块计算这些密码片段的平均破解成功率。最终，该模块重新组织有效的密码片段，生成最终的优化猜测列表。</p>\n","excerpt":"","more":"<p>多视图混合密码猜测</p>\n<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><ol>\n<li>集合多种模型进行密码猜测（也称为混合密码猜测），从而更好地捕获真实破解者的破解能力</li>\n<li>问题提出：为什么整合模型会有效果，如何整合模型还没有研究，</li>\n<li>本文从多视图学习的概念中汲取灵感：<ol>\n<li>将各种密码猜测模型生成的猜测列表视为数据的多个视图。</li>\n<li>通过对这些密码猜测列表的分析发现了混合密码猜测模型能增强破解能力的原因：<ol>\n<li>集成更多元的视图可以覆盖更广泛的异构密码特征。</li>\n<li>并提供更详细的有效密码信息分布。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>提出了一种新的密码猜测框架：GuessFuse <ol>\n<li>采用多视图子集提取模块和分段分割选择模块，从多个猜测列表中准确提取和重组有效密码。</li>\n</ol>\n</li>\n<li>在 六个大型数据集中证明了 GuessFuse 的有效性。<ol>\n<li>通过组合两个（或五个）猜测列表，GuessFuse 在 107 个猜测中比其最重要的同行平均高出 11.00% ∼ 59.62%（或 4.70% ∼ 17.66%）</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><ol>\n<li>密码使用频繁</li>\n<li>密码破解器的性能是密码强度估计器的一个设计标准。</li>\n<li>密码猜测分类：数据驱动和基于规则。当前主要是数据驱动方法效果更好。<ol>\n<li>PCFG [6] 对具有简单结构的密码（例如，passsword123）产生更好的猜测性能</li>\n<li>马尔可夫模型 [22] 对于具有上下文相关特征的密码（例如，1qaz2wsx）更有效。</li>\n</ol>\n</li>\n<li>但是现实世界的破解专家能力大于单一的模型能力。</li>\n<li>混合密码猜测的研究在初级阶段。<ol>\n<li>[16]通过并行应用多个密码猜测模型，设计了一个 Minauto 指标作为混合密码猜测的上限。</li>\n<li>一些研究[29]-[33]试图在结构层面整合特定模型的优点（例如，分别在密码结构层面和字符串层面应用PCFG模型和马尔可夫模型进行密码猜测[29]） 。</li>\n<li> 另一方面，一些研究[32]、[34]实验性地组合来自不同密码猜测模型的多个猜测列表，以实现更准确的密码猜测。</li>\n</ol>\n</li>\n<li>然而，上述方法要么集成了两种特定的密码猜测模型，要么简单地组合猜测列表，而不是从机制上解决这个问题。未能有效利用多种异构密码猜测模型的优势。</li>\n<li> 更重要的是，据我们所知，为什么集成多个密码猜测模型可以增强破解能力尚未得到满意的答案。</li>\n<li>我们将各种密码猜测模型生成的猜测列表视为数据的多个视图。 通过对多个猜测列表组合的深入分析，我们揭示了混合密码猜测能够增强破解能力的关键原因。</li>\n<li> 同时我们还发现多个视图之间的子集中的密码也遵循Zipf定律。</li>\n</ol>\n<p>基于这些关键发现，我们提出了一种基于多视图学习的混合密码猜测框架，名为 GuessFuse。 GuessFuse 可根据以下工作流程从巨大的密码空间中实现准确的密码猜测结果。</p>\n<ol>\n<li>GuessFuse 首先使用单独的密码猜测模型（例如 PCFG 和马尔可夫模型）生成多个密码猜测列表。 </li>\n<li>然后，使用多视图子集提取方法提取多个猜测列表之间的相交和互补子集。</li>\n<li>接下来，GuessFuse 根据幂律将子集分割成密码段。 </li>\n<li>大量的实验表明，GuessFuse 的性能优于同类产品，并且能够有效地整合多种密码猜测模型的优点。</li>\n<li>我们还将 GuessFuse 应用于 PSM 进行更广泛的比较分析。 我们发现 Minauto指标低估了某些密码的强度，从而降低了密码设置的可用性。 使用 GuessFuse 可以解决这个问题。</li>\n</ol>\n<h1 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h1><h2 id=\"相关研究\"><a href=\"#相关研究\" class=\"headerlink\" title=\"相关研究\"></a>相关研究</h2><ol>\n<li>密码破解方式概述</li>\n<li>密码强度指标 minauto ， 但Minauto指标只是理论上的上限，并行使用多个密码猜测模型比使用单个模型需要多数倍的猜测次数，与实际猜测场景的要求不一致。</li>\n<li>混合密码猜测模型提出但是处于起步阶段。 根据集成对象的划分，现有的混合密码猜测方法可以分为模型架构级别的集成和猜测列表级别的集成。<ol>\n<li>模型架构级别：<ol>\n<li>2018 年，Zhang 等人。 [29]提出了一种称为 SPSR 的混合密码猜测模型。 SPSR将PCFG模型[6]应用于密码结构层，将马尔可夫链模型[22]应用于密码字符串层。 </li>\n<li>同年，他们还提出了SPRNN模型[30]，该模型结合了结构划分和双向长短期记忆递归神经网络（BiLSTM）。 </li>\n<li>与 SPRNN 相反，Xia 等人。 [31]提出了另一种混合密码猜测模型，称为 PL。 PL采用PCFG模型[6]进行密码字符串层解构，并采用LSTM模型[15]进行结构层建模。<br> 这些双重方法有效地利用了两种密码猜测模型在不同密码分析粒度层的优势。 然而，这些模型架构级别的集成需要有针对性的定制，限制了它们集成更广泛的密码猜测模型的能力。</li>\n</ol>\n</li>\n<li>猜测列表级别：<ol>\n<li>2021 年，王等人。 [32]平均组合多个密码猜测列表并对输出进行重复数据删除。 他们发现，将密码猜测模型与明显不同的密码生成策略（例如RNN模型[39]和PCFG模型[6]）相结合可以有效提高破解成功率。 </li>\n<li>2022 年，帕里什等人。 [34]对训练集中的密码进行去重，并按密码频率降序排序，生成猜测列表。 他们将其定义为“身份猜测者”。 他们发现，将模型生成的多个猜测列表与 Identity Guesser 相结合，可以显着提高破解成功率。<br> 不过，这两项研究仅在猜测清单层面进行了初步尝试。 同等地组合猜测列表并不能准确地从每个猜测模型中提取有效部分。</li>\n<li>2022 年，Han 等人。 [33]介绍了一种称为 hyPassGu 的混合猜测框架。 hyPassGu 通过限制每个模型生成目标类型的密码并分别确定猜测次数，利用 PCFG 和马尔可夫模型的优势。 尽管声称 hyPassGu 可以应用于 PCFG 和马尔可夫之外的其他模型，但它需要先了解模型的架构及其目标密码类型。 因此，它不能直接应用于其他模型。 另外，hyPassGu根据密码的结构特征将密码粗略地分为两类，导致有效密码大量流失。 因此，hyPassGu的破解成功率低于单个模型，仅略优于限制特定类型密码生成的模型。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>关键问题仍然没有令人满意的答案：<br> （1）什么有助于提高混合密码猜测的破解能力？<br> （2）如何有效发挥多种不同模型的优势？ 本文重点解决这些问题。</li>\n</ol>\n<h2 id=\"密码猜测场景\"><a href=\"#密码猜测场景\" class=\"headerlink\" title=\"密码猜测场景\"></a>密码猜测场景</h2><p><strong>数据驱动的密码猜测模型 + 拖网猜测 + 混合密码猜测</strong></p>\n<ol>\n<li>攻击者首先根据泄露的数据集构建密码猜测模型；</li>\n<li>然后使用模型生成猜测；</li>\n<li>最后尝试使用猜测破解所有目标密码。</li>\n</ol>\n<p>虽然基于规则的密码猜测工具[20]、[21]也可用于混合密码猜测，但这些工具仍然依赖于目标数据集分布的先验知识来增强密码猜测的有效性。</p>\n<p>注意：<br>拖网场景可以进一步分为站内场景和跨站场景。 虽然跨站密码猜测场景较为真实，但攻击者一般以掌握目标数据的部分分布信息为前提来猜测密码。<br>因此，为了更好地描述混合密码猜测的概念，我们将站点内拖网场景中的密码猜测任务形式化。<br><strong>形式化</strong>：一些符号表示，某个猜测密码成功破解了目标系统的多少个密码</p>\n<h2 id=\"多视角学习\"><a href=\"#多视角学习\" class=\"headerlink\" title=\"多视角学习\"></a>多视角学习</h2><p>多视图学习的概念与混合密码猜测的概念非常吻合。 多视图学习引入了一个函数来对特定视图进行建模，并联合优化所有函数以利用相同输入数据的冗余视图，从而提高学习性能[40]。<br>在更高层次上，多视图学习构建多个单一视图并评估它们的表现，然后设计功能来组合这些视图以改善学习成果。<br>同样，混合密码猜测旨在通过利用从不同角度分析数据的多个模型来提高密码猜测的有效性。 因此，多视图学习可以用于解决在混合密码猜测中集成各种密码猜测模型的优势的挑战。</p>\n<p>徐等人。 [41]提出多视图学习基于两个关键原则有效地利用多种视图：</p>\n<ol>\n<li>共识和互补。 共识原则旨在最大限度地达成不同观点之间的一致。 </li>\n<li>互补原则指出，每种观点都可能包含其他观点所不存在的独特知识。 通过有效利用多种观点的共识和互补性，可以实现对数据的全面、准确的描述。<br>在本文中，我们基于这些原理探索混合密码猜测。</li>\n</ol>\n<h2 id=\"数据集\"><a href=\"#数据集\" class=\"headerlink\" title=\"数据集\"></a>数据集</h2><p>使用包含 5400 万个纯文本密码的 6 个数据集（参见表 I）。<br>其中，三个数据集来自英文网站，三个数据集来自中文网站，涵盖六种不同的服务类型。<br>数据源的多样性有助于减少我们分析中的偏差。 由于我们所有的数据集都可以在互联网上公开获取，因此这项工作的结果是可重复的。<br>![[Pasted image 20240418173807.png]]</p>\n<h3 id=\"数据清洗\"><a href=\"#数据清洗\" class=\"headerlink\" title=\"数据清洗\"></a>数据清洗</h3><p>原始数据集包含异常情况，例如未解密的哈希字符串、不可能由用户生成的过长密码以及包含不符合标准密码策略的不可打印字符的密码。 因此，我们首先对数据集进行数据清洗。 我们删除包含 95 个可打印 ASCII 字符之外的字符的密码，并删除长度 &gt; 30 的密码。这种数据清理策略在现有的密码猜测文献中也很流行 [24]、[26]、[42]。</p>\n<h3 id=\"道德考虑\"><a href=\"#道德考虑\" class=\"headerlink\" title=\"道德考虑\"></a>道德考虑</h3><p>尽管我们使用的数据集是公开的，并广泛用于密码猜测研究 [8]、[27]、[32]–[34]，但这些数据集包含敏感的个人信息。 因此，我们仅分析密码数据的分布特征，并报告汇总的统计信息。 我们不会将任何数据用于学术研究以外的目的，因此不会增加受影响个人的风险。</p>\n<h2 id=\"密码猜测模型\"><a href=\"#密码猜测模型\" class=\"headerlink\" title=\"密码猜测模型\"></a>密码猜测模型</h2><p>采用了四种领先的密码猜测模型（例如 Markov、PCFG、FLA 和 RFGuess）。</p>\n<p>为了减轻其他因素对分析结果的影响，我们重点关注站内密码猜测场景。 这种情况被认为是理想的，因为训练集和测试集具有相同的数据分布，确保了我们分析的一致性。</p>\n<p>我们从数据集中随机抽取大小为 $10^6$ 的子集作为测试集，而其余数据用作训练集。 我们发现结果对于基于此测试集大小的分析来说足够稳定。 这一现象与论文[9]、[43]、[44]一致。 用于生成猜测列表的每个模型的设置如下：<br> 1）PCFG。 我们使用了 PCFG 模型 [6] 的 4.0 版，该模型可以在 GitHub 网站上找到。 该模型的语法包括六个段类别：字母A、数字D、其他字符O、键盘D、特殊字符串X和年份Y。<br> 2）Markov。 我们选择 4 阶马尔可夫模型，并采用[26]中使用的拉普拉斯平滑和结束符号正则化来生成猜测。<br> 3）FLA。 我们利用了 GitHub 网站上提供的 FLA 开源代码2，并遵循[15]中指定的推荐参数。 我们训练了一个由三个 LSTM 层组成的模型，每层有 128 个单元和两个密集层，总共 20 个 epoch。<br> 4）RFGuess。 参考[24]，我们训练了一个有 30 棵决策树的随机森林。 其叶子节点的最小数量为10，特征的最大比例为80%，其余为scikit-learn框架的默认值[45]。</p>\n<h1 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h1><p> 本节通过多视角分析，依次解决以下问题：<br>    （1）混合密码猜测能够提高破解能力的关键原因是什么？<br>    （2）使用猜测列表进​​行混合密码猜测可以获得什么好处？</p>\n<h2 id=\"混合密码猜测的本质\"><a href=\"#混合密码猜测的本质\" class=\"headerlink\" title=\"混合密码猜测的本质\"></a>混合密码猜测的本质</h2><h3 id=\"数据集比较\"><a href=\"#数据集比较\" class=\"headerlink\" title=\"数据集比较\"></a>数据集比较</h3><p>我们通过比较每个模型生成的猜测列表来展示密码猜测模型之间的差异<br>![[Pasted image 20240418204958.png]]</p>\n<ol>\n<li>PCFG 模型生成的猜测列表包括诸如 “dearbook123456” 和 “DEARBOOK” 之类的密码，这表明偏向于生成包含常见短语和简单结构的密码。 </li>\n<li>Markov 模型生成的猜测列表包含 “woshili” 和 “1989123” 等密码，反映了基于密码内字符相关性进行猜测的偏见。</li>\n<li>RFGuess 模型的猜测列表包括诸如 “1234567” 和 “1234567}” 之类的密码，表明了将常见短语与各种特征相结合的趋势。 </li>\n<li>FLA 模型与马尔可夫模型类似，会生成一个包含 “45665456” 和 “qwqwqwqww” 等密码的猜测列表，显示出其对密码中顺序上下文一致性的偏见。 然而，FLA 模型生成的猜测列表也与马尔可夫模型不同。</li>\n<li>中心区域还有“dearbook”、“12345678”等密码。 它表明，尽管每个模型都有独特的偏见，但他们已经就某些密码达成了共识。 这些密码可能很常用，并且很容易被各种模型预测到。</li>\n</ol>\n<h3 id=\"为什么需要混合\"><a href=\"#为什么需要混合\" class=\"headerlink\" title=\"为什么需要混合\"></a>为什么需要混合</h3><p>猜测列表中的相似点和差异强调，即使基于相同的数据集，现有的密码猜测模型也可以生成包含不同密码特征的猜测列表。</p>\n<p>本质上，密码猜测模型是根据用户设置易受攻击密码的行为而设计的。通过准确识别和匹配这些弱密码的特征，模型就可以生成破戒律很高的猜测列表。然而，由于用户密码设置行为的异构多样性[42]。即使像 PCFG 这样的已经涵盖了各种弱密码特征的模型（参见第II-E节），也无法在有限的猜测次数内完全覆盖所有特征 。 利用多种具有不同偏差的密码猜测模型的组合，可以更全面地识别和匹配密码特征，从而提高密码猜测的性能。</p>\n<h3 id=\"怎么混合\"><a href=\"#怎么混合\" class=\"headerlink\" title=\"怎么混合\"></a>怎么混合</h3><ol>\n<li>在模型的结构层面上利用多个异构密码猜测模型是相当具有挑战性的，并且不适用于新提出的密码猜测模型（例如RFGuess），这背离了使用多个异构模型的最初想法。</li>\n<li>密码猜测模型最终会生成猜测列表。 鉴于多视图学习对于混合密码猜测的天然适用性（参见第 II-C 节），我们将密码猜测模型生成的猜测列表视为数据的多个视图。<ol>\n<li> 在多视图学习领域，直观的是，集成多个不同视图来分析和处理数据可以产生更全面的信息，从而提高学习模型的性能。 这个概念也适用于混合密码猜测。 </li>\n<li>我们用一个示意性的解释来描述这一点。<br> ![[Pasted image 20240418211929.png]]</li>\n<li>如图3所示，不同的密码猜测模型生成的猜测列表{G1，G2，G3，····，Gl}可以覆盖测试集T的不同部分。假设混合密码猜测方法H可以有效地提取出测试集T的不同部分。 从{G1,G2,G3,····,Gl}中覆盖T的密码，生成优化猜测列表eG。 </li>\n<li>组合的猜测列表越多，测试集的覆盖范围就越大，从而产生更好的破解能力。 </li>\n<li>请注意，图 3 中描绘的示意图可能并不通用，因为猜测列表中的密码通常存在重叠。 然而，组合更多猜测列表可以覆盖更多测试集的因果关系是普遍存在的。 我们将通过下面的分析来证明这一点。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"多视图集成的优点\"><a href=\"#多视图集成的优点\" class=\"headerlink\" title=\"多视图集成的优点\"></a>多视图集成的优点</h2><p>依据：</p>\n<ol>\n<li><p>大量实验已经证实，我们所描述的结果在六个数据集中得到一致观察，从而证实了它们的普遍性</p>\n</li>\n<li><p>以 CSDN 数据集生成的 top $10^6$ 密码猜测列表为例。</p>\n</li>\n<li><p>实验：<br>定量特征分析：<br>对组合猜测列表的统计特征进行定量比较，以证明多视图集成带来的猜测有效性。</p>\n</li>\n<li><p>将每个模型生成的猜测列表以相同的大小组合起来，并对它们进行重复数据删除，然后将结果与单个猜测列表进​​行比较。<br> 例如，在比较大小为 $10^3$ 的猜测列表时，我们结合 PCFG 和马尔可夫模型生成的前 $10^3$ 个猜测，删除任何重复的密码。 输出被定义为两个视图集成。<br> 请注意，这种组合策略与 Minauto 指标 [16] 的计算相同，并不反映现实场景 ( Minauto 指标是一个理论上的上限，代表了每个密码被所有密码猜测模型破解所需的最小猜测次数。然而，在实际的密码猜测场景中，使用多个密码猜测模型并行进行猜测需要的次数是单个模型的数倍，这与实际需求不一致)。</p>\n</li>\n<li><p>我们的目的只是证明通过跨多个视图的特征量化来增强密码破解能力的可行性。<br> ![[Pasted image 20240419151949.png]]<br> 密码结构 Struct：基于 PCFG 算法来分析猜测列表中的密码结构的数量。 例如，如果猜测列表包含 “dearbook134”、“dearbook309” 和 “123dearbook” 等密码，则它包含两种类型的密码结构： “A8D3” 和 “D3A8”。<br> 有效密码比例 Effect：有效密码&#x2F;猜测列表大小。猜测列表中的密码如果能够与测试集中的密码匹配，则认为该密码有效。<br> 破解成功率 $Min_{auto}$<br> 唯一密码比例 Uniq：唯一密码&#x2F;单个单个猜测列表 </p>\n</li>\n<li><p>结果：</p>\n<ol>\n<li>Effect 和  $Min_{auto}$ 说明了多视图集成所带来的猜测有效性的提高。</li>\n<li>Uniq 和 struct 说明通过集成多个视图实现的多样性的增强。整合更多元的观点可以增加猜测的多样性，覆盖更多的密码特征，从而提高密码猜测的有效性</li>\n</ol>\n</li>\n</ol>\n<p>有效的密码分析：<br>问题：组合多个猜测列表会产生许多独特的密码，其大小远远超过单个猜测列表的大小。 如果全部用于最后的破解，会导致破解次数消耗过多。<br>![[Pasted image 20240419155303.png]]<br>幸运的是，图4（a）表明，当猜测数量增长到大约 $4×10^4$ 时，组合多个猜测列表的有效密码数量开始低于单个猜测列表的大小（an注：从一个数据集中选择 100 比 四个数据集中每个选择 25 个效率高）。<br>在这种情况下，通过选择这些有效密码中的一部分，即使优化后的猜测列表大小小于单个猜测列表的大小，猜测的成功率仍然可以达到多视图集成的 Minauto 指标。（an注：此时单猜测列表 和 多猜测列表分母增加相同大小时， 单猜测列表的分子增加的多，论文描述的意思是减少了 多猜测列表分母增加的个数，有点偷换概念的意思）</p>\n<p>在了解测试集的前提下，我们假设了一种最优的混合密码猜测方法，该方法可以有效地整合多个猜测列表以产生优化的猜测列表。 此混合密码猜测方法生成的优化猜测列表包含每个猜测列表中最有效的密码。 如果猜测的密码在测试集中破解频率最高的密码，则认为该密码具有最高的效率。 例如，在整合大小为103的猜测列表时，我们首先对猜测的密码进行去重，并将其与测试集进行比较，计算每个猜测的密码可以破解的测试密码的数量。 然后，我们按照破解次数降序选择猜测的密码，并将其添加到最佳猜测列表中，直到最佳猜测列表的大小也达到103。我们将最佳猜测列表的破解成功率与最佳猜测列表的破解成功率进行比较。 由单一密码猜测模型生成的猜测列表（见图4（b））。 如图 4（b）所示，当猜测数 &lt; 4 × 104 时，与 PCFG 模型相比，整合两视图的最优猜测列表的破解成功率平均提高了 1.3%，整合三视图的破解成功率平均提高了 1.3%。 2.6%，整合四视图增长了2.8%。 尽管有效密码的数量超过了单个猜测列表的大小，但选择效率最高的部分同等大小的猜测密码仍然可以增强破解能力。 </p>\n<p>上述结果表明，从多个视图中准确提取有效密码是进行有效混合密码猜测的关键。</p>\n<p>多视图子集分析：<br>目的：为了找到从多个视图中提取有效密码的有效方法，我们对多个视图之间的子集进行了分析。<br>手段：对不同模型生成的相同大小的猜测列表进​​行集合运算，以获得相交和互补的子集。<br>![[Pasted image 20240419165944.png]]</p>\n<p>我们分析了集成不同数量的视图时多视图子集的变化（见图 5）。 如图 5 所示，集成两个视图生成三个子集，三个视图集成生成七个子集，四个视图集成生成 15 个子集。 此外，随着集成视图数量的增加，每个子集中有效密码的分布变得更加集中。 相交子集中有效密码的比例（中间红色数值表示）随着集成视图的增加而增加。 在基于CSDN数据集的实验中，融合两个视图时，相交子集中有效密码的比例为51.51%。 当集成三视图时，这一比例增加了 21.0%，而当集成四视图时，这一比例又增加了 3.9%。 这些结果表明，集成多个视图可以提供有关有效密码分发的增量信息。 随着更多视图的整合，增量信息增多，有效密码的分布更加集中。</p>\n<p>![[Pasted image 20240419170332.png]]</p>\n<p>我们继续分析有效密码在各个子集中的分布。 目前，当我们仅通过集合运算提取猜测列表中的相交和互补子集时，子集中的密码不包括顺序。 因此，我们通过分析不同大小的猜测列表中子集的平均破解成功率来评估子集中有效密码的分布（见图7）。 为了便于表示，我们用图6来表示每个平均破解成功率所代表的子集。 具体来说，我们使用 4 位二进制代码来命名每个子集，其中每个位代表密码在特定模型生成的猜测列表中的出现，从左到右分别为：PCFG、FLA、Markov 和 RFGuess。 例如，“1000”表示该子集中的密码仅出现在PCFG猜测列表中。</p>\n<p>![[Pasted image 20240419170602.png]]</p>\n<p>如图7所示，相交子集“1111”的整体破解效率明显优于其他子集。 然而，相交子集中的密码的后半部分并不优于其他子集中的密码的前半部分。 例如，相交子集“1111”在101次猜测中的平均破解成功率为3.57×10−6，而互补子集“0010”在101次猜测中的平均破解成功率为2.61×10−5。 有趣的是，子集的平均破解成功率与单个猜测列表的大小呈现近似线性关系。 当我们将 15 条曲线作为一个整体来考虑时，这一点变得更加明显。 这可能符合密码中的 Zipf 定律 [46]。 我们使用PDFZipf模型[46]拟合数据：logfr &#x3D; logC − s · logr，其中fr和r分别对应于平均破解成功率和单个猜测列表的大小。 如表III所示，C ε [-3.55，-0.85]和s ε [-0.92，-0.63]是常数。 拟合的 RMSE 在 [0.08, 0.24] 范围内。</p>\n<p>这种现象有助于在混合密码猜测中利用多种密码猜测模型的优势。 尽管密码分布中的齐普夫定律通常用于解释用户设置密码的行为，但也有研究 [33]、[47] 通过分析密码猜测模型中齐普夫定律的存在来改进密码猜测模型。 在我们的例子中，齐普夫定律表明，猜测密码的效率随着密码在子集中的排名降序而下降。 换句话说，子集中排名较高的密码被认为具有较高的破解效率。</p>\n<h1 id=\"密码结构\"><a href=\"#密码结构\" class=\"headerlink\" title=\"密码结构\"></a>密码结构</h1><p>密码结构（Struct.）的数量是通过对猜测列表中的密码进行分析和统计得出的。具体来说，密码结构是指密码中的字符排列方式，例如”A8D3”或”D3A8”。在文中，作者使用PCFG算法对密码结构进行分析，通过猜测列表中的密码来确定不同类型的密码结构的数量。通过对密码结构的数量进行统计分析，可以评估多视图整合对密码破解能力的提升效果。这些统计特征表明，整合更多不同的视图可以增加猜测的多样性，覆盖更多的密码特征，从而提高口令猜测的有效性。</p>\n<h1 id=\"Minauto\"><a href=\"#Minauto\" class=\"headerlink\" title=\"Minauto\"></a>Minauto</h1><p>类似于一个破解成功率。</p>\n<h1 id=\"多视图提取模块的工作原理是什么？\"><a href=\"#多视图提取模块的工作原理是什么？\" class=\"headerlink\" title=\"多视图提取模块的工作原理是什么？\"></a>多视图提取模块的工作原理是什么？</h1><p>多视图提取模块的工作原理是从多个猜测列表中提取交集和补集密码，以生成多视图子集。该模块首先根据输入的猜测列表数量生成多个子集，并为每个子集分配逻辑标签。然后，根据排名，模块按照密码的逻辑规则将密码分别添加到交集子集或补集子集中。最终，该模块输出维护的多视图子集，其中包含了有效密码的信息。这一过程有助于准确地从多个视图中提取和重新组织有效密码。</p>\n<h1 id=\"分割选择模块的作用是什么？\"><a href=\"#分割选择模块的作用是什么？\" class=\"headerlink\" title=\"分割选择模块的作用是什么？\"></a>分割选择模块的作用是什么？</h1><p>分割选择模块的作用是进一步细化每个子集，根据幂律间隔将其分割成多个密码片段。该模块利用幂律分布间隔序列来将输入的子集分割成更细粒度的密码片段。然后，该模块利用验证集来评估这些密码片段的破解效率，具体来说，该模块计算这些密码片段的平均破解成功率。最终，该模块重新组织有效的密码片段，生成最终的优化猜测列表。</p>\n"},{"_content":"# 摘要\n1. 分析了个人信息和密码之间的关联性。\n2. 实现了一个基于改进 Transformer  的密码猜测模型\n\t1. 数据预训练时引入信息权重。\n\t2. 使用改进的波束搜索算法来快速搜索排名考前的输出结果。\n# 模型和使用\n## 模型结构\n与原始Transformer模型不同的是，我们在词嵌入层之后添加了信息权重层。信息权重层涉及一个权重矩阵，权重矩阵表示每个字符携带的用户信息，该矩阵的维度与词嵌入矩阵相同。信息权重矩阵中，同一输入位置对应的参数值相同。参数值是通过模型的训练来确定的。信息权重矩阵将添加到输入嵌入中。那么后续步骤就和原来的Transformer一样了。\n![[Pasted image 20240327152521.png]]\n\n\n## 模型训练\n\n1. **输入数据处理**：模型的输入是一批代表用户个人信息的数值向量。首先，这些输入通过嵌入层（embedding layer）被转换成字符嵌入（character embeddings），即将数值向量转换为能够代表这些信息的嵌入向量。\n    \n2. **信息权重处理**：接着，通过信息权重层（information weight layer），这些字符嵌入会根据用户信息的权重进行调整，以更准确地反映每部分用户信息的重要性。\n    \n3. **位置编码**：之后，这些调整后的字符嵌入通过位置编码层（positional encoding layer）来获得位置向量，这一步是为了让模型能够理解字符在序列中的位置关系。\n    \n4. **自注意力机制**：调整后的字符嵌入随后进入编码器（encoder）的自注意力层（self-attention layer）。在这一层中，模型计算字符之间的依赖关系，而这种计算忽略了字符之间的距离，即无论字符相隔多远，都能捕捉到它们之间的联系。\n    \n5. **向前传播和解码**：编码器的输出接着被用作前向神经网络（forward neural network）的输入。在编码器的最终层输出的基础上，将这些输出转换成一组键值对（Key, Value），然后这组键值对被传递给解码器（decoder），以帮助解码器获取输入序列的信息。\n\n解码器的输入是一批代表用户密码的数字向量。解码器嵌入输入并添加每个字符的位置嵌入。与编码器不同，解码器中的自注意力层仅关注当前已确认的输出字符。解码器的输出是浮点数的向量列表。接下来，通过线性层将向量列表转换为向量。它称为对数向量。对数向量的每个元素对应一个字符，其值代表该字符的得分。最后，对数向量通过softmax层转换为每个字符出现的概率。 \n\n## 模型预测\n使用改进的束波搜索来快速找到排名考前的预测结果。\n\n\n## 字符匹配算法优化\n存储每个生成密码的 key 和 value，使用hash 表来存储，key 值计算过程。\nKey = (char2int(a)\\*M + char2int(b)\\*M )%p\n\n# 评估\n## 数据集\n1. 收集了 一亿条密码。\n2. 筛选了19种个人信息的 31 个网站。\n3. 统计了密码格式：大多数是 单词+数字，少部分是 单词 和 数字\n4. 分析了密码和数字的关联性\n\t1. 邮箱 + 后缀\n\t2. 生日：年月日组合\n\t3. 姓名：拼音\n\tKMP算法 进行 字字符串比配\n\t结果：关联很大。经过统计，我们得出的结论是，用户密码与邮箱、生日、昵称、电话号码、姓氏、名字、登录网站的域名高度相关。其中，电子邮件相关密码占比最高，占比12.551%，手机号码相关密码占比5%，用户名​​相关密码占比2.617%，生日相关密码占比0.863%，密码相关密码占比最高。与网站域名相关的密码占0.173%，与名字相关的密码占0.794%，与姓氏相关的密码占0.002%。\n\t选择了与密码相关性较大的七个个人信息来构成输入序列，分别是生日、电话号码、网站域名、电子邮件地址、昵称、姓氏和名字。\n5. 研究序列的长度：主要是长度为8 的密码，用 包含8 的长度训练，用包含8的密码测试，生成长度为8 的密码\n## .实验环境\n改进的 Transformer 是用 TensorFlow 实现的。我们使用 TensorFlow 版本 1.12.0 和 Python 版本 3.5.2。我们在 GPU 服务器上进行实验，该服务器具有 2 核 2.2GHz CPU、NVIDIA Tesla V100 GPU 和 16GB 全局内存。\n## 对比实验\n三个序列到序列模型：1. LSTM 2. encoder-decoder 3. Transformer\n在相同的数据集中进行实验：x 轴表示测试集大小 ；y轴表示破解的数量，当生成的密码数量超过 10,000 个时，Transformer 的准确率将高于其他两个模型。我们的实验结果表明，Transformer 在基于用户信息的密码破解研究中表现最好。\n## 实验结果\n### 时间优化\n匹配算法的优化（相同时间内匹配的次数更多）\n### 模型优化\n信息权重和无信息权重（），束波搜索和随机搜索\n\n### 密码长度\n五个不同密码长度： 8  9 10 11 12 \n密码长度越长，相同的猜测次数下越难猜出密码。\n\n\n# 总结\n1. 分析了用户个人信息和密码之间的关联性，邮箱关联度很高\n2. 提出了一种基于改经的 Transformer 模型，数据预处理中引入了信息权重\n3. 波束搜索算法，","source":"_posts/论文笔记/Pass improved Transformer.md","raw":"# 摘要\n1. 分析了个人信息和密码之间的关联性。\n2. 实现了一个基于改进 Transformer  的密码猜测模型\n\t1. 数据预训练时引入信息权重。\n\t2. 使用改进的波束搜索算法来快速搜索排名考前的输出结果。\n# 模型和使用\n## 模型结构\n与原始Transformer模型不同的是，我们在词嵌入层之后添加了信息权重层。信息权重层涉及一个权重矩阵，权重矩阵表示每个字符携带的用户信息，该矩阵的维度与词嵌入矩阵相同。信息权重矩阵中，同一输入位置对应的参数值相同。参数值是通过模型的训练来确定的。信息权重矩阵将添加到输入嵌入中。那么后续步骤就和原来的Transformer一样了。\n![[Pasted image 20240327152521.png]]\n\n\n## 模型训练\n\n1. **输入数据处理**：模型的输入是一批代表用户个人信息的数值向量。首先，这些输入通过嵌入层（embedding layer）被转换成字符嵌入（character embeddings），即将数值向量转换为能够代表这些信息的嵌入向量。\n    \n2. **信息权重处理**：接着，通过信息权重层（information weight layer），这些字符嵌入会根据用户信息的权重进行调整，以更准确地反映每部分用户信息的重要性。\n    \n3. **位置编码**：之后，这些调整后的字符嵌入通过位置编码层（positional encoding layer）来获得位置向量，这一步是为了让模型能够理解字符在序列中的位置关系。\n    \n4. **自注意力机制**：调整后的字符嵌入随后进入编码器（encoder）的自注意力层（self-attention layer）。在这一层中，模型计算字符之间的依赖关系，而这种计算忽略了字符之间的距离，即无论字符相隔多远，都能捕捉到它们之间的联系。\n    \n5. **向前传播和解码**：编码器的输出接着被用作前向神经网络（forward neural network）的输入。在编码器的最终层输出的基础上，将这些输出转换成一组键值对（Key, Value），然后这组键值对被传递给解码器（decoder），以帮助解码器获取输入序列的信息。\n\n解码器的输入是一批代表用户密码的数字向量。解码器嵌入输入并添加每个字符的位置嵌入。与编码器不同，解码器中的自注意力层仅关注当前已确认的输出字符。解码器的输出是浮点数的向量列表。接下来，通过线性层将向量列表转换为向量。它称为对数向量。对数向量的每个元素对应一个字符，其值代表该字符的得分。最后，对数向量通过softmax层转换为每个字符出现的概率。 \n\n## 模型预测\n使用改进的束波搜索来快速找到排名考前的预测结果。\n\n\n## 字符匹配算法优化\n存储每个生成密码的 key 和 value，使用hash 表来存储，key 值计算过程。\nKey = (char2int(a)\\*M + char2int(b)\\*M )%p\n\n# 评估\n## 数据集\n1. 收集了 一亿条密码。\n2. 筛选了19种个人信息的 31 个网站。\n3. 统计了密码格式：大多数是 单词+数字，少部分是 单词 和 数字\n4. 分析了密码和数字的关联性\n\t1. 邮箱 + 后缀\n\t2. 生日：年月日组合\n\t3. 姓名：拼音\n\tKMP算法 进行 字字符串比配\n\t结果：关联很大。经过统计，我们得出的结论是，用户密码与邮箱、生日、昵称、电话号码、姓氏、名字、登录网站的域名高度相关。其中，电子邮件相关密码占比最高，占比12.551%，手机号码相关密码占比5%，用户名​​相关密码占比2.617%，生日相关密码占比0.863%，密码相关密码占比最高。与网站域名相关的密码占0.173%，与名字相关的密码占0.794%，与姓氏相关的密码占0.002%。\n\t选择了与密码相关性较大的七个个人信息来构成输入序列，分别是生日、电话号码、网站域名、电子邮件地址、昵称、姓氏和名字。\n5. 研究序列的长度：主要是长度为8 的密码，用 包含8 的长度训练，用包含8的密码测试，生成长度为8 的密码\n## .实验环境\n改进的 Transformer 是用 TensorFlow 实现的。我们使用 TensorFlow 版本 1.12.0 和 Python 版本 3.5.2。我们在 GPU 服务器上进行实验，该服务器具有 2 核 2.2GHz CPU、NVIDIA Tesla V100 GPU 和 16GB 全局内存。\n## 对比实验\n三个序列到序列模型：1. LSTM 2. encoder-decoder 3. Transformer\n在相同的数据集中进行实验：x 轴表示测试集大小 ；y轴表示破解的数量，当生成的密码数量超过 10,000 个时，Transformer 的准确率将高于其他两个模型。我们的实验结果表明，Transformer 在基于用户信息的密码破解研究中表现最好。\n## 实验结果\n### 时间优化\n匹配算法的优化（相同时间内匹配的次数更多）\n### 模型优化\n信息权重和无信息权重（），束波搜索和随机搜索\n\n### 密码长度\n五个不同密码长度： 8  9 10 11 12 \n密码长度越长，相同的猜测次数下越难猜出密码。\n\n\n# 总结\n1. 分析了用户个人信息和密码之间的关联性，邮箱关联度很高\n2. 提出了一种基于改经的 Transformer 模型，数据预处理中引入了信息权重\n3. 波束搜索算法，","slug":"论文笔记/Pass improved Transformer","published":1,"date":"2024-04-22T13:14:48.837Z","updated":"2024-04-04T16:42:11.043Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0i001ckgg488ixczvt","content":"<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><ol>\n<li>分析了个人信息和密码之间的关联性。</li>\n<li>实现了一个基于改进 Transformer  的密码猜测模型<ol>\n<li>数据预训练时引入信息权重。</li>\n<li>使用改进的波束搜索算法来快速搜索排名考前的输出结果。</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"模型和使用\"><a href=\"#模型和使用\" class=\"headerlink\" title=\"模型和使用\"></a>模型和使用</h1><h2 id=\"模型结构\"><a href=\"#模型结构\" class=\"headerlink\" title=\"模型结构\"></a>模型结构</h2><p>与原始Transformer模型不同的是，我们在词嵌入层之后添加了信息权重层。信息权重层涉及一个权重矩阵，权重矩阵表示每个字符携带的用户信息，该矩阵的维度与词嵌入矩阵相同。信息权重矩阵中，同一输入位置对应的参数值相同。参数值是通过模型的训练来确定的。信息权重矩阵将添加到输入嵌入中。那么后续步骤就和原来的Transformer一样了。<br>![[Pasted image 20240327152521.png]]</p>\n<h2 id=\"模型训练\"><a href=\"#模型训练\" class=\"headerlink\" title=\"模型训练\"></a>模型训练</h2><ol>\n<li><p><strong>输入数据处理</strong>：模型的输入是一批代表用户个人信息的数值向量。首先，这些输入通过嵌入层（embedding layer）被转换成字符嵌入（character embeddings），即将数值向量转换为能够代表这些信息的嵌入向量。</p>\n</li>\n<li><p><strong>信息权重处理</strong>：接着，通过信息权重层（information weight layer），这些字符嵌入会根据用户信息的权重进行调整，以更准确地反映每部分用户信息的重要性。</p>\n</li>\n<li><p><strong>位置编码</strong>：之后，这些调整后的字符嵌入通过位置编码层（positional encoding layer）来获得位置向量，这一步是为了让模型能够理解字符在序列中的位置关系。</p>\n</li>\n<li><p><strong>自注意力机制</strong>：调整后的字符嵌入随后进入编码器（encoder）的自注意力层（self-attention layer）。在这一层中，模型计算字符之间的依赖关系，而这种计算忽略了字符之间的距离，即无论字符相隔多远，都能捕捉到它们之间的联系。</p>\n</li>\n<li><p><strong>向前传播和解码</strong>：编码器的输出接着被用作前向神经网络（forward neural network）的输入。在编码器的最终层输出的基础上，将这些输出转换成一组键值对（Key, Value），然后这组键值对被传递给解码器（decoder），以帮助解码器获取输入序列的信息。</p>\n</li>\n</ol>\n<p>解码器的输入是一批代表用户密码的数字向量。解码器嵌入输入并添加每个字符的位置嵌入。与编码器不同，解码器中的自注意力层仅关注当前已确认的输出字符。解码器的输出是浮点数的向量列表。接下来，通过线性层将向量列表转换为向量。它称为对数向量。对数向量的每个元素对应一个字符，其值代表该字符的得分。最后，对数向量通过softmax层转换为每个字符出现的概率。 </p>\n<h2 id=\"模型预测\"><a href=\"#模型预测\" class=\"headerlink\" title=\"模型预测\"></a>模型预测</h2><p>使用改进的束波搜索来快速找到排名考前的预测结果。</p>\n<h2 id=\"字符匹配算法优化\"><a href=\"#字符匹配算法优化\" class=\"headerlink\" title=\"字符匹配算法优化\"></a>字符匹配算法优化</h2><p>存储每个生成密码的 key 和 value，使用hash 表来存储，key 值计算过程。<br>Key &#x3D; (char2int(a)*M + char2int(b)*M )%p</p>\n<h1 id=\"评估\"><a href=\"#评估\" class=\"headerlink\" title=\"评估\"></a>评估</h1><h2 id=\"数据集\"><a href=\"#数据集\" class=\"headerlink\" title=\"数据集\"></a>数据集</h2><ol>\n<li>收集了 一亿条密码。</li>\n<li>筛选了19种个人信息的 31 个网站。</li>\n<li>统计了密码格式：大多数是 单词+数字，少部分是 单词 和 数字</li>\n<li>分析了密码和数字的关联性<ol>\n<li>邮箱 + 后缀</li>\n<li>生日：年月日组合</li>\n<li>姓名：拼音<br> KMP算法 进行 字字符串比配<br> 结果：关联很大。经过统计，我们得出的结论是，用户密码与邮箱、生日、昵称、电话号码、姓氏、名字、登录网站的域名高度相关。其中，电子邮件相关密码占比最高，占比12.551%，手机号码相关密码占比5%，用户名​​相关密码占比2.617%，生日相关密码占比0.863%，密码相关密码占比最高。与网站域名相关的密码占0.173%，与名字相关的密码占0.794%，与姓氏相关的密码占0.002%。<br> 选择了与密码相关性较大的七个个人信息来构成输入序列，分别是生日、电话号码、网站域名、电子邮件地址、昵称、姓氏和名字。</li>\n</ol>\n</li>\n<li>研究序列的长度：主要是长度为8 的密码，用 包含8 的长度训练，用包含8的密码测试，生成长度为8 的密码</li>\n</ol>\n<h2 id=\"实验环境\"><a href=\"#实验环境\" class=\"headerlink\" title=\".实验环境\"></a>.实验环境</h2><p>改进的 Transformer 是用 TensorFlow 实现的。我们使用 TensorFlow 版本 1.12.0 和 Python 版本 3.5.2。我们在 GPU 服务器上进行实验，该服务器具有 2 核 2.2GHz CPU、NVIDIA Tesla V100 GPU 和 16GB 全局内存。</p>\n<h2 id=\"对比实验\"><a href=\"#对比实验\" class=\"headerlink\" title=\"对比实验\"></a>对比实验</h2><p>三个序列到序列模型：1. LSTM 2. encoder-decoder 3. Transformer<br>在相同的数据集中进行实验：x 轴表示测试集大小 ；y轴表示破解的数量，当生成的密码数量超过 10,000 个时，Transformer 的准确率将高于其他两个模型。我们的实验结果表明，Transformer 在基于用户信息的密码破解研究中表现最好。</p>\n<h2 id=\"实验结果\"><a href=\"#实验结果\" class=\"headerlink\" title=\"实验结果\"></a>实验结果</h2><h3 id=\"时间优化\"><a href=\"#时间优化\" class=\"headerlink\" title=\"时间优化\"></a>时间优化</h3><p>匹配算法的优化（相同时间内匹配的次数更多）</p>\n<h3 id=\"模型优化\"><a href=\"#模型优化\" class=\"headerlink\" title=\"模型优化\"></a>模型优化</h3><p>信息权重和无信息权重（），束波搜索和随机搜索</p>\n<h3 id=\"密码长度\"><a href=\"#密码长度\" class=\"headerlink\" title=\"密码长度\"></a>密码长度</h3><p>五个不同密码长度： 8  9 10 11 12<br>密码长度越长，相同的猜测次数下越难猜出密码。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ol>\n<li>分析了用户个人信息和密码之间的关联性，邮箱关联度很高</li>\n<li>提出了一种基于改经的 Transformer 模型，数据预处理中引入了信息权重</li>\n<li>波束搜索算法，</li>\n</ol>\n","excerpt":"","more":"<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><ol>\n<li>分析了个人信息和密码之间的关联性。</li>\n<li>实现了一个基于改进 Transformer  的密码猜测模型<ol>\n<li>数据预训练时引入信息权重。</li>\n<li>使用改进的波束搜索算法来快速搜索排名考前的输出结果。</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"模型和使用\"><a href=\"#模型和使用\" class=\"headerlink\" title=\"模型和使用\"></a>模型和使用</h1><h2 id=\"模型结构\"><a href=\"#模型结构\" class=\"headerlink\" title=\"模型结构\"></a>模型结构</h2><p>与原始Transformer模型不同的是，我们在词嵌入层之后添加了信息权重层。信息权重层涉及一个权重矩阵，权重矩阵表示每个字符携带的用户信息，该矩阵的维度与词嵌入矩阵相同。信息权重矩阵中，同一输入位置对应的参数值相同。参数值是通过模型的训练来确定的。信息权重矩阵将添加到输入嵌入中。那么后续步骤就和原来的Transformer一样了。<br>![[Pasted image 20240327152521.png]]</p>\n<h2 id=\"模型训练\"><a href=\"#模型训练\" class=\"headerlink\" title=\"模型训练\"></a>模型训练</h2><ol>\n<li><p><strong>输入数据处理</strong>：模型的输入是一批代表用户个人信息的数值向量。首先，这些输入通过嵌入层（embedding layer）被转换成字符嵌入（character embeddings），即将数值向量转换为能够代表这些信息的嵌入向量。</p>\n</li>\n<li><p><strong>信息权重处理</strong>：接着，通过信息权重层（information weight layer），这些字符嵌入会根据用户信息的权重进行调整，以更准确地反映每部分用户信息的重要性。</p>\n</li>\n<li><p><strong>位置编码</strong>：之后，这些调整后的字符嵌入通过位置编码层（positional encoding layer）来获得位置向量，这一步是为了让模型能够理解字符在序列中的位置关系。</p>\n</li>\n<li><p><strong>自注意力机制</strong>：调整后的字符嵌入随后进入编码器（encoder）的自注意力层（self-attention layer）。在这一层中，模型计算字符之间的依赖关系，而这种计算忽略了字符之间的距离，即无论字符相隔多远，都能捕捉到它们之间的联系。</p>\n</li>\n<li><p><strong>向前传播和解码</strong>：编码器的输出接着被用作前向神经网络（forward neural network）的输入。在编码器的最终层输出的基础上，将这些输出转换成一组键值对（Key, Value），然后这组键值对被传递给解码器（decoder），以帮助解码器获取输入序列的信息。</p>\n</li>\n</ol>\n<p>解码器的输入是一批代表用户密码的数字向量。解码器嵌入输入并添加每个字符的位置嵌入。与编码器不同，解码器中的自注意力层仅关注当前已确认的输出字符。解码器的输出是浮点数的向量列表。接下来，通过线性层将向量列表转换为向量。它称为对数向量。对数向量的每个元素对应一个字符，其值代表该字符的得分。最后，对数向量通过softmax层转换为每个字符出现的概率。 </p>\n<h2 id=\"模型预测\"><a href=\"#模型预测\" class=\"headerlink\" title=\"模型预测\"></a>模型预测</h2><p>使用改进的束波搜索来快速找到排名考前的预测结果。</p>\n<h2 id=\"字符匹配算法优化\"><a href=\"#字符匹配算法优化\" class=\"headerlink\" title=\"字符匹配算法优化\"></a>字符匹配算法优化</h2><p>存储每个生成密码的 key 和 value，使用hash 表来存储，key 值计算过程。<br>Key &#x3D; (char2int(a)*M + char2int(b)*M )%p</p>\n<h1 id=\"评估\"><a href=\"#评估\" class=\"headerlink\" title=\"评估\"></a>评估</h1><h2 id=\"数据集\"><a href=\"#数据集\" class=\"headerlink\" title=\"数据集\"></a>数据集</h2><ol>\n<li>收集了 一亿条密码。</li>\n<li>筛选了19种个人信息的 31 个网站。</li>\n<li>统计了密码格式：大多数是 单词+数字，少部分是 单词 和 数字</li>\n<li>分析了密码和数字的关联性<ol>\n<li>邮箱 + 后缀</li>\n<li>生日：年月日组合</li>\n<li>姓名：拼音<br> KMP算法 进行 字字符串比配<br> 结果：关联很大。经过统计，我们得出的结论是，用户密码与邮箱、生日、昵称、电话号码、姓氏、名字、登录网站的域名高度相关。其中，电子邮件相关密码占比最高，占比12.551%，手机号码相关密码占比5%，用户名​​相关密码占比2.617%，生日相关密码占比0.863%，密码相关密码占比最高。与网站域名相关的密码占0.173%，与名字相关的密码占0.794%，与姓氏相关的密码占0.002%。<br> 选择了与密码相关性较大的七个个人信息来构成输入序列，分别是生日、电话号码、网站域名、电子邮件地址、昵称、姓氏和名字。</li>\n</ol>\n</li>\n<li>研究序列的长度：主要是长度为8 的密码，用 包含8 的长度训练，用包含8的密码测试，生成长度为8 的密码</li>\n</ol>\n<h2 id=\"实验环境\"><a href=\"#实验环境\" class=\"headerlink\" title=\".实验环境\"></a>.实验环境</h2><p>改进的 Transformer 是用 TensorFlow 实现的。我们使用 TensorFlow 版本 1.12.0 和 Python 版本 3.5.2。我们在 GPU 服务器上进行实验，该服务器具有 2 核 2.2GHz CPU、NVIDIA Tesla V100 GPU 和 16GB 全局内存。</p>\n<h2 id=\"对比实验\"><a href=\"#对比实验\" class=\"headerlink\" title=\"对比实验\"></a>对比实验</h2><p>三个序列到序列模型：1. LSTM 2. encoder-decoder 3. Transformer<br>在相同的数据集中进行实验：x 轴表示测试集大小 ；y轴表示破解的数量，当生成的密码数量超过 10,000 个时，Transformer 的准确率将高于其他两个模型。我们的实验结果表明，Transformer 在基于用户信息的密码破解研究中表现最好。</p>\n<h2 id=\"实验结果\"><a href=\"#实验结果\" class=\"headerlink\" title=\"实验结果\"></a>实验结果</h2><h3 id=\"时间优化\"><a href=\"#时间优化\" class=\"headerlink\" title=\"时间优化\"></a>时间优化</h3><p>匹配算法的优化（相同时间内匹配的次数更多）</p>\n<h3 id=\"模型优化\"><a href=\"#模型优化\" class=\"headerlink\" title=\"模型优化\"></a>模型优化</h3><p>信息权重和无信息权重（），束波搜索和随机搜索</p>\n<h3 id=\"密码长度\"><a href=\"#密码长度\" class=\"headerlink\" title=\"密码长度\"></a>密码长度</h3><p>五个不同密码长度： 8  9 10 11 12<br>密码长度越长，相同的猜测次数下越难猜出密码。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ol>\n<li>分析了用户个人信息和密码之间的关联性，邮箱关联度很高</li>\n<li>提出了一种基于改经的 Transformer 模型，数据预处理中引入了信息权重</li>\n<li>波束搜索算法，</li>\n</ol>\n"},{"_content":"# 摘要\n\n1. 本文使用去噪扩散模型；\n2. 考虑到密码空间和文本空间的相似性，在输入阶段使用了字节级分词器，并通过修改源代码来优化采样过程。\n3. 进行特殊字符编码使得 PassDiff 可以处理可变长度的输入并获得可变长度输出，无需手动截断。\n4. 比 PassGAN 训练稳定，破解比例显著提高\n5. 去噪步骤增加，能进一步提高破解比例。\n\n# 引言\n1. 传统的密码破解有三种：基于字典、基于概率统计模型、基于深度学习\n\t1. 基于字典：依赖字典和规则\n\t2. 基于概率统计：如马尔可夫和概率上下文无关文法（PCFG）\n\t\t概率上下文无关文法：用标识+个数形式表示密码的结构，然后进行响应的填充。\n\t3.  基于深度学习：不需要预知识，也不会被限制范围\n\n# 贡献\n1. 使用了扩散模型\n2. 使用了字节级别的标记器编码输入向量\n3. 通过调整代码优化了降噪过程，\n# 背景知识以及相关工作\n## GAN\n1. 生成模型\n2. 辨别模型\n## DDPM\n1. 构成：由两个马尔科夫链构成\n\t1. 前向链：扩散过程，添加噪声。\n\t\t目的：经常用于将原始分布转为先验分布\n\t2. 反向链：降噪过程，转换噪声恢复数据。\n\t\t目的：使用从深度神经网络学习的参数化转换内核来反转此过程\n2. 去噪过程分两步不断生成新的数据点：首先从先验分布中采样随机数据，然后执行原始采样。\n3. 数学过程\n\t1. 假设 x0 服从一个分布。\n\t2. 有一个向前传播转换链， 即 转换核心：q(xt|xt-1)，这个通常可以被自定义\n\t3. 计算得到了 x1，x2, x3,.... 的一个分布\n\t4. DDPM 一般会在向前传播时把分布转换为一个初始分布。\n\t5. 扩散过程不断用噪音破坏输入数据，直到丢失所有特征。\n\t6. 新建数据点：从先验分布中收养一个随机噪音点，构造一个规则逆向马尔可夫链从而逐渐排除噪声。\n\t7. 从 xT 得到 x0\n\n\n# PassDiff\n1. 标准扩散模型主要用于图像生成\n2. Diffusion-LM  改进\n\t1. 用 transform 学习噪音分布\n\t2. 添加文本嵌入步骤\n\t3. 添加舍入步骤\n\t4. 文本作为输入，将文本嵌入为一个以为整形向量---使用单词级别的 令牌嵌入\n\t5. 扩散过程中， 这个整形向量被 转为 一维 浮点向量，\n\t6. 去噪过程的最后：舍入步骤会将这个 一维 浮点向量 转为 一维 整形 向量\n\t7. \n\t8. 只能输出固定长度文本\n3. 单词级别的令牌嵌入器 将本文分割为单词，\n\t1. 嵌入频率高能捕获语义信息，但是容易导致嵌入范围过大\n4. 字节级别的令牌嵌入将文本识别为一系列的字节，连续嵌入单字节和多字节\n\t1. 单字节的语义信息很少\n\t2. 多字节是 单字节和 单词级别嵌入之间的妥协。\n5. 密码空间和 文本空间相似，语义信息 在密码的字符之间比在语料库中弱，\n6. 参考 Diffusion-LM 我们使用字符级别的嵌入器\n7. 我们发现降噪过程的生成密码长度一致，引入随机因子生成各种长度。\n8. 多字节嵌入没有比单字节有明显优势，为了简化，使用单字节。即 一个特殊字节和 95 个特殊字节。\n\t1. 特殊字节表示为0.\n\t2. 其余可见字节 按 ascill 顺序表 从 1  到  95 .\n\t3. 特殊字符的编码可以 处理可变长度的输入并且获取可变的输出，无序手动截断。\n\t4. Passdiff使用最少的去噪步骤也能产生高质量的输出，建议 5-50，可以将采样速度提高十倍！\n\t4.\n![[Pasted image 20240229164854.png]]\n# 实验配置\n1. 实验环境：\n\t1. DELL Precision 5820工作站，128G内存，10个CPU核心\n\t2. NVIDIA GeForce RTX 3090显\n\t3. Win10和Ubuntu 22.04下进行的\n\t4. Win10上进行了PassGAN相关实验，使用rnnPassGAN的源代码[8,17]。与扩散模型相关的实验是 在Ubuntu 22.04上进行，源代码来自minimal-text-diffusion[16]。\n2. 数据集\n\t1. 12306 CSDN RockYou\n\t2. 去除密码长度超过15，或者有不可见字符的密码，\n\t3. 8：2 训练集和测试集\n3. 超参数\n\t1. 包括：训练轮次：批次大小：扩散步骤：去噪步骤，输入长度，输出长度，学习率\n4. 实验结果\n\t1. CSDN和RockYou的破解率总体高于12306：重复率都高于12306\n\t2. CSDN和RockYou数据集的破解率逐渐稳定在40个去噪步骤左右，超过了12306所需的去噪步骤：：训练不足和数据量较大。\n\t3. 增加数量 训练轮数和批量大小都可以提高破解率。\n\t4. 随着去噪步数的增加，破解率首先逐渐上升到最大值，然后趋于最佳.\n\t5. 去噪步骤和训练轮次增加，重复率增加\n\t6. 重复率越高，生成独一无二的相同长度密码的概率越低\n# 比较\n1.  我们的PassDiff模型比PassGAN具有显着的优势。当生成108个密码时，我们的模型在12306、CSDN和RockYou数据集上的破解率分别比PassGAN高3.17%、6.33%和13.22%。 另外，这并不是我们在破解率方面最好的表现\n2. 但是，我们的模型与传统的密码猜测模型（例如PCFG）之间仍然存在一些差距。\n# 总结\n本文通过优化扩散模型参数和增加训练轮数，提出了比 PassGAN 训练时间更短、训练过程更稳定的 PassDiff 模型。 但由于扩散模型采样速度较慢，导致本文采用的模型很难生成十亿级字典。扩散模型在构造密码猜测模型方面具有巨大潜力，理论上也能取得很大突破\n在未来的工作中，我们将进一步优化参数并调试其他参数，例如扩散步长和学习率。我们计划使用其他神经网络从噪声中学习以提高破解率。我们还将尝试其他编码方法，例如编码两个以上的字符并尝试将它们与PCFG结合。\n# 专业名词\n","source":"_posts/论文笔记/PassDiff.md","raw":"# 摘要\n\n1. 本文使用去噪扩散模型；\n2. 考虑到密码空间和文本空间的相似性，在输入阶段使用了字节级分词器，并通过修改源代码来优化采样过程。\n3. 进行特殊字符编码使得 PassDiff 可以处理可变长度的输入并获得可变长度输出，无需手动截断。\n4. 比 PassGAN 训练稳定，破解比例显著提高\n5. 去噪步骤增加，能进一步提高破解比例。\n\n# 引言\n1. 传统的密码破解有三种：基于字典、基于概率统计模型、基于深度学习\n\t1. 基于字典：依赖字典和规则\n\t2. 基于概率统计：如马尔可夫和概率上下文无关文法（PCFG）\n\t\t概率上下文无关文法：用标识+个数形式表示密码的结构，然后进行响应的填充。\n\t3.  基于深度学习：不需要预知识，也不会被限制范围\n\n# 贡献\n1. 使用了扩散模型\n2. 使用了字节级别的标记器编码输入向量\n3. 通过调整代码优化了降噪过程，\n# 背景知识以及相关工作\n## GAN\n1. 生成模型\n2. 辨别模型\n## DDPM\n1. 构成：由两个马尔科夫链构成\n\t1. 前向链：扩散过程，添加噪声。\n\t\t目的：经常用于将原始分布转为先验分布\n\t2. 反向链：降噪过程，转换噪声恢复数据。\n\t\t目的：使用从深度神经网络学习的参数化转换内核来反转此过程\n2. 去噪过程分两步不断生成新的数据点：首先从先验分布中采样随机数据，然后执行原始采样。\n3. 数学过程\n\t1. 假设 x0 服从一个分布。\n\t2. 有一个向前传播转换链， 即 转换核心：q(xt|xt-1)，这个通常可以被自定义\n\t3. 计算得到了 x1，x2, x3,.... 的一个分布\n\t4. DDPM 一般会在向前传播时把分布转换为一个初始分布。\n\t5. 扩散过程不断用噪音破坏输入数据，直到丢失所有特征。\n\t6. 新建数据点：从先验分布中收养一个随机噪音点，构造一个规则逆向马尔可夫链从而逐渐排除噪声。\n\t7. 从 xT 得到 x0\n\n\n# PassDiff\n1. 标准扩散模型主要用于图像生成\n2. Diffusion-LM  改进\n\t1. 用 transform 学习噪音分布\n\t2. 添加文本嵌入步骤\n\t3. 添加舍入步骤\n\t4. 文本作为输入，将文本嵌入为一个以为整形向量---使用单词级别的 令牌嵌入\n\t5. 扩散过程中， 这个整形向量被 转为 一维 浮点向量，\n\t6. 去噪过程的最后：舍入步骤会将这个 一维 浮点向量 转为 一维 整形 向量\n\t7. \n\t8. 只能输出固定长度文本\n3. 单词级别的令牌嵌入器 将本文分割为单词，\n\t1. 嵌入频率高能捕获语义信息，但是容易导致嵌入范围过大\n4. 字节级别的令牌嵌入将文本识别为一系列的字节，连续嵌入单字节和多字节\n\t1. 单字节的语义信息很少\n\t2. 多字节是 单字节和 单词级别嵌入之间的妥协。\n5. 密码空间和 文本空间相似，语义信息 在密码的字符之间比在语料库中弱，\n6. 参考 Diffusion-LM 我们使用字符级别的嵌入器\n7. 我们发现降噪过程的生成密码长度一致，引入随机因子生成各种长度。\n8. 多字节嵌入没有比单字节有明显优势，为了简化，使用单字节。即 一个特殊字节和 95 个特殊字节。\n\t1. 特殊字节表示为0.\n\t2. 其余可见字节 按 ascill 顺序表 从 1  到  95 .\n\t3. 特殊字符的编码可以 处理可变长度的输入并且获取可变的输出，无序手动截断。\n\t4. Passdiff使用最少的去噪步骤也能产生高质量的输出，建议 5-50，可以将采样速度提高十倍！\n\t4.\n![[Pasted image 20240229164854.png]]\n# 实验配置\n1. 实验环境：\n\t1. DELL Precision 5820工作站，128G内存，10个CPU核心\n\t2. NVIDIA GeForce RTX 3090显\n\t3. Win10和Ubuntu 22.04下进行的\n\t4. Win10上进行了PassGAN相关实验，使用rnnPassGAN的源代码[8,17]。与扩散模型相关的实验是 在Ubuntu 22.04上进行，源代码来自minimal-text-diffusion[16]。\n2. 数据集\n\t1. 12306 CSDN RockYou\n\t2. 去除密码长度超过15，或者有不可见字符的密码，\n\t3. 8：2 训练集和测试集\n3. 超参数\n\t1. 包括：训练轮次：批次大小：扩散步骤：去噪步骤，输入长度，输出长度，学习率\n4. 实验结果\n\t1. CSDN和RockYou的破解率总体高于12306：重复率都高于12306\n\t2. CSDN和RockYou数据集的破解率逐渐稳定在40个去噪步骤左右，超过了12306所需的去噪步骤：：训练不足和数据量较大。\n\t3. 增加数量 训练轮数和批量大小都可以提高破解率。\n\t4. 随着去噪步数的增加，破解率首先逐渐上升到最大值，然后趋于最佳.\n\t5. 去噪步骤和训练轮次增加，重复率增加\n\t6. 重复率越高，生成独一无二的相同长度密码的概率越低\n# 比较\n1.  我们的PassDiff模型比PassGAN具有显着的优势。当生成108个密码时，我们的模型在12306、CSDN和RockYou数据集上的破解率分别比PassGAN高3.17%、6.33%和13.22%。 另外，这并不是我们在破解率方面最好的表现\n2. 但是，我们的模型与传统的密码猜测模型（例如PCFG）之间仍然存在一些差距。\n# 总结\n本文通过优化扩散模型参数和增加训练轮数，提出了比 PassGAN 训练时间更短、训练过程更稳定的 PassDiff 模型。 但由于扩散模型采样速度较慢，导致本文采用的模型很难生成十亿级字典。扩散模型在构造密码猜测模型方面具有巨大潜力，理论上也能取得很大突破\n在未来的工作中，我们将进一步优化参数并调试其他参数，例如扩散步长和学习率。我们计划使用其他神经网络从噪声中学习以提高破解率。我们还将尝试其他编码方法，例如编码两个以上的字符并尝试将它们与PCFG结合。\n# 专业名词\n","slug":"论文笔记/PassDiff","published":1,"date":"2024-04-22T13:14:48.839Z","updated":"2024-04-13T05:25:16.127Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0i001dkgg4ek0cayaz","content":"<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><ol>\n<li>本文使用去噪扩散模型；</li>\n<li>考虑到密码空间和文本空间的相似性，在输入阶段使用了字节级分词器，并通过修改源代码来优化采样过程。</li>\n<li>进行特殊字符编码使得 PassDiff 可以处理可变长度的输入并获得可变长度输出，无需手动截断。</li>\n<li>比 PassGAN 训练稳定，破解比例显著提高</li>\n<li>去噪步骤增加，能进一步提高破解比例。</li>\n</ol>\n<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><ol>\n<li>传统的密码破解有三种：基于字典、基于概率统计模型、基于深度学习<ol>\n<li>基于字典：依赖字典和规则</li>\n<li>基于概率统计：如马尔可夫和概率上下文无关文法（PCFG）<br> 概率上下文无关文法：用标识+个数形式表示密码的结构，然后进行响应的填充。</li>\n<li>基于深度学习：不需要预知识，也不会被限制范围</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"贡献\"><a href=\"#贡献\" class=\"headerlink\" title=\"贡献\"></a>贡献</h1><ol>\n<li>使用了扩散模型</li>\n<li>使用了字节级别的标记器编码输入向量</li>\n<li>通过调整代码优化了降噪过程，</li>\n</ol>\n<h1 id=\"背景知识以及相关工作\"><a href=\"#背景知识以及相关工作\" class=\"headerlink\" title=\"背景知识以及相关工作\"></a>背景知识以及相关工作</h1><h2 id=\"GAN\"><a href=\"#GAN\" class=\"headerlink\" title=\"GAN\"></a>GAN</h2><ol>\n<li>生成模型</li>\n<li>辨别模型</li>\n</ol>\n<h2 id=\"DDPM\"><a href=\"#DDPM\" class=\"headerlink\" title=\"DDPM\"></a>DDPM</h2><ol>\n<li>构成：由两个马尔科夫链构成<ol>\n<li>前向链：扩散过程，添加噪声。<br> 目的：经常用于将原始分布转为先验分布</li>\n<li>反向链：降噪过程，转换噪声恢复数据。<br> 目的：使用从深度神经网络学习的参数化转换内核来反转此过程</li>\n</ol>\n</li>\n<li>去噪过程分两步不断生成新的数据点：首先从先验分布中采样随机数据，然后执行原始采样。</li>\n<li>数学过程<ol>\n<li>假设 x0 服从一个分布。</li>\n<li>有一个向前传播转换链， 即 转换核心：q(xt|xt-1)，这个通常可以被自定义</li>\n<li>计算得到了 x1，x2, x3,…. 的一个分布</li>\n<li>DDPM 一般会在向前传播时把分布转换为一个初始分布。</li>\n<li>扩散过程不断用噪音破坏输入数据，直到丢失所有特征。</li>\n<li>新建数据点：从先验分布中收养一个随机噪音点，构造一个规则逆向马尔可夫链从而逐渐排除噪声。</li>\n<li>从 xT 得到 x0</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"PassDiff\"><a href=\"#PassDiff\" class=\"headerlink\" title=\"PassDiff\"></a>PassDiff</h1><ol>\n<li>标准扩散模型主要用于图像生成</li>\n<li>Diffusion-LM  改进<ol>\n<li>用 transform 学习噪音分布</li>\n<li>添加文本嵌入步骤</li>\n<li>添加舍入步骤</li>\n<li>文本作为输入，将文本嵌入为一个以为整形向量—使用单词级别的 令牌嵌入</li>\n<li>扩散过程中， 这个整形向量被 转为 一维 浮点向量，</li>\n<li>去噪过程的最后：舍入步骤会将这个 一维 浮点向量 转为 一维 整形 向量</li>\n<li></li>\n<li>只能输出固定长度文本</li>\n</ol>\n</li>\n<li>单词级别的令牌嵌入器 将本文分割为单词，<ol>\n<li>嵌入频率高能捕获语义信息，但是容易导致嵌入范围过大</li>\n</ol>\n</li>\n<li>字节级别的令牌嵌入将文本识别为一系列的字节，连续嵌入单字节和多字节<ol>\n<li>单字节的语义信息很少</li>\n<li>多字节是 单字节和 单词级别嵌入之间的妥协。</li>\n</ol>\n</li>\n<li>密码空间和 文本空间相似，语义信息 在密码的字符之间比在语料库中弱，</li>\n<li>参考 Diffusion-LM 我们使用字符级别的嵌入器</li>\n<li>我们发现降噪过程的生成密码长度一致，引入随机因子生成各种长度。</li>\n<li>多字节嵌入没有比单字节有明显优势，为了简化，使用单字节。即 一个特殊字节和 95 个特殊字节。<ol>\n<li>特殊字节表示为0.</li>\n<li>其余可见字节 按 ascill 顺序表 从 1  到  95 .</li>\n<li>特殊字符的编码可以 处理可变长度的输入并且获取可变的输出，无序手动截断。</li>\n<li>Passdiff使用最少的去噪步骤也能产生高质量的输出，建议 5-50，可以将采样速度提高十倍！</li>\n<li>![[Pasted image 20240229164854.png]]</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"实验配置\"><a href=\"#实验配置\" class=\"headerlink\" title=\"实验配置\"></a>实验配置</h1><ol>\n<li>实验环境：<ol>\n<li>DELL Precision 5820工作站，128G内存，10个CPU核心</li>\n<li>NVIDIA GeForce RTX 3090显</li>\n<li>Win10和Ubuntu 22.04下进行的</li>\n<li>Win10上进行了PassGAN相关实验，使用rnnPassGAN的源代码[8,17]。与扩散模型相关的实验是 在Ubuntu 22.04上进行，源代码来自minimal-text-diffusion[16]。</li>\n</ol>\n</li>\n<li>数据集<ol>\n<li>12306 CSDN RockYou</li>\n<li>去除密码长度超过15，或者有不可见字符的密码，</li>\n<li>8：2 训练集和测试集</li>\n</ol>\n</li>\n<li>超参数<ol>\n<li>包括：训练轮次：批次大小：扩散步骤：去噪步骤，输入长度，输出长度，学习率</li>\n</ol>\n</li>\n<li>实验结果<ol>\n<li>CSDN和RockYou的破解率总体高于12306：重复率都高于12306</li>\n<li>CSDN和RockYou数据集的破解率逐渐稳定在40个去噪步骤左右，超过了12306所需的去噪步骤：：训练不足和数据量较大。</li>\n<li>增加数量 训练轮数和批量大小都可以提高破解率。</li>\n<li>随着去噪步数的增加，破解率首先逐渐上升到最大值，然后趋于最佳.</li>\n<li>去噪步骤和训练轮次增加，重复率增加</li>\n<li>重复率越高，生成独一无二的相同长度密码的概率越低</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"比较\"><a href=\"#比较\" class=\"headerlink\" title=\"比较\"></a>比较</h1><ol>\n<li>我们的PassDiff模型比PassGAN具有显着的优势。当生成108个密码时，我们的模型在12306、CSDN和RockYou数据集上的破解率分别比PassGAN高3.17%、6.33%和13.22%。 另外，这并不是我们在破解率方面最好的表现</li>\n<li>但是，我们的模型与传统的密码猜测模型（例如PCFG）之间仍然存在一些差距。</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>本文通过优化扩散模型参数和增加训练轮数，提出了比 PassGAN 训练时间更短、训练过程更稳定的 PassDiff 模型。 但由于扩散模型采样速度较慢，导致本文采用的模型很难生成十亿级字典。扩散模型在构造密码猜测模型方面具有巨大潜力，理论上也能取得很大突破<br>在未来的工作中，我们将进一步优化参数并调试其他参数，例如扩散步长和学习率。我们计划使用其他神经网络从噪声中学习以提高破解率。我们还将尝试其他编码方法，例如编码两个以上的字符并尝试将它们与PCFG结合。</p>\n<h1 id=\"专业名词\"><a href=\"#专业名词\" class=\"headerlink\" title=\"专业名词\"></a>专业名词</h1>","excerpt":"","more":"<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><ol>\n<li>本文使用去噪扩散模型；</li>\n<li>考虑到密码空间和文本空间的相似性，在输入阶段使用了字节级分词器，并通过修改源代码来优化采样过程。</li>\n<li>进行特殊字符编码使得 PassDiff 可以处理可变长度的输入并获得可变长度输出，无需手动截断。</li>\n<li>比 PassGAN 训练稳定，破解比例显著提高</li>\n<li>去噪步骤增加，能进一步提高破解比例。</li>\n</ol>\n<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><ol>\n<li>传统的密码破解有三种：基于字典、基于概率统计模型、基于深度学习<ol>\n<li>基于字典：依赖字典和规则</li>\n<li>基于概率统计：如马尔可夫和概率上下文无关文法（PCFG）<br> 概率上下文无关文法：用标识+个数形式表示密码的结构，然后进行响应的填充。</li>\n<li>基于深度学习：不需要预知识，也不会被限制范围</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"贡献\"><a href=\"#贡献\" class=\"headerlink\" title=\"贡献\"></a>贡献</h1><ol>\n<li>使用了扩散模型</li>\n<li>使用了字节级别的标记器编码输入向量</li>\n<li>通过调整代码优化了降噪过程，</li>\n</ol>\n<h1 id=\"背景知识以及相关工作\"><a href=\"#背景知识以及相关工作\" class=\"headerlink\" title=\"背景知识以及相关工作\"></a>背景知识以及相关工作</h1><h2 id=\"GAN\"><a href=\"#GAN\" class=\"headerlink\" title=\"GAN\"></a>GAN</h2><ol>\n<li>生成模型</li>\n<li>辨别模型</li>\n</ol>\n<h2 id=\"DDPM\"><a href=\"#DDPM\" class=\"headerlink\" title=\"DDPM\"></a>DDPM</h2><ol>\n<li>构成：由两个马尔科夫链构成<ol>\n<li>前向链：扩散过程，添加噪声。<br> 目的：经常用于将原始分布转为先验分布</li>\n<li>反向链：降噪过程，转换噪声恢复数据。<br> 目的：使用从深度神经网络学习的参数化转换内核来反转此过程</li>\n</ol>\n</li>\n<li>去噪过程分两步不断生成新的数据点：首先从先验分布中采样随机数据，然后执行原始采样。</li>\n<li>数学过程<ol>\n<li>假设 x0 服从一个分布。</li>\n<li>有一个向前传播转换链， 即 转换核心：q(xt|xt-1)，这个通常可以被自定义</li>\n<li>计算得到了 x1，x2, x3,…. 的一个分布</li>\n<li>DDPM 一般会在向前传播时把分布转换为一个初始分布。</li>\n<li>扩散过程不断用噪音破坏输入数据，直到丢失所有特征。</li>\n<li>新建数据点：从先验分布中收养一个随机噪音点，构造一个规则逆向马尔可夫链从而逐渐排除噪声。</li>\n<li>从 xT 得到 x0</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"PassDiff\"><a href=\"#PassDiff\" class=\"headerlink\" title=\"PassDiff\"></a>PassDiff</h1><ol>\n<li>标准扩散模型主要用于图像生成</li>\n<li>Diffusion-LM  改进<ol>\n<li>用 transform 学习噪音分布</li>\n<li>添加文本嵌入步骤</li>\n<li>添加舍入步骤</li>\n<li>文本作为输入，将文本嵌入为一个以为整形向量—使用单词级别的 令牌嵌入</li>\n<li>扩散过程中， 这个整形向量被 转为 一维 浮点向量，</li>\n<li>去噪过程的最后：舍入步骤会将这个 一维 浮点向量 转为 一维 整形 向量</li>\n<li></li>\n<li>只能输出固定长度文本</li>\n</ol>\n</li>\n<li>单词级别的令牌嵌入器 将本文分割为单词，<ol>\n<li>嵌入频率高能捕获语义信息，但是容易导致嵌入范围过大</li>\n</ol>\n</li>\n<li>字节级别的令牌嵌入将文本识别为一系列的字节，连续嵌入单字节和多字节<ol>\n<li>单字节的语义信息很少</li>\n<li>多字节是 单字节和 单词级别嵌入之间的妥协。</li>\n</ol>\n</li>\n<li>密码空间和 文本空间相似，语义信息 在密码的字符之间比在语料库中弱，</li>\n<li>参考 Diffusion-LM 我们使用字符级别的嵌入器</li>\n<li>我们发现降噪过程的生成密码长度一致，引入随机因子生成各种长度。</li>\n<li>多字节嵌入没有比单字节有明显优势，为了简化，使用单字节。即 一个特殊字节和 95 个特殊字节。<ol>\n<li>特殊字节表示为0.</li>\n<li>其余可见字节 按 ascill 顺序表 从 1  到  95 .</li>\n<li>特殊字符的编码可以 处理可变长度的输入并且获取可变的输出，无序手动截断。</li>\n<li>Passdiff使用最少的去噪步骤也能产生高质量的输出，建议 5-50，可以将采样速度提高十倍！</li>\n<li>![[Pasted image 20240229164854.png]]</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"实验配置\"><a href=\"#实验配置\" class=\"headerlink\" title=\"实验配置\"></a>实验配置</h1><ol>\n<li>实验环境：<ol>\n<li>DELL Precision 5820工作站，128G内存，10个CPU核心</li>\n<li>NVIDIA GeForce RTX 3090显</li>\n<li>Win10和Ubuntu 22.04下进行的</li>\n<li>Win10上进行了PassGAN相关实验，使用rnnPassGAN的源代码[8,17]。与扩散模型相关的实验是 在Ubuntu 22.04上进行，源代码来自minimal-text-diffusion[16]。</li>\n</ol>\n</li>\n<li>数据集<ol>\n<li>12306 CSDN RockYou</li>\n<li>去除密码长度超过15，或者有不可见字符的密码，</li>\n<li>8：2 训练集和测试集</li>\n</ol>\n</li>\n<li>超参数<ol>\n<li>包括：训练轮次：批次大小：扩散步骤：去噪步骤，输入长度，输出长度，学习率</li>\n</ol>\n</li>\n<li>实验结果<ol>\n<li>CSDN和RockYou的破解率总体高于12306：重复率都高于12306</li>\n<li>CSDN和RockYou数据集的破解率逐渐稳定在40个去噪步骤左右，超过了12306所需的去噪步骤：：训练不足和数据量较大。</li>\n<li>增加数量 训练轮数和批量大小都可以提高破解率。</li>\n<li>随着去噪步数的增加，破解率首先逐渐上升到最大值，然后趋于最佳.</li>\n<li>去噪步骤和训练轮次增加，重复率增加</li>\n<li>重复率越高，生成独一无二的相同长度密码的概率越低</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"比较\"><a href=\"#比较\" class=\"headerlink\" title=\"比较\"></a>比较</h1><ol>\n<li>我们的PassDiff模型比PassGAN具有显着的优势。当生成108个密码时，我们的模型在12306、CSDN和RockYou数据集上的破解率分别比PassGAN高3.17%、6.33%和13.22%。 另外，这并不是我们在破解率方面最好的表现</li>\n<li>但是，我们的模型与传统的密码猜测模型（例如PCFG）之间仍然存在一些差距。</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>本文通过优化扩散模型参数和增加训练轮数，提出了比 PassGAN 训练时间更短、训练过程更稳定的 PassDiff 模型。 但由于扩散模型采样速度较慢，导致本文采用的模型很难生成十亿级字典。扩散模型在构造密码猜测模型方面具有巨大潜力，理论上也能取得很大突破<br>在未来的工作中，我们将进一步优化参数并调试其他参数，例如扩散步长和学习率。我们计划使用其他神经网络从噪声中学习以提高破解率。我们还将尝试其他编码方法，例如编码两个以上的字符并尝试将它们与PCFG结合。</p>\n<h1 id=\"专业名词\"><a href=\"#专业名词\" class=\"headerlink\" title=\"专业名词\"></a>专业名词</h1>"},{"_content":"\n# 摘要\n1. 2016-2023 发表了 30多种密码猜测方法。\n2. 引入了一种分类方法，将现有的方法分为拖网猜测和定向猜测。\n3. 其次，我们提供了一个广泛的基准数据集，可以帮助研究人员和从业者在后续工作中。\n4. 文献计量学分析，以呈现这一领域的趋势和综述论文之间的交叉引用。\n5. 从不同的应用场景、猜测ﬁ的效率以及传统学习方法和深度学习方法的结合等方面讨论了密码猜测的开放挑战。\n6. 本文提出了密码猜测的未来研究方向，以指导密码猜测的后续研究和发展。\n\n\n# 引言\n1. 互联网和安全发展，认证方式\n2. 基于密码认证的原理\n3. 密码猜测为什么有效\n\n\n身份认证的分类：\n1. 用户知道的：密码，个人识别码\n2. 用户拥有的：U盾，加密卡\n3. 用户本身的：\n\t1. 生理特征：指纹，虹膜\n\t2. 行为特征：手写\n\n为什么密码安全有压力：\n1. 互联网发展。需要很多加密\n2. 记忆能力有限。弱密码，相同密码\n3. 密码泄露\n\n密码猜测的角度：\n1. 启发式搜索\n2. 概率模型\n3. 深度学习\n\n## 相关的综述\n### 综述1 \nA Large-Scale Analysis of the Semantic Password Model and Linguistic Patterns in Passwords\n2021\n从样本量、 和语言信息三个方面对语义密码文法进行了综合评价。\n\n密码是一种特定的文本序列，具有长度短、语义丰富的特点。因此，充分利用口令的语义和语言模式有利于口令猜测。在调查[8]中，从样本量、概率平滑和语言信息三个方面对语义密码语法进行了综合评估，并在交叉验证环境中将其与最新的概率上下文无关文法(PCFG)和神经网络模型进行了比较。实验结果揭示了句法模式和语义模式对口令猜测的贡献，表明句法和语义模式对口令安全的影响更大。此外，本文还说明，与最新的神经网络同类模型相比，PCFG往往仍具有竞争力。在训练密码超过100万的PCFG时，性能略有提高。  \n### 综述2\nDeep Learning for Password Guessing and Password Strength Evaluation: A Survey\n2020\n调查了2019年前密码猜测和密码强度评估的最新深度学习方法。\n\n在文[9]中，作者综述了用于密码猜测和密码强度评估的最新深度学习方法，包括密码模式提取、候选密码生成和密码强度测量。然而，由于发表于2020年，该论文在2019年之前只是一篇与统计相关的论文。近年来，各种人工智能技术迅速迭代，范式从模型转变为机器学习理论。因此，迫切需要更新相关内容。\n\n### 综述3\nA Preliminary Analysis of Password Guessing Algorithm [10]\n\n采用覆盖率指标来量化个人信息在创建个人密码过程中的参与程度，并使用蒙特卡洛和Zxcvbn方法来评估密码强度。\n\n在文献[10]中，简要回顾了现有的各种典型密码猜测算法，包括假设、识别信息和理论模型。多个指标也被用来理解和评估这些算法的性能。通过对实验结果的分析，总结了不同密码猜测算法的特点。证明了当猜测次数相同时，两种算法比一种算法猜测更多的口令。此外，作者还提出了一种混合密码猜测算法PaMLGuess，该算法具有很强的可解释性和泛化能力，并利用概率映射来解决不同密码猜测算法给出的概率大小相差很大的问题。\n### 综述4\nThe AI-Based Cyber Threat Landscape: A Survey\n2020\n探索了通过将人工智能的“黑暗面”与攻击技术相结合而构成的网络攻击的研究实例，并介绍了对这些攻击进行建模的分析框架。\n### 综述5 **\nDeep Learning vs. Traditional Probabilistic Models: Case Study on Short Inputs for Password Guessing [12]\n2019\n重点分析了深度学习算法与传统概率模型在短密码串上的对比分析\n。\n对深度学习算法和传统概率密码猜测模型进行了比较分析[12]。作者分析了泄漏数据集的密码模式，并对两种主流的概率模型进行了比较研究，即基于马尔可夫模型和基于PCFG的模型，以及基于深度学习的代表性方法PassGAN模型。\n\n### 综述6 **\nLet’s Go in for a Closer Look: Observing Passwords in Their Natural Habitat [13]\n2017\n\n\n# 调查方法\n检索和选择作品的方法\n\n这篇关于密码猜测的综述遵循了一种系统的文献综述方法。我们按照[14]提出的程序，从现有文献中检索研究论文，从结果中挑选相关作品，然后进行总结。因此，系统的审查过程是可重复的，并减轻了对文献中作品的选择偏见。第2.1-2.3节概述了本综述的研究问题、搜索策略和研究选择。\n## 专业术语\n密码猜测 神经网络\n密码破解 神经网络\n密码攻击 机器学习\n密码猜测 深度学习\n密码可预测性 VAE(分自编码器（Variational Autoencoder）)\n密码重用 变压器\n密码概率模型 PCFG\n拖网 GaN\n目标 马尔可夫\n## 密码数据\n\n![[Pasted image 20240305093437.png]]\n\n泄露的数据大多来自大国的知名公司，如美国和中国。因此，在泄露的密码数据集中，英语和中文是主要语言。其次，大多数密码数据都是在2010年左右泄露的。最后，一般来说，数据集的大小越大，被用作研究语料库的可能性就越高。例如，就数据量而言，RockYou是表中最大的英文数据集，也是我们评论作品中使用最频繁的语料库。\n\n## 密码猜测攻击\n根据是否在线：\n1. 离线密码猜测\n2. 在线密码猜测\n根据是否利用用户的个人信息：\n1. 拖网猜测\n2. 定向猜测，利用用户个人信息\n\n是否使用人工智能：\n1. 传统攻击\n2. 神经攻击\n\n几乎所有现有的工作都是离线猜测，而在线猜测太难在100个猜测内猜出一个密码。\n### 拖网猜测\n#### 传统拖网猜测\n1. 启发式算法\n\t> 这些算法没有严格的理论体系，严重依赖于零散的奇思妙想，例如，基于开源软件使用精心设计的猜测序列[21]构建独特的猜测词典[18-20]。正如[3]指出的那样，这些启发式方法很难重现，也很难相互公平地比较。因此，在这里，我们只介绍一些常用的启发式密码猜测工具。\n\t1. Jtr是一个密码猜测工具，专注于破解UNIX/Linux系统的弱密码。在JTR中有四种模式--简单破解模式、单词表模式、增量模式和外部模式。\n\t2. Hashcat是世界上速度最快、最先进的密码恢复实用程序，支持针对300多种高度优化的哈希算法的五种独特攻击模式。Hashcat目前支持Linux、Windows和MacOS上的CPU、GPU和其他硬件加速器，并具有帮助启用分布式密码破解的设施。\n\t\t> 彩虹攻击：\n\t\t> 一种基于预先计算和空间-时间折中的攻击方法。通过事先计算大量的密码和散列值之间的对应关系（彩虹表），以便在攻击时快速查找并破解散列值。彩虹表是一个预先计算的表格，其中包含了大量的密码和对应的散列值。通过在彩虹表中进行查找，攻击者可以找到与目标散列值匹配的原始密码。\n2. 概率上下文无关语法\n\t该算法的核心假设是密码的字母段L、数字段D和特殊字符段S相互独立。该算法包括训练和猜测两个阶段。\n\t1. 在训练阶段，最关键的是根据泄露的密码数据集计算密码模式(结构)和字符成分(语义)的频率。\n\t2. 在猜测阶段，根据训练阶段得到的模式频率表和语义频率表生成具有频率猜测的集合，以模拟真实密码的概率分布。\n\t粒度太细，无法获得字符之间的语义关系，改进：\n\t1. [24]基于词的内聚力和自由度提取密码中的语义片段，并对基于语义片段的PCFG算法进行改进\n\t2. [25]中，作者将密码视为由几个块组成，其中块是频繁出现在一起以模拟密码的相关字符的序列。\n\t3. 25扩展了字节对编码(BPE)[26]算法，它使用块词汇表平均长度的可配置参数来替换合并操作的数量。\n\t4. 为了解决长密码猜测的困难，请参考。[27]提出了一种改进的基于PCFG的LONG\n3. 马尔可夫序列决策\n\t该算法的核心假设是用户从前到后依次构造口令。它不像PCFG那样分割密码，而是训练整个密码，并通过从左到右链接字符来计算密码的概率。\n\t1. 传统的马尔可夫模型因其结构简单、推理速度快而被广泛应用于口令猜测工作中。但是，它也有一定的缺陷，如过度拟合、重复率高、基于随机抽样生成的密码覆盖率低等。\n\t2. 过拟合：[17]将拉普拉斯平滑和结束符号正则化技术应用于马尔可夫模型。平滑策略消除了数据集中的过拟合问题，正则化技术使攻击算法产生的猜测概率总是和为1。\n\t3. 重复率：[29]设计了一种基于随机抽样的动态分配机制。该机制允许动态调整密码的概率分布，并在猜测过程中严格收敛到均匀分布。基于上述动态分布机制，提出了一种动态马尔可夫模型。\n\t4. 对口令中的语义段进行建模：Ref.[30]提出了一个名为Word马尔可夫的模型，通过语义分段从密码中提取单词的凝聚力和自由度。\n\t\t\n#### 神经拖网猜测算法\n密码猜测任务视为文本生成问题，\n2006年，参考文献[32]引入浅层神经网络进行密码猜测。\n2016年，参考文献[33]提出了基于递归神经网络的口令分布估计算法FLA。该模型遵循马尔可夫模型的序贯决策过程，但放宽了n-马尔可夫假设。FLA可以通过树遍历算法枚举密码空间，从而产生新的猜测结果。从那时起，各种基于的产生式神经网络被反复观察到用于拖网密码猜测。\n1. 回归神经网络(RNN)：回归神经网络是一个递归神经网络，它以序列数据为输入，在序列进化方向上递归，所有节点以链的形式连接。 RNN 有许多变体：如： LSTM，GRU，BiLSTM 等。\n\t1. 步骤：基于RNN的密码猜测方法通常有以下两个步骤：\n\t\t1. ·将训练集中的密码序列输入到RNN模型中，以进行顺序文本生成的训练。\n\t\t2. 训练好的 RNN 猜测模型旨在根据已有的密码字符生成下一个密码字符，直到输出终止字符位置。\n\t2. 在整个密码生成过程中，RNN计算任何字符作为下一个密码令牌的概率。对于给定的阈值，概率高于阈值的密码将被放入密码猜测集中作为有效密码。\n\t3. 一些变体：\n\t\t1. [38]对密码单词进行切分，在词段的基础上使用BiLSTM生成密码。\n\t\t2. [39]中，作者提出了一种层次语义模型HSM，该模型将LSTM和语义分析相结合，用于挖掘用于密码猜测的词之间潜在的概率关系。\n\t\t3. [40]提出了一种基于汉字音节的密码猜测方法。该方法将汉语音节作为整体元素对密码进行解析和处理。然后，在LSTM神经网络中对处理后的密码进行训练以生成密码。\n\t\t4. [41]中，作者使用深度学习，特别是具有注意力机制的RNN来组合和内插同一组用户的信息，以定义比他们的密码分布更稳健和准确的优先级。推理时使用辅助数据来适应目标密码的分布。通过这种方式，开发了一种利用辅助信息并实例化上下文感知口令计量和猜测攻击的全自动方法，而不需要来自目标口令分布的任何明文样本。\n2. 生成式对抗网络（GAN）：\n\t1. 基于GAN的密码猜测模型由密码生成器和鉴别器组成。这两个网络相互对峙，不断地调整参数。最终目的是使鉴别器网络无法判断生成网络的输出是否真实，从而达到口令生成的效果。\n\t2. 问题：离散密码数据的不可微性可能导致梯度反向传播失败，基于GAN的密码猜测模型训练难以收敛，由GAN模型生成的密码重复率较高。\n\t3. 离散数据不可微问题解决：\n\t\t1. Works[44，45]使用Gumbel-Softmax[46]松弛技术来训练基于GAN的密码猜测模型。此外，在工作[44]中提供了另一种解决方案，其使用通过附加的自动编码器获得的真实口令的平滑表示。\n\t\t2. [47]提出了一种基于SeqGAN的密码猜测方法RLPassGAN，该方法使用策略梯度来确保模型参数的持续优化。\n\t4. 收敛困难的问题解决：[49]设计了一种基于双向生成对抗网络的猜测算法，提高了算法的收敛速度。与传统的GaN相比，它可以在更短的时间内产生相同数量的样本\n\t5. 重复率高问题解决：[47]认为根本问题在于生成器中间层的输出是一个不完整的密码序列，在到达输出层之前不能由鉴别器直接评估，从而导致许多冗余的合成密码。为了解决这个问题，作者提出了一种改进的方法，该方法使用蒙特卡罗搜索[50]来评估中间层输出处的不完整密码序列。不同的是，裁判。[49]使用鉴别器和控制器构建额外的控制器网络，以分别学习生成的密码分布与真实密码分布和均匀分布之间的度量。然后利用这两个度量对生成器进行训练，从而降低了口令生成的重复率。\n\t6.  RLPass[51]还创新性地将表征学习用于密码猜测。具体地，将密码投影到隐藏空间，并且使用隐藏空间中的密码表示之间的距离来定义密码的相似性。基于口令的强局部性和弱局部性现象，提出了一种动态口令猜测和条件口令算法。为了解决基于GAN的模型生成的长密码质量较低的问题，请参阅[52]设计了一种基于DenseNet的[53]GAN密码猜测结构DenseGAN，并提出了两种新的密码猜测DenseGAN模型，这两种模型都能生成高质量的密码猜测。\n3. 自动编码器（AE）：自适应学习是一种无监督的学习模型。它基于反向传播算法和优化方法，使用输入数据本身作为监督来指导神经网络学习映射关系，以获得重建的输出。AE 包括编码器和解码器两部分。根据学习范式，AE 可分为欠完备自动编码器、正则化自动编码器和变分自动编码器，其中前两种是判别性模型，后者是生成性模型。在拖网密码猜测的研究中，通常使用**变分自动编码器**[54]来生成密码猜测。如图5所示，将密码样本(Yu123)输入到VAE的编码器以获得表示，然后使用解码器基于该表示重建样本。基于输入x和生成的x之间的重构损失来训练密码生成器。\n\t[47，51，55，56]使用VAE模型来生成密码猜测，但每种方法都有稍微不同的侧重点。在[55]中，作者使用经典的VAE框架来猜测密码，而不需要任何更改。不同的是，裁判。[47]将VAE技术与GaN技术相结合，用VAE代替GaN生成器，旨在解决离散口令数据的反向传播问题。针对模型的轻量级问题，在[56]中，用门控卷积神经网络(GCNN)[57]代替了复杂的RNN生成单元，大大降低了模型的复杂性。\n4. Transformer.\n\t![[Pasted image 20240305201324.png]]\n\tTransformer 模型采用编解码器体系结构，并使用注意[59]替换 Seq2Seq 模型中的递归结构，以实现序列建模的并行化。这种并行化结构给自然语言处理 (NLP) 领域带来了巨大的冲击。随着研究的深入，相关技术逐渐从自然语言处理向计算机视觉 (CV)、语音、生物、化学等领域发展。同样，在拖网密码猜测的研究中也出现了一些基于Transformer的方法[60，61]。\n\t1. [60]旨在研究常见密码规则中密码破解的概率，为密码设置提供参考。作者收集了大量用户的个人信息和密码，并分析了个人信息和密码的相关性。在此基础上，实现了一种基于改进 Transformer 的口令猜测模型。该工作将消息权重引入到数据预处理中，并在模型中使用改进的波束搜索算法来快速搜索排名靠前的密码猜测。\n\t2. 在[61]中，作者提出了一个基于双向 Transformer 的猜测框架 PassBERT，首次将预训练/微调的范式应用于密码破解。具体地说，首先，作者设计了包含一般密码分布知识的通用密码预训练模型。然后，提出了三种特定于攻击的微调方法来定制预先训练的口令模型以适应以下真实攻击场景：条件口令猜测、目标口令猜测和基于自适应规则的口令猜测。最后，他们进一步提出了一种混合密码强度计来降低这三种攻击的风险。\n5. Reinforcement Learning (RL) 强化学习\n\t1. RL是机器学习的范例和方法之一，用于描述和解决智能代理在与环境交互过程中最大化回报或实现特定目标的学习策略问题。密码生成器是代理，每个生成的密码序列代表一个完整的轨迹，生成过程中的每个字符都被视为一个操作。例如，由时间戳t生成的字符是action at。根据由所生成的不完整序列确定的关于当前状态ST的随机策略来生成每个动作At。生成器根据一组随机策略从任意字符生成密码，直到满足预定长度。\n\t2. 在[47]中，作者提出了一种基于强化学习和遗传算法的拖网密码猜测模型RLPassGAN。具体地说，该工作遵循SeqGAN[48]，将密码猜测视为一个连续决策，并使用策略梯度 来确保参数可以连续优化。此外，通过蒙特卡罗搜索[50]来评估输出的不完整密码序列。蒙特卡罗是一种使用大量随机样本来了解特定系统的计算方法。它非常强大和灵活，但易于理解和实现。它是在1940年的曼哈顿计划中提出的。这个名字来自赌城蒙特卡洛，象征着可能性。除了上述应用，蒙特卡罗还被应用于估计给定口令的猜测次数[62，63]\n6. Flow.在上面介绍了生成模型GaN和VAE；它们都没有显式地学习真实数据p(X)的概率密度函数。对于具有潜在变量的生成模型，几乎不可能计算它们p(X)=p(x|z)p(Z)，因为很难遍历隐藏变量z的所有可能值。\n\t1. 这一挑战被生成性模型解决了--归一化流动[64]，这是一个强大的密度估计统计工具。流动模型的一个非常独特的特征是，它的转变通常是可逆的。如图8所示，流模型不仅找到了从分布Z转移到分布X的网络路径，而且该路径还允许X改变为Z。简而言之，流模型找到了分布Z和X之间的双向路径。当然，这种可逆性是以Z和X的数据维度必须相同为代价的。\n\t2. [68]中，朱利奥·帕尼奥塔等人。提出了一种基于产生流模型的口令猜测方法PassFlow。基于流的口令猜测模型使用精确的对数似然计算和优化，使潜在变量的推断更加准确。此外，还给出了潜在空间的一种有意义的表示，这使得探索潜在空间的特定子空间和内插等操作成为可能。作者论证了产生流模型在密码猜测中的适用性。实验结果表明，PassFlow能够在比以前方法小几个数量级的训练集的情况下，在密码猜测方面优于现有的基于GAN的方法。\n\n#### 传统定向密码猜测\n攻击者使用与目标人员相关的个人信息来增强猜测\n2015年，裁判[69]首次提出了一种基于拖网马尔可夫攻击模型的定向攻击猜测方法[70]。基本思想是，关于使用某些个人信息的人口的百分比，攻击目标也将具有相同的使用该个人信息的可能性百分比。为了实现这一想法，文献[71]首先将PII划分为几种类型，如用户名-A、电子邮件前缀-E和名称-N，并根据所需的粒度进一步细分每种广泛的类型。然后，将训练集的每个密码中的所有PII替换为对应的PII类型。训练阶段的其余步骤与行走马尔可夫模型的步骤相同[71]。猜测集生成阶段分为两个步骤。在第一步中，运行行走马尔可夫模型[71]以生成中间猜测集合，该中间猜测集合包含直接可用的猜测，例如123456，以及具有PII类型的基本字符的中间猜测(例如，N1、N2123)。第二步用相应的PII信息替换中间猜测中的基本PII类型字符。\n个人-PCFG。2016年，参考[5]提出了一种基于PCFG的定向攻击猜测方法--Personal-PCFG。它遵循拖网PCFG攻击模型[16]。其基本思想与PCFG攻击模型相同：根据字符类型和长度对密码进行切片。为了实现这一思想，文献[5]   (即用户名-A、电子邮件前缀-E、姓名-N、生日-B、电话号码-P和ID-G)，并将这六种PI字符类型等同于拖网PCFG模型中的L、D和S，从而在个人PCFG中有九种类型的字符。然后，在训练过程中，与拖网PCFG攻击模型[16]中一样，训练集中的每个密码根据相应的字符类型及其长度进行分段。\nTarGuess Wang等人。[4]提出了一个框架，它用四个数学概率模型系统地刻画了典型的定向猜测场景。\n第一个场景TarGuess-I旨在利用用户的PII创建在线目标密码猜测。为了在密码中表示PII令牌，除了PCFG[16]模型中的L、D和S标签外，作者还定义了基于个人信息类型的28个PII标签(例如，N1−N7和B1−B10)。对于每个PII标签，其下标编号表示该类型的PII使用的细分，而不是指示相应长度的下标编号，例如L、D和S标签。例如，N表示名称信息，而N1表示全名，而n2表示全名的缩写\n第二个是Targuess-II，目的是根据用户在其他网站(例如Dodonew)中泄露的密码来猜测目标网站(例如CSDN)中的用户密码。具体地，作者提出了6种结构级和2种字符级助记转换来描述密码重用，并基于上述重用规则使用马尔可夫模型来刻画上下文无关的转换文法。\n第三个是TarGuessIII，目的是使用姐妹密码和一些PII信息来猜测用户的密码。TarGuess-III将PII信息引入到TarGuess-II模型中，允许在结构级密码重用中嵌入PII信息。\n与TarGuess-III相比，TarGuess-IV场景中的攻击者知道难以量化的额外PII(例如，性别、教育)。为了解决某些PII难以直接体现在口令中的问题，在这种难以量化的PII的基础上，巧妙地引入贝叶斯理论来计算口令的重用概率。\n\nRFGuess-PII.在第4.1.1节介绍的RFGuess的基础上，Wang et al.[31]提出了一种新的目标口令猜测模型RFGuess-PII。密码训练和生成过程类似于拖网猜测场景。不同的是，通过新的PII匹配，密码中的PII字符串被替换为相应的数字标签。这种新的PII匹配旨在最小化信息熵，并试图准确地提取整个用户组的PII使用行为。PII匹配算法的第一步是细分PII的各种可能的变换，并使用数字标签来表示它们。第二步是为训练集中的每个密码列出具有PII标签的所有可能的表示。然后，按频率从高到低对表征进行排序。\n\nRFGuess-重复使用。除了基于PII的针对性密码破解研究外，在[31]中，作者还专注于对用户的密码重复使用行为进行建模。他们还考虑了结构级和段级转换，如TarGuess-II[4]。具体地，它们通过计算训练集中每个密码对的编辑矩阵来计算结构级转换，并训练基于随机森林的段级转换(即，相同类型的字符串内的转换，例如字母段中的密码→密码)模型。\n\nTG-SPSR图谱。在[72]中，作者将马尔可夫模型和PCFG模型转化为目标攻击，提出了一种基于结构划分和字符串重组的系统目标攻击模型，称为TG-SPSR。在结构划分阶段，除了将密码划分为类似于PCFG[16]的基本结构外，还在基本语法模式中定义了基于轨迹的键盘，并引入了索引位来准确描述特殊字符的位置。此外，基于定义的9条修改规则，构造了一个BiLSTM分类器来重用和修改密码的行为。\n\n####  神经定向密码猜测\n\n随着自然语言处理技术的发展，一些复杂的神经网络被应用到目标密码猜测领域。在[73]中，作者提出了一个由指针生成网络组成的有针对性的口令猜测模型PG-PASS。该工作创新性地将目标口令猜测作为一项摘要任务，并将智能摘要领域中常用的指针网络技术应用于该任务。需要注意的是，除了用户的人口统计相关信息(姓名、生日等)外，攻击者还可以利用用户在其他网站上泄露的密码进行有针对性的攻击。可以预期，这种利用用户密码重复使用这一易受攻击行为的定向攻击可能比基于人口统计相关信息的攻击更具危害性。\n基于用户总是渴望通过重用或微调旧密码来生成新密码的事实，参考文献。[74]提出了一种基于密码转换器的重用模型，并对证书篡改攻击进行了模拟。在IEEE S&P‘19会议上，Pal等人。[75]引入深度学习技术来表征用户的密码重复使用行为。更具体地说，他们训练了序列到序列(Seq2seq)模型，以预测将现有密码转换为其姊妹密码所需的修改，并在大规模数据集(即4iQ数据集[76])上进行了验证。此外，Wang et al.[77]提出了一种有针对性的密码猜测算法PASS2EDIT，用于模拟日益严重的凭据篡改攻击，在该攻击中，攻击者利用受害者泄露的密码来提高她在其他站点猜测受害者密码的成功率。特别是，他们提出了一种多步决策训练机制，并建立了一个分类神经网络来学习一步编辑操作对现有密码的反应。由于每项工作使用的数据集不同，因此很难进行横断面比较。以12306数据集为例，当猜测集为100时，现有的定向密码猜测方法的猜测准确率约为41.07%[73]。在重复使用猜测场景中，当受害者在站点A的密码(即PWA)已知时，在100次猜测中，Sota方法[77]在猜测其在站点B的密码(PWB=PWA)时的破解成功率分别为24.2%(对于普通用户)和11.7%(对于安全敏感用户)。\n\n\n\n### 数据统计\n从时间上看，2016年至2018年零星出版数量较少，2021年增至9种。这一数量的增加表明关于密码猜测的研究总体上呈上升趋势。在分布式定位技术方面，基于深度神经网络的猜测方法主要集中在图形的左上角，而基于传统方法的猜测方法主要集中在右下角。这一现象表明，神经密码猜测的研究是近年来的热点。这也反映了密码猜测技术的重点正在从传统方法向深度神经网络方法转移。\n\n从数字的角度来看，在许多研究中，神经密码猜测方法所使用的技术更加多样化。其中，GAN、RNN和CNN是使用最多的技术。在传统的密码猜测方法中，PCFG和马尔可夫是使用最广泛的两种密码猜测技术。\n\n从品类上看，现有研究主要集中在拖网密码猜测技术多达37种，针对定向密码猜测研究的著作仅有6部。一方面，正如前面提到的，目前对密码猜测攻击缺乏系统的研究，而且大多集中在个别攻击场景，如离线拖网猜测。此外，越来越现实的有针对性的在线猜测很少得到解决。另一方面，尽管少数研究侧重于有针对性的密码猜测，但大多停留在用户行为的简单统计和对启发式突发事件的依赖程度上，缺乏理论和原则性的研究。一些根本性的问题需要解决。  \n### 交叉引用分析\nFLA[33]和PassGan[43]是被其他人引用最多的作品。这间接说明了这两部作品的影响。由于FLA和PassGAN是第一个分别使用RNN[34]和GAN[42]来模拟口令可猜测性的方法，它可以确定为什么RNN和GAN使用频率很高。\n我们对第一作者所在机构的国籍进行了统计分析。如图11所示，我们用出版物的数量给世界地图上的国家/地区上色。一眼就可以看出，中国地区的色彩最深。这意味着中国是密码猜测领域发表论文最多的国家。美国队紧随中国之后，位居第二。每个国家的影响因子计算如下：IF=引文出版物。经过计算，中国的IF为0.28，美国的IF为11。这个值表明，虽然中国的出版物数量很多，但其在这一领域的影响力远远小于出版数量较少的美国。\n\n### 挑战和未来趋势\n#### 多样应用前景\n主要集中在拖网竞猜场景上，但在实际应用场景中，往往存在定向竞猜、少发竞猜、资源占用少的要求。对于这种场景，现有的方法很难解决镜头少的问题。虽然可以使用数据增强等技术来缓解样本不足的问题，但要从根本上突破两难境地仍然是棘手的。同样，各种深度学习算法也严重依赖于样本的大小和质量，密码等敏感信息的收集是困难的。因此，根据有限的密码样本猜测目标密码是一个复杂的问题。\n#### 密码猜测的效率\n\n然而，在实际应用中，时间和计算资源往往是有限的。传统和神经密码猜测方法都需要巨大的计算能力来支持。随着神经网络模型变得越来越复杂，存储需求也大大增加。因此，在低资源的情况下快速执行密码猜测也是具有挑战性的。在综述的论文中，只有一篇文章讨论了一个轻量级密码猜测模型[56]。因此，这方面的大量工作仍亟待推进。\n#### 传统学习方法与深度学习方法相结合\n然而，纵观现有的研究，新兴的生成模型，如流[64]和扩散模型[78-80]，很少应用于密码猜测。此外，目前的神经密码猜测方法都有一个前提，即密码字符串是一个字符序列，使用序列编码对密码进行处理。事实上，我们可以做更多的尝试，比如根据密码的语义依赖将密码组织成图，并使用最新的图神经网络(GNN)相关技术[81-84]进行采样和生成。此外，预训练的语言模型[85-88]近年来在自然语言处理领域如火如荼地进行着。然而，只有一部作品[61]讨论了关于密码猜测的预训练/精调范式。因此，将预先训练的语言模型强大的通用语言建模功能与现有的密码猜测工作结合起来也可能是一个好主意","source":"_posts/论文笔记/AReview.md","raw":"\n# 摘要\n1. 2016-2023 发表了 30多种密码猜测方法。\n2. 引入了一种分类方法，将现有的方法分为拖网猜测和定向猜测。\n3. 其次，我们提供了一个广泛的基准数据集，可以帮助研究人员和从业者在后续工作中。\n4. 文献计量学分析，以呈现这一领域的趋势和综述论文之间的交叉引用。\n5. 从不同的应用场景、猜测ﬁ的效率以及传统学习方法和深度学习方法的结合等方面讨论了密码猜测的开放挑战。\n6. 本文提出了密码猜测的未来研究方向，以指导密码猜测的后续研究和发展。\n\n\n# 引言\n1. 互联网和安全发展，认证方式\n2. 基于密码认证的原理\n3. 密码猜测为什么有效\n\n\n身份认证的分类：\n1. 用户知道的：密码，个人识别码\n2. 用户拥有的：U盾，加密卡\n3. 用户本身的：\n\t1. 生理特征：指纹，虹膜\n\t2. 行为特征：手写\n\n为什么密码安全有压力：\n1. 互联网发展。需要很多加密\n2. 记忆能力有限。弱密码，相同密码\n3. 密码泄露\n\n密码猜测的角度：\n1. 启发式搜索\n2. 概率模型\n3. 深度学习\n\n## 相关的综述\n### 综述1 \nA Large-Scale Analysis of the Semantic Password Model and Linguistic Patterns in Passwords\n2021\n从样本量、 和语言信息三个方面对语义密码文法进行了综合评价。\n\n密码是一种特定的文本序列，具有长度短、语义丰富的特点。因此，充分利用口令的语义和语言模式有利于口令猜测。在调查[8]中，从样本量、概率平滑和语言信息三个方面对语义密码语法进行了综合评估，并在交叉验证环境中将其与最新的概率上下文无关文法(PCFG)和神经网络模型进行了比较。实验结果揭示了句法模式和语义模式对口令猜测的贡献，表明句法和语义模式对口令安全的影响更大。此外，本文还说明，与最新的神经网络同类模型相比，PCFG往往仍具有竞争力。在训练密码超过100万的PCFG时，性能略有提高。  \n### 综述2\nDeep Learning for Password Guessing and Password Strength Evaluation: A Survey\n2020\n调查了2019年前密码猜测和密码强度评估的最新深度学习方法。\n\n在文[9]中，作者综述了用于密码猜测和密码强度评估的最新深度学习方法，包括密码模式提取、候选密码生成和密码强度测量。然而，由于发表于2020年，该论文在2019年之前只是一篇与统计相关的论文。近年来，各种人工智能技术迅速迭代，范式从模型转变为机器学习理论。因此，迫切需要更新相关内容。\n\n### 综述3\nA Preliminary Analysis of Password Guessing Algorithm [10]\n\n采用覆盖率指标来量化个人信息在创建个人密码过程中的参与程度，并使用蒙特卡洛和Zxcvbn方法来评估密码强度。\n\n在文献[10]中，简要回顾了现有的各种典型密码猜测算法，包括假设、识别信息和理论模型。多个指标也被用来理解和评估这些算法的性能。通过对实验结果的分析，总结了不同密码猜测算法的特点。证明了当猜测次数相同时，两种算法比一种算法猜测更多的口令。此外，作者还提出了一种混合密码猜测算法PaMLGuess，该算法具有很强的可解释性和泛化能力，并利用概率映射来解决不同密码猜测算法给出的概率大小相差很大的问题。\n### 综述4\nThe AI-Based Cyber Threat Landscape: A Survey\n2020\n探索了通过将人工智能的“黑暗面”与攻击技术相结合而构成的网络攻击的研究实例，并介绍了对这些攻击进行建模的分析框架。\n### 综述5 **\nDeep Learning vs. Traditional Probabilistic Models: Case Study on Short Inputs for Password Guessing [12]\n2019\n重点分析了深度学习算法与传统概率模型在短密码串上的对比分析\n。\n对深度学习算法和传统概率密码猜测模型进行了比较分析[12]。作者分析了泄漏数据集的密码模式，并对两种主流的概率模型进行了比较研究，即基于马尔可夫模型和基于PCFG的模型，以及基于深度学习的代表性方法PassGAN模型。\n\n### 综述6 **\nLet’s Go in for a Closer Look: Observing Passwords in Their Natural Habitat [13]\n2017\n\n\n# 调查方法\n检索和选择作品的方法\n\n这篇关于密码猜测的综述遵循了一种系统的文献综述方法。我们按照[14]提出的程序，从现有文献中检索研究论文，从结果中挑选相关作品，然后进行总结。因此，系统的审查过程是可重复的，并减轻了对文献中作品的选择偏见。第2.1-2.3节概述了本综述的研究问题、搜索策略和研究选择。\n## 专业术语\n密码猜测 神经网络\n密码破解 神经网络\n密码攻击 机器学习\n密码猜测 深度学习\n密码可预测性 VAE(分自编码器（Variational Autoencoder）)\n密码重用 变压器\n密码概率模型 PCFG\n拖网 GaN\n目标 马尔可夫\n## 密码数据\n\n![[Pasted image 20240305093437.png]]\n\n泄露的数据大多来自大国的知名公司，如美国和中国。因此，在泄露的密码数据集中，英语和中文是主要语言。其次，大多数密码数据都是在2010年左右泄露的。最后，一般来说，数据集的大小越大，被用作研究语料库的可能性就越高。例如，就数据量而言，RockYou是表中最大的英文数据集，也是我们评论作品中使用最频繁的语料库。\n\n## 密码猜测攻击\n根据是否在线：\n1. 离线密码猜测\n2. 在线密码猜测\n根据是否利用用户的个人信息：\n1. 拖网猜测\n2. 定向猜测，利用用户个人信息\n\n是否使用人工智能：\n1. 传统攻击\n2. 神经攻击\n\n几乎所有现有的工作都是离线猜测，而在线猜测太难在100个猜测内猜出一个密码。\n### 拖网猜测\n#### 传统拖网猜测\n1. 启发式算法\n\t> 这些算法没有严格的理论体系，严重依赖于零散的奇思妙想，例如，基于开源软件使用精心设计的猜测序列[21]构建独特的猜测词典[18-20]。正如[3]指出的那样，这些启发式方法很难重现，也很难相互公平地比较。因此，在这里，我们只介绍一些常用的启发式密码猜测工具。\n\t1. Jtr是一个密码猜测工具，专注于破解UNIX/Linux系统的弱密码。在JTR中有四种模式--简单破解模式、单词表模式、增量模式和外部模式。\n\t2. Hashcat是世界上速度最快、最先进的密码恢复实用程序，支持针对300多种高度优化的哈希算法的五种独特攻击模式。Hashcat目前支持Linux、Windows和MacOS上的CPU、GPU和其他硬件加速器，并具有帮助启用分布式密码破解的设施。\n\t\t> 彩虹攻击：\n\t\t> 一种基于预先计算和空间-时间折中的攻击方法。通过事先计算大量的密码和散列值之间的对应关系（彩虹表），以便在攻击时快速查找并破解散列值。彩虹表是一个预先计算的表格，其中包含了大量的密码和对应的散列值。通过在彩虹表中进行查找，攻击者可以找到与目标散列值匹配的原始密码。\n2. 概率上下文无关语法\n\t该算法的核心假设是密码的字母段L、数字段D和特殊字符段S相互独立。该算法包括训练和猜测两个阶段。\n\t1. 在训练阶段，最关键的是根据泄露的密码数据集计算密码模式(结构)和字符成分(语义)的频率。\n\t2. 在猜测阶段，根据训练阶段得到的模式频率表和语义频率表生成具有频率猜测的集合，以模拟真实密码的概率分布。\n\t粒度太细，无法获得字符之间的语义关系，改进：\n\t1. [24]基于词的内聚力和自由度提取密码中的语义片段，并对基于语义片段的PCFG算法进行改进\n\t2. [25]中，作者将密码视为由几个块组成，其中块是频繁出现在一起以模拟密码的相关字符的序列。\n\t3. 25扩展了字节对编码(BPE)[26]算法，它使用块词汇表平均长度的可配置参数来替换合并操作的数量。\n\t4. 为了解决长密码猜测的困难，请参考。[27]提出了一种改进的基于PCFG的LONG\n3. 马尔可夫序列决策\n\t该算法的核心假设是用户从前到后依次构造口令。它不像PCFG那样分割密码，而是训练整个密码，并通过从左到右链接字符来计算密码的概率。\n\t1. 传统的马尔可夫模型因其结构简单、推理速度快而被广泛应用于口令猜测工作中。但是，它也有一定的缺陷，如过度拟合、重复率高、基于随机抽样生成的密码覆盖率低等。\n\t2. 过拟合：[17]将拉普拉斯平滑和结束符号正则化技术应用于马尔可夫模型。平滑策略消除了数据集中的过拟合问题，正则化技术使攻击算法产生的猜测概率总是和为1。\n\t3. 重复率：[29]设计了一种基于随机抽样的动态分配机制。该机制允许动态调整密码的概率分布，并在猜测过程中严格收敛到均匀分布。基于上述动态分布机制，提出了一种动态马尔可夫模型。\n\t4. 对口令中的语义段进行建模：Ref.[30]提出了一个名为Word马尔可夫的模型，通过语义分段从密码中提取单词的凝聚力和自由度。\n\t\t\n#### 神经拖网猜测算法\n密码猜测任务视为文本生成问题，\n2006年，参考文献[32]引入浅层神经网络进行密码猜测。\n2016年，参考文献[33]提出了基于递归神经网络的口令分布估计算法FLA。该模型遵循马尔可夫模型的序贯决策过程，但放宽了n-马尔可夫假设。FLA可以通过树遍历算法枚举密码空间，从而产生新的猜测结果。从那时起，各种基于的产生式神经网络被反复观察到用于拖网密码猜测。\n1. 回归神经网络(RNN)：回归神经网络是一个递归神经网络，它以序列数据为输入，在序列进化方向上递归，所有节点以链的形式连接。 RNN 有许多变体：如： LSTM，GRU，BiLSTM 等。\n\t1. 步骤：基于RNN的密码猜测方法通常有以下两个步骤：\n\t\t1. ·将训练集中的密码序列输入到RNN模型中，以进行顺序文本生成的训练。\n\t\t2. 训练好的 RNN 猜测模型旨在根据已有的密码字符生成下一个密码字符，直到输出终止字符位置。\n\t2. 在整个密码生成过程中，RNN计算任何字符作为下一个密码令牌的概率。对于给定的阈值，概率高于阈值的密码将被放入密码猜测集中作为有效密码。\n\t3. 一些变体：\n\t\t1. [38]对密码单词进行切分，在词段的基础上使用BiLSTM生成密码。\n\t\t2. [39]中，作者提出了一种层次语义模型HSM，该模型将LSTM和语义分析相结合，用于挖掘用于密码猜测的词之间潜在的概率关系。\n\t\t3. [40]提出了一种基于汉字音节的密码猜测方法。该方法将汉语音节作为整体元素对密码进行解析和处理。然后，在LSTM神经网络中对处理后的密码进行训练以生成密码。\n\t\t4. [41]中，作者使用深度学习，特别是具有注意力机制的RNN来组合和内插同一组用户的信息，以定义比他们的密码分布更稳健和准确的优先级。推理时使用辅助数据来适应目标密码的分布。通过这种方式，开发了一种利用辅助信息并实例化上下文感知口令计量和猜测攻击的全自动方法，而不需要来自目标口令分布的任何明文样本。\n2. 生成式对抗网络（GAN）：\n\t1. 基于GAN的密码猜测模型由密码生成器和鉴别器组成。这两个网络相互对峙，不断地调整参数。最终目的是使鉴别器网络无法判断生成网络的输出是否真实，从而达到口令生成的效果。\n\t2. 问题：离散密码数据的不可微性可能导致梯度反向传播失败，基于GAN的密码猜测模型训练难以收敛，由GAN模型生成的密码重复率较高。\n\t3. 离散数据不可微问题解决：\n\t\t1. Works[44，45]使用Gumbel-Softmax[46]松弛技术来训练基于GAN的密码猜测模型。此外，在工作[44]中提供了另一种解决方案，其使用通过附加的自动编码器获得的真实口令的平滑表示。\n\t\t2. [47]提出了一种基于SeqGAN的密码猜测方法RLPassGAN，该方法使用策略梯度来确保模型参数的持续优化。\n\t4. 收敛困难的问题解决：[49]设计了一种基于双向生成对抗网络的猜测算法，提高了算法的收敛速度。与传统的GaN相比，它可以在更短的时间内产生相同数量的样本\n\t5. 重复率高问题解决：[47]认为根本问题在于生成器中间层的输出是一个不完整的密码序列，在到达输出层之前不能由鉴别器直接评估，从而导致许多冗余的合成密码。为了解决这个问题，作者提出了一种改进的方法，该方法使用蒙特卡罗搜索[50]来评估中间层输出处的不完整密码序列。不同的是，裁判。[49]使用鉴别器和控制器构建额外的控制器网络，以分别学习生成的密码分布与真实密码分布和均匀分布之间的度量。然后利用这两个度量对生成器进行训练，从而降低了口令生成的重复率。\n\t6.  RLPass[51]还创新性地将表征学习用于密码猜测。具体地，将密码投影到隐藏空间，并且使用隐藏空间中的密码表示之间的距离来定义密码的相似性。基于口令的强局部性和弱局部性现象，提出了一种动态口令猜测和条件口令算法。为了解决基于GAN的模型生成的长密码质量较低的问题，请参阅[52]设计了一种基于DenseNet的[53]GAN密码猜测结构DenseGAN，并提出了两种新的密码猜测DenseGAN模型，这两种模型都能生成高质量的密码猜测。\n3. 自动编码器（AE）：自适应学习是一种无监督的学习模型。它基于反向传播算法和优化方法，使用输入数据本身作为监督来指导神经网络学习映射关系，以获得重建的输出。AE 包括编码器和解码器两部分。根据学习范式，AE 可分为欠完备自动编码器、正则化自动编码器和变分自动编码器，其中前两种是判别性模型，后者是生成性模型。在拖网密码猜测的研究中，通常使用**变分自动编码器**[54]来生成密码猜测。如图5所示，将密码样本(Yu123)输入到VAE的编码器以获得表示，然后使用解码器基于该表示重建样本。基于输入x和生成的x之间的重构损失来训练密码生成器。\n\t[47，51，55，56]使用VAE模型来生成密码猜测，但每种方法都有稍微不同的侧重点。在[55]中，作者使用经典的VAE框架来猜测密码，而不需要任何更改。不同的是，裁判。[47]将VAE技术与GaN技术相结合，用VAE代替GaN生成器，旨在解决离散口令数据的反向传播问题。针对模型的轻量级问题，在[56]中，用门控卷积神经网络(GCNN)[57]代替了复杂的RNN生成单元，大大降低了模型的复杂性。\n4. Transformer.\n\t![[Pasted image 20240305201324.png]]\n\tTransformer 模型采用编解码器体系结构，并使用注意[59]替换 Seq2Seq 模型中的递归结构，以实现序列建模的并行化。这种并行化结构给自然语言处理 (NLP) 领域带来了巨大的冲击。随着研究的深入，相关技术逐渐从自然语言处理向计算机视觉 (CV)、语音、生物、化学等领域发展。同样，在拖网密码猜测的研究中也出现了一些基于Transformer的方法[60，61]。\n\t1. [60]旨在研究常见密码规则中密码破解的概率，为密码设置提供参考。作者收集了大量用户的个人信息和密码，并分析了个人信息和密码的相关性。在此基础上，实现了一种基于改进 Transformer 的口令猜测模型。该工作将消息权重引入到数据预处理中，并在模型中使用改进的波束搜索算法来快速搜索排名靠前的密码猜测。\n\t2. 在[61]中，作者提出了一个基于双向 Transformer 的猜测框架 PassBERT，首次将预训练/微调的范式应用于密码破解。具体地说，首先，作者设计了包含一般密码分布知识的通用密码预训练模型。然后，提出了三种特定于攻击的微调方法来定制预先训练的口令模型以适应以下真实攻击场景：条件口令猜测、目标口令猜测和基于自适应规则的口令猜测。最后，他们进一步提出了一种混合密码强度计来降低这三种攻击的风险。\n5. Reinforcement Learning (RL) 强化学习\n\t1. RL是机器学习的范例和方法之一，用于描述和解决智能代理在与环境交互过程中最大化回报或实现特定目标的学习策略问题。密码生成器是代理，每个生成的密码序列代表一个完整的轨迹，生成过程中的每个字符都被视为一个操作。例如，由时间戳t生成的字符是action at。根据由所生成的不完整序列确定的关于当前状态ST的随机策略来生成每个动作At。生成器根据一组随机策略从任意字符生成密码，直到满足预定长度。\n\t2. 在[47]中，作者提出了一种基于强化学习和遗传算法的拖网密码猜测模型RLPassGAN。具体地说，该工作遵循SeqGAN[48]，将密码猜测视为一个连续决策，并使用策略梯度 来确保参数可以连续优化。此外，通过蒙特卡罗搜索[50]来评估输出的不完整密码序列。蒙特卡罗是一种使用大量随机样本来了解特定系统的计算方法。它非常强大和灵活，但易于理解和实现。它是在1940年的曼哈顿计划中提出的。这个名字来自赌城蒙特卡洛，象征着可能性。除了上述应用，蒙特卡罗还被应用于估计给定口令的猜测次数[62，63]\n6. Flow.在上面介绍了生成模型GaN和VAE；它们都没有显式地学习真实数据p(X)的概率密度函数。对于具有潜在变量的生成模型，几乎不可能计算它们p(X)=p(x|z)p(Z)，因为很难遍历隐藏变量z的所有可能值。\n\t1. 这一挑战被生成性模型解决了--归一化流动[64]，这是一个强大的密度估计统计工具。流动模型的一个非常独特的特征是，它的转变通常是可逆的。如图8所示，流模型不仅找到了从分布Z转移到分布X的网络路径，而且该路径还允许X改变为Z。简而言之，流模型找到了分布Z和X之间的双向路径。当然，这种可逆性是以Z和X的数据维度必须相同为代价的。\n\t2. [68]中，朱利奥·帕尼奥塔等人。提出了一种基于产生流模型的口令猜测方法PassFlow。基于流的口令猜测模型使用精确的对数似然计算和优化，使潜在变量的推断更加准确。此外，还给出了潜在空间的一种有意义的表示，这使得探索潜在空间的特定子空间和内插等操作成为可能。作者论证了产生流模型在密码猜测中的适用性。实验结果表明，PassFlow能够在比以前方法小几个数量级的训练集的情况下，在密码猜测方面优于现有的基于GAN的方法。\n\n#### 传统定向密码猜测\n攻击者使用与目标人员相关的个人信息来增强猜测\n2015年，裁判[69]首次提出了一种基于拖网马尔可夫攻击模型的定向攻击猜测方法[70]。基本思想是，关于使用某些个人信息的人口的百分比，攻击目标也将具有相同的使用该个人信息的可能性百分比。为了实现这一想法，文献[71]首先将PII划分为几种类型，如用户名-A、电子邮件前缀-E和名称-N，并根据所需的粒度进一步细分每种广泛的类型。然后，将训练集的每个密码中的所有PII替换为对应的PII类型。训练阶段的其余步骤与行走马尔可夫模型的步骤相同[71]。猜测集生成阶段分为两个步骤。在第一步中，运行行走马尔可夫模型[71]以生成中间猜测集合，该中间猜测集合包含直接可用的猜测，例如123456，以及具有PII类型的基本字符的中间猜测(例如，N1、N2123)。第二步用相应的PII信息替换中间猜测中的基本PII类型字符。\n个人-PCFG。2016年，参考[5]提出了一种基于PCFG的定向攻击猜测方法--Personal-PCFG。它遵循拖网PCFG攻击模型[16]。其基本思想与PCFG攻击模型相同：根据字符类型和长度对密码进行切片。为了实现这一思想，文献[5]   (即用户名-A、电子邮件前缀-E、姓名-N、生日-B、电话号码-P和ID-G)，并将这六种PI字符类型等同于拖网PCFG模型中的L、D和S，从而在个人PCFG中有九种类型的字符。然后，在训练过程中，与拖网PCFG攻击模型[16]中一样，训练集中的每个密码根据相应的字符类型及其长度进行分段。\nTarGuess Wang等人。[4]提出了一个框架，它用四个数学概率模型系统地刻画了典型的定向猜测场景。\n第一个场景TarGuess-I旨在利用用户的PII创建在线目标密码猜测。为了在密码中表示PII令牌，除了PCFG[16]模型中的L、D和S标签外，作者还定义了基于个人信息类型的28个PII标签(例如，N1−N7和B1−B10)。对于每个PII标签，其下标编号表示该类型的PII使用的细分，而不是指示相应长度的下标编号，例如L、D和S标签。例如，N表示名称信息，而N1表示全名，而n2表示全名的缩写\n第二个是Targuess-II，目的是根据用户在其他网站(例如Dodonew)中泄露的密码来猜测目标网站(例如CSDN)中的用户密码。具体地，作者提出了6种结构级和2种字符级助记转换来描述密码重用，并基于上述重用规则使用马尔可夫模型来刻画上下文无关的转换文法。\n第三个是TarGuessIII，目的是使用姐妹密码和一些PII信息来猜测用户的密码。TarGuess-III将PII信息引入到TarGuess-II模型中，允许在结构级密码重用中嵌入PII信息。\n与TarGuess-III相比，TarGuess-IV场景中的攻击者知道难以量化的额外PII(例如，性别、教育)。为了解决某些PII难以直接体现在口令中的问题，在这种难以量化的PII的基础上，巧妙地引入贝叶斯理论来计算口令的重用概率。\n\nRFGuess-PII.在第4.1.1节介绍的RFGuess的基础上，Wang et al.[31]提出了一种新的目标口令猜测模型RFGuess-PII。密码训练和生成过程类似于拖网猜测场景。不同的是，通过新的PII匹配，密码中的PII字符串被替换为相应的数字标签。这种新的PII匹配旨在最小化信息熵，并试图准确地提取整个用户组的PII使用行为。PII匹配算法的第一步是细分PII的各种可能的变换，并使用数字标签来表示它们。第二步是为训练集中的每个密码列出具有PII标签的所有可能的表示。然后，按频率从高到低对表征进行排序。\n\nRFGuess-重复使用。除了基于PII的针对性密码破解研究外，在[31]中，作者还专注于对用户的密码重复使用行为进行建模。他们还考虑了结构级和段级转换，如TarGuess-II[4]。具体地，它们通过计算训练集中每个密码对的编辑矩阵来计算结构级转换，并训练基于随机森林的段级转换(即，相同类型的字符串内的转换，例如字母段中的密码→密码)模型。\n\nTG-SPSR图谱。在[72]中，作者将马尔可夫模型和PCFG模型转化为目标攻击，提出了一种基于结构划分和字符串重组的系统目标攻击模型，称为TG-SPSR。在结构划分阶段，除了将密码划分为类似于PCFG[16]的基本结构外，还在基本语法模式中定义了基于轨迹的键盘，并引入了索引位来准确描述特殊字符的位置。此外，基于定义的9条修改规则，构造了一个BiLSTM分类器来重用和修改密码的行为。\n\n####  神经定向密码猜测\n\n随着自然语言处理技术的发展，一些复杂的神经网络被应用到目标密码猜测领域。在[73]中，作者提出了一个由指针生成网络组成的有针对性的口令猜测模型PG-PASS。该工作创新性地将目标口令猜测作为一项摘要任务，并将智能摘要领域中常用的指针网络技术应用于该任务。需要注意的是，除了用户的人口统计相关信息(姓名、生日等)外，攻击者还可以利用用户在其他网站上泄露的密码进行有针对性的攻击。可以预期，这种利用用户密码重复使用这一易受攻击行为的定向攻击可能比基于人口统计相关信息的攻击更具危害性。\n基于用户总是渴望通过重用或微调旧密码来生成新密码的事实，参考文献。[74]提出了一种基于密码转换器的重用模型，并对证书篡改攻击进行了模拟。在IEEE S&P‘19会议上，Pal等人。[75]引入深度学习技术来表征用户的密码重复使用行为。更具体地说，他们训练了序列到序列(Seq2seq)模型，以预测将现有密码转换为其姊妹密码所需的修改，并在大规模数据集(即4iQ数据集[76])上进行了验证。此外，Wang et al.[77]提出了一种有针对性的密码猜测算法PASS2EDIT，用于模拟日益严重的凭据篡改攻击，在该攻击中，攻击者利用受害者泄露的密码来提高她在其他站点猜测受害者密码的成功率。特别是，他们提出了一种多步决策训练机制，并建立了一个分类神经网络来学习一步编辑操作对现有密码的反应。由于每项工作使用的数据集不同，因此很难进行横断面比较。以12306数据集为例，当猜测集为100时，现有的定向密码猜测方法的猜测准确率约为41.07%[73]。在重复使用猜测场景中，当受害者在站点A的密码(即PWA)已知时，在100次猜测中，Sota方法[77]在猜测其在站点B的密码(PWB=PWA)时的破解成功率分别为24.2%(对于普通用户)和11.7%(对于安全敏感用户)。\n\n\n\n### 数据统计\n从时间上看，2016年至2018年零星出版数量较少，2021年增至9种。这一数量的增加表明关于密码猜测的研究总体上呈上升趋势。在分布式定位技术方面，基于深度神经网络的猜测方法主要集中在图形的左上角，而基于传统方法的猜测方法主要集中在右下角。这一现象表明，神经密码猜测的研究是近年来的热点。这也反映了密码猜测技术的重点正在从传统方法向深度神经网络方法转移。\n\n从数字的角度来看，在许多研究中，神经密码猜测方法所使用的技术更加多样化。其中，GAN、RNN和CNN是使用最多的技术。在传统的密码猜测方法中，PCFG和马尔可夫是使用最广泛的两种密码猜测技术。\n\n从品类上看，现有研究主要集中在拖网密码猜测技术多达37种，针对定向密码猜测研究的著作仅有6部。一方面，正如前面提到的，目前对密码猜测攻击缺乏系统的研究，而且大多集中在个别攻击场景，如离线拖网猜测。此外，越来越现实的有针对性的在线猜测很少得到解决。另一方面，尽管少数研究侧重于有针对性的密码猜测，但大多停留在用户行为的简单统计和对启发式突发事件的依赖程度上，缺乏理论和原则性的研究。一些根本性的问题需要解决。  \n### 交叉引用分析\nFLA[33]和PassGan[43]是被其他人引用最多的作品。这间接说明了这两部作品的影响。由于FLA和PassGAN是第一个分别使用RNN[34]和GAN[42]来模拟口令可猜测性的方法，它可以确定为什么RNN和GAN使用频率很高。\n我们对第一作者所在机构的国籍进行了统计分析。如图11所示，我们用出版物的数量给世界地图上的国家/地区上色。一眼就可以看出，中国地区的色彩最深。这意味着中国是密码猜测领域发表论文最多的国家。美国队紧随中国之后，位居第二。每个国家的影响因子计算如下：IF=引文出版物。经过计算，中国的IF为0.28，美国的IF为11。这个值表明，虽然中国的出版物数量很多，但其在这一领域的影响力远远小于出版数量较少的美国。\n\n### 挑战和未来趋势\n#### 多样应用前景\n主要集中在拖网竞猜场景上，但在实际应用场景中，往往存在定向竞猜、少发竞猜、资源占用少的要求。对于这种场景，现有的方法很难解决镜头少的问题。虽然可以使用数据增强等技术来缓解样本不足的问题，但要从根本上突破两难境地仍然是棘手的。同样，各种深度学习算法也严重依赖于样本的大小和质量，密码等敏感信息的收集是困难的。因此，根据有限的密码样本猜测目标密码是一个复杂的问题。\n#### 密码猜测的效率\n\n然而，在实际应用中，时间和计算资源往往是有限的。传统和神经密码猜测方法都需要巨大的计算能力来支持。随着神经网络模型变得越来越复杂，存储需求也大大增加。因此，在低资源的情况下快速执行密码猜测也是具有挑战性的。在综述的论文中，只有一篇文章讨论了一个轻量级密码猜测模型[56]。因此，这方面的大量工作仍亟待推进。\n#### 传统学习方法与深度学习方法相结合\n然而，纵观现有的研究，新兴的生成模型，如流[64]和扩散模型[78-80]，很少应用于密码猜测。此外，目前的神经密码猜测方法都有一个前提，即密码字符串是一个字符序列，使用序列编码对密码进行处理。事实上，我们可以做更多的尝试，比如根据密码的语义依赖将密码组织成图，并使用最新的图神经网络(GNN)相关技术[81-84]进行采样和生成。此外，预训练的语言模型[85-88]近年来在自然语言处理领域如火如荼地进行着。然而，只有一部作品[61]讨论了关于密码猜测的预训练/精调范式。因此，将预先训练的语言模型强大的通用语言建模功能与现有的密码猜测工作结合起来也可能是一个好主意","slug":"论文笔记/AReview","published":1,"date":"2024-04-22T13:14:48.834Z","updated":"2024-03-07T16:14:02.919Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0i001ekgg4a5x41g1y","content":"<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><ol>\n<li>2016-2023 发表了 30多种密码猜测方法。</li>\n<li>引入了一种分类方法，将现有的方法分为拖网猜测和定向猜测。</li>\n<li>其次，我们提供了一个广泛的基准数据集，可以帮助研究人员和从业者在后续工作中。</li>\n<li>文献计量学分析，以呈现这一领域的趋势和综述论文之间的交叉引用。</li>\n<li>从不同的应用场景、猜测ﬁ的效率以及传统学习方法和深度学习方法的结合等方面讨论了密码猜测的开放挑战。</li>\n<li>本文提出了密码猜测的未来研究方向，以指导密码猜测的后续研究和发展。</li>\n</ol>\n<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><ol>\n<li>互联网和安全发展，认证方式</li>\n<li>基于密码认证的原理</li>\n<li>密码猜测为什么有效</li>\n</ol>\n<p>身份认证的分类：</p>\n<ol>\n<li>用户知道的：密码，个人识别码</li>\n<li>用户拥有的：U盾，加密卡</li>\n<li>用户本身的：<ol>\n<li>生理特征：指纹，虹膜</li>\n<li>行为特征：手写</li>\n</ol>\n</li>\n</ol>\n<p>为什么密码安全有压力：</p>\n<ol>\n<li>互联网发展。需要很多加密</li>\n<li>记忆能力有限。弱密码，相同密码</li>\n<li>密码泄露</li>\n</ol>\n<p>密码猜测的角度：</p>\n<ol>\n<li>启发式搜索</li>\n<li>概率模型</li>\n<li>深度学习</li>\n</ol>\n<h2 id=\"相关的综述\"><a href=\"#相关的综述\" class=\"headerlink\" title=\"相关的综述\"></a>相关的综述</h2><h3 id=\"综述1\"><a href=\"#综述1\" class=\"headerlink\" title=\"综述1\"></a>综述1</h3><p>A Large-Scale Analysis of the Semantic Password Model and Linguistic Patterns in Passwords<br>2021<br>从样本量、 和语言信息三个方面对语义密码文法进行了综合评价。</p>\n<p>密码是一种特定的文本序列，具有长度短、语义丰富的特点。因此，充分利用口令的语义和语言模式有利于口令猜测。在调查[8]中，从样本量、概率平滑和语言信息三个方面对语义密码语法进行了综合评估，并在交叉验证环境中将其与最新的概率上下文无关文法(PCFG)和神经网络模型进行了比较。实验结果揭示了句法模式和语义模式对口令猜测的贡献，表明句法和语义模式对口令安全的影响更大。此外，本文还说明，与最新的神经网络同类模型相比，PCFG往往仍具有竞争力。在训练密码超过100万的PCFG时，性能略有提高。  </p>\n<h3 id=\"综述2\"><a href=\"#综述2\" class=\"headerlink\" title=\"综述2\"></a>综述2</h3><p>Deep Learning for Password Guessing and Password Strength Evaluation: A Survey<br>2020<br>调查了2019年前密码猜测和密码强度评估的最新深度学习方法。</p>\n<p>在文[9]中，作者综述了用于密码猜测和密码强度评估的最新深度学习方法，包括密码模式提取、候选密码生成和密码强度测量。然而，由于发表于2020年，该论文在2019年之前只是一篇与统计相关的论文。近年来，各种人工智能技术迅速迭代，范式从模型转变为机器学习理论。因此，迫切需要更新相关内容。</p>\n<h3 id=\"综述3\"><a href=\"#综述3\" class=\"headerlink\" title=\"综述3\"></a>综述3</h3><p>A Preliminary Analysis of Password Guessing Algorithm [10]</p>\n<p>采用覆盖率指标来量化个人信息在创建个人密码过程中的参与程度，并使用蒙特卡洛和Zxcvbn方法来评估密码强度。</p>\n<p>在文献[10]中，简要回顾了现有的各种典型密码猜测算法，包括假设、识别信息和理论模型。多个指标也被用来理解和评估这些算法的性能。通过对实验结果的分析，总结了不同密码猜测算法的特点。证明了当猜测次数相同时，两种算法比一种算法猜测更多的口令。此外，作者还提出了一种混合密码猜测算法PaMLGuess，该算法具有很强的可解释性和泛化能力，并利用概率映射来解决不同密码猜测算法给出的概率大小相差很大的问题。</p>\n<h3 id=\"综述4\"><a href=\"#综述4\" class=\"headerlink\" title=\"综述4\"></a>综述4</h3><p>The AI-Based Cyber Threat Landscape: A Survey<br>2020<br>探索了通过将人工智能的“黑暗面”与攻击技术相结合而构成的网络攻击的研究实例，并介绍了对这些攻击进行建模的分析框架。</p>\n<h3 id=\"综述5\"><a href=\"#综述5\" class=\"headerlink\" title=\"综述5 **\"></a>综述5 **</h3><p>Deep Learning vs. Traditional Probabilistic Models: Case Study on Short Inputs for Password Guessing [12]<br>2019<br>重点分析了深度学习算法与传统概率模型在短密码串上的对比分析<br>。<br>对深度学习算法和传统概率密码猜测模型进行了比较分析[12]。作者分析了泄漏数据集的密码模式，并对两种主流的概率模型进行了比较研究，即基于马尔可夫模型和基于PCFG的模型，以及基于深度学习的代表性方法PassGAN模型。</p>\n<h3 id=\"综述6\"><a href=\"#综述6\" class=\"headerlink\" title=\"综述6 **\"></a>综述6 **</h3><p>Let’s Go in for a Closer Look: Observing Passwords in Their Natural Habitat [13]<br>2017</p>\n<h1 id=\"调查方法\"><a href=\"#调查方法\" class=\"headerlink\" title=\"调查方法\"></a>调查方法</h1><p>检索和选择作品的方法</p>\n<p>这篇关于密码猜测的综述遵循了一种系统的文献综述方法。我们按照[14]提出的程序，从现有文献中检索研究论文，从结果中挑选相关作品，然后进行总结。因此，系统的审查过程是可重复的，并减轻了对文献中作品的选择偏见。第2.1-2.3节概述了本综述的研究问题、搜索策略和研究选择。</p>\n<h2 id=\"专业术语\"><a href=\"#专业术语\" class=\"headerlink\" title=\"专业术语\"></a>专业术语</h2><p>密码猜测 神经网络<br>密码破解 神经网络<br>密码攻击 机器学习<br>密码猜测 深度学习<br>密码可预测性 VAE(分自编码器（Variational Autoencoder）)<br>密码重用 变压器<br>密码概率模型 PCFG<br>拖网 GaN<br>目标 马尔可夫</p>\n<h2 id=\"密码数据\"><a href=\"#密码数据\" class=\"headerlink\" title=\"密码数据\"></a>密码数据</h2><p>![[Pasted image 20240305093437.png]]</p>\n<p>泄露的数据大多来自大国的知名公司，如美国和中国。因此，在泄露的密码数据集中，英语和中文是主要语言。其次，大多数密码数据都是在2010年左右泄露的。最后，一般来说，数据集的大小越大，被用作研究语料库的可能性就越高。例如，就数据量而言，RockYou是表中最大的英文数据集，也是我们评论作品中使用最频繁的语料库。</p>\n<h2 id=\"密码猜测攻击\"><a href=\"#密码猜测攻击\" class=\"headerlink\" title=\"密码猜测攻击\"></a>密码猜测攻击</h2><p>根据是否在线：</p>\n<ol>\n<li>离线密码猜测</li>\n<li>在线密码猜测<br>根据是否利用用户的个人信息：</li>\n<li>拖网猜测</li>\n<li>定向猜测，利用用户个人信息</li>\n</ol>\n<p>是否使用人工智能：</p>\n<ol>\n<li>传统攻击</li>\n<li>神经攻击</li>\n</ol>\n<p>几乎所有现有的工作都是离线猜测，而在线猜测太难在100个猜测内猜出一个密码。</p>\n<h3 id=\"拖网猜测\"><a href=\"#拖网猜测\" class=\"headerlink\" title=\"拖网猜测\"></a>拖网猜测</h3><h4 id=\"传统拖网猜测\"><a href=\"#传统拖网猜测\" class=\"headerlink\" title=\"传统拖网猜测\"></a>传统拖网猜测</h4><ol>\n<li>启发式算法<blockquote>\n<p>这些算法没有严格的理论体系，严重依赖于零散的奇思妙想，例如，基于开源软件使用精心设计的猜测序列[21]构建独特的猜测词典[18-20]。正如[3]指出的那样，这些启发式方法很难重现，也很难相互公平地比较。因此，在这里，我们只介绍一些常用的启发式密码猜测工具。</p>\n</blockquote>\n<ol>\n<li>Jtr是一个密码猜测工具，专注于破解UNIX&#x2F;Linux系统的弱密码。在JTR中有四种模式–简单破解模式、单词表模式、增量模式和外部模式。</li>\n<li>Hashcat是世界上速度最快、最先进的密码恢复实用程序，支持针对300多种高度优化的哈希算法的五种独特攻击模式。Hashcat目前支持Linux、Windows和MacOS上的CPU、GPU和其他硬件加速器，并具有帮助启用分布式密码破解的设施。<blockquote>\n<p>彩虹攻击：<br>一种基于预先计算和空间-时间折中的攻击方法。通过事先计算大量的密码和散列值之间的对应关系（彩虹表），以便在攻击时快速查找并破解散列值。彩虹表是一个预先计算的表格，其中包含了大量的密码和对应的散列值。通过在彩虹表中进行查找，攻击者可以找到与目标散列值匹配的原始密码。</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li>概率上下文无关语法<br> 该算法的核心假设是密码的字母段L、数字段D和特殊字符段S相互独立。该算法包括训练和猜测两个阶段。<ol>\n<li>在训练阶段，最关键的是根据泄露的密码数据集计算密码模式(结构)和字符成分(语义)的频率。</li>\n<li>在猜测阶段，根据训练阶段得到的模式频率表和语义频率表生成具有频率猜测的集合，以模拟真实密码的概率分布。<br> 粒度太细，无法获得字符之间的语义关系，改进：</li>\n<li>[24]基于词的内聚力和自由度提取密码中的语义片段，并对基于语义片段的PCFG算法进行改进</li>\n<li>[25]中，作者将密码视为由几个块组成，其中块是频繁出现在一起以模拟密码的相关字符的序列。</li>\n<li>25扩展了字节对编码(BPE)[26]算法，它使用块词汇表平均长度的可配置参数来替换合并操作的数量。</li>\n<li>为了解决长密码猜测的困难，请参考。[27]提出了一种改进的基于PCFG的LONG</li>\n</ol>\n</li>\n<li>马尔可夫序列决策<br> 该算法的核心假设是用户从前到后依次构造口令。它不像PCFG那样分割密码，而是训练整个密码，并通过从左到右链接字符来计算密码的概率。<ol>\n<li>传统的马尔可夫模型因其结构简单、推理速度快而被广泛应用于口令猜测工作中。但是，它也有一定的缺陷，如过度拟合、重复率高、基于随机抽样生成的密码覆盖率低等。</li>\n<li>过拟合：[17]将拉普拉斯平滑和结束符号正则化技术应用于马尔可夫模型。平滑策略消除了数据集中的过拟合问题，正则化技术使攻击算法产生的猜测概率总是和为1。</li>\n<li>重复率：[29]设计了一种基于随机抽样的动态分配机制。该机制允许动态调整密码的概率分布，并在猜测过程中严格收敛到均匀分布。基于上述动态分布机制，提出了一种动态马尔可夫模型。</li>\n<li>对口令中的语义段进行建模：Ref.[30]提出了一个名为Word马尔可夫的模型，通过语义分段从密码中提取单词的凝聚力和自由度。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"神经拖网猜测算法\"><a href=\"#神经拖网猜测算法\" class=\"headerlink\" title=\"神经拖网猜测算法\"></a>神经拖网猜测算法</h4><p>密码猜测任务视为文本生成问题，<br>2006年，参考文献[32]引入浅层神经网络进行密码猜测。<br>2016年，参考文献[33]提出了基于递归神经网络的口令分布估计算法FLA。该模型遵循马尔可夫模型的序贯决策过程，但放宽了n-马尔可夫假设。FLA可以通过树遍历算法枚举密码空间，从而产生新的猜测结果。从那时起，各种基于的产生式神经网络被反复观察到用于拖网密码猜测。</p>\n<ol>\n<li>回归神经网络(RNN)：回归神经网络是一个递归神经网络，它以序列数据为输入，在序列进化方向上递归，所有节点以链的形式连接。 RNN 有许多变体：如： LSTM，GRU，BiLSTM 等。<ol>\n<li>步骤：基于RNN的密码猜测方法通常有以下两个步骤：<ol>\n<li>·将训练集中的密码序列输入到RNN模型中，以进行顺序文本生成的训练。</li>\n<li>训练好的 RNN 猜测模型旨在根据已有的密码字符生成下一个密码字符，直到输出终止字符位置。</li>\n</ol>\n</li>\n<li>在整个密码生成过程中，RNN计算任何字符作为下一个密码令牌的概率。对于给定的阈值，概率高于阈值的密码将被放入密码猜测集中作为有效密码。</li>\n<li>一些变体：<ol>\n<li>[38]对密码单词进行切分，在词段的基础上使用BiLSTM生成密码。</li>\n<li>[39]中，作者提出了一种层次语义模型HSM，该模型将LSTM和语义分析相结合，用于挖掘用于密码猜测的词之间潜在的概率关系。</li>\n<li>[40]提出了一种基于汉字音节的密码猜测方法。该方法将汉语音节作为整体元素对密码进行解析和处理。然后，在LSTM神经网络中对处理后的密码进行训练以生成密码。</li>\n<li>[41]中，作者使用深度学习，特别是具有注意力机制的RNN来组合和内插同一组用户的信息，以定义比他们的密码分布更稳健和准确的优先级。推理时使用辅助数据来适应目标密码的分布。通过这种方式，开发了一种利用辅助信息并实例化上下文感知口令计量和猜测攻击的全自动方法，而不需要来自目标口令分布的任何明文样本。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>生成式对抗网络（GAN）：<ol>\n<li>基于GAN的密码猜测模型由密码生成器和鉴别器组成。这两个网络相互对峙，不断地调整参数。最终目的是使鉴别器网络无法判断生成网络的输出是否真实，从而达到口令生成的效果。</li>\n<li>问题：离散密码数据的不可微性可能导致梯度反向传播失败，基于GAN的密码猜测模型训练难以收敛，由GAN模型生成的密码重复率较高。</li>\n<li>离散数据不可微问题解决：<ol>\n<li>Works[44，45]使用Gumbel-Softmax[46]松弛技术来训练基于GAN的密码猜测模型。此外，在工作[44]中提供了另一种解决方案，其使用通过附加的自动编码器获得的真实口令的平滑表示。</li>\n<li>[47]提出了一种基于SeqGAN的密码猜测方法RLPassGAN，该方法使用策略梯度来确保模型参数的持续优化。</li>\n</ol>\n</li>\n<li>收敛困难的问题解决：[49]设计了一种基于双向生成对抗网络的猜测算法，提高了算法的收敛速度。与传统的GaN相比，它可以在更短的时间内产生相同数量的样本</li>\n<li>重复率高问题解决：[47]认为根本问题在于生成器中间层的输出是一个不完整的密码序列，在到达输出层之前不能由鉴别器直接评估，从而导致许多冗余的合成密码。为了解决这个问题，作者提出了一种改进的方法，该方法使用蒙特卡罗搜索[50]来评估中间层输出处的不完整密码序列。不同的是，裁判。[49]使用鉴别器和控制器构建额外的控制器网络，以分别学习生成的密码分布与真实密码分布和均匀分布之间的度量。然后利用这两个度量对生成器进行训练，从而降低了口令生成的重复率。</li>\n<li>RLPass[51]还创新性地将表征学习用于密码猜测。具体地，将密码投影到隐藏空间，并且使用隐藏空间中的密码表示之间的距离来定义密码的相似性。基于口令的强局部性和弱局部性现象，提出了一种动态口令猜测和条件口令算法。为了解决基于GAN的模型生成的长密码质量较低的问题，请参阅[52]设计了一种基于DenseNet的[53]GAN密码猜测结构DenseGAN，并提出了两种新的密码猜测DenseGAN模型，这两种模型都能生成高质量的密码猜测。</li>\n</ol>\n</li>\n<li>自动编码器（AE）：自适应学习是一种无监督的学习模型。它基于反向传播算法和优化方法，使用输入数据本身作为监督来指导神经网络学习映射关系，以获得重建的输出。AE 包括编码器和解码器两部分。根据学习范式，AE 可分为欠完备自动编码器、正则化自动编码器和变分自动编码器，其中前两种是判别性模型，后者是生成性模型。在拖网密码猜测的研究中，通常使用<strong>变分自动编码器</strong>[54]来生成密码猜测。如图5所示，将密码样本(Yu123)输入到VAE的编码器以获得表示，然后使用解码器基于该表示重建样本。基于输入x和生成的x之间的重构损失来训练密码生成器。<br> [47，51，55，56]使用VAE模型来生成密码猜测，但每种方法都有稍微不同的侧重点。在[55]中，作者使用经典的VAE框架来猜测密码，而不需要任何更改。不同的是，裁判。[47]将VAE技术与GaN技术相结合，用VAE代替GaN生成器，旨在解决离散口令数据的反向传播问题。针对模型的轻量级问题，在[56]中，用门控卷积神经网络(GCNN)[57]代替了复杂的RNN生成单元，大大降低了模型的复杂性。</li>\n<li>Transformer.<br> ![[Pasted image 20240305201324.png]]<br> Transformer 模型采用编解码器体系结构，并使用注意[59]替换 Seq2Seq 模型中的递归结构，以实现序列建模的并行化。这种并行化结构给自然语言处理 (NLP) 领域带来了巨大的冲击。随着研究的深入，相关技术逐渐从自然语言处理向计算机视觉 (CV)、语音、生物、化学等领域发展。同样，在拖网密码猜测的研究中也出现了一些基于Transformer的方法[60，61]。<ol>\n<li>[60]旨在研究常见密码规则中密码破解的概率，为密码设置提供参考。作者收集了大量用户的个人信息和密码，并分析了个人信息和密码的相关性。在此基础上，实现了一种基于改进 Transformer 的口令猜测模型。该工作将消息权重引入到数据预处理中，并在模型中使用改进的波束搜索算法来快速搜索排名靠前的密码猜测。</li>\n<li>在[61]中，作者提出了一个基于双向 Transformer 的猜测框架 PassBERT，首次将预训练&#x2F;微调的范式应用于密码破解。具体地说，首先，作者设计了包含一般密码分布知识的通用密码预训练模型。然后，提出了三种特定于攻击的微调方法来定制预先训练的口令模型以适应以下真实攻击场景：条件口令猜测、目标口令猜测和基于自适应规则的口令猜测。最后，他们进一步提出了一种混合密码强度计来降低这三种攻击的风险。</li>\n</ol>\n</li>\n<li>Reinforcement Learning (RL) 强化学习<ol>\n<li>RL是机器学习的范例和方法之一，用于描述和解决智能代理在与环境交互过程中最大化回报或实现特定目标的学习策略问题。密码生成器是代理，每个生成的密码序列代表一个完整的轨迹，生成过程中的每个字符都被视为一个操作。例如，由时间戳t生成的字符是action at。根据由所生成的不完整序列确定的关于当前状态ST的随机策略来生成每个动作At。生成器根据一组随机策略从任意字符生成密码，直到满足预定长度。</li>\n<li>在[47]中，作者提出了一种基于强化学习和遗传算法的拖网密码猜测模型RLPassGAN。具体地说，该工作遵循SeqGAN[48]，将密码猜测视为一个连续决策，并使用策略梯度 来确保参数可以连续优化。此外，通过蒙特卡罗搜索[50]来评估输出的不完整密码序列。蒙特卡罗是一种使用大量随机样本来了解特定系统的计算方法。它非常强大和灵活，但易于理解和实现。它是在1940年的曼哈顿计划中提出的。这个名字来自赌城蒙特卡洛，象征着可能性。除了上述应用，蒙特卡罗还被应用于估计给定口令的猜测次数[62，63]</li>\n</ol>\n</li>\n<li>Flow.在上面介绍了生成模型GaN和VAE；它们都没有显式地学习真实数据p(X)的概率密度函数。对于具有潜在变量的生成模型，几乎不可能计算它们p(X)&#x3D;p(x|z)p(Z)，因为很难遍历隐藏变量z的所有可能值。<ol>\n<li>这一挑战被生成性模型解决了–归一化流动[64]，这是一个强大的密度估计统计工具。流动模型的一个非常独特的特征是，它的转变通常是可逆的。如图8所示，流模型不仅找到了从分布Z转移到分布X的网络路径，而且该路径还允许X改变为Z。简而言之，流模型找到了分布Z和X之间的双向路径。当然，这种可逆性是以Z和X的数据维度必须相同为代价的。</li>\n<li>[68]中，朱利奥·帕尼奥塔等人。提出了一种基于产生流模型的口令猜测方法PassFlow。基于流的口令猜测模型使用精确的对数似然计算和优化，使潜在变量的推断更加准确。此外，还给出了潜在空间的一种有意义的表示，这使得探索潜在空间的特定子空间和内插等操作成为可能。作者论证了产生流模型在密码猜测中的适用性。实验结果表明，PassFlow能够在比以前方法小几个数量级的训练集的情况下，在密码猜测方面优于现有的基于GAN的方法。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"传统定向密码猜测\"><a href=\"#传统定向密码猜测\" class=\"headerlink\" title=\"传统定向密码猜测\"></a>传统定向密码猜测</h4><p>攻击者使用与目标人员相关的个人信息来增强猜测<br>2015年，裁判[69]首次提出了一种基于拖网马尔可夫攻击模型的定向攻击猜测方法[70]。基本思想是，关于使用某些个人信息的人口的百分比，攻击目标也将具有相同的使用该个人信息的可能性百分比。为了实现这一想法，文献[71]首先将PII划分为几种类型，如用户名-A、电子邮件前缀-E和名称-N，并根据所需的粒度进一步细分每种广泛的类型。然后，将训练集的每个密码中的所有PII替换为对应的PII类型。训练阶段的其余步骤与行走马尔可夫模型的步骤相同[71]。猜测集生成阶段分为两个步骤。在第一步中，运行行走马尔可夫模型[71]以生成中间猜测集合，该中间猜测集合包含直接可用的猜测，例如123456，以及具有PII类型的基本字符的中间猜测(例如，N1、N2123)。第二步用相应的PII信息替换中间猜测中的基本PII类型字符。<br>个人-PCFG。2016年，参考[5]提出了一种基于PCFG的定向攻击猜测方法–Personal-PCFG。它遵循拖网PCFG攻击模型[16]。其基本思想与PCFG攻击模型相同：根据字符类型和长度对密码进行切片。为了实现这一思想，文献[5]   (即用户名-A、电子邮件前缀-E、姓名-N、生日-B、电话号码-P和ID-G)，并将这六种PI字符类型等同于拖网PCFG模型中的L、D和S，从而在个人PCFG中有九种类型的字符。然后，在训练过程中，与拖网PCFG攻击模型[16]中一样，训练集中的每个密码根据相应的字符类型及其长度进行分段。<br>TarGuess Wang等人。[4]提出了一个框架，它用四个数学概率模型系统地刻画了典型的定向猜测场景。<br>第一个场景TarGuess-I旨在利用用户的PII创建在线目标密码猜测。为了在密码中表示PII令牌，除了PCFG[16]模型中的L、D和S标签外，作者还定义了基于个人信息类型的28个PII标签(例如，N1−N7和B1−B10)。对于每个PII标签，其下标编号表示该类型的PII使用的细分，而不是指示相应长度的下标编号，例如L、D和S标签。例如，N表示名称信息，而N1表示全名，而n2表示全名的缩写<br>第二个是Targuess-II，目的是根据用户在其他网站(例如Dodonew)中泄露的密码来猜测目标网站(例如CSDN)中的用户密码。具体地，作者提出了6种结构级和2种字符级助记转换来描述密码重用，并基于上述重用规则使用马尔可夫模型来刻画上下文无关的转换文法。<br>第三个是TarGuessIII，目的是使用姐妹密码和一些PII信息来猜测用户的密码。TarGuess-III将PII信息引入到TarGuess-II模型中，允许在结构级密码重用中嵌入PII信息。<br>与TarGuess-III相比，TarGuess-IV场景中的攻击者知道难以量化的额外PII(例如，性别、教育)。为了解决某些PII难以直接体现在口令中的问题，在这种难以量化的PII的基础上，巧妙地引入贝叶斯理论来计算口令的重用概率。</p>\n<p>RFGuess-PII.在第4.1.1节介绍的RFGuess的基础上，Wang et al.[31]提出了一种新的目标口令猜测模型RFGuess-PII。密码训练和生成过程类似于拖网猜测场景。不同的是，通过新的PII匹配，密码中的PII字符串被替换为相应的数字标签。这种新的PII匹配旨在最小化信息熵，并试图准确地提取整个用户组的PII使用行为。PII匹配算法的第一步是细分PII的各种可能的变换，并使用数字标签来表示它们。第二步是为训练集中的每个密码列出具有PII标签的所有可能的表示。然后，按频率从高到低对表征进行排序。</p>\n<p>RFGuess-重复使用。除了基于PII的针对性密码破解研究外，在[31]中，作者还专注于对用户的密码重复使用行为进行建模。他们还考虑了结构级和段级转换，如TarGuess-II[4]。具体地，它们通过计算训练集中每个密码对的编辑矩阵来计算结构级转换，并训练基于随机森林的段级转换(即，相同类型的字符串内的转换，例如字母段中的密码→密码)模型。</p>\n<p>TG-SPSR图谱。在[72]中，作者将马尔可夫模型和PCFG模型转化为目标攻击，提出了一种基于结构划分和字符串重组的系统目标攻击模型，称为TG-SPSR。在结构划分阶段，除了将密码划分为类似于PCFG[16]的基本结构外，还在基本语法模式中定义了基于轨迹的键盘，并引入了索引位来准确描述特殊字符的位置。此外，基于定义的9条修改规则，构造了一个BiLSTM分类器来重用和修改密码的行为。</p>\n<h4 id=\"神经定向密码猜测\"><a href=\"#神经定向密码猜测\" class=\"headerlink\" title=\"神经定向密码猜测\"></a>神经定向密码猜测</h4><p>随着自然语言处理技术的发展，一些复杂的神经网络被应用到目标密码猜测领域。在[73]中，作者提出了一个由指针生成网络组成的有针对性的口令猜测模型PG-PASS。该工作创新性地将目标口令猜测作为一项摘要任务，并将智能摘要领域中常用的指针网络技术应用于该任务。需要注意的是，除了用户的人口统计相关信息(姓名、生日等)外，攻击者还可以利用用户在其他网站上泄露的密码进行有针对性的攻击。可以预期，这种利用用户密码重复使用这一易受攻击行为的定向攻击可能比基于人口统计相关信息的攻击更具危害性。<br>基于用户总是渴望通过重用或微调旧密码来生成新密码的事实，参考文献。[74]提出了一种基于密码转换器的重用模型，并对证书篡改攻击进行了模拟。在IEEE S&amp;P‘19会议上，Pal等人。[75]引入深度学习技术来表征用户的密码重复使用行为。更具体地说，他们训练了序列到序列(Seq2seq)模型，以预测将现有密码转换为其姊妹密码所需的修改，并在大规模数据集(即4iQ数据集[76])上进行了验证。此外，Wang et al.[77]提出了一种有针对性的密码猜测算法PASS2EDIT，用于模拟日益严重的凭据篡改攻击，在该攻击中，攻击者利用受害者泄露的密码来提高她在其他站点猜测受害者密码的成功率。特别是，他们提出了一种多步决策训练机制，并建立了一个分类神经网络来学习一步编辑操作对现有密码的反应。由于每项工作使用的数据集不同，因此很难进行横断面比较。以12306数据集为例，当猜测集为100时，现有的定向密码猜测方法的猜测准确率约为41.07%[73]。在重复使用猜测场景中，当受害者在站点A的密码(即PWA)已知时，在100次猜测中，Sota方法[77]在猜测其在站点B的密码(PWB&#x3D;PWA)时的破解成功率分别为24.2%(对于普通用户)和11.7%(对于安全敏感用户)。</p>\n<h3 id=\"数据统计\"><a href=\"#数据统计\" class=\"headerlink\" title=\"数据统计\"></a>数据统计</h3><p>从时间上看，2016年至2018年零星出版数量较少，2021年增至9种。这一数量的增加表明关于密码猜测的研究总体上呈上升趋势。在分布式定位技术方面，基于深度神经网络的猜测方法主要集中在图形的左上角，而基于传统方法的猜测方法主要集中在右下角。这一现象表明，神经密码猜测的研究是近年来的热点。这也反映了密码猜测技术的重点正在从传统方法向深度神经网络方法转移。</p>\n<p>从数字的角度来看，在许多研究中，神经密码猜测方法所使用的技术更加多样化。其中，GAN、RNN和CNN是使用最多的技术。在传统的密码猜测方法中，PCFG和马尔可夫是使用最广泛的两种密码猜测技术。</p>\n<p>从品类上看，现有研究主要集中在拖网密码猜测技术多达37种，针对定向密码猜测研究的著作仅有6部。一方面，正如前面提到的，目前对密码猜测攻击缺乏系统的研究，而且大多集中在个别攻击场景，如离线拖网猜测。此外，越来越现实的有针对性的在线猜测很少得到解决。另一方面，尽管少数研究侧重于有针对性的密码猜测，但大多停留在用户行为的简单统计和对启发式突发事件的依赖程度上，缺乏理论和原则性的研究。一些根本性的问题需要解决。  </p>\n<h3 id=\"交叉引用分析\"><a href=\"#交叉引用分析\" class=\"headerlink\" title=\"交叉引用分析\"></a>交叉引用分析</h3><p>FLA[33]和PassGan[43]是被其他人引用最多的作品。这间接说明了这两部作品的影响。由于FLA和PassGAN是第一个分别使用RNN[34]和GAN[42]来模拟口令可猜测性的方法，它可以确定为什么RNN和GAN使用频率很高。<br>我们对第一作者所在机构的国籍进行了统计分析。如图11所示，我们用出版物的数量给世界地图上的国家&#x2F;地区上色。一眼就可以看出，中国地区的色彩最深。这意味着中国是密码猜测领域发表论文最多的国家。美国队紧随中国之后，位居第二。每个国家的影响因子计算如下：IF&#x3D;引文出版物。经过计算，中国的IF为0.28，美国的IF为11。这个值表明，虽然中国的出版物数量很多，但其在这一领域的影响力远远小于出版数量较少的美国。</p>\n<h3 id=\"挑战和未来趋势\"><a href=\"#挑战和未来趋势\" class=\"headerlink\" title=\"挑战和未来趋势\"></a>挑战和未来趋势</h3><h4 id=\"多样应用前景\"><a href=\"#多样应用前景\" class=\"headerlink\" title=\"多样应用前景\"></a>多样应用前景</h4><p>主要集中在拖网竞猜场景上，但在实际应用场景中，往往存在定向竞猜、少发竞猜、资源占用少的要求。对于这种场景，现有的方法很难解决镜头少的问题。虽然可以使用数据增强等技术来缓解样本不足的问题，但要从根本上突破两难境地仍然是棘手的。同样，各种深度学习算法也严重依赖于样本的大小和质量，密码等敏感信息的收集是困难的。因此，根据有限的密码样本猜测目标密码是一个复杂的问题。</p>\n<h4 id=\"密码猜测的效率\"><a href=\"#密码猜测的效率\" class=\"headerlink\" title=\"密码猜测的效率\"></a>密码猜测的效率</h4><p>然而，在实际应用中，时间和计算资源往往是有限的。传统和神经密码猜测方法都需要巨大的计算能力来支持。随着神经网络模型变得越来越复杂，存储需求也大大增加。因此，在低资源的情况下快速执行密码猜测也是具有挑战性的。在综述的论文中，只有一篇文章讨论了一个轻量级密码猜测模型[56]。因此，这方面的大量工作仍亟待推进。</p>\n<h4 id=\"传统学习方法与深度学习方法相结合\"><a href=\"#传统学习方法与深度学习方法相结合\" class=\"headerlink\" title=\"传统学习方法与深度学习方法相结合\"></a>传统学习方法与深度学习方法相结合</h4><p>然而，纵观现有的研究，新兴的生成模型，如流[64]和扩散模型[78-80]，很少应用于密码猜测。此外，目前的神经密码猜测方法都有一个前提，即密码字符串是一个字符序列，使用序列编码对密码进行处理。事实上，我们可以做更多的尝试，比如根据密码的语义依赖将密码组织成图，并使用最新的图神经网络(GNN)相关技术[81-84]进行采样和生成。此外，预训练的语言模型[85-88]近年来在自然语言处理领域如火如荼地进行着。然而，只有一部作品[61]讨论了关于密码猜测的预训练&#x2F;精调范式。因此，将预先训练的语言模型强大的通用语言建模功能与现有的密码猜测工作结合起来也可能是一个好主意</p>\n","excerpt":"","more":"<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><ol>\n<li>2016-2023 发表了 30多种密码猜测方法。</li>\n<li>引入了一种分类方法，将现有的方法分为拖网猜测和定向猜测。</li>\n<li>其次，我们提供了一个广泛的基准数据集，可以帮助研究人员和从业者在后续工作中。</li>\n<li>文献计量学分析，以呈现这一领域的趋势和综述论文之间的交叉引用。</li>\n<li>从不同的应用场景、猜测ﬁ的效率以及传统学习方法和深度学习方法的结合等方面讨论了密码猜测的开放挑战。</li>\n<li>本文提出了密码猜测的未来研究方向，以指导密码猜测的后续研究和发展。</li>\n</ol>\n<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><ol>\n<li>互联网和安全发展，认证方式</li>\n<li>基于密码认证的原理</li>\n<li>密码猜测为什么有效</li>\n</ol>\n<p>身份认证的分类：</p>\n<ol>\n<li>用户知道的：密码，个人识别码</li>\n<li>用户拥有的：U盾，加密卡</li>\n<li>用户本身的：<ol>\n<li>生理特征：指纹，虹膜</li>\n<li>行为特征：手写</li>\n</ol>\n</li>\n</ol>\n<p>为什么密码安全有压力：</p>\n<ol>\n<li>互联网发展。需要很多加密</li>\n<li>记忆能力有限。弱密码，相同密码</li>\n<li>密码泄露</li>\n</ol>\n<p>密码猜测的角度：</p>\n<ol>\n<li>启发式搜索</li>\n<li>概率模型</li>\n<li>深度学习</li>\n</ol>\n<h2 id=\"相关的综述\"><a href=\"#相关的综述\" class=\"headerlink\" title=\"相关的综述\"></a>相关的综述</h2><h3 id=\"综述1\"><a href=\"#综述1\" class=\"headerlink\" title=\"综述1\"></a>综述1</h3><p>A Large-Scale Analysis of the Semantic Password Model and Linguistic Patterns in Passwords<br>2021<br>从样本量、 和语言信息三个方面对语义密码文法进行了综合评价。</p>\n<p>密码是一种特定的文本序列，具有长度短、语义丰富的特点。因此，充分利用口令的语义和语言模式有利于口令猜测。在调查[8]中，从样本量、概率平滑和语言信息三个方面对语义密码语法进行了综合评估，并在交叉验证环境中将其与最新的概率上下文无关文法(PCFG)和神经网络模型进行了比较。实验结果揭示了句法模式和语义模式对口令猜测的贡献，表明句法和语义模式对口令安全的影响更大。此外，本文还说明，与最新的神经网络同类模型相比，PCFG往往仍具有竞争力。在训练密码超过100万的PCFG时，性能略有提高。  </p>\n<h3 id=\"综述2\"><a href=\"#综述2\" class=\"headerlink\" title=\"综述2\"></a>综述2</h3><p>Deep Learning for Password Guessing and Password Strength Evaluation: A Survey<br>2020<br>调查了2019年前密码猜测和密码强度评估的最新深度学习方法。</p>\n<p>在文[9]中，作者综述了用于密码猜测和密码强度评估的最新深度学习方法，包括密码模式提取、候选密码生成和密码强度测量。然而，由于发表于2020年，该论文在2019年之前只是一篇与统计相关的论文。近年来，各种人工智能技术迅速迭代，范式从模型转变为机器学习理论。因此，迫切需要更新相关内容。</p>\n<h3 id=\"综述3\"><a href=\"#综述3\" class=\"headerlink\" title=\"综述3\"></a>综述3</h3><p>A Preliminary Analysis of Password Guessing Algorithm [10]</p>\n<p>采用覆盖率指标来量化个人信息在创建个人密码过程中的参与程度，并使用蒙特卡洛和Zxcvbn方法来评估密码强度。</p>\n<p>在文献[10]中，简要回顾了现有的各种典型密码猜测算法，包括假设、识别信息和理论模型。多个指标也被用来理解和评估这些算法的性能。通过对实验结果的分析，总结了不同密码猜测算法的特点。证明了当猜测次数相同时，两种算法比一种算法猜测更多的口令。此外，作者还提出了一种混合密码猜测算法PaMLGuess，该算法具有很强的可解释性和泛化能力，并利用概率映射来解决不同密码猜测算法给出的概率大小相差很大的问题。</p>\n<h3 id=\"综述4\"><a href=\"#综述4\" class=\"headerlink\" title=\"综述4\"></a>综述4</h3><p>The AI-Based Cyber Threat Landscape: A Survey<br>2020<br>探索了通过将人工智能的“黑暗面”与攻击技术相结合而构成的网络攻击的研究实例，并介绍了对这些攻击进行建模的分析框架。</p>\n<h3 id=\"综述5\"><a href=\"#综述5\" class=\"headerlink\" title=\"综述5 **\"></a>综述5 **</h3><p>Deep Learning vs. Traditional Probabilistic Models: Case Study on Short Inputs for Password Guessing [12]<br>2019<br>重点分析了深度学习算法与传统概率模型在短密码串上的对比分析<br>。<br>对深度学习算法和传统概率密码猜测模型进行了比较分析[12]。作者分析了泄漏数据集的密码模式，并对两种主流的概率模型进行了比较研究，即基于马尔可夫模型和基于PCFG的模型，以及基于深度学习的代表性方法PassGAN模型。</p>\n<h3 id=\"综述6\"><a href=\"#综述6\" class=\"headerlink\" title=\"综述6 **\"></a>综述6 **</h3><p>Let’s Go in for a Closer Look: Observing Passwords in Their Natural Habitat [13]<br>2017</p>\n<h1 id=\"调查方法\"><a href=\"#调查方法\" class=\"headerlink\" title=\"调查方法\"></a>调查方法</h1><p>检索和选择作品的方法</p>\n<p>这篇关于密码猜测的综述遵循了一种系统的文献综述方法。我们按照[14]提出的程序，从现有文献中检索研究论文，从结果中挑选相关作品，然后进行总结。因此，系统的审查过程是可重复的，并减轻了对文献中作品的选择偏见。第2.1-2.3节概述了本综述的研究问题、搜索策略和研究选择。</p>\n<h2 id=\"专业术语\"><a href=\"#专业术语\" class=\"headerlink\" title=\"专业术语\"></a>专业术语</h2><p>密码猜测 神经网络<br>密码破解 神经网络<br>密码攻击 机器学习<br>密码猜测 深度学习<br>密码可预测性 VAE(分自编码器（Variational Autoencoder）)<br>密码重用 变压器<br>密码概率模型 PCFG<br>拖网 GaN<br>目标 马尔可夫</p>\n<h2 id=\"密码数据\"><a href=\"#密码数据\" class=\"headerlink\" title=\"密码数据\"></a>密码数据</h2><p>![[Pasted image 20240305093437.png]]</p>\n<p>泄露的数据大多来自大国的知名公司，如美国和中国。因此，在泄露的密码数据集中，英语和中文是主要语言。其次，大多数密码数据都是在2010年左右泄露的。最后，一般来说，数据集的大小越大，被用作研究语料库的可能性就越高。例如，就数据量而言，RockYou是表中最大的英文数据集，也是我们评论作品中使用最频繁的语料库。</p>\n<h2 id=\"密码猜测攻击\"><a href=\"#密码猜测攻击\" class=\"headerlink\" title=\"密码猜测攻击\"></a>密码猜测攻击</h2><p>根据是否在线：</p>\n<ol>\n<li>离线密码猜测</li>\n<li>在线密码猜测<br>根据是否利用用户的个人信息：</li>\n<li>拖网猜测</li>\n<li>定向猜测，利用用户个人信息</li>\n</ol>\n<p>是否使用人工智能：</p>\n<ol>\n<li>传统攻击</li>\n<li>神经攻击</li>\n</ol>\n<p>几乎所有现有的工作都是离线猜测，而在线猜测太难在100个猜测内猜出一个密码。</p>\n<h3 id=\"拖网猜测\"><a href=\"#拖网猜测\" class=\"headerlink\" title=\"拖网猜测\"></a>拖网猜测</h3><h4 id=\"传统拖网猜测\"><a href=\"#传统拖网猜测\" class=\"headerlink\" title=\"传统拖网猜测\"></a>传统拖网猜测</h4><ol>\n<li>启发式算法<blockquote>\n<p>这些算法没有严格的理论体系，严重依赖于零散的奇思妙想，例如，基于开源软件使用精心设计的猜测序列[21]构建独特的猜测词典[18-20]。正如[3]指出的那样，这些启发式方法很难重现，也很难相互公平地比较。因此，在这里，我们只介绍一些常用的启发式密码猜测工具。</p>\n</blockquote>\n<ol>\n<li>Jtr是一个密码猜测工具，专注于破解UNIX&#x2F;Linux系统的弱密码。在JTR中有四种模式–简单破解模式、单词表模式、增量模式和外部模式。</li>\n<li>Hashcat是世界上速度最快、最先进的密码恢复实用程序，支持针对300多种高度优化的哈希算法的五种独特攻击模式。Hashcat目前支持Linux、Windows和MacOS上的CPU、GPU和其他硬件加速器，并具有帮助启用分布式密码破解的设施。<blockquote>\n<p>彩虹攻击：<br>一种基于预先计算和空间-时间折中的攻击方法。通过事先计算大量的密码和散列值之间的对应关系（彩虹表），以便在攻击时快速查找并破解散列值。彩虹表是一个预先计算的表格，其中包含了大量的密码和对应的散列值。通过在彩虹表中进行查找，攻击者可以找到与目标散列值匹配的原始密码。</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li>概率上下文无关语法<br> 该算法的核心假设是密码的字母段L、数字段D和特殊字符段S相互独立。该算法包括训练和猜测两个阶段。<ol>\n<li>在训练阶段，最关键的是根据泄露的密码数据集计算密码模式(结构)和字符成分(语义)的频率。</li>\n<li>在猜测阶段，根据训练阶段得到的模式频率表和语义频率表生成具有频率猜测的集合，以模拟真实密码的概率分布。<br> 粒度太细，无法获得字符之间的语义关系，改进：</li>\n<li>[24]基于词的内聚力和自由度提取密码中的语义片段，并对基于语义片段的PCFG算法进行改进</li>\n<li>[25]中，作者将密码视为由几个块组成，其中块是频繁出现在一起以模拟密码的相关字符的序列。</li>\n<li>25扩展了字节对编码(BPE)[26]算法，它使用块词汇表平均长度的可配置参数来替换合并操作的数量。</li>\n<li>为了解决长密码猜测的困难，请参考。[27]提出了一种改进的基于PCFG的LONG</li>\n</ol>\n</li>\n<li>马尔可夫序列决策<br> 该算法的核心假设是用户从前到后依次构造口令。它不像PCFG那样分割密码，而是训练整个密码，并通过从左到右链接字符来计算密码的概率。<ol>\n<li>传统的马尔可夫模型因其结构简单、推理速度快而被广泛应用于口令猜测工作中。但是，它也有一定的缺陷，如过度拟合、重复率高、基于随机抽样生成的密码覆盖率低等。</li>\n<li>过拟合：[17]将拉普拉斯平滑和结束符号正则化技术应用于马尔可夫模型。平滑策略消除了数据集中的过拟合问题，正则化技术使攻击算法产生的猜测概率总是和为1。</li>\n<li>重复率：[29]设计了一种基于随机抽样的动态分配机制。该机制允许动态调整密码的概率分布，并在猜测过程中严格收敛到均匀分布。基于上述动态分布机制，提出了一种动态马尔可夫模型。</li>\n<li>对口令中的语义段进行建模：Ref.[30]提出了一个名为Word马尔可夫的模型，通过语义分段从密码中提取单词的凝聚力和自由度。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"神经拖网猜测算法\"><a href=\"#神经拖网猜测算法\" class=\"headerlink\" title=\"神经拖网猜测算法\"></a>神经拖网猜测算法</h4><p>密码猜测任务视为文本生成问题，<br>2006年，参考文献[32]引入浅层神经网络进行密码猜测。<br>2016年，参考文献[33]提出了基于递归神经网络的口令分布估计算法FLA。该模型遵循马尔可夫模型的序贯决策过程，但放宽了n-马尔可夫假设。FLA可以通过树遍历算法枚举密码空间，从而产生新的猜测结果。从那时起，各种基于的产生式神经网络被反复观察到用于拖网密码猜测。</p>\n<ol>\n<li>回归神经网络(RNN)：回归神经网络是一个递归神经网络，它以序列数据为输入，在序列进化方向上递归，所有节点以链的形式连接。 RNN 有许多变体：如： LSTM，GRU，BiLSTM 等。<ol>\n<li>步骤：基于RNN的密码猜测方法通常有以下两个步骤：<ol>\n<li>·将训练集中的密码序列输入到RNN模型中，以进行顺序文本生成的训练。</li>\n<li>训练好的 RNN 猜测模型旨在根据已有的密码字符生成下一个密码字符，直到输出终止字符位置。</li>\n</ol>\n</li>\n<li>在整个密码生成过程中，RNN计算任何字符作为下一个密码令牌的概率。对于给定的阈值，概率高于阈值的密码将被放入密码猜测集中作为有效密码。</li>\n<li>一些变体：<ol>\n<li>[38]对密码单词进行切分，在词段的基础上使用BiLSTM生成密码。</li>\n<li>[39]中，作者提出了一种层次语义模型HSM，该模型将LSTM和语义分析相结合，用于挖掘用于密码猜测的词之间潜在的概率关系。</li>\n<li>[40]提出了一种基于汉字音节的密码猜测方法。该方法将汉语音节作为整体元素对密码进行解析和处理。然后，在LSTM神经网络中对处理后的密码进行训练以生成密码。</li>\n<li>[41]中，作者使用深度学习，特别是具有注意力机制的RNN来组合和内插同一组用户的信息，以定义比他们的密码分布更稳健和准确的优先级。推理时使用辅助数据来适应目标密码的分布。通过这种方式，开发了一种利用辅助信息并实例化上下文感知口令计量和猜测攻击的全自动方法，而不需要来自目标口令分布的任何明文样本。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>生成式对抗网络（GAN）：<ol>\n<li>基于GAN的密码猜测模型由密码生成器和鉴别器组成。这两个网络相互对峙，不断地调整参数。最终目的是使鉴别器网络无法判断生成网络的输出是否真实，从而达到口令生成的效果。</li>\n<li>问题：离散密码数据的不可微性可能导致梯度反向传播失败，基于GAN的密码猜测模型训练难以收敛，由GAN模型生成的密码重复率较高。</li>\n<li>离散数据不可微问题解决：<ol>\n<li>Works[44，45]使用Gumbel-Softmax[46]松弛技术来训练基于GAN的密码猜测模型。此外，在工作[44]中提供了另一种解决方案，其使用通过附加的自动编码器获得的真实口令的平滑表示。</li>\n<li>[47]提出了一种基于SeqGAN的密码猜测方法RLPassGAN，该方法使用策略梯度来确保模型参数的持续优化。</li>\n</ol>\n</li>\n<li>收敛困难的问题解决：[49]设计了一种基于双向生成对抗网络的猜测算法，提高了算法的收敛速度。与传统的GaN相比，它可以在更短的时间内产生相同数量的样本</li>\n<li>重复率高问题解决：[47]认为根本问题在于生成器中间层的输出是一个不完整的密码序列，在到达输出层之前不能由鉴别器直接评估，从而导致许多冗余的合成密码。为了解决这个问题，作者提出了一种改进的方法，该方法使用蒙特卡罗搜索[50]来评估中间层输出处的不完整密码序列。不同的是，裁判。[49]使用鉴别器和控制器构建额外的控制器网络，以分别学习生成的密码分布与真实密码分布和均匀分布之间的度量。然后利用这两个度量对生成器进行训练，从而降低了口令生成的重复率。</li>\n<li>RLPass[51]还创新性地将表征学习用于密码猜测。具体地，将密码投影到隐藏空间，并且使用隐藏空间中的密码表示之间的距离来定义密码的相似性。基于口令的强局部性和弱局部性现象，提出了一种动态口令猜测和条件口令算法。为了解决基于GAN的模型生成的长密码质量较低的问题，请参阅[52]设计了一种基于DenseNet的[53]GAN密码猜测结构DenseGAN，并提出了两种新的密码猜测DenseGAN模型，这两种模型都能生成高质量的密码猜测。</li>\n</ol>\n</li>\n<li>自动编码器（AE）：自适应学习是一种无监督的学习模型。它基于反向传播算法和优化方法，使用输入数据本身作为监督来指导神经网络学习映射关系，以获得重建的输出。AE 包括编码器和解码器两部分。根据学习范式，AE 可分为欠完备自动编码器、正则化自动编码器和变分自动编码器，其中前两种是判别性模型，后者是生成性模型。在拖网密码猜测的研究中，通常使用<strong>变分自动编码器</strong>[54]来生成密码猜测。如图5所示，将密码样本(Yu123)输入到VAE的编码器以获得表示，然后使用解码器基于该表示重建样本。基于输入x和生成的x之间的重构损失来训练密码生成器。<br> [47，51，55，56]使用VAE模型来生成密码猜测，但每种方法都有稍微不同的侧重点。在[55]中，作者使用经典的VAE框架来猜测密码，而不需要任何更改。不同的是，裁判。[47]将VAE技术与GaN技术相结合，用VAE代替GaN生成器，旨在解决离散口令数据的反向传播问题。针对模型的轻量级问题，在[56]中，用门控卷积神经网络(GCNN)[57]代替了复杂的RNN生成单元，大大降低了模型的复杂性。</li>\n<li>Transformer.<br> ![[Pasted image 20240305201324.png]]<br> Transformer 模型采用编解码器体系结构，并使用注意[59]替换 Seq2Seq 模型中的递归结构，以实现序列建模的并行化。这种并行化结构给自然语言处理 (NLP) 领域带来了巨大的冲击。随着研究的深入，相关技术逐渐从自然语言处理向计算机视觉 (CV)、语音、生物、化学等领域发展。同样，在拖网密码猜测的研究中也出现了一些基于Transformer的方法[60，61]。<ol>\n<li>[60]旨在研究常见密码规则中密码破解的概率，为密码设置提供参考。作者收集了大量用户的个人信息和密码，并分析了个人信息和密码的相关性。在此基础上，实现了一种基于改进 Transformer 的口令猜测模型。该工作将消息权重引入到数据预处理中，并在模型中使用改进的波束搜索算法来快速搜索排名靠前的密码猜测。</li>\n<li>在[61]中，作者提出了一个基于双向 Transformer 的猜测框架 PassBERT，首次将预训练&#x2F;微调的范式应用于密码破解。具体地说，首先，作者设计了包含一般密码分布知识的通用密码预训练模型。然后，提出了三种特定于攻击的微调方法来定制预先训练的口令模型以适应以下真实攻击场景：条件口令猜测、目标口令猜测和基于自适应规则的口令猜测。最后，他们进一步提出了一种混合密码强度计来降低这三种攻击的风险。</li>\n</ol>\n</li>\n<li>Reinforcement Learning (RL) 强化学习<ol>\n<li>RL是机器学习的范例和方法之一，用于描述和解决智能代理在与环境交互过程中最大化回报或实现特定目标的学习策略问题。密码生成器是代理，每个生成的密码序列代表一个完整的轨迹，生成过程中的每个字符都被视为一个操作。例如，由时间戳t生成的字符是action at。根据由所生成的不完整序列确定的关于当前状态ST的随机策略来生成每个动作At。生成器根据一组随机策略从任意字符生成密码，直到满足预定长度。</li>\n<li>在[47]中，作者提出了一种基于强化学习和遗传算法的拖网密码猜测模型RLPassGAN。具体地说，该工作遵循SeqGAN[48]，将密码猜测视为一个连续决策，并使用策略梯度 来确保参数可以连续优化。此外，通过蒙特卡罗搜索[50]来评估输出的不完整密码序列。蒙特卡罗是一种使用大量随机样本来了解特定系统的计算方法。它非常强大和灵活，但易于理解和实现。它是在1940年的曼哈顿计划中提出的。这个名字来自赌城蒙特卡洛，象征着可能性。除了上述应用，蒙特卡罗还被应用于估计给定口令的猜测次数[62，63]</li>\n</ol>\n</li>\n<li>Flow.在上面介绍了生成模型GaN和VAE；它们都没有显式地学习真实数据p(X)的概率密度函数。对于具有潜在变量的生成模型，几乎不可能计算它们p(X)&#x3D;p(x|z)p(Z)，因为很难遍历隐藏变量z的所有可能值。<ol>\n<li>这一挑战被生成性模型解决了–归一化流动[64]，这是一个强大的密度估计统计工具。流动模型的一个非常独特的特征是，它的转变通常是可逆的。如图8所示，流模型不仅找到了从分布Z转移到分布X的网络路径，而且该路径还允许X改变为Z。简而言之，流模型找到了分布Z和X之间的双向路径。当然，这种可逆性是以Z和X的数据维度必须相同为代价的。</li>\n<li>[68]中，朱利奥·帕尼奥塔等人。提出了一种基于产生流模型的口令猜测方法PassFlow。基于流的口令猜测模型使用精确的对数似然计算和优化，使潜在变量的推断更加准确。此外，还给出了潜在空间的一种有意义的表示，这使得探索潜在空间的特定子空间和内插等操作成为可能。作者论证了产生流模型在密码猜测中的适用性。实验结果表明，PassFlow能够在比以前方法小几个数量级的训练集的情况下，在密码猜测方面优于现有的基于GAN的方法。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"传统定向密码猜测\"><a href=\"#传统定向密码猜测\" class=\"headerlink\" title=\"传统定向密码猜测\"></a>传统定向密码猜测</h4><p>攻击者使用与目标人员相关的个人信息来增强猜测<br>2015年，裁判[69]首次提出了一种基于拖网马尔可夫攻击模型的定向攻击猜测方法[70]。基本思想是，关于使用某些个人信息的人口的百分比，攻击目标也将具有相同的使用该个人信息的可能性百分比。为了实现这一想法，文献[71]首先将PII划分为几种类型，如用户名-A、电子邮件前缀-E和名称-N，并根据所需的粒度进一步细分每种广泛的类型。然后，将训练集的每个密码中的所有PII替换为对应的PII类型。训练阶段的其余步骤与行走马尔可夫模型的步骤相同[71]。猜测集生成阶段分为两个步骤。在第一步中，运行行走马尔可夫模型[71]以生成中间猜测集合，该中间猜测集合包含直接可用的猜测，例如123456，以及具有PII类型的基本字符的中间猜测(例如，N1、N2123)。第二步用相应的PII信息替换中间猜测中的基本PII类型字符。<br>个人-PCFG。2016年，参考[5]提出了一种基于PCFG的定向攻击猜测方法–Personal-PCFG。它遵循拖网PCFG攻击模型[16]。其基本思想与PCFG攻击模型相同：根据字符类型和长度对密码进行切片。为了实现这一思想，文献[5]   (即用户名-A、电子邮件前缀-E、姓名-N、生日-B、电话号码-P和ID-G)，并将这六种PI字符类型等同于拖网PCFG模型中的L、D和S，从而在个人PCFG中有九种类型的字符。然后，在训练过程中，与拖网PCFG攻击模型[16]中一样，训练集中的每个密码根据相应的字符类型及其长度进行分段。<br>TarGuess Wang等人。[4]提出了一个框架，它用四个数学概率模型系统地刻画了典型的定向猜测场景。<br>第一个场景TarGuess-I旨在利用用户的PII创建在线目标密码猜测。为了在密码中表示PII令牌，除了PCFG[16]模型中的L、D和S标签外，作者还定义了基于个人信息类型的28个PII标签(例如，N1−N7和B1−B10)。对于每个PII标签，其下标编号表示该类型的PII使用的细分，而不是指示相应长度的下标编号，例如L、D和S标签。例如，N表示名称信息，而N1表示全名，而n2表示全名的缩写<br>第二个是Targuess-II，目的是根据用户在其他网站(例如Dodonew)中泄露的密码来猜测目标网站(例如CSDN)中的用户密码。具体地，作者提出了6种结构级和2种字符级助记转换来描述密码重用，并基于上述重用规则使用马尔可夫模型来刻画上下文无关的转换文法。<br>第三个是TarGuessIII，目的是使用姐妹密码和一些PII信息来猜测用户的密码。TarGuess-III将PII信息引入到TarGuess-II模型中，允许在结构级密码重用中嵌入PII信息。<br>与TarGuess-III相比，TarGuess-IV场景中的攻击者知道难以量化的额外PII(例如，性别、教育)。为了解决某些PII难以直接体现在口令中的问题，在这种难以量化的PII的基础上，巧妙地引入贝叶斯理论来计算口令的重用概率。</p>\n<p>RFGuess-PII.在第4.1.1节介绍的RFGuess的基础上，Wang et al.[31]提出了一种新的目标口令猜测模型RFGuess-PII。密码训练和生成过程类似于拖网猜测场景。不同的是，通过新的PII匹配，密码中的PII字符串被替换为相应的数字标签。这种新的PII匹配旨在最小化信息熵，并试图准确地提取整个用户组的PII使用行为。PII匹配算法的第一步是细分PII的各种可能的变换，并使用数字标签来表示它们。第二步是为训练集中的每个密码列出具有PII标签的所有可能的表示。然后，按频率从高到低对表征进行排序。</p>\n<p>RFGuess-重复使用。除了基于PII的针对性密码破解研究外，在[31]中，作者还专注于对用户的密码重复使用行为进行建模。他们还考虑了结构级和段级转换，如TarGuess-II[4]。具体地，它们通过计算训练集中每个密码对的编辑矩阵来计算结构级转换，并训练基于随机森林的段级转换(即，相同类型的字符串内的转换，例如字母段中的密码→密码)模型。</p>\n<p>TG-SPSR图谱。在[72]中，作者将马尔可夫模型和PCFG模型转化为目标攻击，提出了一种基于结构划分和字符串重组的系统目标攻击模型，称为TG-SPSR。在结构划分阶段，除了将密码划分为类似于PCFG[16]的基本结构外，还在基本语法模式中定义了基于轨迹的键盘，并引入了索引位来准确描述特殊字符的位置。此外，基于定义的9条修改规则，构造了一个BiLSTM分类器来重用和修改密码的行为。</p>\n<h4 id=\"神经定向密码猜测\"><a href=\"#神经定向密码猜测\" class=\"headerlink\" title=\"神经定向密码猜测\"></a>神经定向密码猜测</h4><p>随着自然语言处理技术的发展，一些复杂的神经网络被应用到目标密码猜测领域。在[73]中，作者提出了一个由指针生成网络组成的有针对性的口令猜测模型PG-PASS。该工作创新性地将目标口令猜测作为一项摘要任务，并将智能摘要领域中常用的指针网络技术应用于该任务。需要注意的是，除了用户的人口统计相关信息(姓名、生日等)外，攻击者还可以利用用户在其他网站上泄露的密码进行有针对性的攻击。可以预期，这种利用用户密码重复使用这一易受攻击行为的定向攻击可能比基于人口统计相关信息的攻击更具危害性。<br>基于用户总是渴望通过重用或微调旧密码来生成新密码的事实，参考文献。[74]提出了一种基于密码转换器的重用模型，并对证书篡改攻击进行了模拟。在IEEE S&amp;P‘19会议上，Pal等人。[75]引入深度学习技术来表征用户的密码重复使用行为。更具体地说，他们训练了序列到序列(Seq2seq)模型，以预测将现有密码转换为其姊妹密码所需的修改，并在大规模数据集(即4iQ数据集[76])上进行了验证。此外，Wang et al.[77]提出了一种有针对性的密码猜测算法PASS2EDIT，用于模拟日益严重的凭据篡改攻击，在该攻击中，攻击者利用受害者泄露的密码来提高她在其他站点猜测受害者密码的成功率。特别是，他们提出了一种多步决策训练机制，并建立了一个分类神经网络来学习一步编辑操作对现有密码的反应。由于每项工作使用的数据集不同，因此很难进行横断面比较。以12306数据集为例，当猜测集为100时，现有的定向密码猜测方法的猜测准确率约为41.07%[73]。在重复使用猜测场景中，当受害者在站点A的密码(即PWA)已知时，在100次猜测中，Sota方法[77]在猜测其在站点B的密码(PWB&#x3D;PWA)时的破解成功率分别为24.2%(对于普通用户)和11.7%(对于安全敏感用户)。</p>\n<h3 id=\"数据统计\"><a href=\"#数据统计\" class=\"headerlink\" title=\"数据统计\"></a>数据统计</h3><p>从时间上看，2016年至2018年零星出版数量较少，2021年增至9种。这一数量的增加表明关于密码猜测的研究总体上呈上升趋势。在分布式定位技术方面，基于深度神经网络的猜测方法主要集中在图形的左上角，而基于传统方法的猜测方法主要集中在右下角。这一现象表明，神经密码猜测的研究是近年来的热点。这也反映了密码猜测技术的重点正在从传统方法向深度神经网络方法转移。</p>\n<p>从数字的角度来看，在许多研究中，神经密码猜测方法所使用的技术更加多样化。其中，GAN、RNN和CNN是使用最多的技术。在传统的密码猜测方法中，PCFG和马尔可夫是使用最广泛的两种密码猜测技术。</p>\n<p>从品类上看，现有研究主要集中在拖网密码猜测技术多达37种，针对定向密码猜测研究的著作仅有6部。一方面，正如前面提到的，目前对密码猜测攻击缺乏系统的研究，而且大多集中在个别攻击场景，如离线拖网猜测。此外，越来越现实的有针对性的在线猜测很少得到解决。另一方面，尽管少数研究侧重于有针对性的密码猜测，但大多停留在用户行为的简单统计和对启发式突发事件的依赖程度上，缺乏理论和原则性的研究。一些根本性的问题需要解决。  </p>\n<h3 id=\"交叉引用分析\"><a href=\"#交叉引用分析\" class=\"headerlink\" title=\"交叉引用分析\"></a>交叉引用分析</h3><p>FLA[33]和PassGan[43]是被其他人引用最多的作品。这间接说明了这两部作品的影响。由于FLA和PassGAN是第一个分别使用RNN[34]和GAN[42]来模拟口令可猜测性的方法，它可以确定为什么RNN和GAN使用频率很高。<br>我们对第一作者所在机构的国籍进行了统计分析。如图11所示，我们用出版物的数量给世界地图上的国家&#x2F;地区上色。一眼就可以看出，中国地区的色彩最深。这意味着中国是密码猜测领域发表论文最多的国家。美国队紧随中国之后，位居第二。每个国家的影响因子计算如下：IF&#x3D;引文出版物。经过计算，中国的IF为0.28，美国的IF为11。这个值表明，虽然中国的出版物数量很多，但其在这一领域的影响力远远小于出版数量较少的美国。</p>\n<h3 id=\"挑战和未来趋势\"><a href=\"#挑战和未来趋势\" class=\"headerlink\" title=\"挑战和未来趋势\"></a>挑战和未来趋势</h3><h4 id=\"多样应用前景\"><a href=\"#多样应用前景\" class=\"headerlink\" title=\"多样应用前景\"></a>多样应用前景</h4><p>主要集中在拖网竞猜场景上，但在实际应用场景中，往往存在定向竞猜、少发竞猜、资源占用少的要求。对于这种场景，现有的方法很难解决镜头少的问题。虽然可以使用数据增强等技术来缓解样本不足的问题，但要从根本上突破两难境地仍然是棘手的。同样，各种深度学习算法也严重依赖于样本的大小和质量，密码等敏感信息的收集是困难的。因此，根据有限的密码样本猜测目标密码是一个复杂的问题。</p>\n<h4 id=\"密码猜测的效率\"><a href=\"#密码猜测的效率\" class=\"headerlink\" title=\"密码猜测的效率\"></a>密码猜测的效率</h4><p>然而，在实际应用中，时间和计算资源往往是有限的。传统和神经密码猜测方法都需要巨大的计算能力来支持。随着神经网络模型变得越来越复杂，存储需求也大大增加。因此，在低资源的情况下快速执行密码猜测也是具有挑战性的。在综述的论文中，只有一篇文章讨论了一个轻量级密码猜测模型[56]。因此，这方面的大量工作仍亟待推进。</p>\n<h4 id=\"传统学习方法与深度学习方法相结合\"><a href=\"#传统学习方法与深度学习方法相结合\" class=\"headerlink\" title=\"传统学习方法与深度学习方法相结合\"></a>传统学习方法与深度学习方法相结合</h4><p>然而，纵观现有的研究，新兴的生成模型，如流[64]和扩散模型[78-80]，很少应用于密码猜测。此外，目前的神经密码猜测方法都有一个前提，即密码字符串是一个字符序列，使用序列编码对密码进行处理。事实上，我们可以做更多的尝试，比如根据密码的语义依赖将密码组织成图，并使用最新的图神经网络(GNN)相关技术[81-84]进行采样和生成。此外，预训练的语言模型[85-88]近年来在自然语言处理领域如火如荼地进行着。然而，只有一部作品[61]讨论了关于密码猜测的预训练&#x2F;精调范式。因此，将预先训练的语言模型强大的通用语言建模功能与现有的密码猜测工作结合起来也可能是一个好主意</p>\n"},{"_content":"# 摘要\nsformer 的密码猜测框架。\n2. 使用预训练/微调范例。\n3. 设计了三个特定场景下的密码猜测任务的微调方式：\n\t1. 条件性口令猜测，在给定部分口令的情况下回复完整口令。\n\t2. 针对、定向性口令猜测，利用特定用户的个人信息猜测其口令。\n\t3. 基于规则的自适应密码猜测，其为单词(即，基本密码)选择自适应调整规则以生成经规则转换的候选密码。\n4. 最后我们提出了一种**混合口令强度计量器**来降低这三种攻击的风险。\n\n# 引言\n\n1. 数据驱动模型(例如，马尔科夫[28，32])和基于规则的工具(例如，Hashcat[17])来有效地离线破解密码\n2. 现实世界猜测攻击：使用先验信息，\n\t1. 定向密码猜测 TPG。\n\t2. 条件密码猜测 CPG\n\t3. 基于自适应规则密码猜测 ARPG\n3. 双向转换器在自然语言处理领域受到了极大的关注[12，27，51]。由于能够捕获双向上下文信息和高度可转移性[51]，转换器在多语言任务(例如，文本分类[59]、语法校正[34])中是有效的。\n\t1. 有的密码猜测攻击，无论是一般的还是基于现实世界的，都可以概念化为近似密码(即文本)的概率分布的努力，\n\t2. 这表明它自然适合基于双向转换器的猜测框架。\n4.  现有有一些琐碎的工作（看了一下只是 神经网网络，不是特指 Transformer）效果不佳。\n5. 成功使用 Transformer 需要一些特定的设计，比如这里使用了序列标签，参考之前的序列到序列机制。\n6. 本文设计了一个基于字符级别的双向变化猜测框架。设计了特定方式的微调。取得了一定的效果。\n7. 本文测试了预训练的效果。预先训练的密码模型比预先训练的自然语言模型能够产生更好的猜测性能，这表明了预先训练在特定密码语料库上的有效性。\n8. 本文引入了混合密码强度计（HPSM）来降低三种攻击的风险。HPSM可以与密码泄漏检查[23，47]相结合来检测输入是否公开泄漏，一旦泄漏，输入就会遭受ARPG攻击。\n# 相关工作\n## 一般密码猜测\n1. 基于数据驱动模型，基于密码数据对模型进行训练\n2. 基于规则猜测，由专家知识定制初始配置，转换初始密码到候选密码。\n## 基于额外信息攻击\n CPG：Pasquini等人[38，39]提出了一种基于Wasserstein自动编码器的最先进的CPG方法[48]。他们将最终的模型称为CWAE(上下文瓦瑟斯坦自动编码器)，它由将部分密码嵌入到潜在表示中的编码器和将部分密码的潜在表示转换为密码的解码器组成。\n TPG：其中，Pal等人提出的Pass2Path。[35]2019年，是最新、最有效的定向竞猜模式。他们提出了凭据调整，以破解用户历史密码的变体(调整)\n ARPG：021年，Pasquini et al.[37]提出了第一个基于规则的自适应猜测框架ADAMS(Adaptive Dynamic Mgling Rules Attack)，该框架构建了一个卷积规则(CNN神经网络)建模，为每个单词选择自适应规则。\n\n\n## 基准攻击模型\n我们使用最先进的CWAE、Pass2Path和ADAMS模型分别作为CPG、TPG和ARPG攻击的基线，因为这些模型与其他模型相比具有最高的猜测性能。例如，CWAE已被证明比基于PCFG、马尔可夫和神经网络的模型更好。因此，我们不会检查与其他型号的比较。\n\n## 双向 Transformer\n基于自我注意机制(即将给定的标记与所有文本环境连接起来)提出的，由于能够捕获深层文本特征而在自然语言处理领域获得了广泛的应用。\nBERT(来自Transformers的双向编码器表示)[12，27]是一种流行的基于变压器的架构，已经在11个单独的NLP任务上取得了最先进的结果。\nBERT针对 **MLM(掩蔽语言建模)** 和 **NSP(下一句预测)** 两个目标进行预训练，以建立基于大量未标记Web语料库的预训练语言模型。\n1. 对于 MLM 目标，BERT 训练模型，使其能够预测屏蔽位置的正确标记。由于自然语言的特性，BERT很大程度上是为了预测屏蔽词而设计的。\n2. NSP的目标是取一个句子对A和B，并预测B是否是A之后的实际下一个句子。Bert[12]提出了两种次级训练方法：微调和基于特征。\n\t1. 在微调方法中，所有参数都在下行任务期间更新。\n\t2. 而在基于特征的方法中，通过冻结一些普通的预训练层来从预训练的参数中提取固定的特征。 \n\t通常，微调方法会随着训练时间的增加而产生更好的结果[12]。在本文中，我们选择了所有参数都是可学习的微调方法。\n\n# 预任务\n\n## 工作流\n攻击模型的工作流程是根据监督信号训练监督模型。我们将它们的监管信号总结在表1中。\n1. 具体来说，CPG的监管信号是部分密码及其完整密码。 CPG 旨在训练模型，使其在给定部分密码的情况下预测正确的密码。 CPG 的输出直接作为密码候选。\n2. TPG的监督信号是通过动态规划算法计算出的最短编辑路径的密码（在[35]中实现）。编辑路径是一系列原子编辑操作（在我们的攻击设计中预定义），\n3. ARPG的监督信号是具有命中规则（即规则集的子集）的单词，例如根据两个假设数据集之间的命中信息删除最后三个字符。 ARPG模型输出自适应规则，然后将其应用于单词以获得候选密码。自适应规则通常与单词更兼容，从而可以尽早产生命中。 ARPG 中使用的修改规则在 Hashcat 中定义。一般情况下，大多数重整规则可以是常见原子规则的组合（例如，“删除最后三个字符”是“删除最后一个字符”的三个原子规则的组合），并且可以自然地模拟应用多个规则的场景按顺序到基本词。\n\n## 威胁模型\n假设攻击者可以选择预先训练的自然语言和密码特定参数（作为先验知识）或随机变量来初始化他们的攻击模型。\n\n## 密码泄漏数据集\n### 数据集选择\n在实验中选择了先前作品[16、21、37、38、43、54、60]中使用的几个数据集。用于定向猜测的数据集是电子邮件，而用于非定向猜测攻击的数据集是明文密码。\n\n密码预训练、CPG和ARPG使用由明文密码组成的数据集，\nRockyou-2009、000Webhost、Neopets、Cit0day、Rockyou-2021：\n\n对于TPG攻击，我们选择以下两个包含电子邮件的数据集，并总结表2中的基本信息：\nBreachCompilation (4iQ)\nCollection#1\n### 数据处理\n账户加入：为了找到属于同一用户的密码列表，我们根据相同的电子邮件地址合并帐户（用户）[35]\n\n数据集清理：\n我们采用常用的清理策略[16,35,37,60]来过滤掉原始数据集中的哈希密码、非ASCII密码和超过32个字符的异常长密码。\n\n\n## 密码二向性\n顺序性：字符通常与其相邻字符更相关，这也可以是单向性的体现。聚合：相关字符的内部序列（例如“password123”中的“p@ssw0rd”和“123”；“mike199730”中的“199730”）有更多的连接线。\n捕获双向表示可以提供更好的候选密码，从而提高密码猜测效率!!!! ！\n\n\n\n# PassBERT\n\n## 预训练\n预训练模型主要捕获输入密码的上下文嵌入，这是密码中每个字符的具有上下文信息的高维表示。上下文嵌入是预训练层（即最后一个变压器块）的输出。\n### 嵌入\n1. 密码标记为字符序列，\n2. 带有表示开头 ([CLS]) 和结尾 ([SEP]) 的附加符号，因为密码通常比句子短，\n3. 对比：与 BERT 不同，BERT 通常在 token 级别对文本进行 token 化，其 token 主要是单词，并将每个句子剪辑为 512 个 token。\n4. 我们考虑最大密码长度为32个字符，并考虑总共99个有效字符，包括95个ASCII字符（表示为Σ）和4个附加符号开始、结束、占位符和未知字符。\n5. 嵌入层：\n\t1. 其字符嵌入和位置嵌入 求和。将标记化输入转换为其输入嵌入。\n\t2. 删除了 BERT 中的句子嵌入\n\t3. ![[Pasted image 20240314160458.png]]\n\n### 数据处理\n1. 为了使用 MLM 目标预训练密码模型（即预测屏蔽位置后面的屏蔽字符），我们将训练集中的每个密码 (Dtraining) 预处理为部分密码的形式（表示为pivot）：关联完整的密码（表示为 pwd）。我们遵循 BERT [12] 中相同的掩码比例：我们随机选择密码中 15% 的字符，然后分别以 80%、10% 和 10% 的概率用掩码符号、随机字符和未更改字符替换所选字符 。随机且未改变的字符可以防止模型记住被屏蔽的字符。一个密码可以预处理到很多个pivot，本文设置了20个pivot。我们设置预训练任务，找到参数 θ 来最大化以下似然：\n![[Pasted image 20240314161946.png]]\n\n### 数据集选择\n我们使用 Rockyou-2021 作为我们的预训练数据集，该数据集非常大。为了在训练时间和模型性能之间取得平衡，我们从 Rockyou-2021 中随机抽取了 6000 万个密码。\n\n\n### 计算性能\n我们的工作是在一台配备 Nvidia GeForce RTX 2080 Ti 的 Ubuntu 20.04 机器上执行的，大约需要 2 天才能完成预训练。存储预训练模型需要 8.9 MB。\n\n## 密码微调\n根据特定的攻击场景定制预训练模型。微调方法通常包括架构修改和模型重新训练。\n\n1. 架构修改期间，\n\t1. 通常修改预训练模型架构的任务特定层（表9中的全连接层和输出层），并保留预训练层，包括顶部输入层、嵌入层和几个 Transformer 块。\n\t2. 然后，我们使用特定的监督信号重新训练下游模型，以学习特定于任务的功能（例如密码规则兼容性）。（注意，重新训练过程中所有的参数都会改变：包括上面的所有层）。\n\n# 用于现实世界攻击模型的 PassBERT\n介绍三种 微调。\n\n三种预训练模型：\n1. 预训练的密码模型：PassBERT\n2. 预训练的 BERT 自然语言模型：Vanilla BERT \n\tVanilla BERT 可以在字级、子字级和字符级对文本（即密码）进行标记，而我们仅根据词汇表将密码标记为字符序列。由于我们的 Vanilla BERT 的词汇表只有小写字母，因此我们扩展词汇表以涵盖 Σ 中的所有有效字符（通过替换未使用的标记） \n3. 随机变量模型：PassBERT\n\n## 条件密码猜测\n任务：pivot（例如，“p ＊ ＊ ＊w0rd ＊ ＊ ＊ ”） ————>恢复密码。\n建模：掩码语言模型任务，预测缺失字符的 pivot 的条件概率\n数据构建：使用与 CWAE [38, 39] 相同的策略创建：\n1. 我们以一定比例（即 50%）随机用表示缺失字符的屏蔽符号替换每个字符。\n2. 然后，我们只保留那些包含至少四个可观察字符和至少五个屏蔽符号的生成主元。\n### 微调\n攻击设计：根据 Pivot 的创建机制调整 屏蔽机制。\n1. 增加掩码比例：只用掩码符号，\n2. （默认的屏蔽机制结果不佳）\n模型再训练：从中提取具有正确密码的有效枢轴以进行模型重新训练。\n评估：\nCPG 与 CWAE 具有相同的 评估 pivots 。\n1. 对一个 pivot 生成相同数量的候选密码。然后，比较匹配的个数。\n2. 按照匹配的个数分类这些 pivot 。区分不同频率的 pivot 的猜测性能\n评估集： Neopets 和 Cit0day 空间较大：\n1. WAE 仅为每个主元类别生成 30 个评估主元，可能会引起偏差。\n2. 我们从评估集中为每个类别总共提取了 120 个评估基准\n评估指标： 每个 pivot 的平均破解率。\n结果：很好\n预训练效果：用密码预训练的效果更好。\n改进原则：模型通过以递减的概率耗尽屏蔽位置中的字符来生成候选密码，而 CWAE 通过解码器将潜在表示（即高维空间中的点）转换为候选密码。很优\n计算性能：训练我们的 CPG 模型大约需要 2 天（8.9 MB），训练 CWAE 大约需要一天半的时间（4.4 MB）\n\n## 定向的密码猜测\n目标：用历史密码生成其变体\n目标：对给定的密码训练模型输出编辑路径。\n\n### 微调：\n攻击设计： Pass2path 基于 RNN 模型的序列机制将密码转换为编辑路径。Transformer 不支持，修改：使用序列标记机制来预测密码中每个字符的一个编辑操作。其中一系列编辑操作构成编辑路径。在序列标注机制中，每个字符位置只能输出一次编辑操作。\n\n为了适应序列标记机制，我们预先定义了新的编辑操作如下：保留（keep）、删除（del）和替换（rep1，rep2）这里，替换涉及用一个（表示为rep1）或两个字符替换（表示为rep2）。\n\n缺陷：无法捕获一些转换，比如：插入三个字符\n模型结构：\n![[Pasted image 20240314203049.png]]\n 修改特定于任务的层以学习密码中每个字符的编辑操作（例如，(op, str)）的概率。\n模型再训练：\n遵循 Pass2path [35]，我们在 BreachCompilation 中从同一用户中随机抽取 80% 的密码对，并在最小编辑距离不超过 4 时选择合格的密码对，最终得到 85,269,455 个密码对。\n\n评估：\n评估设置： 和 Pass2pass 保证相同数据集训练对\n评估指标。我们选择特定用户泄露的密码之一作为输入，然后根据 TPG 模型推断其变体（限制为 1,000 次猜测）计算了 Ncracked Naccounts 给出不同猜测（即 10、100 和 1,000）的评估用途/帐户之间的破解率\n实验结果：三个模型都高于 Pass2path\n\n预训练效果：密码和自然语言模型在 TPG 中表现出边际收益。发现预训练的改进空间仍然很小，这表明预训练的作用较弱。这种现象是可以理解的，因为有针对性的攻击集中在个性化密码转换上，这与预训练模型中的全局密码分布关系不大。两个预训练模型生成的上下文嵌入在帮助理解密码转换方面几乎没有效果。 TPG 往往依赖于任务，主要根据特定攻击的数据集形成其模型参数。\n\n改进原则：更关注本地角色信息。准确地说，我们的编辑操作二元组 (op, str) 可以比 Pass2path 中使用的三元组操作 (op, str,pos) 减少一维搜索空间，其中 pos 指密码中的位置。 \n\n看法：随着编辑距离的增加，破解率下降。\n\n计算性能比较。训练 PassBERT (82 MB) 和 Pass2path (166 MB) 分别需要大约 13.6 和 42 小时。我们根据经验计算得出，两种模型都实现了相似的推理速度。 PassBERT 和 Pass2path 每秒可以推断 4.38 和 4.63 个密码对（pairs/s）。\n\n## 基于自适应规则的密码猜测\n目标：每个单词仅与选定的自适应修改规则关联以生成猜测。\n\t\t[37]尝试使用默认变压器，但与 ADaM 相比没有取得实质性改进。\n本质：找出单词适应的规则。\n效果：输入单词和规则输出破解的可能性\n方式：构建分类模型，\n### 微调\n捕获整个单词和密码级别的修饰规则之间的自适应关系，因为修饰规则最终适用于单词。\n监督信号：是在两个假设数据集上带有标记规则（即命中规则）的单词。\n模型架构：\n1. 修改了特定任务层，推断重整规则和具有焦点损失函数的基本单词之间的自适应概率。\n2. 输出层没有序列长度。\n模型再训练：\n1. 针对两个规则集训练了两个 APRG 模型\n2. 使用 2 亿个密码作为目标空间\n3. 使用 1000 万条数据作为初始空间\n4. 训练：Ri 是个向量，每个元素对应一个规则的匹配可能性\n\t注意：0和1的比例极其不平衡，即超过95%的标签都是0。因此，我们应用与ADAM相同参数策略的焦点损失[25,37]来关注硬标签。\n5. 设置一个 阈值 来表示规则使用的条件。\n\n### 评估\n评估设置：比较了静态和动态模型。\n专注于单词和规则之间的关系建模，即我们的目标是为单词选择更具适应性的规则，以在相同的猜测下获得更高的猜测效率。\n评估指标：动态策略模型的最终破解率作为评估指标。\n试验结果：动态模型和静态模型都高于 ADaMs\n1.  Dynamic PassBERT 在这些模型中实现了最高的破解率，并且在四个实验中比 ADaM 平均提高了 4.86%。\n2.  静态 ARPG 的显着提前停止是因为每个单词仅与自适应规则关联，其大小小于标准基于规则的攻击中的所有规则。\n预训练效果：\n1. 密码预训练使 Transformer 的性能优于 ADaM\n2. 用默认 Transformer 基本没改进。所以这些个模型的改进没有效果。\n改进原则：密码预训练对于 ARPG 的提升有着重要的作用。 \n见解：发现了容易收到攻击的破坏规则。\n计算性能比较：\n1. 我们两个小时： ADam 需要 十个小时\n2. 推理速度相似。\n# 密码强度估计\n\n\n# 讨论\n密码双向性：\n1. 双向 Transformer 在文本特征提取方面比自动编码器 (CWAE)、RNN (Pass2path) 或 CNN (ADaMs) 等领先方法效果更好，\n2. 工作[22]已经设置了单向变压器，并显示了双向训练机制在一般猜测任务中的优越性。\n3. 密码具有双向性，对字符进行不同的权重。\n4. 预训练对于提高猜测效率也能起到重要作用。深度学习模型通常由通用预训练层和特定于任务的层组成，其中预训练层的上下文嵌入层可以为任务相关层提供更多上下文信息。\n预训练的合适场景猜测：\n密码训练和自然语言训练：只能为有针对性的攻击提供效益","source":"_posts/论文笔记/PassBERT.md","raw":"# 摘要\nsformer 的密码猜测框架。\n2. 使用预训练/微调范例。\n3. 设计了三个特定场景下的密码猜测任务的微调方式：\n\t1. 条件性口令猜测，在给定部分口令的情况下回复完整口令。\n\t2. 针对、定向性口令猜测，利用特定用户的个人信息猜测其口令。\n\t3. 基于规则的自适应密码猜测，其为单词(即，基本密码)选择自适应调整规则以生成经规则转换的候选密码。\n4. 最后我们提出了一种**混合口令强度计量器**来降低这三种攻击的风险。\n\n# 引言\n\n1. 数据驱动模型(例如，马尔科夫[28，32])和基于规则的工具(例如，Hashcat[17])来有效地离线破解密码\n2. 现实世界猜测攻击：使用先验信息，\n\t1. 定向密码猜测 TPG。\n\t2. 条件密码猜测 CPG\n\t3. 基于自适应规则密码猜测 ARPG\n3. 双向转换器在自然语言处理领域受到了极大的关注[12，27，51]。由于能够捕获双向上下文信息和高度可转移性[51]，转换器在多语言任务(例如，文本分类[59]、语法校正[34])中是有效的。\n\t1. 有的密码猜测攻击，无论是一般的还是基于现实世界的，都可以概念化为近似密码(即文本)的概率分布的努力，\n\t2. 这表明它自然适合基于双向转换器的猜测框架。\n4.  现有有一些琐碎的工作（看了一下只是 神经网网络，不是特指 Transformer）效果不佳。\n5. 成功使用 Transformer 需要一些特定的设计，比如这里使用了序列标签，参考之前的序列到序列机制。\n6. 本文设计了一个基于字符级别的双向变化猜测框架。设计了特定方式的微调。取得了一定的效果。\n7. 本文测试了预训练的效果。预先训练的密码模型比预先训练的自然语言模型能够产生更好的猜测性能，这表明了预先训练在特定密码语料库上的有效性。\n8. 本文引入了混合密码强度计（HPSM）来降低三种攻击的风险。HPSM可以与密码泄漏检查[23，47]相结合来检测输入是否公开泄漏，一旦泄漏，输入就会遭受ARPG攻击。\n# 相关工作\n## 一般密码猜测\n1. 基于数据驱动模型，基于密码数据对模型进行训练\n2. 基于规则猜测，由专家知识定制初始配置，转换初始密码到候选密码。\n## 基于额外信息攻击\n CPG：Pasquini等人[38，39]提出了一种基于Wasserstein自动编码器的最先进的CPG方法[48]。他们将最终的模型称为CWAE(上下文瓦瑟斯坦自动编码器)，它由将部分密码嵌入到潜在表示中的编码器和将部分密码的潜在表示转换为密码的解码器组成。\n TPG：其中，Pal等人提出的Pass2Path。[35]2019年，是最新、最有效的定向竞猜模式。他们提出了凭据调整，以破解用户历史密码的变体(调整)\n ARPG：021年，Pasquini et al.[37]提出了第一个基于规则的自适应猜测框架ADAMS(Adaptive Dynamic Mgling Rules Attack)，该框架构建了一个卷积规则(CNN神经网络)建模，为每个单词选择自适应规则。\n\n\n## 基准攻击模型\n我们使用最先进的CWAE、Pass2Path和ADAMS模型分别作为CPG、TPG和ARPG攻击的基线，因为这些模型与其他模型相比具有最高的猜测性能。例如，CWAE已被证明比基于PCFG、马尔可夫和神经网络的模型更好。因此，我们不会检查与其他型号的比较。\n\n## 双向 Transformer\n基于自我注意机制(即将给定的标记与所有文本环境连接起来)提出的，由于能够捕获深层文本特征而在自然语言处理领域获得了广泛的应用。\nBERT(来自Transformers的双向编码器表示)[12，27]是一种流行的基于变压器的架构，已经在11个单独的NLP任务上取得了最先进的结果。\nBERT针对 **MLM(掩蔽语言建模)** 和 **NSP(下一句预测)** 两个目标进行预训练，以建立基于大量未标记Web语料库的预训练语言模型。\n1. 对于 MLM 目标，BERT 训练模型，使其能够预测屏蔽位置的正确标记。由于自然语言的特性，BERT很大程度上是为了预测屏蔽词而设计的。\n2. NSP的目标是取一个句子对A和B，并预测B是否是A之后的实际下一个句子。Bert[12]提出了两种次级训练方法：微调和基于特征。\n\t1. 在微调方法中，所有参数都在下行任务期间更新。\n\t2. 而在基于特征的方法中，通过冻结一些普通的预训练层来从预训练的参数中提取固定的特征。 \n\t通常，微调方法会随着训练时间的增加而产生更好的结果[12]。在本文中，我们选择了所有参数都是可学习的微调方法。\n\n# 预任务\n\n## 工作流\n攻击模型的工作流程是根据监督信号训练监督模型。我们将它们的监管信号总结在表1中。\n1. 具体来说，CPG的监管信号是部分密码及其完整密码。 CPG 旨在训练模型，使其在给定部分密码的情况下预测正确的密码。 CPG 的输出直接作为密码候选。\n2. TPG的监督信号是通过动态规划算法计算出的最短编辑路径的密码（在[35]中实现）。编辑路径是一系列原子编辑操作（在我们的攻击设计中预定义），\n3. ARPG的监督信号是具有命中规则（即规则集的子集）的单词，例如根据两个假设数据集之间的命中信息删除最后三个字符。 ARPG模型输出自适应规则，然后将其应用于单词以获得候选密码。自适应规则通常与单词更兼容，从而可以尽早产生命中。 ARPG 中使用的修改规则在 Hashcat 中定义。一般情况下，大多数重整规则可以是常见原子规则的组合（例如，“删除最后三个字符”是“删除最后一个字符”的三个原子规则的组合），并且可以自然地模拟应用多个规则的场景按顺序到基本词。\n\n## 威胁模型\n假设攻击者可以选择预先训练的自然语言和密码特定参数（作为先验知识）或随机变量来初始化他们的攻击模型。\n\n## 密码泄漏数据集\n### 数据集选择\n在实验中选择了先前作品[16、21、37、38、43、54、60]中使用的几个数据集。用于定向猜测的数据集是电子邮件，而用于非定向猜测攻击的数据集是明文密码。\n\n密码预训练、CPG和ARPG使用由明文密码组成的数据集，\nRockyou-2009、000Webhost、Neopets、Cit0day、Rockyou-2021：\n\n对于TPG攻击，我们选择以下两个包含电子邮件的数据集，并总结表2中的基本信息：\nBreachCompilation (4iQ)\nCollection#1\n### 数据处理\n账户加入：为了找到属于同一用户的密码列表，我们根据相同的电子邮件地址合并帐户（用户）[35]\n\n数据集清理：\n我们采用常用的清理策略[16,35,37,60]来过滤掉原始数据集中的哈希密码、非ASCII密码和超过32个字符的异常长密码。\n\n\n## 密码二向性\n顺序性：字符通常与其相邻字符更相关，这也可以是单向性的体现。聚合：相关字符的内部序列（例如“password123”中的“p@ssw0rd”和“123”；“mike199730”中的“199730”）有更多的连接线。\n捕获双向表示可以提供更好的候选密码，从而提高密码猜测效率!!!! ！\n\n\n\n# PassBERT\n\n## 预训练\n预训练模型主要捕获输入密码的上下文嵌入，这是密码中每个字符的具有上下文信息的高维表示。上下文嵌入是预训练层（即最后一个变压器块）的输出。\n### 嵌入\n1. 密码标记为字符序列，\n2. 带有表示开头 ([CLS]) 和结尾 ([SEP]) 的附加符号，因为密码通常比句子短，\n3. 对比：与 BERT 不同，BERT 通常在 token 级别对文本进行 token 化，其 token 主要是单词，并将每个句子剪辑为 512 个 token。\n4. 我们考虑最大密码长度为32个字符，并考虑总共99个有效字符，包括95个ASCII字符（表示为Σ）和4个附加符号开始、结束、占位符和未知字符。\n5. 嵌入层：\n\t1. 其字符嵌入和位置嵌入 求和。将标记化输入转换为其输入嵌入。\n\t2. 删除了 BERT 中的句子嵌入\n\t3. ![[Pasted image 20240314160458.png]]\n\n### 数据处理\n1. 为了使用 MLM 目标预训练密码模型（即预测屏蔽位置后面的屏蔽字符），我们将训练集中的每个密码 (Dtraining) 预处理为部分密码的形式（表示为pivot）：关联完整的密码（表示为 pwd）。我们遵循 BERT [12] 中相同的掩码比例：我们随机选择密码中 15% 的字符，然后分别以 80%、10% 和 10% 的概率用掩码符号、随机字符和未更改字符替换所选字符 。随机且未改变的字符可以防止模型记住被屏蔽的字符。一个密码可以预处理到很多个pivot，本文设置了20个pivot。我们设置预训练任务，找到参数 θ 来最大化以下似然：\n![[Pasted image 20240314161946.png]]\n\n### 数据集选择\n我们使用 Rockyou-2021 作为我们的预训练数据集，该数据集非常大。为了在训练时间和模型性能之间取得平衡，我们从 Rockyou-2021 中随机抽取了 6000 万个密码。\n\n\n### 计算性能\n我们的工作是在一台配备 Nvidia GeForce RTX 2080 Ti 的 Ubuntu 20.04 机器上执行的，大约需要 2 天才能完成预训练。存储预训练模型需要 8.9 MB。\n\n## 密码微调\n根据特定的攻击场景定制预训练模型。微调方法通常包括架构修改和模型重新训练。\n\n1. 架构修改期间，\n\t1. 通常修改预训练模型架构的任务特定层（表9中的全连接层和输出层），并保留预训练层，包括顶部输入层、嵌入层和几个 Transformer 块。\n\t2. 然后，我们使用特定的监督信号重新训练下游模型，以学习特定于任务的功能（例如密码规则兼容性）。（注意，重新训练过程中所有的参数都会改变：包括上面的所有层）。\n\n# 用于现实世界攻击模型的 PassBERT\n介绍三种 微调。\n\n三种预训练模型：\n1. 预训练的密码模型：PassBERT\n2. 预训练的 BERT 自然语言模型：Vanilla BERT \n\tVanilla BERT 可以在字级、子字级和字符级对文本（即密码）进行标记，而我们仅根据词汇表将密码标记为字符序列。由于我们的 Vanilla BERT 的词汇表只有小写字母，因此我们扩展词汇表以涵盖 Σ 中的所有有效字符（通过替换未使用的标记） \n3. 随机变量模型：PassBERT\n\n## 条件密码猜测\n任务：pivot（例如，“p ＊ ＊ ＊w0rd ＊ ＊ ＊ ”） ————>恢复密码。\n建模：掩码语言模型任务，预测缺失字符的 pivot 的条件概率\n数据构建：使用与 CWAE [38, 39] 相同的策略创建：\n1. 我们以一定比例（即 50%）随机用表示缺失字符的屏蔽符号替换每个字符。\n2. 然后，我们只保留那些包含至少四个可观察字符和至少五个屏蔽符号的生成主元。\n### 微调\n攻击设计：根据 Pivot 的创建机制调整 屏蔽机制。\n1. 增加掩码比例：只用掩码符号，\n2. （默认的屏蔽机制结果不佳）\n模型再训练：从中提取具有正确密码的有效枢轴以进行模型重新训练。\n评估：\nCPG 与 CWAE 具有相同的 评估 pivots 。\n1. 对一个 pivot 生成相同数量的候选密码。然后，比较匹配的个数。\n2. 按照匹配的个数分类这些 pivot 。区分不同频率的 pivot 的猜测性能\n评估集： Neopets 和 Cit0day 空间较大：\n1. WAE 仅为每个主元类别生成 30 个评估主元，可能会引起偏差。\n2. 我们从评估集中为每个类别总共提取了 120 个评估基准\n评估指标： 每个 pivot 的平均破解率。\n结果：很好\n预训练效果：用密码预训练的效果更好。\n改进原则：模型通过以递减的概率耗尽屏蔽位置中的字符来生成候选密码，而 CWAE 通过解码器将潜在表示（即高维空间中的点）转换为候选密码。很优\n计算性能：训练我们的 CPG 模型大约需要 2 天（8.9 MB），训练 CWAE 大约需要一天半的时间（4.4 MB）\n\n## 定向的密码猜测\n目标：用历史密码生成其变体\n目标：对给定的密码训练模型输出编辑路径。\n\n### 微调：\n攻击设计： Pass2path 基于 RNN 模型的序列机制将密码转换为编辑路径。Transformer 不支持，修改：使用序列标记机制来预测密码中每个字符的一个编辑操作。其中一系列编辑操作构成编辑路径。在序列标注机制中，每个字符位置只能输出一次编辑操作。\n\n为了适应序列标记机制，我们预先定义了新的编辑操作如下：保留（keep）、删除（del）和替换（rep1，rep2）这里，替换涉及用一个（表示为rep1）或两个字符替换（表示为rep2）。\n\n缺陷：无法捕获一些转换，比如：插入三个字符\n模型结构：\n![[Pasted image 20240314203049.png]]\n 修改特定于任务的层以学习密码中每个字符的编辑操作（例如，(op, str)）的概率。\n模型再训练：\n遵循 Pass2path [35]，我们在 BreachCompilation 中从同一用户中随机抽取 80% 的密码对，并在最小编辑距离不超过 4 时选择合格的密码对，最终得到 85,269,455 个密码对。\n\n评估：\n评估设置： 和 Pass2pass 保证相同数据集训练对\n评估指标。我们选择特定用户泄露的密码之一作为输入，然后根据 TPG 模型推断其变体（限制为 1,000 次猜测）计算了 Ncracked Naccounts 给出不同猜测（即 10、100 和 1,000）的评估用途/帐户之间的破解率\n实验结果：三个模型都高于 Pass2path\n\n预训练效果：密码和自然语言模型在 TPG 中表现出边际收益。发现预训练的改进空间仍然很小，这表明预训练的作用较弱。这种现象是可以理解的，因为有针对性的攻击集中在个性化密码转换上，这与预训练模型中的全局密码分布关系不大。两个预训练模型生成的上下文嵌入在帮助理解密码转换方面几乎没有效果。 TPG 往往依赖于任务，主要根据特定攻击的数据集形成其模型参数。\n\n改进原则：更关注本地角色信息。准确地说，我们的编辑操作二元组 (op, str) 可以比 Pass2path 中使用的三元组操作 (op, str,pos) 减少一维搜索空间，其中 pos 指密码中的位置。 \n\n看法：随着编辑距离的增加，破解率下降。\n\n计算性能比较。训练 PassBERT (82 MB) 和 Pass2path (166 MB) 分别需要大约 13.6 和 42 小时。我们根据经验计算得出，两种模型都实现了相似的推理速度。 PassBERT 和 Pass2path 每秒可以推断 4.38 和 4.63 个密码对（pairs/s）。\n\n## 基于自适应规则的密码猜测\n目标：每个单词仅与选定的自适应修改规则关联以生成猜测。\n\t\t[37]尝试使用默认变压器，但与 ADaM 相比没有取得实质性改进。\n本质：找出单词适应的规则。\n效果：输入单词和规则输出破解的可能性\n方式：构建分类模型，\n### 微调\n捕获整个单词和密码级别的修饰规则之间的自适应关系，因为修饰规则最终适用于单词。\n监督信号：是在两个假设数据集上带有标记规则（即命中规则）的单词。\n模型架构：\n1. 修改了特定任务层，推断重整规则和具有焦点损失函数的基本单词之间的自适应概率。\n2. 输出层没有序列长度。\n模型再训练：\n1. 针对两个规则集训练了两个 APRG 模型\n2. 使用 2 亿个密码作为目标空间\n3. 使用 1000 万条数据作为初始空间\n4. 训练：Ri 是个向量，每个元素对应一个规则的匹配可能性\n\t注意：0和1的比例极其不平衡，即超过95%的标签都是0。因此，我们应用与ADAM相同参数策略的焦点损失[25,37]来关注硬标签。\n5. 设置一个 阈值 来表示规则使用的条件。\n\n### 评估\n评估设置：比较了静态和动态模型。\n专注于单词和规则之间的关系建模，即我们的目标是为单词选择更具适应性的规则，以在相同的猜测下获得更高的猜测效率。\n评估指标：动态策略模型的最终破解率作为评估指标。\n试验结果：动态模型和静态模型都高于 ADaMs\n1.  Dynamic PassBERT 在这些模型中实现了最高的破解率，并且在四个实验中比 ADaM 平均提高了 4.86%。\n2.  静态 ARPG 的显着提前停止是因为每个单词仅与自适应规则关联，其大小小于标准基于规则的攻击中的所有规则。\n预训练效果：\n1. 密码预训练使 Transformer 的性能优于 ADaM\n2. 用默认 Transformer 基本没改进。所以这些个模型的改进没有效果。\n改进原则：密码预训练对于 ARPG 的提升有着重要的作用。 \n见解：发现了容易收到攻击的破坏规则。\n计算性能比较：\n1. 我们两个小时： ADam 需要 十个小时\n2. 推理速度相似。\n# 密码强度估计\n\n\n# 讨论\n密码双向性：\n1. 双向 Transformer 在文本特征提取方面比自动编码器 (CWAE)、RNN (Pass2path) 或 CNN (ADaMs) 等领先方法效果更好，\n2. 工作[22]已经设置了单向变压器，并显示了双向训练机制在一般猜测任务中的优越性。\n3. 密码具有双向性，对字符进行不同的权重。\n4. 预训练对于提高猜测效率也能起到重要作用。深度学习模型通常由通用预训练层和特定于任务的层组成，其中预训练层的上下文嵌入层可以为任务相关层提供更多上下文信息。\n预训练的合适场景猜测：\n密码训练和自然语言训练：只能为有针对性的攻击提供效益","slug":"论文笔记/PassBERT","published":1,"date":"2024-04-22T13:14:48.838Z","updated":"2024-03-15T05:31:53.017Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0i001fkgg43ss58i7q","content":"<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><p>sformer 的密码猜测框架。<br>2. 使用预训练&#x2F;微调范例。<br>3. 设计了三个特定场景下的密码猜测任务的微调方式：<br>    1. 条件性口令猜测，在给定部分口令的情况下回复完整口令。<br>    2. 针对、定向性口令猜测，利用特定用户的个人信息猜测其口令。<br>    3. 基于规则的自适应密码猜测，其为单词(即，基本密码)选择自适应调整规则以生成经规则转换的候选密码。<br>4. 最后我们提出了一种<strong>混合口令强度计量器</strong>来降低这三种攻击的风险。</p>\n<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><ol>\n<li>数据驱动模型(例如，马尔科夫[28，32])和基于规则的工具(例如，Hashcat[17])来有效地离线破解密码</li>\n<li>现实世界猜测攻击：使用先验信息，<ol>\n<li>定向密码猜测 TPG。</li>\n<li>条件密码猜测 CPG</li>\n<li>基于自适应规则密码猜测 ARPG</li>\n</ol>\n</li>\n<li>双向转换器在自然语言处理领域受到了极大的关注[12，27，51]。由于能够捕获双向上下文信息和高度可转移性[51]，转换器在多语言任务(例如，文本分类[59]、语法校正[34])中是有效的。<ol>\n<li>有的密码猜测攻击，无论是一般的还是基于现实世界的，都可以概念化为近似密码(即文本)的概率分布的努力，</li>\n<li>这表明它自然适合基于双向转换器的猜测框架。</li>\n</ol>\n</li>\n<li>现有有一些琐碎的工作（看了一下只是 神经网网络，不是特指 Transformer）效果不佳。</li>\n<li>成功使用 Transformer 需要一些特定的设计，比如这里使用了序列标签，参考之前的序列到序列机制。</li>\n<li>本文设计了一个基于字符级别的双向变化猜测框架。设计了特定方式的微调。取得了一定的效果。</li>\n<li>本文测试了预训练的效果。预先训练的密码模型比预先训练的自然语言模型能够产生更好的猜测性能，这表明了预先训练在特定密码语料库上的有效性。</li>\n<li>本文引入了混合密码强度计（HPSM）来降低三种攻击的风险。HPSM可以与密码泄漏检查[23，47]相结合来检测输入是否公开泄漏，一旦泄漏，输入就会遭受ARPG攻击。</li>\n</ol>\n<h1 id=\"相关工作\"><a href=\"#相关工作\" class=\"headerlink\" title=\"相关工作\"></a>相关工作</h1><h2 id=\"一般密码猜测\"><a href=\"#一般密码猜测\" class=\"headerlink\" title=\"一般密码猜测\"></a>一般密码猜测</h2><ol>\n<li>基于数据驱动模型，基于密码数据对模型进行训练</li>\n<li>基于规则猜测，由专家知识定制初始配置，转换初始密码到候选密码。</li>\n</ol>\n<h2 id=\"基于额外信息攻击\"><a href=\"#基于额外信息攻击\" class=\"headerlink\" title=\"基于额外信息攻击\"></a>基于额外信息攻击</h2><p> CPG：Pasquini等人[38，39]提出了一种基于Wasserstein自动编码器的最先进的CPG方法[48]。他们将最终的模型称为CWAE(上下文瓦瑟斯坦自动编码器)，它由将部分密码嵌入到潜在表示中的编码器和将部分密码的潜在表示转换为密码的解码器组成。<br> TPG：其中，Pal等人提出的Pass2Path。[35]2019年，是最新、最有效的定向竞猜模式。他们提出了凭据调整，以破解用户历史密码的变体(调整)<br> ARPG：021年，Pasquini et al.[37]提出了第一个基于规则的自适应猜测框架ADAMS(Adaptive Dynamic Mgling Rules Attack)，该框架构建了一个卷积规则(CNN神经网络)建模，为每个单词选择自适应规则。</p>\n<h2 id=\"基准攻击模型\"><a href=\"#基准攻击模型\" class=\"headerlink\" title=\"基准攻击模型\"></a>基准攻击模型</h2><p>我们使用最先进的CWAE、Pass2Path和ADAMS模型分别作为CPG、TPG和ARPG攻击的基线，因为这些模型与其他模型相比具有最高的猜测性能。例如，CWAE已被证明比基于PCFG、马尔可夫和神经网络的模型更好。因此，我们不会检查与其他型号的比较。</p>\n<h2 id=\"双向-Transformer\"><a href=\"#双向-Transformer\" class=\"headerlink\" title=\"双向 Transformer\"></a>双向 Transformer</h2><p>基于自我注意机制(即将给定的标记与所有文本环境连接起来)提出的，由于能够捕获深层文本特征而在自然语言处理领域获得了广泛的应用。<br>BERT(来自Transformers的双向编码器表示)[12，27]是一种流行的基于变压器的架构，已经在11个单独的NLP任务上取得了最先进的结果。<br>BERT针对 <strong>MLM(掩蔽语言建模)</strong> 和 <strong>NSP(下一句预测)</strong> 两个目标进行预训练，以建立基于大量未标记Web语料库的预训练语言模型。</p>\n<ol>\n<li>对于 MLM 目标，BERT 训练模型，使其能够预测屏蔽位置的正确标记。由于自然语言的特性，BERT很大程度上是为了预测屏蔽词而设计的。</li>\n<li>NSP的目标是取一个句子对A和B，并预测B是否是A之后的实际下一个句子。Bert[12]提出了两种次级训练方法：微调和基于特征。<ol>\n<li>在微调方法中，所有参数都在下行任务期间更新。</li>\n<li>而在基于特征的方法中，通过冻结一些普通的预训练层来从预训练的参数中提取固定的特征。<br> 通常，微调方法会随着训练时间的增加而产生更好的结果[12]。在本文中，我们选择了所有参数都是可学习的微调方法。</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"预任务\"><a href=\"#预任务\" class=\"headerlink\" title=\"预任务\"></a>预任务</h1><h2 id=\"工作流\"><a href=\"#工作流\" class=\"headerlink\" title=\"工作流\"></a>工作流</h2><p>攻击模型的工作流程是根据监督信号训练监督模型。我们将它们的监管信号总结在表1中。</p>\n<ol>\n<li>具体来说，CPG的监管信号是部分密码及其完整密码。 CPG 旨在训练模型，使其在给定部分密码的情况下预测正确的密码。 CPG 的输出直接作为密码候选。</li>\n<li>TPG的监督信号是通过动态规划算法计算出的最短编辑路径的密码（在[35]中实现）。编辑路径是一系列原子编辑操作（在我们的攻击设计中预定义），</li>\n<li>ARPG的监督信号是具有命中规则（即规则集的子集）的单词，例如根据两个假设数据集之间的命中信息删除最后三个字符。 ARPG模型输出自适应规则，然后将其应用于单词以获得候选密码。自适应规则通常与单词更兼容，从而可以尽早产生命中。 ARPG 中使用的修改规则在 Hashcat 中定义。一般情况下，大多数重整规则可以是常见原子规则的组合（例如，“删除最后三个字符”是“删除最后一个字符”的三个原子规则的组合），并且可以自然地模拟应用多个规则的场景按顺序到基本词。</li>\n</ol>\n<h2 id=\"威胁模型\"><a href=\"#威胁模型\" class=\"headerlink\" title=\"威胁模型\"></a>威胁模型</h2><p>假设攻击者可以选择预先训练的自然语言和密码特定参数（作为先验知识）或随机变量来初始化他们的攻击模型。</p>\n<h2 id=\"密码泄漏数据集\"><a href=\"#密码泄漏数据集\" class=\"headerlink\" title=\"密码泄漏数据集\"></a>密码泄漏数据集</h2><h3 id=\"数据集选择\"><a href=\"#数据集选择\" class=\"headerlink\" title=\"数据集选择\"></a>数据集选择</h3><p>在实验中选择了先前作品[16、21、37、38、43、54、60]中使用的几个数据集。用于定向猜测的数据集是电子邮件，而用于非定向猜测攻击的数据集是明文密码。</p>\n<p>密码预训练、CPG和ARPG使用由明文密码组成的数据集，<br>Rockyou-2009、000Webhost、Neopets、Cit0day、Rockyou-2021：</p>\n<p>对于TPG攻击，我们选择以下两个包含电子邮件的数据集，并总结表2中的基本信息：<br>BreachCompilation (4iQ)<br>Collection#1</p>\n<h3 id=\"数据处理\"><a href=\"#数据处理\" class=\"headerlink\" title=\"数据处理\"></a>数据处理</h3><p>账户加入：为了找到属于同一用户的密码列表，我们根据相同的电子邮件地址合并帐户（用户）[35]</p>\n<p>数据集清理：<br>我们采用常用的清理策略[16,35,37,60]来过滤掉原始数据集中的哈希密码、非ASCII密码和超过32个字符的异常长密码。</p>\n<h2 id=\"密码二向性\"><a href=\"#密码二向性\" class=\"headerlink\" title=\"密码二向性\"></a>密码二向性</h2><p>顺序性：字符通常与其相邻字符更相关，这也可以是单向性的体现。聚合：相关字符的内部序列（例如“password123”中的“p@ssw0rd”和“123”；“mike199730”中的“199730”）有更多的连接线。<br>捕获双向表示可以提供更好的候选密码，从而提高密码猜测效率!!!! ！</p>\n<h1 id=\"PassBERT\"><a href=\"#PassBERT\" class=\"headerlink\" title=\"PassBERT\"></a>PassBERT</h1><h2 id=\"预训练\"><a href=\"#预训练\" class=\"headerlink\" title=\"预训练\"></a>预训练</h2><p>预训练模型主要捕获输入密码的上下文嵌入，这是密码中每个字符的具有上下文信息的高维表示。上下文嵌入是预训练层（即最后一个变压器块）的输出。</p>\n<h3 id=\"嵌入\"><a href=\"#嵌入\" class=\"headerlink\" title=\"嵌入\"></a>嵌入</h3><ol>\n<li>密码标记为字符序列，</li>\n<li>带有表示开头 ([CLS]) 和结尾 ([SEP]) 的附加符号，因为密码通常比句子短，</li>\n<li>对比：与 BERT 不同，BERT 通常在 token 级别对文本进行 token 化，其 token 主要是单词，并将每个句子剪辑为 512 个 token。</li>\n<li>我们考虑最大密码长度为32个字符，并考虑总共99个有效字符，包括95个ASCII字符（表示为Σ）和4个附加符号开始、结束、占位符和未知字符。</li>\n<li>嵌入层：<ol>\n<li>其字符嵌入和位置嵌入 求和。将标记化输入转换为其输入嵌入。</li>\n<li>删除了 BERT 中的句子嵌入</li>\n<li>![[Pasted image 20240314160458.png]]</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"数据处理-1\"><a href=\"#数据处理-1\" class=\"headerlink\" title=\"数据处理\"></a>数据处理</h3><ol>\n<li>为了使用 MLM 目标预训练密码模型（即预测屏蔽位置后面的屏蔽字符），我们将训练集中的每个密码 (Dtraining) 预处理为部分密码的形式（表示为pivot）：关联完整的密码（表示为 pwd）。我们遵循 BERT [12] 中相同的掩码比例：我们随机选择密码中 15% 的字符，然后分别以 80%、10% 和 10% 的概率用掩码符号、随机字符和未更改字符替换所选字符 。随机且未改变的字符可以防止模型记住被屏蔽的字符。一个密码可以预处理到很多个pivot，本文设置了20个pivot。我们设置预训练任务，找到参数 θ 来最大化以下似然：<br>![[Pasted image 20240314161946.png]]</li>\n</ol>\n<h3 id=\"数据集选择-1\"><a href=\"#数据集选择-1\" class=\"headerlink\" title=\"数据集选择\"></a>数据集选择</h3><p>我们使用 Rockyou-2021 作为我们的预训练数据集，该数据集非常大。为了在训练时间和模型性能之间取得平衡，我们从 Rockyou-2021 中随机抽取了 6000 万个密码。</p>\n<h3 id=\"计算性能\"><a href=\"#计算性能\" class=\"headerlink\" title=\"计算性能\"></a>计算性能</h3><p>我们的工作是在一台配备 Nvidia GeForce RTX 2080 Ti 的 Ubuntu 20.04 机器上执行的，大约需要 2 天才能完成预训练。存储预训练模型需要 8.9 MB。</p>\n<h2 id=\"密码微调\"><a href=\"#密码微调\" class=\"headerlink\" title=\"密码微调\"></a>密码微调</h2><p>根据特定的攻击场景定制预训练模型。微调方法通常包括架构修改和模型重新训练。</p>\n<ol>\n<li>架构修改期间，<ol>\n<li>通常修改预训练模型架构的任务特定层（表9中的全连接层和输出层），并保留预训练层，包括顶部输入层、嵌入层和几个 Transformer 块。</li>\n<li>然后，我们使用特定的监督信号重新训练下游模型，以学习特定于任务的功能（例如密码规则兼容性）。（注意，重新训练过程中所有的参数都会改变：包括上面的所有层）。</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"用于现实世界攻击模型的-PassBERT\"><a href=\"#用于现实世界攻击模型的-PassBERT\" class=\"headerlink\" title=\"用于现实世界攻击模型的 PassBERT\"></a>用于现实世界攻击模型的 PassBERT</h1><p>介绍三种 微调。</p>\n<p>三种预训练模型：</p>\n<ol>\n<li>预训练的密码模型：PassBERT</li>\n<li>预训练的 BERT 自然语言模型：Vanilla BERT<br> Vanilla BERT 可以在字级、子字级和字符级对文本（即密码）进行标记，而我们仅根据词汇表将密码标记为字符序列。由于我们的 Vanilla BERT 的词汇表只有小写字母，因此我们扩展词汇表以涵盖 Σ 中的所有有效字符（通过替换未使用的标记） </li>\n<li>随机变量模型：PassBERT</li>\n</ol>\n<h2 id=\"条件密码猜测\"><a href=\"#条件密码猜测\" class=\"headerlink\" title=\"条件密码猜测\"></a>条件密码猜测</h2><p>任务：pivot（例如，“p ＊ ＊ ＊w0rd ＊ ＊ ＊ ”） ————&gt;恢复密码。<br>建模：掩码语言模型任务，预测缺失字符的 pivot 的条件概率<br>数据构建：使用与 CWAE [38, 39] 相同的策略创建：</p>\n<ol>\n<li>我们以一定比例（即 50%）随机用表示缺失字符的屏蔽符号替换每个字符。</li>\n<li>然后，我们只保留那些包含至少四个可观察字符和至少五个屏蔽符号的生成主元。</li>\n</ol>\n<h3 id=\"微调\"><a href=\"#微调\" class=\"headerlink\" title=\"微调\"></a>微调</h3><p>攻击设计：根据 Pivot 的创建机制调整 屏蔽机制。</p>\n<ol>\n<li>增加掩码比例：只用掩码符号，</li>\n<li>（默认的屏蔽机制结果不佳）<br>模型再训练：从中提取具有正确密码的有效枢轴以进行模型重新训练。<br>评估：<br>CPG 与 CWAE 具有相同的 评估 pivots 。</li>\n<li>对一个 pivot 生成相同数量的候选密码。然后，比较匹配的个数。</li>\n<li>按照匹配的个数分类这些 pivot 。区分不同频率的 pivot 的猜测性能<br>评估集： Neopets 和 Cit0day 空间较大：</li>\n<li>WAE 仅为每个主元类别生成 30 个评估主元，可能会引起偏差。</li>\n<li>我们从评估集中为每个类别总共提取了 120 个评估基准<br>评估指标： 每个 pivot 的平均破解率。<br>结果：很好<br>预训练效果：用密码预训练的效果更好。<br>改进原则：模型通过以递减的概率耗尽屏蔽位置中的字符来生成候选密码，而 CWAE 通过解码器将潜在表示（即高维空间中的点）转换为候选密码。很优<br>计算性能：训练我们的 CPG 模型大约需要 2 天（8.9 MB），训练 CWAE 大约需要一天半的时间（4.4 MB）</li>\n</ol>\n<h2 id=\"定向的密码猜测\"><a href=\"#定向的密码猜测\" class=\"headerlink\" title=\"定向的密码猜测\"></a>定向的密码猜测</h2><p>目标：用历史密码生成其变体<br>目标：对给定的密码训练模型输出编辑路径。</p>\n<h3 id=\"微调：\"><a href=\"#微调：\" class=\"headerlink\" title=\"微调：\"></a>微调：</h3><p>攻击设计： Pass2path 基于 RNN 模型的序列机制将密码转换为编辑路径。Transformer 不支持，修改：使用序列标记机制来预测密码中每个字符的一个编辑操作。其中一系列编辑操作构成编辑路径。在序列标注机制中，每个字符位置只能输出一次编辑操作。</p>\n<p>为了适应序列标记机制，我们预先定义了新的编辑操作如下：保留（keep）、删除（del）和替换（rep1，rep2）这里，替换涉及用一个（表示为rep1）或两个字符替换（表示为rep2）。</p>\n<p>缺陷：无法捕获一些转换，比如：插入三个字符<br>模型结构：<br>![[Pasted image 20240314203049.png]]<br> 修改特定于任务的层以学习密码中每个字符的编辑操作（例如，(op, str)）的概率。<br>模型再训练：<br>遵循 Pass2path [35]，我们在 BreachCompilation 中从同一用户中随机抽取 80% 的密码对，并在最小编辑距离不超过 4 时选择合格的密码对，最终得到 85,269,455 个密码对。</p>\n<p>评估：<br>评估设置： 和 Pass2pass 保证相同数据集训练对<br>评估指标。我们选择特定用户泄露的密码之一作为输入，然后根据 TPG 模型推断其变体（限制为 1,000 次猜测）计算了 Ncracked Naccounts 给出不同猜测（即 10、100 和 1,000）的评估用途&#x2F;帐户之间的破解率<br>实验结果：三个模型都高于 Pass2path</p>\n<p>预训练效果：密码和自然语言模型在 TPG 中表现出边际收益。发现预训练的改进空间仍然很小，这表明预训练的作用较弱。这种现象是可以理解的，因为有针对性的攻击集中在个性化密码转换上，这与预训练模型中的全局密码分布关系不大。两个预训练模型生成的上下文嵌入在帮助理解密码转换方面几乎没有效果。 TPG 往往依赖于任务，主要根据特定攻击的数据集形成其模型参数。</p>\n<p>改进原则：更关注本地角色信息。准确地说，我们的编辑操作二元组 (op, str) 可以比 Pass2path 中使用的三元组操作 (op, str,pos) 减少一维搜索空间，其中 pos 指密码中的位置。 </p>\n<p>看法：随着编辑距离的增加，破解率下降。</p>\n<p>计算性能比较。训练 PassBERT (82 MB) 和 Pass2path (166 MB) 分别需要大约 13.6 和 42 小时。我们根据经验计算得出，两种模型都实现了相似的推理速度。 PassBERT 和 Pass2path 每秒可以推断 4.38 和 4.63 个密码对（pairs&#x2F;s）。</p>\n<h2 id=\"基于自适应规则的密码猜测\"><a href=\"#基于自适应规则的密码猜测\" class=\"headerlink\" title=\"基于自适应规则的密码猜测\"></a>基于自适应规则的密码猜测</h2><p>目标：每个单词仅与选定的自适应修改规则关联以生成猜测。<br>        [37]尝试使用默认变压器，但与 ADaM 相比没有取得实质性改进。<br>本质：找出单词适应的规则。<br>效果：输入单词和规则输出破解的可能性<br>方式：构建分类模型，</p>\n<h3 id=\"微调-1\"><a href=\"#微调-1\" class=\"headerlink\" title=\"微调\"></a>微调</h3><p>捕获整个单词和密码级别的修饰规则之间的自适应关系，因为修饰规则最终适用于单词。<br>监督信号：是在两个假设数据集上带有标记规则（即命中规则）的单词。<br>模型架构：</p>\n<ol>\n<li>修改了特定任务层，推断重整规则和具有焦点损失函数的基本单词之间的自适应概率。</li>\n<li>输出层没有序列长度。<br>模型再训练：</li>\n<li>针对两个规则集训练了两个 APRG 模型</li>\n<li>使用 2 亿个密码作为目标空间</li>\n<li>使用 1000 万条数据作为初始空间</li>\n<li>训练：Ri 是个向量，每个元素对应一个规则的匹配可能性<br> 注意：0和1的比例极其不平衡，即超过95%的标签都是0。因此，我们应用与ADAM相同参数策略的焦点损失[25,37]来关注硬标签。</li>\n<li>设置一个 阈值 来表示规则使用的条件。</li>\n</ol>\n<h3 id=\"评估\"><a href=\"#评估\" class=\"headerlink\" title=\"评估\"></a>评估</h3><p>评估设置：比较了静态和动态模型。<br>专注于单词和规则之间的关系建模，即我们的目标是为单词选择更具适应性的规则，以在相同的猜测下获得更高的猜测效率。<br>评估指标：动态策略模型的最终破解率作为评估指标。<br>试验结果：动态模型和静态模型都高于 ADaMs</p>\n<ol>\n<li> Dynamic PassBERT 在这些模型中实现了最高的破解率，并且在四个实验中比 ADaM 平均提高了 4.86%。</li>\n<li> 静态 ARPG 的显着提前停止是因为每个单词仅与自适应规则关联，其大小小于标准基于规则的攻击中的所有规则。<br>预训练效果：</li>\n<li>密码预训练使 Transformer 的性能优于 ADaM</li>\n<li>用默认 Transformer 基本没改进。所以这些个模型的改进没有效果。<br>改进原则：密码预训练对于 ARPG 的提升有着重要的作用。<br>见解：发现了容易收到攻击的破坏规则。<br>计算性能比较：</li>\n<li>我们两个小时： ADam 需要 十个小时</li>\n<li>推理速度相似。</li>\n</ol>\n<h1 id=\"密码强度估计\"><a href=\"#密码强度估计\" class=\"headerlink\" title=\"密码强度估计\"></a>密码强度估计</h1><h1 id=\"讨论\"><a href=\"#讨论\" class=\"headerlink\" title=\"讨论\"></a>讨论</h1><p>密码双向性：</p>\n<ol>\n<li>双向 Transformer 在文本特征提取方面比自动编码器 (CWAE)、RNN (Pass2path) 或 CNN (ADaMs) 等领先方法效果更好，</li>\n<li>工作[22]已经设置了单向变压器，并显示了双向训练机制在一般猜测任务中的优越性。</li>\n<li>密码具有双向性，对字符进行不同的权重。</li>\n<li>预训练对于提高猜测效率也能起到重要作用。深度学习模型通常由通用预训练层和特定于任务的层组成，其中预训练层的上下文嵌入层可以为任务相关层提供更多上下文信息。<br>预训练的合适场景猜测：<br>密码训练和自然语言训练：只能为有针对性的攻击提供效益</li>\n</ol>\n","excerpt":"","more":"<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><p>sformer 的密码猜测框架。<br>2. 使用预训练&#x2F;微调范例。<br>3. 设计了三个特定场景下的密码猜测任务的微调方式：<br>    1. 条件性口令猜测，在给定部分口令的情况下回复完整口令。<br>    2. 针对、定向性口令猜测，利用特定用户的个人信息猜测其口令。<br>    3. 基于规则的自适应密码猜测，其为单词(即，基本密码)选择自适应调整规则以生成经规则转换的候选密码。<br>4. 最后我们提出了一种<strong>混合口令强度计量器</strong>来降低这三种攻击的风险。</p>\n<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><ol>\n<li>数据驱动模型(例如，马尔科夫[28，32])和基于规则的工具(例如，Hashcat[17])来有效地离线破解密码</li>\n<li>现实世界猜测攻击：使用先验信息，<ol>\n<li>定向密码猜测 TPG。</li>\n<li>条件密码猜测 CPG</li>\n<li>基于自适应规则密码猜测 ARPG</li>\n</ol>\n</li>\n<li>双向转换器在自然语言处理领域受到了极大的关注[12，27，51]。由于能够捕获双向上下文信息和高度可转移性[51]，转换器在多语言任务(例如，文本分类[59]、语法校正[34])中是有效的。<ol>\n<li>有的密码猜测攻击，无论是一般的还是基于现实世界的，都可以概念化为近似密码(即文本)的概率分布的努力，</li>\n<li>这表明它自然适合基于双向转换器的猜测框架。</li>\n</ol>\n</li>\n<li>现有有一些琐碎的工作（看了一下只是 神经网网络，不是特指 Transformer）效果不佳。</li>\n<li>成功使用 Transformer 需要一些特定的设计，比如这里使用了序列标签，参考之前的序列到序列机制。</li>\n<li>本文设计了一个基于字符级别的双向变化猜测框架。设计了特定方式的微调。取得了一定的效果。</li>\n<li>本文测试了预训练的效果。预先训练的密码模型比预先训练的自然语言模型能够产生更好的猜测性能，这表明了预先训练在特定密码语料库上的有效性。</li>\n<li>本文引入了混合密码强度计（HPSM）来降低三种攻击的风险。HPSM可以与密码泄漏检查[23，47]相结合来检测输入是否公开泄漏，一旦泄漏，输入就会遭受ARPG攻击。</li>\n</ol>\n<h1 id=\"相关工作\"><a href=\"#相关工作\" class=\"headerlink\" title=\"相关工作\"></a>相关工作</h1><h2 id=\"一般密码猜测\"><a href=\"#一般密码猜测\" class=\"headerlink\" title=\"一般密码猜测\"></a>一般密码猜测</h2><ol>\n<li>基于数据驱动模型，基于密码数据对模型进行训练</li>\n<li>基于规则猜测，由专家知识定制初始配置，转换初始密码到候选密码。</li>\n</ol>\n<h2 id=\"基于额外信息攻击\"><a href=\"#基于额外信息攻击\" class=\"headerlink\" title=\"基于额外信息攻击\"></a>基于额外信息攻击</h2><p> CPG：Pasquini等人[38，39]提出了一种基于Wasserstein自动编码器的最先进的CPG方法[48]。他们将最终的模型称为CWAE(上下文瓦瑟斯坦自动编码器)，它由将部分密码嵌入到潜在表示中的编码器和将部分密码的潜在表示转换为密码的解码器组成。<br> TPG：其中，Pal等人提出的Pass2Path。[35]2019年，是最新、最有效的定向竞猜模式。他们提出了凭据调整，以破解用户历史密码的变体(调整)<br> ARPG：021年，Pasquini et al.[37]提出了第一个基于规则的自适应猜测框架ADAMS(Adaptive Dynamic Mgling Rules Attack)，该框架构建了一个卷积规则(CNN神经网络)建模，为每个单词选择自适应规则。</p>\n<h2 id=\"基准攻击模型\"><a href=\"#基准攻击模型\" class=\"headerlink\" title=\"基准攻击模型\"></a>基准攻击模型</h2><p>我们使用最先进的CWAE、Pass2Path和ADAMS模型分别作为CPG、TPG和ARPG攻击的基线，因为这些模型与其他模型相比具有最高的猜测性能。例如，CWAE已被证明比基于PCFG、马尔可夫和神经网络的模型更好。因此，我们不会检查与其他型号的比较。</p>\n<h2 id=\"双向-Transformer\"><a href=\"#双向-Transformer\" class=\"headerlink\" title=\"双向 Transformer\"></a>双向 Transformer</h2><p>基于自我注意机制(即将给定的标记与所有文本环境连接起来)提出的，由于能够捕获深层文本特征而在自然语言处理领域获得了广泛的应用。<br>BERT(来自Transformers的双向编码器表示)[12，27]是一种流行的基于变压器的架构，已经在11个单独的NLP任务上取得了最先进的结果。<br>BERT针对 <strong>MLM(掩蔽语言建模)</strong> 和 <strong>NSP(下一句预测)</strong> 两个目标进行预训练，以建立基于大量未标记Web语料库的预训练语言模型。</p>\n<ol>\n<li>对于 MLM 目标，BERT 训练模型，使其能够预测屏蔽位置的正确标记。由于自然语言的特性，BERT很大程度上是为了预测屏蔽词而设计的。</li>\n<li>NSP的目标是取一个句子对A和B，并预测B是否是A之后的实际下一个句子。Bert[12]提出了两种次级训练方法：微调和基于特征。<ol>\n<li>在微调方法中，所有参数都在下行任务期间更新。</li>\n<li>而在基于特征的方法中，通过冻结一些普通的预训练层来从预训练的参数中提取固定的特征。<br> 通常，微调方法会随着训练时间的增加而产生更好的结果[12]。在本文中，我们选择了所有参数都是可学习的微调方法。</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"预任务\"><a href=\"#预任务\" class=\"headerlink\" title=\"预任务\"></a>预任务</h1><h2 id=\"工作流\"><a href=\"#工作流\" class=\"headerlink\" title=\"工作流\"></a>工作流</h2><p>攻击模型的工作流程是根据监督信号训练监督模型。我们将它们的监管信号总结在表1中。</p>\n<ol>\n<li>具体来说，CPG的监管信号是部分密码及其完整密码。 CPG 旨在训练模型，使其在给定部分密码的情况下预测正确的密码。 CPG 的输出直接作为密码候选。</li>\n<li>TPG的监督信号是通过动态规划算法计算出的最短编辑路径的密码（在[35]中实现）。编辑路径是一系列原子编辑操作（在我们的攻击设计中预定义），</li>\n<li>ARPG的监督信号是具有命中规则（即规则集的子集）的单词，例如根据两个假设数据集之间的命中信息删除最后三个字符。 ARPG模型输出自适应规则，然后将其应用于单词以获得候选密码。自适应规则通常与单词更兼容，从而可以尽早产生命中。 ARPG 中使用的修改规则在 Hashcat 中定义。一般情况下，大多数重整规则可以是常见原子规则的组合（例如，“删除最后三个字符”是“删除最后一个字符”的三个原子规则的组合），并且可以自然地模拟应用多个规则的场景按顺序到基本词。</li>\n</ol>\n<h2 id=\"威胁模型\"><a href=\"#威胁模型\" class=\"headerlink\" title=\"威胁模型\"></a>威胁模型</h2><p>假设攻击者可以选择预先训练的自然语言和密码特定参数（作为先验知识）或随机变量来初始化他们的攻击模型。</p>\n<h2 id=\"密码泄漏数据集\"><a href=\"#密码泄漏数据集\" class=\"headerlink\" title=\"密码泄漏数据集\"></a>密码泄漏数据集</h2><h3 id=\"数据集选择\"><a href=\"#数据集选择\" class=\"headerlink\" title=\"数据集选择\"></a>数据集选择</h3><p>在实验中选择了先前作品[16、21、37、38、43、54、60]中使用的几个数据集。用于定向猜测的数据集是电子邮件，而用于非定向猜测攻击的数据集是明文密码。</p>\n<p>密码预训练、CPG和ARPG使用由明文密码组成的数据集，<br>Rockyou-2009、000Webhost、Neopets、Cit0day、Rockyou-2021：</p>\n<p>对于TPG攻击，我们选择以下两个包含电子邮件的数据集，并总结表2中的基本信息：<br>BreachCompilation (4iQ)<br>Collection#1</p>\n<h3 id=\"数据处理\"><a href=\"#数据处理\" class=\"headerlink\" title=\"数据处理\"></a>数据处理</h3><p>账户加入：为了找到属于同一用户的密码列表，我们根据相同的电子邮件地址合并帐户（用户）[35]</p>\n<p>数据集清理：<br>我们采用常用的清理策略[16,35,37,60]来过滤掉原始数据集中的哈希密码、非ASCII密码和超过32个字符的异常长密码。</p>\n<h2 id=\"密码二向性\"><a href=\"#密码二向性\" class=\"headerlink\" title=\"密码二向性\"></a>密码二向性</h2><p>顺序性：字符通常与其相邻字符更相关，这也可以是单向性的体现。聚合：相关字符的内部序列（例如“password123”中的“p@ssw0rd”和“123”；“mike199730”中的“199730”）有更多的连接线。<br>捕获双向表示可以提供更好的候选密码，从而提高密码猜测效率!!!! ！</p>\n<h1 id=\"PassBERT\"><a href=\"#PassBERT\" class=\"headerlink\" title=\"PassBERT\"></a>PassBERT</h1><h2 id=\"预训练\"><a href=\"#预训练\" class=\"headerlink\" title=\"预训练\"></a>预训练</h2><p>预训练模型主要捕获输入密码的上下文嵌入，这是密码中每个字符的具有上下文信息的高维表示。上下文嵌入是预训练层（即最后一个变压器块）的输出。</p>\n<h3 id=\"嵌入\"><a href=\"#嵌入\" class=\"headerlink\" title=\"嵌入\"></a>嵌入</h3><ol>\n<li>密码标记为字符序列，</li>\n<li>带有表示开头 ([CLS]) 和结尾 ([SEP]) 的附加符号，因为密码通常比句子短，</li>\n<li>对比：与 BERT 不同，BERT 通常在 token 级别对文本进行 token 化，其 token 主要是单词，并将每个句子剪辑为 512 个 token。</li>\n<li>我们考虑最大密码长度为32个字符，并考虑总共99个有效字符，包括95个ASCII字符（表示为Σ）和4个附加符号开始、结束、占位符和未知字符。</li>\n<li>嵌入层：<ol>\n<li>其字符嵌入和位置嵌入 求和。将标记化输入转换为其输入嵌入。</li>\n<li>删除了 BERT 中的句子嵌入</li>\n<li>![[Pasted image 20240314160458.png]]</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"数据处理-1\"><a href=\"#数据处理-1\" class=\"headerlink\" title=\"数据处理\"></a>数据处理</h3><ol>\n<li>为了使用 MLM 目标预训练密码模型（即预测屏蔽位置后面的屏蔽字符），我们将训练集中的每个密码 (Dtraining) 预处理为部分密码的形式（表示为pivot）：关联完整的密码（表示为 pwd）。我们遵循 BERT [12] 中相同的掩码比例：我们随机选择密码中 15% 的字符，然后分别以 80%、10% 和 10% 的概率用掩码符号、随机字符和未更改字符替换所选字符 。随机且未改变的字符可以防止模型记住被屏蔽的字符。一个密码可以预处理到很多个pivot，本文设置了20个pivot。我们设置预训练任务，找到参数 θ 来最大化以下似然：<br>![[Pasted image 20240314161946.png]]</li>\n</ol>\n<h3 id=\"数据集选择-1\"><a href=\"#数据集选择-1\" class=\"headerlink\" title=\"数据集选择\"></a>数据集选择</h3><p>我们使用 Rockyou-2021 作为我们的预训练数据集，该数据集非常大。为了在训练时间和模型性能之间取得平衡，我们从 Rockyou-2021 中随机抽取了 6000 万个密码。</p>\n<h3 id=\"计算性能\"><a href=\"#计算性能\" class=\"headerlink\" title=\"计算性能\"></a>计算性能</h3><p>我们的工作是在一台配备 Nvidia GeForce RTX 2080 Ti 的 Ubuntu 20.04 机器上执行的，大约需要 2 天才能完成预训练。存储预训练模型需要 8.9 MB。</p>\n<h2 id=\"密码微调\"><a href=\"#密码微调\" class=\"headerlink\" title=\"密码微调\"></a>密码微调</h2><p>根据特定的攻击场景定制预训练模型。微调方法通常包括架构修改和模型重新训练。</p>\n<ol>\n<li>架构修改期间，<ol>\n<li>通常修改预训练模型架构的任务特定层（表9中的全连接层和输出层），并保留预训练层，包括顶部输入层、嵌入层和几个 Transformer 块。</li>\n<li>然后，我们使用特定的监督信号重新训练下游模型，以学习特定于任务的功能（例如密码规则兼容性）。（注意，重新训练过程中所有的参数都会改变：包括上面的所有层）。</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"用于现实世界攻击模型的-PassBERT\"><a href=\"#用于现实世界攻击模型的-PassBERT\" class=\"headerlink\" title=\"用于现实世界攻击模型的 PassBERT\"></a>用于现实世界攻击模型的 PassBERT</h1><p>介绍三种 微调。</p>\n<p>三种预训练模型：</p>\n<ol>\n<li>预训练的密码模型：PassBERT</li>\n<li>预训练的 BERT 自然语言模型：Vanilla BERT<br> Vanilla BERT 可以在字级、子字级和字符级对文本（即密码）进行标记，而我们仅根据词汇表将密码标记为字符序列。由于我们的 Vanilla BERT 的词汇表只有小写字母，因此我们扩展词汇表以涵盖 Σ 中的所有有效字符（通过替换未使用的标记） </li>\n<li>随机变量模型：PassBERT</li>\n</ol>\n<h2 id=\"条件密码猜测\"><a href=\"#条件密码猜测\" class=\"headerlink\" title=\"条件密码猜测\"></a>条件密码猜测</h2><p>任务：pivot（例如，“p ＊ ＊ ＊w0rd ＊ ＊ ＊ ”） ————&gt;恢复密码。<br>建模：掩码语言模型任务，预测缺失字符的 pivot 的条件概率<br>数据构建：使用与 CWAE [38, 39] 相同的策略创建：</p>\n<ol>\n<li>我们以一定比例（即 50%）随机用表示缺失字符的屏蔽符号替换每个字符。</li>\n<li>然后，我们只保留那些包含至少四个可观察字符和至少五个屏蔽符号的生成主元。</li>\n</ol>\n<h3 id=\"微调\"><a href=\"#微调\" class=\"headerlink\" title=\"微调\"></a>微调</h3><p>攻击设计：根据 Pivot 的创建机制调整 屏蔽机制。</p>\n<ol>\n<li>增加掩码比例：只用掩码符号，</li>\n<li>（默认的屏蔽机制结果不佳）<br>模型再训练：从中提取具有正确密码的有效枢轴以进行模型重新训练。<br>评估：<br>CPG 与 CWAE 具有相同的 评估 pivots 。</li>\n<li>对一个 pivot 生成相同数量的候选密码。然后，比较匹配的个数。</li>\n<li>按照匹配的个数分类这些 pivot 。区分不同频率的 pivot 的猜测性能<br>评估集： Neopets 和 Cit0day 空间较大：</li>\n<li>WAE 仅为每个主元类别生成 30 个评估主元，可能会引起偏差。</li>\n<li>我们从评估集中为每个类别总共提取了 120 个评估基准<br>评估指标： 每个 pivot 的平均破解率。<br>结果：很好<br>预训练效果：用密码预训练的效果更好。<br>改进原则：模型通过以递减的概率耗尽屏蔽位置中的字符来生成候选密码，而 CWAE 通过解码器将潜在表示（即高维空间中的点）转换为候选密码。很优<br>计算性能：训练我们的 CPG 模型大约需要 2 天（8.9 MB），训练 CWAE 大约需要一天半的时间（4.4 MB）</li>\n</ol>\n<h2 id=\"定向的密码猜测\"><a href=\"#定向的密码猜测\" class=\"headerlink\" title=\"定向的密码猜测\"></a>定向的密码猜测</h2><p>目标：用历史密码生成其变体<br>目标：对给定的密码训练模型输出编辑路径。</p>\n<h3 id=\"微调：\"><a href=\"#微调：\" class=\"headerlink\" title=\"微调：\"></a>微调：</h3><p>攻击设计： Pass2path 基于 RNN 模型的序列机制将密码转换为编辑路径。Transformer 不支持，修改：使用序列标记机制来预测密码中每个字符的一个编辑操作。其中一系列编辑操作构成编辑路径。在序列标注机制中，每个字符位置只能输出一次编辑操作。</p>\n<p>为了适应序列标记机制，我们预先定义了新的编辑操作如下：保留（keep）、删除（del）和替换（rep1，rep2）这里，替换涉及用一个（表示为rep1）或两个字符替换（表示为rep2）。</p>\n<p>缺陷：无法捕获一些转换，比如：插入三个字符<br>模型结构：<br>![[Pasted image 20240314203049.png]]<br> 修改特定于任务的层以学习密码中每个字符的编辑操作（例如，(op, str)）的概率。<br>模型再训练：<br>遵循 Pass2path [35]，我们在 BreachCompilation 中从同一用户中随机抽取 80% 的密码对，并在最小编辑距离不超过 4 时选择合格的密码对，最终得到 85,269,455 个密码对。</p>\n<p>评估：<br>评估设置： 和 Pass2pass 保证相同数据集训练对<br>评估指标。我们选择特定用户泄露的密码之一作为输入，然后根据 TPG 模型推断其变体（限制为 1,000 次猜测）计算了 Ncracked Naccounts 给出不同猜测（即 10、100 和 1,000）的评估用途&#x2F;帐户之间的破解率<br>实验结果：三个模型都高于 Pass2path</p>\n<p>预训练效果：密码和自然语言模型在 TPG 中表现出边际收益。发现预训练的改进空间仍然很小，这表明预训练的作用较弱。这种现象是可以理解的，因为有针对性的攻击集中在个性化密码转换上，这与预训练模型中的全局密码分布关系不大。两个预训练模型生成的上下文嵌入在帮助理解密码转换方面几乎没有效果。 TPG 往往依赖于任务，主要根据特定攻击的数据集形成其模型参数。</p>\n<p>改进原则：更关注本地角色信息。准确地说，我们的编辑操作二元组 (op, str) 可以比 Pass2path 中使用的三元组操作 (op, str,pos) 减少一维搜索空间，其中 pos 指密码中的位置。 </p>\n<p>看法：随着编辑距离的增加，破解率下降。</p>\n<p>计算性能比较。训练 PassBERT (82 MB) 和 Pass2path (166 MB) 分别需要大约 13.6 和 42 小时。我们根据经验计算得出，两种模型都实现了相似的推理速度。 PassBERT 和 Pass2path 每秒可以推断 4.38 和 4.63 个密码对（pairs&#x2F;s）。</p>\n<h2 id=\"基于自适应规则的密码猜测\"><a href=\"#基于自适应规则的密码猜测\" class=\"headerlink\" title=\"基于自适应规则的密码猜测\"></a>基于自适应规则的密码猜测</h2><p>目标：每个单词仅与选定的自适应修改规则关联以生成猜测。<br>        [37]尝试使用默认变压器，但与 ADaM 相比没有取得实质性改进。<br>本质：找出单词适应的规则。<br>效果：输入单词和规则输出破解的可能性<br>方式：构建分类模型，</p>\n<h3 id=\"微调-1\"><a href=\"#微调-1\" class=\"headerlink\" title=\"微调\"></a>微调</h3><p>捕获整个单词和密码级别的修饰规则之间的自适应关系，因为修饰规则最终适用于单词。<br>监督信号：是在两个假设数据集上带有标记规则（即命中规则）的单词。<br>模型架构：</p>\n<ol>\n<li>修改了特定任务层，推断重整规则和具有焦点损失函数的基本单词之间的自适应概率。</li>\n<li>输出层没有序列长度。<br>模型再训练：</li>\n<li>针对两个规则集训练了两个 APRG 模型</li>\n<li>使用 2 亿个密码作为目标空间</li>\n<li>使用 1000 万条数据作为初始空间</li>\n<li>训练：Ri 是个向量，每个元素对应一个规则的匹配可能性<br> 注意：0和1的比例极其不平衡，即超过95%的标签都是0。因此，我们应用与ADAM相同参数策略的焦点损失[25,37]来关注硬标签。</li>\n<li>设置一个 阈值 来表示规则使用的条件。</li>\n</ol>\n<h3 id=\"评估\"><a href=\"#评估\" class=\"headerlink\" title=\"评估\"></a>评估</h3><p>评估设置：比较了静态和动态模型。<br>专注于单词和规则之间的关系建模，即我们的目标是为单词选择更具适应性的规则，以在相同的猜测下获得更高的猜测效率。<br>评估指标：动态策略模型的最终破解率作为评估指标。<br>试验结果：动态模型和静态模型都高于 ADaMs</p>\n<ol>\n<li> Dynamic PassBERT 在这些模型中实现了最高的破解率，并且在四个实验中比 ADaM 平均提高了 4.86%。</li>\n<li> 静态 ARPG 的显着提前停止是因为每个单词仅与自适应规则关联，其大小小于标准基于规则的攻击中的所有规则。<br>预训练效果：</li>\n<li>密码预训练使 Transformer 的性能优于 ADaM</li>\n<li>用默认 Transformer 基本没改进。所以这些个模型的改进没有效果。<br>改进原则：密码预训练对于 ARPG 的提升有着重要的作用。<br>见解：发现了容易收到攻击的破坏规则。<br>计算性能比较：</li>\n<li>我们两个小时： ADam 需要 十个小时</li>\n<li>推理速度相似。</li>\n</ol>\n<h1 id=\"密码强度估计\"><a href=\"#密码强度估计\" class=\"headerlink\" title=\"密码强度估计\"></a>密码强度估计</h1><h1 id=\"讨论\"><a href=\"#讨论\" class=\"headerlink\" title=\"讨论\"></a>讨论</h1><p>密码双向性：</p>\n<ol>\n<li>双向 Transformer 在文本特征提取方面比自动编码器 (CWAE)、RNN (Pass2path) 或 CNN (ADaMs) 等领先方法效果更好，</li>\n<li>工作[22]已经设置了单向变压器，并显示了双向训练机制在一般猜测任务中的优越性。</li>\n<li>密码具有双向性，对字符进行不同的权重。</li>\n<li>预训练对于提高猜测效率也能起到重要作用。深度学习模型通常由通用预训练层和特定于任务的层组成，其中预训练层的上下文嵌入层可以为任务相关层提供更多上下文信息。<br>预训练的合适场景猜测：<br>密码训练和自然语言训练：只能为有针对性的攻击提供效益</li>\n</ol>\n"},{"_content":"# 关键点\n1. 第一个使用 GANs 生成密码\n\n\n# 摘要\n\n已有工作 HashCat 和 John the Ripper 很成熟，但是还是需要扩展来进一步建模密码；\nPassGAN 使用的是 GAN；\nPassGAN 可以提取相当数量的密码属性，而其他工具没有；\n\n# 引言\n密码常见；用户使用的密码简单；导致密码猜测很有效；\n密码猜测的效率由匹配大量可能密码和特定密码哈希的速度有关；（可能的密码不是穷尽所有组合，而是有一定的候选密码）\n最先进的工具在密码猜测时使用一些启发式算法可以构造许多新的候选密码。\n但是，这些启发式的变换规则基于直觉，而不是基于大型密码数据集的分析。\n\n因此，生成的候选密码覆盖范围小并且这些启发式的变换规则的开发和测试是很耗时的事情；\n总结：当前方法的伸缩较差。\n\n# 我们的方法\n**核心：**训练一个模型自动决定密码的特征和结构，并利用这些知识生成新的候选密码；同时神经网络的训练必须要任何先验知识和属性的假定。\n**比较：**\n1. 马尔可夫模型：隐含地假设所有相关的密码特征都可以用n元语法定义；\n2. 基于规则：只能猜测与可用规则匹配的密码；\n**结果：**\n1. 神经网络生成的密码覆盖范围很广\nGANs：在高维空间中进行密度估计\n\t通过训练一个深度神经网络架构来执行隐式生成建模，该架构会输入一个简单的随机分布（如高斯分布或均匀分布），并生成遵循可用数据分布的样本。\n\t在某种程度上，他们用深度神经网络隐含地模拟了累积分布的逆模型，即 x = F-1 θ (s)，其中 s 是一个均匀分布的随机变量。\n\t训练过程：GAN 使用了一种猫捉老鼠的游戏\n\t1. 其中深度生成网络（G）试图模仿样本的底层分布，\n\t2. 而判别型深度神经网络（D）则试图区分原始训练样本（即 \"真样本\"）和由 G 生成的样本（即 \"假样本\"）。\n\t3. 这种对抗性程序迫使 D 泄露训练数据的相关信息，这些信息有助于 G 充分再现原始数据的分布\n\n# 贡献\n1. 预测率高\n2. 输出质量高于规则\n3. PassGAN 可以输出几乎没有限制的密码猜测数\n4. 实验中 PassGAN猜出来的密码最多，但是生成的候选密码也最多\n5. 与基于深度神经网络的密码猜测算法相比有竞争力。\n6. PassGAN可以用于有效增强密码生成规则\n7. 缺点：\n\t分析：有缺点\n\t1. 优势(表现力、通用性和从样本中自主学习的能力) 和 输出大小方面的成本 之间存在权衡。\n\t2. 基于规则的密码猜测工具可以在极少的尝试次数内生成大量的匹配结果，而 PassGAN 则必须输出更多的密码才能达到同样的效果。\n\t分析：不是问题\n\t1. 密码猜测工具可以很容易地组合在一起，先 hashcat 不行再 PassGAN\n\t2. 存储不是问题，可以离线生成。\n\t结论：用匹配个数作为主要指标是有意义的，而不是匹配生成的速度 \n# 背景知识\n1. GAN\n2. 当前工具，hashcat | JTR \n\t1. 基于字典\n\t2. 基于规则\n\t3. 基于马尔可夫模型： [HC解释](https://www.trustwave.com/en-us/resources/blogs/spiderlabs-blog/hashcat-per-position-markov-chains/)[JTR解释](https://openwall.info/wiki/john/markov)\n\t4. 神经网络的使用（注意点在密码强度估计）\n# 使用\n\n1. 模型：使用改进型 Wasserstein GANs（IWGAN）训练。\n2. 优化器：ADAM 优化器\n3. 参数：\n\t1. 批次大小：\n\t2. 迭代次数：在每次迭代中，GAN 会运行一次生成器迭代和一次或多次判别器迭代。\n\t3. 每次生成器迭代的判别器迭代次数：表示判别器在每次 GAN 迭代中执行的迭代次数。每次生成器迭代的判别器迭代次数设为 10，这是 IWGAN 使用的默认值。\n\t4. 模型维度：表示每个卷积层的维数。我们尝试在生成器和鉴别器中使用 5 个残差层，两个深度神经网络中的每个层都有 128 个维度。\n\t5. 梯度惩罚系数 (λ)：它规定了应用于判别器相对于输入的梯度准则的惩罚。增加该参数可使 GAN 的训练更加稳定。在实验中，我们将梯度惩罚值设为 10。\n\t6. 输出序列长度，表示生成器 (G) 生成的字符串的最大长度。我们将 GAN 生成的序列长度从 32 个字符（IWGAN 的默认长度）修改为 10 个字符，以符合训练过程中使用的密码最大长度。\n\t7. 输入噪声矢量（种子）的大小：它决定了正态分布中的随机数有多少个作为 G 的输入，以生成样本。我们将这一大小设置为 128 个浮点数。\n\t8. 最大示例数：表示要加载的训练项（PassGAN 中为密码）的最大数量。GAN 加载的最大示例数设置为整个训练数据集的大小。\n\t9. ADAM 优化器的超参数：\n\t- 学习率，即调整模型权重的速度 \n\t- 系数 β1，表示梯度运行平均值的衰减率。\n\t- 系数 β2，表示梯度平方运行平均值的衰减速度。\n\t- ADAM 优化器的系数 β1 和 β2 分别设置为 0.5 和 0.9，学习率为$$\n\t10^{-4}\n$$这些参数是 Gulrajani 等人使用的默认值。\n4. 整体结构：\n\t1. 残差块结构\n\t\t![[Pasted image 20240222172953.png]]\n\t2. 生成器和判别器各有五个残差块\n\t\t![[Pasted image 20240222173025.png]]\n5. 运行环境\n\t1. 软件\n\t\t1. IWGAN 的 TensorFlow 版本【代码】\n\t\t2. TensorFlow 1.2.1\n\t\t3. Python 2.7.12\n\t\t4. Ubuntu 16.04.2 LTS\n\t2. 硬件：\n\t\t1.  64GB 内存\n\t\t2. 12 核 2.0 GHz 英特尔至强 CPU \n\t\t3. 英伟达™（NVIDIA®）GeForce GTX 1080 Ti GPU（11GB 全局内存）。\n6. IWGAN\n\t1. 寻常在训练深度神经网络时，最初的训练误差会随着层数的增加而减小。然而，在达到一定层数后，训练误差又开始增加。\n\t2. 但是 ResNet 包含层与层之间的 \"快捷连接\"。这可以看作是对这些层的封装，并以标识函数（图 1 中表示为残差块）的形式实现。通过使用多个连续的残差块，ResNet 可以随着层数的增加不断减少训练误差。\n\t3. PassGAN 中的残差区块由两个一维卷积层组成，并通过整流线性单元（ReLU）激活函数相互连接，如图 1 所示。区块的输入是标识函数，并与 0.3 个卷积层的输出相加，产生区块的输出。\n7. 训练数据\n\t1. RockYou 数据集：选择长度为10，并且选择 80% 作为训练集，20% 作为测试集\n\t2. LinkedIn 数据集：数据是散列形式的，基于规则的系统具有潜在的优势。\n8. 测试方向\n\t1. 相同的密码分布上训练和测试时，PassGAN 的预测效果如果\n\t2. PassGAN 在不同数据集的预测效果\n9. 比较\n\t1. 用 PassGAN 的训练集作为HashCat Best64、HashCat gen2、JTR Spiderlab 规则、马尔可夫模型、PCFG 和 FLA 的输入数据集\n\t\t1. 按频率降序排序的密码实例化了 HashCat 和 JTR 的规则\n\t\t\t1. HashCat Best64 生成了 754,315,842 个密码，其中 361,728,683 个密码是唯一的，长度不超过 10 个字符。请注意，这是 Best64 规则集在给定输入集（即 RockYou 训练集）上生成的最大样本数。\n\t\t\t2. 对于 HashCat gen2 和 JTR SpiderLab，我们从它们的输出中统一抽取了一个大小为 10的9 的随机子集。该子集由长度不超过 10 个字符的密码组成。\n\t\t2. 对于 FLA，我们根据中提供的说明设置了 [44] 中的代码。我们训练了一个包含 2 个隐藏层和 1 个大小为 512 的密集层的模型（全部参数列表见附录 A 表 6）。为了与其他工具保持一致，我们没有对训练集进行任何转换（例如删除符号或将所有字符转换为小写）。训练完成后，FLA 会枚举其输出空间的一个子集，该子集由概率阈值 p 定义：当且仅当一个密码的估计概率至少为 p 时，该密码才属于 FLA 的输出。这样，长度为 10 个字符或以下的密码总数达到了 747,542,984 个。在评估中使用这些密码之前，我们按照概率从大到小进行了排序。\n\t\t3. 我们使用 3-gram Markov 模型生成了 494,369,794 个长度不超过 10 的唯一密码。我们使用该模型的标准配置运行了该模型[18]。\n\t\t4. 我们使用韦尔等人[91]的 PCFG 实现生成了 109 个长度在 10 或以下的唯一密码\n10. 评估\n\t1. 首先评估了 PassGAN 的输出所生成的匹配数\n\t2. 然后将其与 FLA、马尔可夫模型的一种流行的 3-gram 实现[18]、PCFGs [91]以及 JTR 的密码生成规则（SpiderLab 混淆规则[82]）和 HashCat 的密码生成规则（Best64 和 gen2 规则[29]）进行了比较，（这些工具都在本文的训练数据集上做了多年的优化）。\n\t3. 结合 HashCat Best64 对 PassGAN 进行评估的实验结果。最后，我们从概率密度和密码分布的角度对 PassGAN 和 FLA 进行了比较。\n\t4. 如何避免过拟合：\n\t\t1. 比较不同迭代次数时的生成匹配个数，个数开始下降说明即将过拟合\n\t5. 如何 PassGAN 生成密码的质量\n\t\t1. 唯一个数\n\t\t2. 生成的密码和其他数据集的匹配个数\n\t\t3. 结果：\n\t\t\t1. 可以生成不少于其他工具的匹配个数的密码\n\t\t\t2. 且总的密码和其他工具相差在一个数量级之内\n\t\t\t3. 猜测不同于训练数据集的密码时，比基于规则的密码生成更有优势。\n\t6. 结合 PassGAN 和 HashCat\n\t\t1. 首先删除训练集中所有匹配HashCat Best64 的密码 \n\t\t2. 实验结果表明结合后可以匹配更多密码，\n\t\t3. Hashcat 的下新版本的  “slow candidates” 支持了这重结合\n\t7. 比较 PassGAN 和 FLA \n\t\t1. FLA 是一个概率估计模型，本质是一个参数估计模型，会输出密码以及其概率估计\n\t\t2. FLA 受马尔可夫过程限制，变异性与 n-gram 范围有关，而 PassGAN 的变异性更高\n\t\t3. 次数较少时，FLA 的概率模拟不准确，次数较高，两者差不多 \n\n# 结论\n1. PassGAN 很有效，能从一个数据集中猜测另一个数据集的密码\n2. 基于规则的限制很大。\n3. FLA  和 PassGAN 也差不多\n# 总结\n1. 方法是革命性的，无需用户干预就可以生成密码，也无需用户分析密码库\n2. PassGAN 可以输出相同的匹配数目，但是需要输出更多密码，这个成本可以忽略。\n3. 将 PassGAN 的生成模型换位条件 GAN 可以生成特定字符字段的密码\n\n# 专业名词\n\n| 名词 | 含义 |  |\n| ---- | ---- | ---- |\n| leet speak | 黑客文 |  |\n","source":"_posts/论文笔记/PassGAN.md","raw":"# 关键点\n1. 第一个使用 GANs 生成密码\n\n\n# 摘要\n\n已有工作 HashCat 和 John the Ripper 很成熟，但是还是需要扩展来进一步建模密码；\nPassGAN 使用的是 GAN；\nPassGAN 可以提取相当数量的密码属性，而其他工具没有；\n\n# 引言\n密码常见；用户使用的密码简单；导致密码猜测很有效；\n密码猜测的效率由匹配大量可能密码和特定密码哈希的速度有关；（可能的密码不是穷尽所有组合，而是有一定的候选密码）\n最先进的工具在密码猜测时使用一些启发式算法可以构造许多新的候选密码。\n但是，这些启发式的变换规则基于直觉，而不是基于大型密码数据集的分析。\n\n因此，生成的候选密码覆盖范围小并且这些启发式的变换规则的开发和测试是很耗时的事情；\n总结：当前方法的伸缩较差。\n\n# 我们的方法\n**核心：**训练一个模型自动决定密码的特征和结构，并利用这些知识生成新的候选密码；同时神经网络的训练必须要任何先验知识和属性的假定。\n**比较：**\n1. 马尔可夫模型：隐含地假设所有相关的密码特征都可以用n元语法定义；\n2. 基于规则：只能猜测与可用规则匹配的密码；\n**结果：**\n1. 神经网络生成的密码覆盖范围很广\nGANs：在高维空间中进行密度估计\n\t通过训练一个深度神经网络架构来执行隐式生成建模，该架构会输入一个简单的随机分布（如高斯分布或均匀分布），并生成遵循可用数据分布的样本。\n\t在某种程度上，他们用深度神经网络隐含地模拟了累积分布的逆模型，即 x = F-1 θ (s)，其中 s 是一个均匀分布的随机变量。\n\t训练过程：GAN 使用了一种猫捉老鼠的游戏\n\t1. 其中深度生成网络（G）试图模仿样本的底层分布，\n\t2. 而判别型深度神经网络（D）则试图区分原始训练样本（即 \"真样本\"）和由 G 生成的样本（即 \"假样本\"）。\n\t3. 这种对抗性程序迫使 D 泄露训练数据的相关信息，这些信息有助于 G 充分再现原始数据的分布\n\n# 贡献\n1. 预测率高\n2. 输出质量高于规则\n3. PassGAN 可以输出几乎没有限制的密码猜测数\n4. 实验中 PassGAN猜出来的密码最多，但是生成的候选密码也最多\n5. 与基于深度神经网络的密码猜测算法相比有竞争力。\n6. PassGAN可以用于有效增强密码生成规则\n7. 缺点：\n\t分析：有缺点\n\t1. 优势(表现力、通用性和从样本中自主学习的能力) 和 输出大小方面的成本 之间存在权衡。\n\t2. 基于规则的密码猜测工具可以在极少的尝试次数内生成大量的匹配结果，而 PassGAN 则必须输出更多的密码才能达到同样的效果。\n\t分析：不是问题\n\t1. 密码猜测工具可以很容易地组合在一起，先 hashcat 不行再 PassGAN\n\t2. 存储不是问题，可以离线生成。\n\t结论：用匹配个数作为主要指标是有意义的，而不是匹配生成的速度 \n# 背景知识\n1. GAN\n2. 当前工具，hashcat | JTR \n\t1. 基于字典\n\t2. 基于规则\n\t3. 基于马尔可夫模型： [HC解释](https://www.trustwave.com/en-us/resources/blogs/spiderlabs-blog/hashcat-per-position-markov-chains/)[JTR解释](https://openwall.info/wiki/john/markov)\n\t4. 神经网络的使用（注意点在密码强度估计）\n# 使用\n\n1. 模型：使用改进型 Wasserstein GANs（IWGAN）训练。\n2. 优化器：ADAM 优化器\n3. 参数：\n\t1. 批次大小：\n\t2. 迭代次数：在每次迭代中，GAN 会运行一次生成器迭代和一次或多次判别器迭代。\n\t3. 每次生成器迭代的判别器迭代次数：表示判别器在每次 GAN 迭代中执行的迭代次数。每次生成器迭代的判别器迭代次数设为 10，这是 IWGAN 使用的默认值。\n\t4. 模型维度：表示每个卷积层的维数。我们尝试在生成器和鉴别器中使用 5 个残差层，两个深度神经网络中的每个层都有 128 个维度。\n\t5. 梯度惩罚系数 (λ)：它规定了应用于判别器相对于输入的梯度准则的惩罚。增加该参数可使 GAN 的训练更加稳定。在实验中，我们将梯度惩罚值设为 10。\n\t6. 输出序列长度，表示生成器 (G) 生成的字符串的最大长度。我们将 GAN 生成的序列长度从 32 个字符（IWGAN 的默认长度）修改为 10 个字符，以符合训练过程中使用的密码最大长度。\n\t7. 输入噪声矢量（种子）的大小：它决定了正态分布中的随机数有多少个作为 G 的输入，以生成样本。我们将这一大小设置为 128 个浮点数。\n\t8. 最大示例数：表示要加载的训练项（PassGAN 中为密码）的最大数量。GAN 加载的最大示例数设置为整个训练数据集的大小。\n\t9. ADAM 优化器的超参数：\n\t- 学习率，即调整模型权重的速度 \n\t- 系数 β1，表示梯度运行平均值的衰减率。\n\t- 系数 β2，表示梯度平方运行平均值的衰减速度。\n\t- ADAM 优化器的系数 β1 和 β2 分别设置为 0.5 和 0.9，学习率为$$\n\t10^{-4}\n$$这些参数是 Gulrajani 等人使用的默认值。\n4. 整体结构：\n\t1. 残差块结构\n\t\t![[Pasted image 20240222172953.png]]\n\t2. 生成器和判别器各有五个残差块\n\t\t![[Pasted image 20240222173025.png]]\n5. 运行环境\n\t1. 软件\n\t\t1. IWGAN 的 TensorFlow 版本【代码】\n\t\t2. TensorFlow 1.2.1\n\t\t3. Python 2.7.12\n\t\t4. Ubuntu 16.04.2 LTS\n\t2. 硬件：\n\t\t1.  64GB 内存\n\t\t2. 12 核 2.0 GHz 英特尔至强 CPU \n\t\t3. 英伟达™（NVIDIA®）GeForce GTX 1080 Ti GPU（11GB 全局内存）。\n6. IWGAN\n\t1. 寻常在训练深度神经网络时，最初的训练误差会随着层数的增加而减小。然而，在达到一定层数后，训练误差又开始增加。\n\t2. 但是 ResNet 包含层与层之间的 \"快捷连接\"。这可以看作是对这些层的封装，并以标识函数（图 1 中表示为残差块）的形式实现。通过使用多个连续的残差块，ResNet 可以随着层数的增加不断减少训练误差。\n\t3. PassGAN 中的残差区块由两个一维卷积层组成，并通过整流线性单元（ReLU）激活函数相互连接，如图 1 所示。区块的输入是标识函数，并与 0.3 个卷积层的输出相加，产生区块的输出。\n7. 训练数据\n\t1. RockYou 数据集：选择长度为10，并且选择 80% 作为训练集，20% 作为测试集\n\t2. LinkedIn 数据集：数据是散列形式的，基于规则的系统具有潜在的优势。\n8. 测试方向\n\t1. 相同的密码分布上训练和测试时，PassGAN 的预测效果如果\n\t2. PassGAN 在不同数据集的预测效果\n9. 比较\n\t1. 用 PassGAN 的训练集作为HashCat Best64、HashCat gen2、JTR Spiderlab 规则、马尔可夫模型、PCFG 和 FLA 的输入数据集\n\t\t1. 按频率降序排序的密码实例化了 HashCat 和 JTR 的规则\n\t\t\t1. HashCat Best64 生成了 754,315,842 个密码，其中 361,728,683 个密码是唯一的，长度不超过 10 个字符。请注意，这是 Best64 规则集在给定输入集（即 RockYou 训练集）上生成的最大样本数。\n\t\t\t2. 对于 HashCat gen2 和 JTR SpiderLab，我们从它们的输出中统一抽取了一个大小为 10的9 的随机子集。该子集由长度不超过 10 个字符的密码组成。\n\t\t2. 对于 FLA，我们根据中提供的说明设置了 [44] 中的代码。我们训练了一个包含 2 个隐藏层和 1 个大小为 512 的密集层的模型（全部参数列表见附录 A 表 6）。为了与其他工具保持一致，我们没有对训练集进行任何转换（例如删除符号或将所有字符转换为小写）。训练完成后，FLA 会枚举其输出空间的一个子集，该子集由概率阈值 p 定义：当且仅当一个密码的估计概率至少为 p 时，该密码才属于 FLA 的输出。这样，长度为 10 个字符或以下的密码总数达到了 747,542,984 个。在评估中使用这些密码之前，我们按照概率从大到小进行了排序。\n\t\t3. 我们使用 3-gram Markov 模型生成了 494,369,794 个长度不超过 10 的唯一密码。我们使用该模型的标准配置运行了该模型[18]。\n\t\t4. 我们使用韦尔等人[91]的 PCFG 实现生成了 109 个长度在 10 或以下的唯一密码\n10. 评估\n\t1. 首先评估了 PassGAN 的输出所生成的匹配数\n\t2. 然后将其与 FLA、马尔可夫模型的一种流行的 3-gram 实现[18]、PCFGs [91]以及 JTR 的密码生成规则（SpiderLab 混淆规则[82]）和 HashCat 的密码生成规则（Best64 和 gen2 规则[29]）进行了比较，（这些工具都在本文的训练数据集上做了多年的优化）。\n\t3. 结合 HashCat Best64 对 PassGAN 进行评估的实验结果。最后，我们从概率密度和密码分布的角度对 PassGAN 和 FLA 进行了比较。\n\t4. 如何避免过拟合：\n\t\t1. 比较不同迭代次数时的生成匹配个数，个数开始下降说明即将过拟合\n\t5. 如何 PassGAN 生成密码的质量\n\t\t1. 唯一个数\n\t\t2. 生成的密码和其他数据集的匹配个数\n\t\t3. 结果：\n\t\t\t1. 可以生成不少于其他工具的匹配个数的密码\n\t\t\t2. 且总的密码和其他工具相差在一个数量级之内\n\t\t\t3. 猜测不同于训练数据集的密码时，比基于规则的密码生成更有优势。\n\t6. 结合 PassGAN 和 HashCat\n\t\t1. 首先删除训练集中所有匹配HashCat Best64 的密码 \n\t\t2. 实验结果表明结合后可以匹配更多密码，\n\t\t3. Hashcat 的下新版本的  “slow candidates” 支持了这重结合\n\t7. 比较 PassGAN 和 FLA \n\t\t1. FLA 是一个概率估计模型，本质是一个参数估计模型，会输出密码以及其概率估计\n\t\t2. FLA 受马尔可夫过程限制，变异性与 n-gram 范围有关，而 PassGAN 的变异性更高\n\t\t3. 次数较少时，FLA 的概率模拟不准确，次数较高，两者差不多 \n\n# 结论\n1. PassGAN 很有效，能从一个数据集中猜测另一个数据集的密码\n2. 基于规则的限制很大。\n3. FLA  和 PassGAN 也差不多\n# 总结\n1. 方法是革命性的，无需用户干预就可以生成密码，也无需用户分析密码库\n2. PassGAN 可以输出相同的匹配数目，但是需要输出更多密码，这个成本可以忽略。\n3. 将 PassGAN 的生成模型换位条件 GAN 可以生成特定字符字段的密码\n\n# 专业名词\n\n| 名词 | 含义 |  |\n| ---- | ---- | ---- |\n| leet speak | 黑客文 |  |\n","slug":"论文笔记/PassGAN","published":1,"date":"2024-04-22T13:14:48.840Z","updated":"2024-03-19T02:51:34.723Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0j001gkgg4cx387p4z","content":"<h1 id=\"关键点\"><a href=\"#关键点\" class=\"headerlink\" title=\"关键点\"></a>关键点</h1><ol>\n<li>第一个使用 GANs 生成密码</li>\n</ol>\n<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><p>已有工作 HashCat 和 John the Ripper 很成熟，但是还是需要扩展来进一步建模密码；<br>PassGAN 使用的是 GAN；<br>PassGAN 可以提取相当数量的密码属性，而其他工具没有；</p>\n<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>密码常见；用户使用的密码简单；导致密码猜测很有效；<br>密码猜测的效率由匹配大量可能密码和特定密码哈希的速度有关；（可能的密码不是穷尽所有组合，而是有一定的候选密码）<br>最先进的工具在密码猜测时使用一些启发式算法可以构造许多新的候选密码。<br>但是，这些启发式的变换规则基于直觉，而不是基于大型密码数据集的分析。</p>\n<p>因此，生成的候选密码覆盖范围小并且这些启发式的变换规则的开发和测试是很耗时的事情；<br>总结：当前方法的伸缩较差。</p>\n<h1 id=\"我们的方法\"><a href=\"#我们的方法\" class=\"headerlink\" title=\"我们的方法\"></a>我们的方法</h1><p><strong>核心：</strong>训练一个模型自动决定密码的特征和结构，并利用这些知识生成新的候选密码；同时神经网络的训练必须要任何先验知识和属性的假定。<br><strong>比较：</strong></p>\n<ol>\n<li>马尔可夫模型：隐含地假设所有相关的密码特征都可以用n元语法定义；</li>\n<li>基于规则：只能猜测与可用规则匹配的密码；<br><strong>结果：</strong></li>\n<li>神经网络生成的密码覆盖范围很广<br>GANs：在高维空间中进行密度估计<br> 通过训练一个深度神经网络架构来执行隐式生成建模，该架构会输入一个简单的随机分布（如高斯分布或均匀分布），并生成遵循可用数据分布的样本。<br> 在某种程度上，他们用深度神经网络隐含地模拟了累积分布的逆模型，即 x &#x3D; F-1 θ (s)，其中 s 是一个均匀分布的随机变量。<br> 训练过程：GAN 使用了一种猫捉老鼠的游戏<ol>\n<li>其中深度生成网络（G）试图模仿样本的底层分布，</li>\n<li>而判别型深度神经网络（D）则试图区分原始训练样本（即 “真样本”）和由 G 生成的样本（即 “假样本”）。</li>\n<li>这种对抗性程序迫使 D 泄露训练数据的相关信息，这些信息有助于 G 充分再现原始数据的分布</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"贡献\"><a href=\"#贡献\" class=\"headerlink\" title=\"贡献\"></a>贡献</h1><ol>\n<li>预测率高</li>\n<li>输出质量高于规则</li>\n<li>PassGAN 可以输出几乎没有限制的密码猜测数</li>\n<li>实验中 PassGAN猜出来的密码最多，但是生成的候选密码也最多</li>\n<li>与基于深度神经网络的密码猜测算法相比有竞争力。</li>\n<li>PassGAN可以用于有效增强密码生成规则</li>\n<li>缺点：<br> 分析：有缺点<ol>\n<li>优势(表现力、通用性和从样本中自主学习的能力) 和 输出大小方面的成本 之间存在权衡。</li>\n<li>基于规则的密码猜测工具可以在极少的尝试次数内生成大量的匹配结果，而 PassGAN 则必须输出更多的密码才能达到同样的效果。<br> 分析：不是问题</li>\n<li>密码猜测工具可以很容易地组合在一起，先 hashcat 不行再 PassGAN</li>\n<li>存储不是问题，可以离线生成。<br> 结论：用匹配个数作为主要指标是有意义的，而不是匹配生成的速度</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"背景知识\"><a href=\"#背景知识\" class=\"headerlink\" title=\"背景知识\"></a>背景知识</h1><ol>\n<li>GAN</li>\n<li>当前工具，hashcat | JTR <ol>\n<li>基于字典</li>\n<li>基于规则</li>\n<li>基于马尔可夫模型： <a href=\"https://www.trustwave.com/en-us/resources/blogs/spiderlabs-blog/hashcat-per-position-markov-chains/\">HC解释</a><a href=\"https://openwall.info/wiki/john/markov\">JTR解释</a></li>\n<li>神经网络的使用（注意点在密码强度估计）</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><ol>\n<li>模型：使用改进型 Wasserstein GANs（IWGAN）训练。</li>\n<li>优化器：ADAM 优化器</li>\n<li>参数：<ol>\n<li>批次大小：</li>\n<li>迭代次数：在每次迭代中，GAN 会运行一次生成器迭代和一次或多次判别器迭代。</li>\n<li>每次生成器迭代的判别器迭代次数：表示判别器在每次 GAN 迭代中执行的迭代次数。每次生成器迭代的判别器迭代次数设为 10，这是 IWGAN 使用的默认值。</li>\n<li>模型维度：表示每个卷积层的维数。我们尝试在生成器和鉴别器中使用 5 个残差层，两个深度神经网络中的每个层都有 128 个维度。</li>\n<li>梯度惩罚系数 (λ)：它规定了应用于判别器相对于输入的梯度准则的惩罚。增加该参数可使 GAN 的训练更加稳定。在实验中，我们将梯度惩罚值设为 10。</li>\n<li>输出序列长度，表示生成器 (G) 生成的字符串的最大长度。我们将 GAN 生成的序列长度从 32 个字符（IWGAN 的默认长度）修改为 10 个字符，以符合训练过程中使用的密码最大长度。</li>\n<li>输入噪声矢量（种子）的大小：它决定了正态分布中的随机数有多少个作为 G 的输入，以生成样本。我们将这一大小设置为 128 个浮点数。</li>\n<li>最大示例数：表示要加载的训练项（PassGAN 中为密码）的最大数量。GAN 加载的最大示例数设置为整个训练数据集的大小。</li>\n<li>ADAM 优化器的超参数：</li>\n</ol>\n<ul>\n<li>学习率，即调整模型权重的速度 </li>\n<li>系数 β1，表示梯度运行平均值的衰减率。</li>\n<li>系数 β2，表示梯度平方运行平均值的衰减速度。</li>\n<li>ADAM 优化器的系数 β1 和 β2 分别设置为 0.5 和 0.9，学习率为$$<br> 10^{-4}<br>$$这些参数是 Gulrajani 等人使用的默认值。</li>\n</ul>\n</li>\n<li>整体结构：<ol>\n<li>残差块结构<br> ![[Pasted image 20240222172953.png]]</li>\n<li>生成器和判别器各有五个残差块<br> ![[Pasted image 20240222173025.png]]</li>\n</ol>\n</li>\n<li>运行环境<ol>\n<li>软件<ol>\n<li>IWGAN 的 TensorFlow 版本【代码】</li>\n<li>TensorFlow 1.2.1</li>\n<li>Python 2.7.12</li>\n<li>Ubuntu 16.04.2 LTS</li>\n</ol>\n</li>\n<li>硬件：<ol>\n<li> 64GB 内存</li>\n<li>12 核 2.0 GHz 英特尔至强 CPU </li>\n<li>英伟达™（NVIDIA®）GeForce GTX 1080 Ti GPU（11GB 全局内存）。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>IWGAN<ol>\n<li>寻常在训练深度神经网络时，最初的训练误差会随着层数的增加而减小。然而，在达到一定层数后，训练误差又开始增加。</li>\n<li>但是 ResNet 包含层与层之间的 “快捷连接”。这可以看作是对这些层的封装，并以标识函数（图 1 中表示为残差块）的形式实现。通过使用多个连续的残差块，ResNet 可以随着层数的增加不断减少训练误差。</li>\n<li>PassGAN 中的残差区块由两个一维卷积层组成，并通过整流线性单元（ReLU）激活函数相互连接，如图 1 所示。区块的输入是标识函数，并与 0.3 个卷积层的输出相加，产生区块的输出。</li>\n</ol>\n</li>\n<li>训练数据<ol>\n<li>RockYou 数据集：选择长度为10，并且选择 80% 作为训练集，20% 作为测试集</li>\n<li>LinkedIn 数据集：数据是散列形式的，基于规则的系统具有潜在的优势。</li>\n</ol>\n</li>\n<li>测试方向<ol>\n<li>相同的密码分布上训练和测试时，PassGAN 的预测效果如果</li>\n<li>PassGAN 在不同数据集的预测效果</li>\n</ol>\n</li>\n<li>比较<ol>\n<li>用 PassGAN 的训练集作为HashCat Best64、HashCat gen2、JTR Spiderlab 规则、马尔可夫模型、PCFG 和 FLA 的输入数据集<ol>\n<li>按频率降序排序的密码实例化了 HashCat 和 JTR 的规则<ol>\n<li>HashCat Best64 生成了 754,315,842 个密码，其中 361,728,683 个密码是唯一的，长度不超过 10 个字符。请注意，这是 Best64 规则集在给定输入集（即 RockYou 训练集）上生成的最大样本数。</li>\n<li>对于 HashCat gen2 和 JTR SpiderLab，我们从它们的输出中统一抽取了一个大小为 10的9 的随机子集。该子集由长度不超过 10 个字符的密码组成。</li>\n</ol>\n</li>\n<li>对于 FLA，我们根据中提供的说明设置了 [44] 中的代码。我们训练了一个包含 2 个隐藏层和 1 个大小为 512 的密集层的模型（全部参数列表见附录 A 表 6）。为了与其他工具保持一致，我们没有对训练集进行任何转换（例如删除符号或将所有字符转换为小写）。训练完成后，FLA 会枚举其输出空间的一个子集，该子集由概率阈值 p 定义：当且仅当一个密码的估计概率至少为 p 时，该密码才属于 FLA 的输出。这样，长度为 10 个字符或以下的密码总数达到了 747,542,984 个。在评估中使用这些密码之前，我们按照概率从大到小进行了排序。</li>\n<li>我们使用 3-gram Markov 模型生成了 494,369,794 个长度不超过 10 的唯一密码。我们使用该模型的标准配置运行了该模型[18]。</li>\n<li>我们使用韦尔等人[91]的 PCFG 实现生成了 109 个长度在 10 或以下的唯一密码</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>评估<ol>\n<li>首先评估了 PassGAN 的输出所生成的匹配数</li>\n<li>然后将其与 FLA、马尔可夫模型的一种流行的 3-gram 实现[18]、PCFGs [91]以及 JTR 的密码生成规则（SpiderLab 混淆规则[82]）和 HashCat 的密码生成规则（Best64 和 gen2 规则[29]）进行了比较，（这些工具都在本文的训练数据集上做了多年的优化）。</li>\n<li>结合 HashCat Best64 对 PassGAN 进行评估的实验结果。最后，我们从概率密度和密码分布的角度对 PassGAN 和 FLA 进行了比较。</li>\n<li>如何避免过拟合：<ol>\n<li>比较不同迭代次数时的生成匹配个数，个数开始下降说明即将过拟合</li>\n</ol>\n</li>\n<li>如何 PassGAN 生成密码的质量<ol>\n<li>唯一个数</li>\n<li>生成的密码和其他数据集的匹配个数</li>\n<li>结果：<ol>\n<li>可以生成不少于其他工具的匹配个数的密码</li>\n<li>且总的密码和其他工具相差在一个数量级之内</li>\n<li>猜测不同于训练数据集的密码时，比基于规则的密码生成更有优势。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>结合 PassGAN 和 HashCat<ol>\n<li>首先删除训练集中所有匹配HashCat Best64 的密码 </li>\n<li>实验结果表明结合后可以匹配更多密码，</li>\n<li>Hashcat 的下新版本的  “slow candidates” 支持了这重结合</li>\n</ol>\n</li>\n<li>比较 PassGAN 和 FLA <ol>\n<li>FLA 是一个概率估计模型，本质是一个参数估计模型，会输出密码以及其概率估计</li>\n<li>FLA 受马尔可夫过程限制，变异性与 n-gram 范围有关，而 PassGAN 的变异性更高</li>\n<li>次数较少时，FLA 的概率模拟不准确，次数较高，两者差不多</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><ol>\n<li>PassGAN 很有效，能从一个数据集中猜测另一个数据集的密码</li>\n<li>基于规则的限制很大。</li>\n<li>FLA  和 PassGAN 也差不多</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ol>\n<li>方法是革命性的，无需用户干预就可以生成密码，也无需用户分析密码库</li>\n<li>PassGAN 可以输出相同的匹配数目，但是需要输出更多密码，这个成本可以忽略。</li>\n<li>将 PassGAN 的生成模型换位条件 GAN 可以生成特定字符字段的密码</li>\n</ol>\n<h1 id=\"专业名词\"><a href=\"#专业名词\" class=\"headerlink\" title=\"专业名词\"></a>专业名词</h1><table>\n<thead>\n<tr>\n<th>名词</th>\n<th>含义</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>leet speak</td>\n<td>黑客文</td>\n<td></td>\n</tr>\n</tbody></table>\n","excerpt":"","more":"<h1 id=\"关键点\"><a href=\"#关键点\" class=\"headerlink\" title=\"关键点\"></a>关键点</h1><ol>\n<li>第一个使用 GANs 生成密码</li>\n</ol>\n<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><p>已有工作 HashCat 和 John the Ripper 很成熟，但是还是需要扩展来进一步建模密码；<br>PassGAN 使用的是 GAN；<br>PassGAN 可以提取相当数量的密码属性，而其他工具没有；</p>\n<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>密码常见；用户使用的密码简单；导致密码猜测很有效；<br>密码猜测的效率由匹配大量可能密码和特定密码哈希的速度有关；（可能的密码不是穷尽所有组合，而是有一定的候选密码）<br>最先进的工具在密码猜测时使用一些启发式算法可以构造许多新的候选密码。<br>但是，这些启发式的变换规则基于直觉，而不是基于大型密码数据集的分析。</p>\n<p>因此，生成的候选密码覆盖范围小并且这些启发式的变换规则的开发和测试是很耗时的事情；<br>总结：当前方法的伸缩较差。</p>\n<h1 id=\"我们的方法\"><a href=\"#我们的方法\" class=\"headerlink\" title=\"我们的方法\"></a>我们的方法</h1><p><strong>核心：</strong>训练一个模型自动决定密码的特征和结构，并利用这些知识生成新的候选密码；同时神经网络的训练必须要任何先验知识和属性的假定。<br><strong>比较：</strong></p>\n<ol>\n<li>马尔可夫模型：隐含地假设所有相关的密码特征都可以用n元语法定义；</li>\n<li>基于规则：只能猜测与可用规则匹配的密码；<br><strong>结果：</strong></li>\n<li>神经网络生成的密码覆盖范围很广<br>GANs：在高维空间中进行密度估计<br> 通过训练一个深度神经网络架构来执行隐式生成建模，该架构会输入一个简单的随机分布（如高斯分布或均匀分布），并生成遵循可用数据分布的样本。<br> 在某种程度上，他们用深度神经网络隐含地模拟了累积分布的逆模型，即 x &#x3D; F-1 θ (s)，其中 s 是一个均匀分布的随机变量。<br> 训练过程：GAN 使用了一种猫捉老鼠的游戏<ol>\n<li>其中深度生成网络（G）试图模仿样本的底层分布，</li>\n<li>而判别型深度神经网络（D）则试图区分原始训练样本（即 “真样本”）和由 G 生成的样本（即 “假样本”）。</li>\n<li>这种对抗性程序迫使 D 泄露训练数据的相关信息，这些信息有助于 G 充分再现原始数据的分布</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"贡献\"><a href=\"#贡献\" class=\"headerlink\" title=\"贡献\"></a>贡献</h1><ol>\n<li>预测率高</li>\n<li>输出质量高于规则</li>\n<li>PassGAN 可以输出几乎没有限制的密码猜测数</li>\n<li>实验中 PassGAN猜出来的密码最多，但是生成的候选密码也最多</li>\n<li>与基于深度神经网络的密码猜测算法相比有竞争力。</li>\n<li>PassGAN可以用于有效增强密码生成规则</li>\n<li>缺点：<br> 分析：有缺点<ol>\n<li>优势(表现力、通用性和从样本中自主学习的能力) 和 输出大小方面的成本 之间存在权衡。</li>\n<li>基于规则的密码猜测工具可以在极少的尝试次数内生成大量的匹配结果，而 PassGAN 则必须输出更多的密码才能达到同样的效果。<br> 分析：不是问题</li>\n<li>密码猜测工具可以很容易地组合在一起，先 hashcat 不行再 PassGAN</li>\n<li>存储不是问题，可以离线生成。<br> 结论：用匹配个数作为主要指标是有意义的，而不是匹配生成的速度</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"背景知识\"><a href=\"#背景知识\" class=\"headerlink\" title=\"背景知识\"></a>背景知识</h1><ol>\n<li>GAN</li>\n<li>当前工具，hashcat | JTR <ol>\n<li>基于字典</li>\n<li>基于规则</li>\n<li>基于马尔可夫模型： <a href=\"https://www.trustwave.com/en-us/resources/blogs/spiderlabs-blog/hashcat-per-position-markov-chains/\">HC解释</a><a href=\"https://openwall.info/wiki/john/markov\">JTR解释</a></li>\n<li>神经网络的使用（注意点在密码强度估计）</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><ol>\n<li>模型：使用改进型 Wasserstein GANs（IWGAN）训练。</li>\n<li>优化器：ADAM 优化器</li>\n<li>参数：<ol>\n<li>批次大小：</li>\n<li>迭代次数：在每次迭代中，GAN 会运行一次生成器迭代和一次或多次判别器迭代。</li>\n<li>每次生成器迭代的判别器迭代次数：表示判别器在每次 GAN 迭代中执行的迭代次数。每次生成器迭代的判别器迭代次数设为 10，这是 IWGAN 使用的默认值。</li>\n<li>模型维度：表示每个卷积层的维数。我们尝试在生成器和鉴别器中使用 5 个残差层，两个深度神经网络中的每个层都有 128 个维度。</li>\n<li>梯度惩罚系数 (λ)：它规定了应用于判别器相对于输入的梯度准则的惩罚。增加该参数可使 GAN 的训练更加稳定。在实验中，我们将梯度惩罚值设为 10。</li>\n<li>输出序列长度，表示生成器 (G) 生成的字符串的最大长度。我们将 GAN 生成的序列长度从 32 个字符（IWGAN 的默认长度）修改为 10 个字符，以符合训练过程中使用的密码最大长度。</li>\n<li>输入噪声矢量（种子）的大小：它决定了正态分布中的随机数有多少个作为 G 的输入，以生成样本。我们将这一大小设置为 128 个浮点数。</li>\n<li>最大示例数：表示要加载的训练项（PassGAN 中为密码）的最大数量。GAN 加载的最大示例数设置为整个训练数据集的大小。</li>\n<li>ADAM 优化器的超参数：</li>\n</ol>\n<ul>\n<li>学习率，即调整模型权重的速度 </li>\n<li>系数 β1，表示梯度运行平均值的衰减率。</li>\n<li>系数 β2，表示梯度平方运行平均值的衰减速度。</li>\n<li>ADAM 优化器的系数 β1 和 β2 分别设置为 0.5 和 0.9，学习率为$$<br> 10^{-4}<br>$$这些参数是 Gulrajani 等人使用的默认值。</li>\n</ul>\n</li>\n<li>整体结构：<ol>\n<li>残差块结构<br> ![[Pasted image 20240222172953.png]]</li>\n<li>生成器和判别器各有五个残差块<br> ![[Pasted image 20240222173025.png]]</li>\n</ol>\n</li>\n<li>运行环境<ol>\n<li>软件<ol>\n<li>IWGAN 的 TensorFlow 版本【代码】</li>\n<li>TensorFlow 1.2.1</li>\n<li>Python 2.7.12</li>\n<li>Ubuntu 16.04.2 LTS</li>\n</ol>\n</li>\n<li>硬件：<ol>\n<li> 64GB 内存</li>\n<li>12 核 2.0 GHz 英特尔至强 CPU </li>\n<li>英伟达™（NVIDIA®）GeForce GTX 1080 Ti GPU（11GB 全局内存）。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>IWGAN<ol>\n<li>寻常在训练深度神经网络时，最初的训练误差会随着层数的增加而减小。然而，在达到一定层数后，训练误差又开始增加。</li>\n<li>但是 ResNet 包含层与层之间的 “快捷连接”。这可以看作是对这些层的封装，并以标识函数（图 1 中表示为残差块）的形式实现。通过使用多个连续的残差块，ResNet 可以随着层数的增加不断减少训练误差。</li>\n<li>PassGAN 中的残差区块由两个一维卷积层组成，并通过整流线性单元（ReLU）激活函数相互连接，如图 1 所示。区块的输入是标识函数，并与 0.3 个卷积层的输出相加，产生区块的输出。</li>\n</ol>\n</li>\n<li>训练数据<ol>\n<li>RockYou 数据集：选择长度为10，并且选择 80% 作为训练集，20% 作为测试集</li>\n<li>LinkedIn 数据集：数据是散列形式的，基于规则的系统具有潜在的优势。</li>\n</ol>\n</li>\n<li>测试方向<ol>\n<li>相同的密码分布上训练和测试时，PassGAN 的预测效果如果</li>\n<li>PassGAN 在不同数据集的预测效果</li>\n</ol>\n</li>\n<li>比较<ol>\n<li>用 PassGAN 的训练集作为HashCat Best64、HashCat gen2、JTR Spiderlab 规则、马尔可夫模型、PCFG 和 FLA 的输入数据集<ol>\n<li>按频率降序排序的密码实例化了 HashCat 和 JTR 的规则<ol>\n<li>HashCat Best64 生成了 754,315,842 个密码，其中 361,728,683 个密码是唯一的，长度不超过 10 个字符。请注意，这是 Best64 规则集在给定输入集（即 RockYou 训练集）上生成的最大样本数。</li>\n<li>对于 HashCat gen2 和 JTR SpiderLab，我们从它们的输出中统一抽取了一个大小为 10的9 的随机子集。该子集由长度不超过 10 个字符的密码组成。</li>\n</ol>\n</li>\n<li>对于 FLA，我们根据中提供的说明设置了 [44] 中的代码。我们训练了一个包含 2 个隐藏层和 1 个大小为 512 的密集层的模型（全部参数列表见附录 A 表 6）。为了与其他工具保持一致，我们没有对训练集进行任何转换（例如删除符号或将所有字符转换为小写）。训练完成后，FLA 会枚举其输出空间的一个子集，该子集由概率阈值 p 定义：当且仅当一个密码的估计概率至少为 p 时，该密码才属于 FLA 的输出。这样，长度为 10 个字符或以下的密码总数达到了 747,542,984 个。在评估中使用这些密码之前，我们按照概率从大到小进行了排序。</li>\n<li>我们使用 3-gram Markov 模型生成了 494,369,794 个长度不超过 10 的唯一密码。我们使用该模型的标准配置运行了该模型[18]。</li>\n<li>我们使用韦尔等人[91]的 PCFG 实现生成了 109 个长度在 10 或以下的唯一密码</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>评估<ol>\n<li>首先评估了 PassGAN 的输出所生成的匹配数</li>\n<li>然后将其与 FLA、马尔可夫模型的一种流行的 3-gram 实现[18]、PCFGs [91]以及 JTR 的密码生成规则（SpiderLab 混淆规则[82]）和 HashCat 的密码生成规则（Best64 和 gen2 规则[29]）进行了比较，（这些工具都在本文的训练数据集上做了多年的优化）。</li>\n<li>结合 HashCat Best64 对 PassGAN 进行评估的实验结果。最后，我们从概率密度和密码分布的角度对 PassGAN 和 FLA 进行了比较。</li>\n<li>如何避免过拟合：<ol>\n<li>比较不同迭代次数时的生成匹配个数，个数开始下降说明即将过拟合</li>\n</ol>\n</li>\n<li>如何 PassGAN 生成密码的质量<ol>\n<li>唯一个数</li>\n<li>生成的密码和其他数据集的匹配个数</li>\n<li>结果：<ol>\n<li>可以生成不少于其他工具的匹配个数的密码</li>\n<li>且总的密码和其他工具相差在一个数量级之内</li>\n<li>猜测不同于训练数据集的密码时，比基于规则的密码生成更有优势。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>结合 PassGAN 和 HashCat<ol>\n<li>首先删除训练集中所有匹配HashCat Best64 的密码 </li>\n<li>实验结果表明结合后可以匹配更多密码，</li>\n<li>Hashcat 的下新版本的  “slow candidates” 支持了这重结合</li>\n</ol>\n</li>\n<li>比较 PassGAN 和 FLA <ol>\n<li>FLA 是一个概率估计模型，本质是一个参数估计模型，会输出密码以及其概率估计</li>\n<li>FLA 受马尔可夫过程限制，变异性与 n-gram 范围有关，而 PassGAN 的变异性更高</li>\n<li>次数较少时，FLA 的概率模拟不准确，次数较高，两者差不多</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><ol>\n<li>PassGAN 很有效，能从一个数据集中猜测另一个数据集的密码</li>\n<li>基于规则的限制很大。</li>\n<li>FLA  和 PassGAN 也差不多</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ol>\n<li>方法是革命性的，无需用户干预就可以生成密码，也无需用户分析密码库</li>\n<li>PassGAN 可以输出相同的匹配数目，但是需要输出更多密码，这个成本可以忽略。</li>\n<li>将 PassGAN 的生成模型换位条件 GAN 可以生成特定字符字段的密码</li>\n</ol>\n<h1 id=\"专业名词\"><a href=\"#专业名词\" class=\"headerlink\" title=\"专业名词\"></a>专业名词</h1><table>\n<thead>\n<tr>\n<th>名词</th>\n<th>含义</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>leet speak</td>\n<td>黑客文</td>\n<td></td>\n</tr>\n</tbody></table>\n"},{"_content":"# 摘要\n1. LLM 无需显式监督： PassGPT\n2. 引导密码生成：利用 PassGPT 来生成匹配任意约束的密码。\n# 引言\n贡献：\n1. 密码猜测\n2. 密码强度估计\nPassGPT 多猜测 20% 的未见过的密码，并且对新的泄露展现了良好的泛化能力。\n此外，我们通过矢量量化增强了 PassGPT [55]。由此产生的架构是 PassVQT，它可以增加生成密码的复杂性。\n\n与之前整体生成密码的深度生成模型不同，PassGPT 对每个字符进行顺序采样，从而引入了引导密码生成的新颖任务。此方法确保对搜索空间进行更细粒度（字符级）的引导探索，其中根据任意约束对生成的密码进行采样。\n\n最后，与 GAN 相比，PassGPT 提供了密码概率分布的明确表示。我们证明密码概率与最先进的密码强度估计器一致：PassGPT 为更强的密码分配较低的概率。\n\n总结如下：\n– 我们引入了 PassGPT，一种自回归转换器，它在密码生成和对未见过的数据集的泛化方面获得了最先进的结果。 \n– 我们展示 PassGPT 如何在任意约束下启用一种新颖的密码生成方法：引导密码生成。 \n– 我们检查 PassGPT 下的密码概率以及它们如何与强度保持一致。我们讨论如何使用该指标来改进当前强度估计器。 \n – 我们提出了 PassVQT，这是一种通过矢量量化增强的类似架构，以增加生成的复杂性。\n\n# 实验设置\n\n\n## 数据集\n![[Pasted image 20240319110425.png]]\n1. 最主要的是  RockYou 和 LinkedIn\n2. 对于 RockYou，我们分别获取最多 10 个和 16 个字符的所有密码列表。\n\t1. 我们将此列表中的 80% 作为训练数据。\n\t2. 在剩下的 20% 中，我们将训练分割中未包含的所有密码保留为测试数据，仅保留频率较低的密码。\n\t\t1. 测试集中最常用的密码仅出现了7 次\n\t\t2. 平均频率为 1.03\n\t\t3. 有助于测试生成低概率密码的能力。\n3. 对于 LinkedIn \n\t1. LinkedIn 泄露事件没有提供有关密码频率的信息，因此我们将 80% 作为训练数据，其余 20% 用于评估。同样保证没有相同的数据 同时 出现在两组中\n\t2. 评估集中删除 RockYou 训练密码来定义交叉评估测试集，反之亦然，以评估对未见分布的泛化。\n4. 最后，我们还将 MySpace、phpBB 和 Hotmail [52] 泄漏视为评估集。我们执行类似的交叉评估程序，从所有数据中删除 RockYou 和 LinkedIn 训练数据。 OST 10 OST。\n\n## 模型\n自回归生成模型。PassGPT 和PassVQT 对密码中某个字符的出现概率进行建模，给定前面的值，对密码中某个字符的概率进行建模，给定前面的值，从分布中顺序采样可以生成可能的密码。\n1. 模型在词汇表 Σ 上运行，包含 256 个 UTF-8 字符。\n2. tokenizer 定义为将词汇表中的每个字符 σ 映射为整数的函数，分词器：Σ 7→ [0, |Σ| − 1]。\n3. 然后，在 tokenizer 函数下使用其图像的 one-hot 编码为每个 token σ 创建向量表示。这会产生一个维度向量 |Σ|，在标记器 (σ) 位置处所有条目均等于 0，单个条目等于 1。\n### PassGPT\n![[Pasted image 20240319150308.png]]\nGPT 模型利用 Transformer 的解码器组件，并经过训练以自回归方式预测序列中的下一个标记。\n1. 为了预测密码中的特定字符 xi，转换器解码器仅考虑之前的字符 x0,...。 。 。 ，xi−1 作为输入，\n2. 并输出一个维度为 d 的潜在向量（在我们的工作中 d = 768）。\n3. 然后这个潜在向量被映射到维度 |Σ| 的实数向量通过线性层并使用 softmax 函数进一步转换为词汇表上的概率分布。\n4. 词汇表上的输出分布表示 p(xi|x<i; θ)。使用相对于在该位置找到的真实字符的独热编码表示的交叉熵损失来优化该分布。\n一旦网络经过训练，它就会为我们提供基于先前标记的词汇表的参数化分布，即 p(xi|x<i; θ)。\n1. 我们可以从密码开始标记 <\\s>  开始，并找到 p(x1|x0 = <\\s>)。这为我们词汇表中的每个字符分配了成为密码中第一个标记的概率。如果我们从这个分布中采样，我们可以固定第一个字符并通过计算 p(x2|x0, x1) 重复该过程来找到第二个字符。当在任何给定步骤从分布中采样到密码结束标记 <\\/s> 时，密码采样过程即告完成。\n\t1. 与训练不同，此过程是连续的。我们的 PassGPT 实现使用 HuggingFace 库 [53]，并具有以下规范：12 个注意力头、8 个解码器层和 GeLU 激活 [24]。此外，我们使用 AdamW 优化器对所有模型进行 1 轮训练，起始学习率为 5e-5，训练期间线性衰减。\n# PassVQT\n使用潜在空间的矢量量化增强了转换器架构。在计算机视觉领域，这已被证明可以提高样本质量[55]。 PassVQT 遵循 Yu 等人设计的架构。  [55]。 \n1. 在对与 PassGPT 相同的条件分布进行建模时，我们的目标是评估量化是否可以提供任何额外的好处。\n2. 在图 2 所示的架构中，变压器编码器将每个输入标记映射到维度为 768 的潜在表示。\n3. 然后使用线性层将该潜在表示映射到 10 维，并使用 k 均值和具有 N 的码本进行量化条目。量化的 10 维向量通过线性层映射回 768 维，并作为变压器自回归解码器的输入。\n4. 该解码器经过训练，可以仅使用先前标记的量化表示来逐个字符地重建输入密码。\n5. 我们通过最小化 RockYou 泄漏训练分割的重建损失来进行超参数搜索。\n6. 我们的研究结果表明，更深的编码器和解码器结构可以提供更好的结果，码本大小为 300 可以提供最佳性能。\n7. PassVQT 采用变压器编码器和 GPT-2 解码器，分别具有 12 个注意力头和 8 个层。它是使用 HuggingFace 库 [53] 实现的，并使用 AdamW 优化器进行端到端训练，起始学习率为 5e-5，具有线性衰减。一旦编码器-解码器网络收敛，该模型就可以从压缩的量化潜在表示重建输入密码。如果我们对潜在代码的分布进行建模，我们可以从中采样以生成可能的代码序列，然后解码器可以将其转换为可能的密码。为此，我们在训练数据集的量化表示上训练自回归代码模型。在推理过程中，我们通过从代码模型中采样代码序列并使用原始解码器将它们转换为密码来创建新密码。不再需要编码器。\n\n4.3 引导式生成 \n我们提出了一种新颖的密码生成方法：引导式密码生成。\n与之前生成整体密码的深度生成方法不同，PassGPT 分别对每个令牌进行建模，从而授予对每个字符的完全控制权。\n这使得生成过程能够满足特定的约束。\n这些限制的一些示例包括：密码长度、固定字符（例如，第一个位置的“a”）和模板（例如，四个小写字母和两个数字）。\n这可以通过限制采样分布 p(xi|x0, · · ·, xi−1) 以仅考虑分配给感兴趣子集 Σ′ ⊂ Σ 的概率质量来实现；例如，限制 Σ′。\n\n## 实验结果\n将 PassGPT 和 PassVQT 和最新的深度生成模型，并演示了它们对不同数据集的泛化，而无需进一步训练。\n检查了 PassGPT 下密码的概率和熵，以深入了解其功能和建模分布。\n\n训练集的两种变体：（1）唯一密码和（2）所有出现的密码。\n1. 在使用唯一密码进行训练时，PassGPT 表现出卓越的泛化能力，\n2. 相反，在使用唯一条目进行训练时，PassVQT 会遇到生成分发内密码的困难，但在合并其绝对出现次数后会显着改进。\n3. 从 PassGPT（针对唯一密码进行训练）和 PassVQT（针对所有密码进行训练）中对越来越大的密码猜测池进行采样，对越来越大的密码猜测池进行采样，并计算它们恢复的 RockYou 测试分割的百分比。\n4. 结果表明 PassGPT 优于所有其他模型。它在 109 个猜测中恢复了测试集的 41.9%，而最先进的 GAN 模型的匹配率为 23.33%。 \n\n密码生成评估的另一个重要因素是生成新颖且独特样本的能力。\n\t在 109 次猜测中，PassGPT 保留唯一密码的比例最高 (60%)，而 PassVQT 则下降至 20%。由于 PassVQT 是针对所有出现的密码进行训练的，因此在其发行版下\n\n测试集的恢复比例\n![[Pasted image 20240327105738.png]]\n\n长密码效率：\nPassGPT 在对独特样本进行训练时表现最佳，PassVQT 现在在使用唯一密码进行训练时获得了更好的性能。在对这个新分布进行训练后，模型保持了相似的准确性。从 108 个猜测中，PassGPT 和 PassVQT 分别恢复了测试集的 15.5% 和 8.57%，而在 10 个字符设置中则为 19.37% 和 10.30%。\n\n模型对为见过密码分布的泛化能力：。分别用 RockYou 和 LinkedIn 的数据集进行训练，然后都用  LinkedIn 的测试集测试。\n![[Pasted image 20240327142047.png]]\n\n用 Rockyou 训练的模型 泛化效果更好\n![[Pasted image 20240327111524.png]]\n","source":"_posts/论文笔记/PassGPT.md","raw":"# 摘要\n1. LLM 无需显式监督： PassGPT\n2. 引导密码生成：利用 PassGPT 来生成匹配任意约束的密码。\n# 引言\n贡献：\n1. 密码猜测\n2. 密码强度估计\nPassGPT 多猜测 20% 的未见过的密码，并且对新的泄露展现了良好的泛化能力。\n此外，我们通过矢量量化增强了 PassGPT [55]。由此产生的架构是 PassVQT，它可以增加生成密码的复杂性。\n\n与之前整体生成密码的深度生成模型不同，PassGPT 对每个字符进行顺序采样，从而引入了引导密码生成的新颖任务。此方法确保对搜索空间进行更细粒度（字符级）的引导探索，其中根据任意约束对生成的密码进行采样。\n\n最后，与 GAN 相比，PassGPT 提供了密码概率分布的明确表示。我们证明密码概率与最先进的密码强度估计器一致：PassGPT 为更强的密码分配较低的概率。\n\n总结如下：\n– 我们引入了 PassGPT，一种自回归转换器，它在密码生成和对未见过的数据集的泛化方面获得了最先进的结果。 \n– 我们展示 PassGPT 如何在任意约束下启用一种新颖的密码生成方法：引导密码生成。 \n– 我们检查 PassGPT 下的密码概率以及它们如何与强度保持一致。我们讨论如何使用该指标来改进当前强度估计器。 \n – 我们提出了 PassVQT，这是一种通过矢量量化增强的类似架构，以增加生成的复杂性。\n\n# 实验设置\n\n\n## 数据集\n![[Pasted image 20240319110425.png]]\n1. 最主要的是  RockYou 和 LinkedIn\n2. 对于 RockYou，我们分别获取最多 10 个和 16 个字符的所有密码列表。\n\t1. 我们将此列表中的 80% 作为训练数据。\n\t2. 在剩下的 20% 中，我们将训练分割中未包含的所有密码保留为测试数据，仅保留频率较低的密码。\n\t\t1. 测试集中最常用的密码仅出现了7 次\n\t\t2. 平均频率为 1.03\n\t\t3. 有助于测试生成低概率密码的能力。\n3. 对于 LinkedIn \n\t1. LinkedIn 泄露事件没有提供有关密码频率的信息，因此我们将 80% 作为训练数据，其余 20% 用于评估。同样保证没有相同的数据 同时 出现在两组中\n\t2. 评估集中删除 RockYou 训练密码来定义交叉评估测试集，反之亦然，以评估对未见分布的泛化。\n4. 最后，我们还将 MySpace、phpBB 和 Hotmail [52] 泄漏视为评估集。我们执行类似的交叉评估程序，从所有数据中删除 RockYou 和 LinkedIn 训练数据。 OST 10 OST。\n\n## 模型\n自回归生成模型。PassGPT 和PassVQT 对密码中某个字符的出现概率进行建模，给定前面的值，对密码中某个字符的概率进行建模，给定前面的值，从分布中顺序采样可以生成可能的密码。\n1. 模型在词汇表 Σ 上运行，包含 256 个 UTF-8 字符。\n2. tokenizer 定义为将词汇表中的每个字符 σ 映射为整数的函数，分词器：Σ 7→ [0, |Σ| − 1]。\n3. 然后，在 tokenizer 函数下使用其图像的 one-hot 编码为每个 token σ 创建向量表示。这会产生一个维度向量 |Σ|，在标记器 (σ) 位置处所有条目均等于 0，单个条目等于 1。\n### PassGPT\n![[Pasted image 20240319150308.png]]\nGPT 模型利用 Transformer 的解码器组件，并经过训练以自回归方式预测序列中的下一个标记。\n1. 为了预测密码中的特定字符 xi，转换器解码器仅考虑之前的字符 x0,...。 。 。 ，xi−1 作为输入，\n2. 并输出一个维度为 d 的潜在向量（在我们的工作中 d = 768）。\n3. 然后这个潜在向量被映射到维度 |Σ| 的实数向量通过线性层并使用 softmax 函数进一步转换为词汇表上的概率分布。\n4. 词汇表上的输出分布表示 p(xi|x<i; θ)。使用相对于在该位置找到的真实字符的独热编码表示的交叉熵损失来优化该分布。\n一旦网络经过训练，它就会为我们提供基于先前标记的词汇表的参数化分布，即 p(xi|x<i; θ)。\n1. 我们可以从密码开始标记 <\\s>  开始，并找到 p(x1|x0 = <\\s>)。这为我们词汇表中的每个字符分配了成为密码中第一个标记的概率。如果我们从这个分布中采样，我们可以固定第一个字符并通过计算 p(x2|x0, x1) 重复该过程来找到第二个字符。当在任何给定步骤从分布中采样到密码结束标记 <\\/s> 时，密码采样过程即告完成。\n\t1. 与训练不同，此过程是连续的。我们的 PassGPT 实现使用 HuggingFace 库 [53]，并具有以下规范：12 个注意力头、8 个解码器层和 GeLU 激活 [24]。此外，我们使用 AdamW 优化器对所有模型进行 1 轮训练，起始学习率为 5e-5，训练期间线性衰减。\n# PassVQT\n使用潜在空间的矢量量化增强了转换器架构。在计算机视觉领域，这已被证明可以提高样本质量[55]。 PassVQT 遵循 Yu 等人设计的架构。  [55]。 \n1. 在对与 PassGPT 相同的条件分布进行建模时，我们的目标是评估量化是否可以提供任何额外的好处。\n2. 在图 2 所示的架构中，变压器编码器将每个输入标记映射到维度为 768 的潜在表示。\n3. 然后使用线性层将该潜在表示映射到 10 维，并使用 k 均值和具有 N 的码本进行量化条目。量化的 10 维向量通过线性层映射回 768 维，并作为变压器自回归解码器的输入。\n4. 该解码器经过训练，可以仅使用先前标记的量化表示来逐个字符地重建输入密码。\n5. 我们通过最小化 RockYou 泄漏训练分割的重建损失来进行超参数搜索。\n6. 我们的研究结果表明，更深的编码器和解码器结构可以提供更好的结果，码本大小为 300 可以提供最佳性能。\n7. PassVQT 采用变压器编码器和 GPT-2 解码器，分别具有 12 个注意力头和 8 个层。它是使用 HuggingFace 库 [53] 实现的，并使用 AdamW 优化器进行端到端训练，起始学习率为 5e-5，具有线性衰减。一旦编码器-解码器网络收敛，该模型就可以从压缩的量化潜在表示重建输入密码。如果我们对潜在代码的分布进行建模，我们可以从中采样以生成可能的代码序列，然后解码器可以将其转换为可能的密码。为此，我们在训练数据集的量化表示上训练自回归代码模型。在推理过程中，我们通过从代码模型中采样代码序列并使用原始解码器将它们转换为密码来创建新密码。不再需要编码器。\n\n4.3 引导式生成 \n我们提出了一种新颖的密码生成方法：引导式密码生成。\n与之前生成整体密码的深度生成方法不同，PassGPT 分别对每个令牌进行建模，从而授予对每个字符的完全控制权。\n这使得生成过程能够满足特定的约束。\n这些限制的一些示例包括：密码长度、固定字符（例如，第一个位置的“a”）和模板（例如，四个小写字母和两个数字）。\n这可以通过限制采样分布 p(xi|x0, · · ·, xi−1) 以仅考虑分配给感兴趣子集 Σ′ ⊂ Σ 的概率质量来实现；例如，限制 Σ′。\n\n## 实验结果\n将 PassGPT 和 PassVQT 和最新的深度生成模型，并演示了它们对不同数据集的泛化，而无需进一步训练。\n检查了 PassGPT 下密码的概率和熵，以深入了解其功能和建模分布。\n\n训练集的两种变体：（1）唯一密码和（2）所有出现的密码。\n1. 在使用唯一密码进行训练时，PassGPT 表现出卓越的泛化能力，\n2. 相反，在使用唯一条目进行训练时，PassVQT 会遇到生成分发内密码的困难，但在合并其绝对出现次数后会显着改进。\n3. 从 PassGPT（针对唯一密码进行训练）和 PassVQT（针对所有密码进行训练）中对越来越大的密码猜测池进行采样，对越来越大的密码猜测池进行采样，并计算它们恢复的 RockYou 测试分割的百分比。\n4. 结果表明 PassGPT 优于所有其他模型。它在 109 个猜测中恢复了测试集的 41.9%，而最先进的 GAN 模型的匹配率为 23.33%。 \n\n密码生成评估的另一个重要因素是生成新颖且独特样本的能力。\n\t在 109 次猜测中，PassGPT 保留唯一密码的比例最高 (60%)，而 PassVQT 则下降至 20%。由于 PassVQT 是针对所有出现的密码进行训练的，因此在其发行版下\n\n测试集的恢复比例\n![[Pasted image 20240327105738.png]]\n\n长密码效率：\nPassGPT 在对独特样本进行训练时表现最佳，PassVQT 现在在使用唯一密码进行训练时获得了更好的性能。在对这个新分布进行训练后，模型保持了相似的准确性。从 108 个猜测中，PassGPT 和 PassVQT 分别恢复了测试集的 15.5% 和 8.57%，而在 10 个字符设置中则为 19.37% 和 10.30%。\n\n模型对为见过密码分布的泛化能力：。分别用 RockYou 和 LinkedIn 的数据集进行训练，然后都用  LinkedIn 的测试集测试。\n![[Pasted image 20240327142047.png]]\n\n用 Rockyou 训练的模型 泛化效果更好\n![[Pasted image 20240327111524.png]]\n","slug":"论文笔记/PassGPT","published":1,"date":"2024-04-22T13:14:48.841Z","updated":"2024-03-27T06:31:48.278Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0j001hkgg439gn9w0b","content":"<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><ol>\n<li>LLM 无需显式监督： PassGPT</li>\n<li>引导密码生成：利用 PassGPT 来生成匹配任意约束的密码。</li>\n</ol>\n<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>贡献：</p>\n<ol>\n<li>密码猜测</li>\n<li>密码强度估计<br>PassGPT 多猜测 20% 的未见过的密码，并且对新的泄露展现了良好的泛化能力。<br>此外，我们通过矢量量化增强了 PassGPT [55]。由此产生的架构是 PassVQT，它可以增加生成密码的复杂性。</li>\n</ol>\n<p>与之前整体生成密码的深度生成模型不同，PassGPT 对每个字符进行顺序采样，从而引入了引导密码生成的新颖任务。此方法确保对搜索空间进行更细粒度（字符级）的引导探索，其中根据任意约束对生成的密码进行采样。</p>\n<p>最后，与 GAN 相比，PassGPT 提供了密码概率分布的明确表示。我们证明密码概率与最先进的密码强度估计器一致：PassGPT 为更强的密码分配较低的概率。</p>\n<p>总结如下：<br>– 我们引入了 PassGPT，一种自回归转换器，它在密码生成和对未见过的数据集的泛化方面获得了最先进的结果。<br>– 我们展示 PassGPT 如何在任意约束下启用一种新颖的密码生成方法：引导密码生成。<br>– 我们检查 PassGPT 下的密码概率以及它们如何与强度保持一致。我们讨论如何使用该指标来改进当前强度估计器。<br> – 我们提出了 PassVQT，这是一种通过矢量量化增强的类似架构，以增加生成的复杂性。</p>\n<h1 id=\"实验设置\"><a href=\"#实验设置\" class=\"headerlink\" title=\"实验设置\"></a>实验设置</h1><h2 id=\"数据集\"><a href=\"#数据集\" class=\"headerlink\" title=\"数据集\"></a>数据集</h2><p>![[Pasted image 20240319110425.png]]</p>\n<ol>\n<li>最主要的是  RockYou 和 LinkedIn</li>\n<li>对于 RockYou，我们分别获取最多 10 个和 16 个字符的所有密码列表。<ol>\n<li>我们将此列表中的 80% 作为训练数据。</li>\n<li>在剩下的 20% 中，我们将训练分割中未包含的所有密码保留为测试数据，仅保留频率较低的密码。<ol>\n<li>测试集中最常用的密码仅出现了7 次</li>\n<li>平均频率为 1.03</li>\n<li>有助于测试生成低概率密码的能力。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>对于 LinkedIn <ol>\n<li>LinkedIn 泄露事件没有提供有关密码频率的信息，因此我们将 80% 作为训练数据，其余 20% 用于评估。同样保证没有相同的数据 同时 出现在两组中</li>\n<li>评估集中删除 RockYou 训练密码来定义交叉评估测试集，反之亦然，以评估对未见分布的泛化。</li>\n</ol>\n</li>\n<li>最后，我们还将 MySpace、phpBB 和 Hotmail [52] 泄漏视为评估集。我们执行类似的交叉评估程序，从所有数据中删除 RockYou 和 LinkedIn 训练数据。 OST 10 OST。</li>\n</ol>\n<h2 id=\"模型\"><a href=\"#模型\" class=\"headerlink\" title=\"模型\"></a>模型</h2><p>自回归生成模型。PassGPT 和PassVQT 对密码中某个字符的出现概率进行建模，给定前面的值，对密码中某个字符的概率进行建模，给定前面的值，从分布中顺序采样可以生成可能的密码。</p>\n<ol>\n<li>模型在词汇表 Σ 上运行，包含 256 个 UTF-8 字符。</li>\n<li>tokenizer 定义为将词汇表中的每个字符 σ 映射为整数的函数，分词器：Σ 7→ [0, |Σ| − 1]。</li>\n<li>然后，在 tokenizer 函数下使用其图像的 one-hot 编码为每个 token σ 创建向量表示。这会产生一个维度向量 |Σ|，在标记器 (σ) 位置处所有条目均等于 0，单个条目等于 1。</li>\n</ol>\n<h3 id=\"PassGPT\"><a href=\"#PassGPT\" class=\"headerlink\" title=\"PassGPT\"></a>PassGPT</h3><p>![[Pasted image 20240319150308.png]]<br>GPT 模型利用 Transformer 的解码器组件，并经过训练以自回归方式预测序列中的下一个标记。</p>\n<ol>\n<li>为了预测密码中的特定字符 xi，转换器解码器仅考虑之前的字符 x0,…。 。 。 ，xi−1 作为输入，</li>\n<li>并输出一个维度为 d 的潜在向量（在我们的工作中 d &#x3D; 768）。</li>\n<li>然后这个潜在向量被映射到维度 |Σ| 的实数向量通过线性层并使用 softmax 函数进一步转换为词汇表上的概率分布。</li>\n<li>词汇表上的输出分布表示 p(xi|x&lt;i; θ)。使用相对于在该位置找到的真实字符的独热编码表示的交叉熵损失来优化该分布。<br>一旦网络经过训练，它就会为我们提供基于先前标记的词汇表的参数化分布，即 p(xi|x&lt;i; θ)。</li>\n<li>我们可以从密码开始标记 &lt;\\s&gt;  开始，并找到 p(x1|x0 &#x3D; &lt;\\s&gt;)。这为我们词汇表中的每个字符分配了成为密码中第一个标记的概率。如果我们从这个分布中采样，我们可以固定第一个字符并通过计算 p(x2|x0, x1) 重复该过程来找到第二个字符。当在任何给定步骤从分布中采样到密码结束标记 &lt;/s&gt; 时，密码采样过程即告完成。<ol>\n<li>与训练不同，此过程是连续的。我们的 PassGPT 实现使用 HuggingFace 库 [53]，并具有以下规范：12 个注意力头、8 个解码器层和 GeLU 激活 [24]。此外，我们使用 AdamW 优化器对所有模型进行 1 轮训练，起始学习率为 5e-5，训练期间线性衰减。</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"PassVQT\"><a href=\"#PassVQT\" class=\"headerlink\" title=\"PassVQT\"></a>PassVQT</h1><p>使用潜在空间的矢量量化增强了转换器架构。在计算机视觉领域，这已被证明可以提高样本质量[55]。 PassVQT 遵循 Yu 等人设计的架构。  [55]。 </p>\n<ol>\n<li>在对与 PassGPT 相同的条件分布进行建模时，我们的目标是评估量化是否可以提供任何额外的好处。</li>\n<li>在图 2 所示的架构中，变压器编码器将每个输入标记映射到维度为 768 的潜在表示。</li>\n<li>然后使用线性层将该潜在表示映射到 10 维，并使用 k 均值和具有 N 的码本进行量化条目。量化的 10 维向量通过线性层映射回 768 维，并作为变压器自回归解码器的输入。</li>\n<li>该解码器经过训练，可以仅使用先前标记的量化表示来逐个字符地重建输入密码。</li>\n<li>我们通过最小化 RockYou 泄漏训练分割的重建损失来进行超参数搜索。</li>\n<li>我们的研究结果表明，更深的编码器和解码器结构可以提供更好的结果，码本大小为 300 可以提供最佳性能。</li>\n<li>PassVQT 采用变压器编码器和 GPT-2 解码器，分别具有 12 个注意力头和 8 个层。它是使用 HuggingFace 库 [53] 实现的，并使用 AdamW 优化器进行端到端训练，起始学习率为 5e-5，具有线性衰减。一旦编码器-解码器网络收敛，该模型就可以从压缩的量化潜在表示重建输入密码。如果我们对潜在代码的分布进行建模，我们可以从中采样以生成可能的代码序列，然后解码器可以将其转换为可能的密码。为此，我们在训练数据集的量化表示上训练自回归代码模型。在推理过程中，我们通过从代码模型中采样代码序列并使用原始解码器将它们转换为密码来创建新密码。不再需要编码器。</li>\n</ol>\n<p>4.3 引导式生成<br>我们提出了一种新颖的密码生成方法：引导式密码生成。<br>与之前生成整体密码的深度生成方法不同，PassGPT 分别对每个令牌进行建模，从而授予对每个字符的完全控制权。<br>这使得生成过程能够满足特定的约束。<br>这些限制的一些示例包括：密码长度、固定字符（例如，第一个位置的“a”）和模板（例如，四个小写字母和两个数字）。<br>这可以通过限制采样分布 p(xi|x0, · · ·, xi−1) 以仅考虑分配给感兴趣子集 Σ′ ⊂ Σ 的概率质量来实现；例如，限制 Σ′。</p>\n<h2 id=\"实验结果\"><a href=\"#实验结果\" class=\"headerlink\" title=\"实验结果\"></a>实验结果</h2><p>将 PassGPT 和 PassVQT 和最新的深度生成模型，并演示了它们对不同数据集的泛化，而无需进一步训练。<br>检查了 PassGPT 下密码的概率和熵，以深入了解其功能和建模分布。</p>\n<p>训练集的两种变体：（1）唯一密码和（2）所有出现的密码。</p>\n<ol>\n<li>在使用唯一密码进行训练时，PassGPT 表现出卓越的泛化能力，</li>\n<li>相反，在使用唯一条目进行训练时，PassVQT 会遇到生成分发内密码的困难，但在合并其绝对出现次数后会显着改进。</li>\n<li>从 PassGPT（针对唯一密码进行训练）和 PassVQT（针对所有密码进行训练）中对越来越大的密码猜测池进行采样，对越来越大的密码猜测池进行采样，并计算它们恢复的 RockYou 测试分割的百分比。</li>\n<li>结果表明 PassGPT 优于所有其他模型。它在 109 个猜测中恢复了测试集的 41.9%，而最先进的 GAN 模型的匹配率为 23.33%。</li>\n</ol>\n<p> </p>\n<p>密码生成评估的另一个重要因素是生成新颖且独特样本的能力。<br>    在 109 次猜测中，PassGPT 保留唯一密码的比例最高 (60%)，而 PassVQT 则下降至 20%。由于 PassVQT 是针对所有出现的密码进行训练的，因此在其发行版下</p>\n<p>测试集的恢复比例<br>![[Pasted image 20240327105738.png]]</p>\n<p>长密码效率：<br>PassGPT 在对独特样本进行训练时表现最佳，PassVQT 现在在使用唯一密码进行训练时获得了更好的性能。在对这个新分布进行训练后，模型保持了相似的准确性。从 108 个猜测中，PassGPT 和 PassVQT 分别恢复了测试集的 15.5% 和 8.57%，而在 10 个字符设置中则为 19.37% 和 10.30%。</p>\n<p>模型对为见过密码分布的泛化能力：。分别用 RockYou 和 LinkedIn 的数据集进行训练，然后都用  LinkedIn 的测试集测试。<br>![[Pasted image 20240327142047.png]]</p>\n<p>用 Rockyou 训练的模型 泛化效果更好<br>![[Pasted image 20240327111524.png]]</p>\n","excerpt":"","more":"<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><ol>\n<li>LLM 无需显式监督： PassGPT</li>\n<li>引导密码生成：利用 PassGPT 来生成匹配任意约束的密码。</li>\n</ol>\n<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>贡献：</p>\n<ol>\n<li>密码猜测</li>\n<li>密码强度估计<br>PassGPT 多猜测 20% 的未见过的密码，并且对新的泄露展现了良好的泛化能力。<br>此外，我们通过矢量量化增强了 PassGPT [55]。由此产生的架构是 PassVQT，它可以增加生成密码的复杂性。</li>\n</ol>\n<p>与之前整体生成密码的深度生成模型不同，PassGPT 对每个字符进行顺序采样，从而引入了引导密码生成的新颖任务。此方法确保对搜索空间进行更细粒度（字符级）的引导探索，其中根据任意约束对生成的密码进行采样。</p>\n<p>最后，与 GAN 相比，PassGPT 提供了密码概率分布的明确表示。我们证明密码概率与最先进的密码强度估计器一致：PassGPT 为更强的密码分配较低的概率。</p>\n<p>总结如下：<br>– 我们引入了 PassGPT，一种自回归转换器，它在密码生成和对未见过的数据集的泛化方面获得了最先进的结果。<br>– 我们展示 PassGPT 如何在任意约束下启用一种新颖的密码生成方法：引导密码生成。<br>– 我们检查 PassGPT 下的密码概率以及它们如何与强度保持一致。我们讨论如何使用该指标来改进当前强度估计器。<br> – 我们提出了 PassVQT，这是一种通过矢量量化增强的类似架构，以增加生成的复杂性。</p>\n<h1 id=\"实验设置\"><a href=\"#实验设置\" class=\"headerlink\" title=\"实验设置\"></a>实验设置</h1><h2 id=\"数据集\"><a href=\"#数据集\" class=\"headerlink\" title=\"数据集\"></a>数据集</h2><p>![[Pasted image 20240319110425.png]]</p>\n<ol>\n<li>最主要的是  RockYou 和 LinkedIn</li>\n<li>对于 RockYou，我们分别获取最多 10 个和 16 个字符的所有密码列表。<ol>\n<li>我们将此列表中的 80% 作为训练数据。</li>\n<li>在剩下的 20% 中，我们将训练分割中未包含的所有密码保留为测试数据，仅保留频率较低的密码。<ol>\n<li>测试集中最常用的密码仅出现了7 次</li>\n<li>平均频率为 1.03</li>\n<li>有助于测试生成低概率密码的能力。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>对于 LinkedIn <ol>\n<li>LinkedIn 泄露事件没有提供有关密码频率的信息，因此我们将 80% 作为训练数据，其余 20% 用于评估。同样保证没有相同的数据 同时 出现在两组中</li>\n<li>评估集中删除 RockYou 训练密码来定义交叉评估测试集，反之亦然，以评估对未见分布的泛化。</li>\n</ol>\n</li>\n<li>最后，我们还将 MySpace、phpBB 和 Hotmail [52] 泄漏视为评估集。我们执行类似的交叉评估程序，从所有数据中删除 RockYou 和 LinkedIn 训练数据。 OST 10 OST。</li>\n</ol>\n<h2 id=\"模型\"><a href=\"#模型\" class=\"headerlink\" title=\"模型\"></a>模型</h2><p>自回归生成模型。PassGPT 和PassVQT 对密码中某个字符的出现概率进行建模，给定前面的值，对密码中某个字符的概率进行建模，给定前面的值，从分布中顺序采样可以生成可能的密码。</p>\n<ol>\n<li>模型在词汇表 Σ 上运行，包含 256 个 UTF-8 字符。</li>\n<li>tokenizer 定义为将词汇表中的每个字符 σ 映射为整数的函数，分词器：Σ 7→ [0, |Σ| − 1]。</li>\n<li>然后，在 tokenizer 函数下使用其图像的 one-hot 编码为每个 token σ 创建向量表示。这会产生一个维度向量 |Σ|，在标记器 (σ) 位置处所有条目均等于 0，单个条目等于 1。</li>\n</ol>\n<h3 id=\"PassGPT\"><a href=\"#PassGPT\" class=\"headerlink\" title=\"PassGPT\"></a>PassGPT</h3><p>![[Pasted image 20240319150308.png]]<br>GPT 模型利用 Transformer 的解码器组件，并经过训练以自回归方式预测序列中的下一个标记。</p>\n<ol>\n<li>为了预测密码中的特定字符 xi，转换器解码器仅考虑之前的字符 x0,…。 。 。 ，xi−1 作为输入，</li>\n<li>并输出一个维度为 d 的潜在向量（在我们的工作中 d &#x3D; 768）。</li>\n<li>然后这个潜在向量被映射到维度 |Σ| 的实数向量通过线性层并使用 softmax 函数进一步转换为词汇表上的概率分布。</li>\n<li>词汇表上的输出分布表示 p(xi|x&lt;i; θ)。使用相对于在该位置找到的真实字符的独热编码表示的交叉熵损失来优化该分布。<br>一旦网络经过训练，它就会为我们提供基于先前标记的词汇表的参数化分布，即 p(xi|x&lt;i; θ)。</li>\n<li>我们可以从密码开始标记 &lt;\\s&gt;  开始，并找到 p(x1|x0 &#x3D; &lt;\\s&gt;)。这为我们词汇表中的每个字符分配了成为密码中第一个标记的概率。如果我们从这个分布中采样，我们可以固定第一个字符并通过计算 p(x2|x0, x1) 重复该过程来找到第二个字符。当在任何给定步骤从分布中采样到密码结束标记 &lt;/s&gt; 时，密码采样过程即告完成。<ol>\n<li>与训练不同，此过程是连续的。我们的 PassGPT 实现使用 HuggingFace 库 [53]，并具有以下规范：12 个注意力头、8 个解码器层和 GeLU 激活 [24]。此外，我们使用 AdamW 优化器对所有模型进行 1 轮训练，起始学习率为 5e-5，训练期间线性衰减。</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"PassVQT\"><a href=\"#PassVQT\" class=\"headerlink\" title=\"PassVQT\"></a>PassVQT</h1><p>使用潜在空间的矢量量化增强了转换器架构。在计算机视觉领域，这已被证明可以提高样本质量[55]。 PassVQT 遵循 Yu 等人设计的架构。  [55]。 </p>\n<ol>\n<li>在对与 PassGPT 相同的条件分布进行建模时，我们的目标是评估量化是否可以提供任何额外的好处。</li>\n<li>在图 2 所示的架构中，变压器编码器将每个输入标记映射到维度为 768 的潜在表示。</li>\n<li>然后使用线性层将该潜在表示映射到 10 维，并使用 k 均值和具有 N 的码本进行量化条目。量化的 10 维向量通过线性层映射回 768 维，并作为变压器自回归解码器的输入。</li>\n<li>该解码器经过训练，可以仅使用先前标记的量化表示来逐个字符地重建输入密码。</li>\n<li>我们通过最小化 RockYou 泄漏训练分割的重建损失来进行超参数搜索。</li>\n<li>我们的研究结果表明，更深的编码器和解码器结构可以提供更好的结果，码本大小为 300 可以提供最佳性能。</li>\n<li>PassVQT 采用变压器编码器和 GPT-2 解码器，分别具有 12 个注意力头和 8 个层。它是使用 HuggingFace 库 [53] 实现的，并使用 AdamW 优化器进行端到端训练，起始学习率为 5e-5，具有线性衰减。一旦编码器-解码器网络收敛，该模型就可以从压缩的量化潜在表示重建输入密码。如果我们对潜在代码的分布进行建模，我们可以从中采样以生成可能的代码序列，然后解码器可以将其转换为可能的密码。为此，我们在训练数据集的量化表示上训练自回归代码模型。在推理过程中，我们通过从代码模型中采样代码序列并使用原始解码器将它们转换为密码来创建新密码。不再需要编码器。</li>\n</ol>\n<p>4.3 引导式生成<br>我们提出了一种新颖的密码生成方法：引导式密码生成。<br>与之前生成整体密码的深度生成方法不同，PassGPT 分别对每个令牌进行建模，从而授予对每个字符的完全控制权。<br>这使得生成过程能够满足特定的约束。<br>这些限制的一些示例包括：密码长度、固定字符（例如，第一个位置的“a”）和模板（例如，四个小写字母和两个数字）。<br>这可以通过限制采样分布 p(xi|x0, · · ·, xi−1) 以仅考虑分配给感兴趣子集 Σ′ ⊂ Σ 的概率质量来实现；例如，限制 Σ′。</p>\n<h2 id=\"实验结果\"><a href=\"#实验结果\" class=\"headerlink\" title=\"实验结果\"></a>实验结果</h2><p>将 PassGPT 和 PassVQT 和最新的深度生成模型，并演示了它们对不同数据集的泛化，而无需进一步训练。<br>检查了 PassGPT 下密码的概率和熵，以深入了解其功能和建模分布。</p>\n<p>训练集的两种变体：（1）唯一密码和（2）所有出现的密码。</p>\n<ol>\n<li>在使用唯一密码进行训练时，PassGPT 表现出卓越的泛化能力，</li>\n<li>相反，在使用唯一条目进行训练时，PassVQT 会遇到生成分发内密码的困难，但在合并其绝对出现次数后会显着改进。</li>\n<li>从 PassGPT（针对唯一密码进行训练）和 PassVQT（针对所有密码进行训练）中对越来越大的密码猜测池进行采样，对越来越大的密码猜测池进行采样，并计算它们恢复的 RockYou 测试分割的百分比。</li>\n<li>结果表明 PassGPT 优于所有其他模型。它在 109 个猜测中恢复了测试集的 41.9%，而最先进的 GAN 模型的匹配率为 23.33%。</li>\n</ol>\n<p> </p>\n<p>密码生成评估的另一个重要因素是生成新颖且独特样本的能力。<br>    在 109 次猜测中，PassGPT 保留唯一密码的比例最高 (60%)，而 PassVQT 则下降至 20%。由于 PassVQT 是针对所有出现的密码进行训练的，因此在其发行版下</p>\n<p>测试集的恢复比例<br>![[Pasted image 20240327105738.png]]</p>\n<p>长密码效率：<br>PassGPT 在对独特样本进行训练时表现最佳，PassVQT 现在在使用唯一密码进行训练时获得了更好的性能。在对这个新分布进行训练后，模型保持了相似的准确性。从 108 个猜测中，PassGPT 和 PassVQT 分别恢复了测试集的 15.5% 和 8.57%，而在 10 个字符设置中则为 19.37% 和 10.30%。</p>\n<p>模型对为见过密码分布的泛化能力：。分别用 RockYou 和 LinkedIn 的数据集进行训练，然后都用  LinkedIn 的测试集测试。<br>![[Pasted image 20240327142047.png]]</p>\n<p>用 Rockyou 训练的模型 泛化效果更好<br>![[Pasted image 20240327111524.png]]</p>\n"},{"_content":"\n# 摘要\n1. 密码攻击频繁\n2. 利用密码的相似性和可预测性之间的相关性。使用基于规则的方法，但将规则推导、分类和预测委托给循环神经网络 (RNN)。\n3. 试验结果：尝试的猜测次数限定为10次，结果 5 次就达到了 83% 准确率。其他模型的两倍\n4. 模型能有效进行有针对性的**在线密码**猜测，而不会恢复或者锁定。\n\n# 引言\n1. 密码使用频繁，密码有规律性。\n2. 密码攻击频繁，使用之前网站泄漏的密码攻击同一用户的新密码。\n3. 密码攻击方式多样，字典，规则，模型。\n4. 基于旧的密码，规则能在很少的次数下，对新的网站达到很高的破解率。\n5. 本文使用基于规则的方法，使用神经网络自动执行猜测过程。\n\t1. 导出修改模式，\n\t2. 建立分类，神经网络方法\n\t3. 生成密码猜测，BiLSTM模型\n6. 本文建立了一个实验模型，可以在不知道猜测模式的情况下，进行预测。\n\t1. 使用基于字符 LSTM 编码器解码器模型\n7. 本文将 RNN 和 预训练Transformer 用于（研究较少的）密码短语猜测领域，\n\t1. 构建了一个具有注意力机制的双向 LSTM 模型，预测短语的模式（用少量短语生成完整的密码），\n\t2. 比传统方法所需要的猜测次数明显减少。\n\n\n# 密码猜测——针对性在线猜测\n\n## 数据集\n1. 来源：2018 ，6000，0000 个密码\n2. 处理：\n\t1. 数据集中每个用户至少两个密码，只选择两个构成密码对。\n\t2. 消除重复密码对，和多次出现的密码，剩余 1700，0000 唯一密码对。\n3. 两个指标来评价数据分布：\n\t1. 编辑距离是将一个字符串转换为另一个字符串所需的编辑（例如，替换、插入或删除）次数。数据集中，密码之间的编辑距离范围为 0 到 17，如图 1 所示。大多数密码对的编辑距离范围为 1 到 11。编辑距离可以帮助设置密码重用规则易于用户理解（例如，确保后续密码与原始密码相差三个字符）。\n\t2. 表现出最高相似度的密码将具有最小的 Levenshtein 距离和最高的 JaroWinkler 距离，并且将是跨站点猜测攻击的最佳候选者。\n4. 处理：\n\t1. 已知规则：在之前的研究中，确定了几种最常见的修改模式，包括子字符串、公共子字符串、大写、Leet 和顺序键（Wang 等人，2018 年；Walia 等人，2020 年）。我们根据这五种模式标记每个密码对，以创建一个标记数据集。最后，不符合任何这些规则的对将被丢弃。带标签的数据集包含 3,006,871 个唯一密码对。\n\t2. 工作集：唯一密码对中 长度在 5 - 17 的字符。\n\n## 模型预测过程\n1. 目标：预测流程：对上面处理好的每一个数据：识别标签，分类，生成预测。\n\t1. 第一步，定义常见的修改模式，分析每个密码对并标记相应的类别。\n\t2. 在第二步中，我们使用神经网络模型将每个原始密码分配到单个修改类别中。这个过程称为单标签预测问题。\n\t3. 在第三步中，我们构建第二个模型来了解每个类别中可能的修改。该模型对测试数据的准确率达到 90%（），可以理解并生成每个类别的所有可能的修改。\n\t4. 然后组合两个模型，并在最后一步组装生成的管道。我们的方法可以仅将一个原始密码作为输入，将其分类为修改类别，并生成密码。\n2. 标记：同上面的处理过程。\n3. 分类：使用 Keras Python 库构建了一个 4 层分类器，用于自动密码修改类别预测。\n\t1. 输入层采用与数据集中最长密码相同长度的单个字符序列，即 17 个字符长。 \n\t2. One-Hot 编码器将每个密码处理为字符序列，并将这些序列转换为 One-Hot 数值数组。\n\t3. 编码被传递到 LSTM 单元。我们使用字符级双向 LSTM (BiLSTM) 层，它是传统 LSTM 的扩展，可以提高模型在序列分类问题上的性能。 BiLSTM 层在两个方向上运行输入，一个从过去到未来，另一个从未来到过去。与单向 LSTM 不同，BiLSTM 使用两个隐藏状态，可以保留过去和未来任意时间点的信息。由于这些特性，BiLSTM 可以更好地理解序列中每个字符周围的上下文（Xu 等人，2019）。 BiLSTM 单元的输出被馈送到密集的激活层。\n\t4. 激活层包含一个激活函数，它定义如何将输入的加权和转换为输出。为了确保模型学习特征并且不会过早收敛，我们使用具有较小学习率的 Adam 优化器（Kingma & Ba，2014）。该优化器用于在每次训练迭代期间更新网络权重。\n4. 生成：训练字符级 BiLSTM 模型来生成每个修改类别内的密码。\n\t输入层 1 将先前使用的字符序列形式的密码作为输入，而输入层 2 将密码修改类别作为输入。第一个流包括输入层 1、One-Hot 编码器和 BiLSTM 层。这三层的作用与第 3.2.2 节中描述的类似。第二个输入流包括输入层 #2 和重复向量层，这两个层都用于在单个类别内生成每个预测时向模型添加修改模式列表。最后，串联层组合两个流的输出，并将组合的输出馈送到激活层。激活层的作用与第 3.2.2 节中描述的相同。生成的模型可以为每个修改类别生成高度准确的密码猜测。\n我们最终采用了这种架构，因为它在超参数调整过程中产生了最佳性能。然而，添加更多 LSTM 层可能会导致模型过度拟合。\n\n此外，单独实现了一个直接密码预测，在我们的模型中，它将确定输出修改后的密码。由于模型可以生成具有不同置信度的多个预测，因此我们需要一种算法来选择前十个最可能的输出。我们使用 Beam 搜索算法，这是序列到序列机器翻译问题中最广泛使用的算法之一（Yoo 等人，2020），来帮助我们识别最可能的预测。直接密码预测是最有前途的方法，因为它消除了不断的规则推导和分布分析的需要，并简化了数据集预处理。由此产生的模型，即直接预测机制 (DPM)，是独立于规则的，并提供高预测率。\n\n## 实验结果\n\n在 Google Colab Pro（一个基于云的 Jupyter 笔记本环境）上运行了该项目的大部分内容。\n\n托管运行时环境使用 Tesla P100-PCIE-16GB GPU、Intel(R) Xeon(R) CPU @ 2.20GHz 处理器、25GB RAM 和 109GB 磁盘空间。实验中对硬件要求最高的部分是数据集预处理、模型训练和直接密码预测。直接密码预测的计算成本最高。根据 Google Colab 的测量，在 40 万条记录上训练模型需要 13GB RAM，在 50 万条记录上训练模型需要 20GB。\n\n\n# 短语猜测——针对性离线攻击\n第一种方法采用基于单词级注意力的 LSTM 模型，这与我们在第 3 节中开发的没有注意力机制的字符级 LSTM 模型不同。\n第二种方法利用 OpenAI 提供的生成式预训练 Transformer (GPT-2)，并且可供公众使用 Radfordetal。 （2019）。\n\n## 数据集\n单词集语料库中的短语集（单词数量2 3 4）+ 频率\n生成的数据集包含 574,531 个短语，其中 99,953 个是不同的。\n\n## 攻击向量\n1. 输入是一个短语，用于预测后续短语;\n2. 通过使用马尔可夫链模型建立基线来开始我们的实验。该模型将二元语法或三元语法的第一个单词作为输入，并使用马尔可夫算法生成短语的其余部分。\n3. 然后，该模型根据两个单词同时出现的统计概率构建一个转移矩阵。\n4. 结果，模型生成预测，我们将其与目标短语进行比较，看看它们是否匹配。\n\n## 第一种——LSTM\n\n![[Pasted image 20240409191656.png]]\n1. 由编码器和解码器组成\n\t1. 编码器：获取输入序列并且将信息汇总为上下文向量。\n\t\t1. 输入层：第一个单词作为预测的起点。\n\t\t2. 嵌入层：使用 GloVe 模型（2014）进行词嵌入；\n\t\t3. BiLSTM层：压缩输入，降低向量维度。\n\t2. 上下文向量：所有编码器单元的输出作为输入来计算每个单字解码器想要生成的概率分布。它帮助解码器捕获有关输入的整体信息。\n\t3. 解码器：生成预测\n\t\t1. 输入层：上一步的向量；\n\t\t2. 注意力机制：多个注意力层\n\t\t\t1. 使用函数而不是使用单个隐藏状态来编码和解码\n\t\t\t2. 上下文向量将所有编码器单元的输出作为输入来计算每个单字解码器想要生成的概率分布\n\t\t3. 基于LSTM层。\n2. 使用 Adam 优化器和稀疏分类交叉熵作为损失函数。使用稀疏分类交叉熵的一个优点是更好的内存和计算资源利用率，因为它为每个类使用单个整数而不是整个向量。\n## 第二种——GPT-2\nTransformer 长期以来一直用于短语自动完成（Vaswani 等人，2017）。我们使用 GPT-2，一种开源语言模型（Radford 等人，2019）。\n该模型的架构与纯解码器变压器非常相似。\n1. 由堆叠在一起的多个解码器块组成。\n2. 每个解码器块都有一个前馈神经网络和一个屏蔽自注意力层。\n3. 屏蔽自注意力层基于模型对相关和关联单词的理解以及处理该单词之前所需的上下文。该层分配定义片段中每个单词的相关性的分数，并将它们的向量表示相加（Vaswani 等人，2017）。\n4. 矢量表示被传递到完全连接的神经网络层进行处理。\n实验过程：\n1. 使用具有 124M 参数的 GPT-2 Small 模型版本。\n2. 使用的 4 元数据集样本中提取的单词列表上重新训练它。\n3. 还利用模型作者提供的一些超参数\n\t1. 前缀参数用于为模型提供短语的开头。\n\t2. 温度参数是控制随机性的浮点数。较低的温度使预测更加重复。\n\t3. 长度控制生成的短语将包含多少个单词。\n\t4. 参数 top_p 有助于缩小预测范围以选择最佳候选者。\n\t5. 我们生成的短语数量由 N_samples 参数控制，设置为 50。\n## 结果\n不幸的是，大多数模型需要进行大量尝试才能正确猜测密码。请注意，现有工作的大多数作者没有透露他们实验的每个细节和参数。此外，在现有模型和我们的模型之间进行公平的一对一比较非常困难，因为它们经常使用并不总是提供的不同数据集。\n\nLSTM 模型随时间变化的预测率。该模型在大约 1000 次尝试中破解了 24% 的密码。经过大约 5000 次尝试，它最终达到了 40% 的最大预测率。然后预测率开始趋于平缓。\n\n除了我们开发的 LSTM 和 GPT-2 模型之外，我们还实现了基于马尔可夫的模型作为基线 和  我们开发和配置的模型之间的详细比较。我们对基于马尔可夫的模型的实现并未针对有效的 GPU 和资源利用进行优化，并且在大约 20 次尝试后停止收敛。那时，我们无法记录预测率。如果我们将尝试次数设置为高于 20，模型就会开始超时。\n\n1. 对于 LSTM，我们发现尝试次数越多，资源就会成比例增加；然而，总体利用率仍然较低。 \n2. GPT-2 模型在预测较长短语方面表现最佳，但需要更多输入才能更快地提供准确的猜测。\n3. 即使对于不太频繁出现的短语（通常更难破解），LSTM 也表现出了出色的预测率。\n\n该实验断言，对于基于马尔可夫的模型和 LSTM，较长的短语和具有三个或更多单词的短语更难预测。我们所有的模型都显着增加了正确预测的数量，同时减少了尝试的次数。它表明我们的模型在破解密码方面非常有效。\n\n\n# 未来展望\n## 密码的见解\n原始密码进行轻微修改在跨站点攻击中几乎没有提供额外的安全性。姐妹密码之间的相似度越低，用户数据就越安全。\n\t因此构建一个主动密码检查器\n\t防止用户选择易于猜测的后续密码，特别是当它与使用的密码相似时。\n服务提供商应考虑单独使用密码，转而使用双因素身份验证、生物识别、行为身份验证和其他替代手段\n\n## 密码短语的见解\n1. 易于在企业级别进行实施和维护，对用户程序友好。\n2. 更长，更容易记住。\n3. 本质上是不安全的。构成密码的短语通常来自于主流文化和\n4. 容易被人工智能方式攻击。\n\n# 未来展望\n1. 更多密码泄漏\n2. 原始密码生成后续密码，可以用新数据训练旧模型。\n# 总结\n在本研究中，我们首先研究了有针对性的在线密码猜测问题。,我们使用 RNN 构建了一个密码预测管道来自动进行密码分类和生成。,预测结果优于传统的分类和猜测算法。,当我们将猜测尝试限制为五次时，性能提升尤其显着。,我们结合了对基于规则的预测算法的理解和 LSTM 神经网络的强大功能，解决了同一用户创建的密码的跨站点预测问题。,这是一种相对较新的方法，也许是使用 RNN 来完成此特定任务的首次尝试之一。,我们可以量化后续密码的相似性、修改模式和可预测性之间的相关性。,此外，我们还展示了最常见的修改策略的易于预测性和高精度，例如在原始密码或大写中添加头或尾符号。,我们展示了由于 RNN 模型的低复杂性和浅层性质，可以通过负担得起的硬件或在线计算资源（例如 Google Colab）来促进这种预测过程。,此外，预测效率使其可以在帐户被锁定之前允许尝试五次或更少的平台上运行。,我们还讨论了在线服务应采取的具体步骤，以提高身份验证过程的安全性。,然后我们探讨了使用 RNN 进行有针对性的离线密码猜测的问题。,我们构建了一个基于注意力的 LSTM 模型和一个微调的 GPT-2 模型来预测常用密码。,我们分析了结果，并将其与最常用的方法进行了比较，例如基于字典、基于规则和基于马尔可夫链的预测算法。,我们实现了明显更好的预测率，特别是考虑到使用的尝试次数、部署时间、资源利用率和操作简便性。,尽管这些方法并不是全新的，但它们在密码短语预测领域是新颖的，并且产生有竞争力的预测率。,资金 没有收到任何资金来协助准备本手稿。","source":"_posts/论文笔记/Pass_RNN.md","raw":"\n# 摘要\n1. 密码攻击频繁\n2. 利用密码的相似性和可预测性之间的相关性。使用基于规则的方法，但将规则推导、分类和预测委托给循环神经网络 (RNN)。\n3. 试验结果：尝试的猜测次数限定为10次，结果 5 次就达到了 83% 准确率。其他模型的两倍\n4. 模型能有效进行有针对性的**在线密码**猜测，而不会恢复或者锁定。\n\n# 引言\n1. 密码使用频繁，密码有规律性。\n2. 密码攻击频繁，使用之前网站泄漏的密码攻击同一用户的新密码。\n3. 密码攻击方式多样，字典，规则，模型。\n4. 基于旧的密码，规则能在很少的次数下，对新的网站达到很高的破解率。\n5. 本文使用基于规则的方法，使用神经网络自动执行猜测过程。\n\t1. 导出修改模式，\n\t2. 建立分类，神经网络方法\n\t3. 生成密码猜测，BiLSTM模型\n6. 本文建立了一个实验模型，可以在不知道猜测模式的情况下，进行预测。\n\t1. 使用基于字符 LSTM 编码器解码器模型\n7. 本文将 RNN 和 预训练Transformer 用于（研究较少的）密码短语猜测领域，\n\t1. 构建了一个具有注意力机制的双向 LSTM 模型，预测短语的模式（用少量短语生成完整的密码），\n\t2. 比传统方法所需要的猜测次数明显减少。\n\n\n# 密码猜测——针对性在线猜测\n\n## 数据集\n1. 来源：2018 ，6000，0000 个密码\n2. 处理：\n\t1. 数据集中每个用户至少两个密码，只选择两个构成密码对。\n\t2. 消除重复密码对，和多次出现的密码，剩余 1700，0000 唯一密码对。\n3. 两个指标来评价数据分布：\n\t1. 编辑距离是将一个字符串转换为另一个字符串所需的编辑（例如，替换、插入或删除）次数。数据集中，密码之间的编辑距离范围为 0 到 17，如图 1 所示。大多数密码对的编辑距离范围为 1 到 11。编辑距离可以帮助设置密码重用规则易于用户理解（例如，确保后续密码与原始密码相差三个字符）。\n\t2. 表现出最高相似度的密码将具有最小的 Levenshtein 距离和最高的 JaroWinkler 距离，并且将是跨站点猜测攻击的最佳候选者。\n4. 处理：\n\t1. 已知规则：在之前的研究中，确定了几种最常见的修改模式，包括子字符串、公共子字符串、大写、Leet 和顺序键（Wang 等人，2018 年；Walia 等人，2020 年）。我们根据这五种模式标记每个密码对，以创建一个标记数据集。最后，不符合任何这些规则的对将被丢弃。带标签的数据集包含 3,006,871 个唯一密码对。\n\t2. 工作集：唯一密码对中 长度在 5 - 17 的字符。\n\n## 模型预测过程\n1. 目标：预测流程：对上面处理好的每一个数据：识别标签，分类，生成预测。\n\t1. 第一步，定义常见的修改模式，分析每个密码对并标记相应的类别。\n\t2. 在第二步中，我们使用神经网络模型将每个原始密码分配到单个修改类别中。这个过程称为单标签预测问题。\n\t3. 在第三步中，我们构建第二个模型来了解每个类别中可能的修改。该模型对测试数据的准确率达到 90%（），可以理解并生成每个类别的所有可能的修改。\n\t4. 然后组合两个模型，并在最后一步组装生成的管道。我们的方法可以仅将一个原始密码作为输入，将其分类为修改类别，并生成密码。\n2. 标记：同上面的处理过程。\n3. 分类：使用 Keras Python 库构建了一个 4 层分类器，用于自动密码修改类别预测。\n\t1. 输入层采用与数据集中最长密码相同长度的单个字符序列，即 17 个字符长。 \n\t2. One-Hot 编码器将每个密码处理为字符序列，并将这些序列转换为 One-Hot 数值数组。\n\t3. 编码被传递到 LSTM 单元。我们使用字符级双向 LSTM (BiLSTM) 层，它是传统 LSTM 的扩展，可以提高模型在序列分类问题上的性能。 BiLSTM 层在两个方向上运行输入，一个从过去到未来，另一个从未来到过去。与单向 LSTM 不同，BiLSTM 使用两个隐藏状态，可以保留过去和未来任意时间点的信息。由于这些特性，BiLSTM 可以更好地理解序列中每个字符周围的上下文（Xu 等人，2019）。 BiLSTM 单元的输出被馈送到密集的激活层。\n\t4. 激活层包含一个激活函数，它定义如何将输入的加权和转换为输出。为了确保模型学习特征并且不会过早收敛，我们使用具有较小学习率的 Adam 优化器（Kingma & Ba，2014）。该优化器用于在每次训练迭代期间更新网络权重。\n4. 生成：训练字符级 BiLSTM 模型来生成每个修改类别内的密码。\n\t输入层 1 将先前使用的字符序列形式的密码作为输入，而输入层 2 将密码修改类别作为输入。第一个流包括输入层 1、One-Hot 编码器和 BiLSTM 层。这三层的作用与第 3.2.2 节中描述的类似。第二个输入流包括输入层 #2 和重复向量层，这两个层都用于在单个类别内生成每个预测时向模型添加修改模式列表。最后，串联层组合两个流的输出，并将组合的输出馈送到激活层。激活层的作用与第 3.2.2 节中描述的相同。生成的模型可以为每个修改类别生成高度准确的密码猜测。\n我们最终采用了这种架构，因为它在超参数调整过程中产生了最佳性能。然而，添加更多 LSTM 层可能会导致模型过度拟合。\n\n此外，单独实现了一个直接密码预测，在我们的模型中，它将确定输出修改后的密码。由于模型可以生成具有不同置信度的多个预测，因此我们需要一种算法来选择前十个最可能的输出。我们使用 Beam 搜索算法，这是序列到序列机器翻译问题中最广泛使用的算法之一（Yoo 等人，2020），来帮助我们识别最可能的预测。直接密码预测是最有前途的方法，因为它消除了不断的规则推导和分布分析的需要，并简化了数据集预处理。由此产生的模型，即直接预测机制 (DPM)，是独立于规则的，并提供高预测率。\n\n## 实验结果\n\n在 Google Colab Pro（一个基于云的 Jupyter 笔记本环境）上运行了该项目的大部分内容。\n\n托管运行时环境使用 Tesla P100-PCIE-16GB GPU、Intel(R) Xeon(R) CPU @ 2.20GHz 处理器、25GB RAM 和 109GB 磁盘空间。实验中对硬件要求最高的部分是数据集预处理、模型训练和直接密码预测。直接密码预测的计算成本最高。根据 Google Colab 的测量，在 40 万条记录上训练模型需要 13GB RAM，在 50 万条记录上训练模型需要 20GB。\n\n\n# 短语猜测——针对性离线攻击\n第一种方法采用基于单词级注意力的 LSTM 模型，这与我们在第 3 节中开发的没有注意力机制的字符级 LSTM 模型不同。\n第二种方法利用 OpenAI 提供的生成式预训练 Transformer (GPT-2)，并且可供公众使用 Radfordetal。 （2019）。\n\n## 数据集\n单词集语料库中的短语集（单词数量2 3 4）+ 频率\n生成的数据集包含 574,531 个短语，其中 99,953 个是不同的。\n\n## 攻击向量\n1. 输入是一个短语，用于预测后续短语;\n2. 通过使用马尔可夫链模型建立基线来开始我们的实验。该模型将二元语法或三元语法的第一个单词作为输入，并使用马尔可夫算法生成短语的其余部分。\n3. 然后，该模型根据两个单词同时出现的统计概率构建一个转移矩阵。\n4. 结果，模型生成预测，我们将其与目标短语进行比较，看看它们是否匹配。\n\n## 第一种——LSTM\n\n![[Pasted image 20240409191656.png]]\n1. 由编码器和解码器组成\n\t1. 编码器：获取输入序列并且将信息汇总为上下文向量。\n\t\t1. 输入层：第一个单词作为预测的起点。\n\t\t2. 嵌入层：使用 GloVe 模型（2014）进行词嵌入；\n\t\t3. BiLSTM层：压缩输入，降低向量维度。\n\t2. 上下文向量：所有编码器单元的输出作为输入来计算每个单字解码器想要生成的概率分布。它帮助解码器捕获有关输入的整体信息。\n\t3. 解码器：生成预测\n\t\t1. 输入层：上一步的向量；\n\t\t2. 注意力机制：多个注意力层\n\t\t\t1. 使用函数而不是使用单个隐藏状态来编码和解码\n\t\t\t2. 上下文向量将所有编码器单元的输出作为输入来计算每个单字解码器想要生成的概率分布\n\t\t3. 基于LSTM层。\n2. 使用 Adam 优化器和稀疏分类交叉熵作为损失函数。使用稀疏分类交叉熵的一个优点是更好的内存和计算资源利用率，因为它为每个类使用单个整数而不是整个向量。\n## 第二种——GPT-2\nTransformer 长期以来一直用于短语自动完成（Vaswani 等人，2017）。我们使用 GPT-2，一种开源语言模型（Radford 等人，2019）。\n该模型的架构与纯解码器变压器非常相似。\n1. 由堆叠在一起的多个解码器块组成。\n2. 每个解码器块都有一个前馈神经网络和一个屏蔽自注意力层。\n3. 屏蔽自注意力层基于模型对相关和关联单词的理解以及处理该单词之前所需的上下文。该层分配定义片段中每个单词的相关性的分数，并将它们的向量表示相加（Vaswani 等人，2017）。\n4. 矢量表示被传递到完全连接的神经网络层进行处理。\n实验过程：\n1. 使用具有 124M 参数的 GPT-2 Small 模型版本。\n2. 使用的 4 元数据集样本中提取的单词列表上重新训练它。\n3. 还利用模型作者提供的一些超参数\n\t1. 前缀参数用于为模型提供短语的开头。\n\t2. 温度参数是控制随机性的浮点数。较低的温度使预测更加重复。\n\t3. 长度控制生成的短语将包含多少个单词。\n\t4. 参数 top_p 有助于缩小预测范围以选择最佳候选者。\n\t5. 我们生成的短语数量由 N_samples 参数控制，设置为 50。\n## 结果\n不幸的是，大多数模型需要进行大量尝试才能正确猜测密码。请注意，现有工作的大多数作者没有透露他们实验的每个细节和参数。此外，在现有模型和我们的模型之间进行公平的一对一比较非常困难，因为它们经常使用并不总是提供的不同数据集。\n\nLSTM 模型随时间变化的预测率。该模型在大约 1000 次尝试中破解了 24% 的密码。经过大约 5000 次尝试，它最终达到了 40% 的最大预测率。然后预测率开始趋于平缓。\n\n除了我们开发的 LSTM 和 GPT-2 模型之外，我们还实现了基于马尔可夫的模型作为基线 和  我们开发和配置的模型之间的详细比较。我们对基于马尔可夫的模型的实现并未针对有效的 GPU 和资源利用进行优化，并且在大约 20 次尝试后停止收敛。那时，我们无法记录预测率。如果我们将尝试次数设置为高于 20，模型就会开始超时。\n\n1. 对于 LSTM，我们发现尝试次数越多，资源就会成比例增加；然而，总体利用率仍然较低。 \n2. GPT-2 模型在预测较长短语方面表现最佳，但需要更多输入才能更快地提供准确的猜测。\n3. 即使对于不太频繁出现的短语（通常更难破解），LSTM 也表现出了出色的预测率。\n\n该实验断言，对于基于马尔可夫的模型和 LSTM，较长的短语和具有三个或更多单词的短语更难预测。我们所有的模型都显着增加了正确预测的数量，同时减少了尝试的次数。它表明我们的模型在破解密码方面非常有效。\n\n\n# 未来展望\n## 密码的见解\n原始密码进行轻微修改在跨站点攻击中几乎没有提供额外的安全性。姐妹密码之间的相似度越低，用户数据就越安全。\n\t因此构建一个主动密码检查器\n\t防止用户选择易于猜测的后续密码，特别是当它与使用的密码相似时。\n服务提供商应考虑单独使用密码，转而使用双因素身份验证、生物识别、行为身份验证和其他替代手段\n\n## 密码短语的见解\n1. 易于在企业级别进行实施和维护，对用户程序友好。\n2. 更长，更容易记住。\n3. 本质上是不安全的。构成密码的短语通常来自于主流文化和\n4. 容易被人工智能方式攻击。\n\n# 未来展望\n1. 更多密码泄漏\n2. 原始密码生成后续密码，可以用新数据训练旧模型。\n# 总结\n在本研究中，我们首先研究了有针对性的在线密码猜测问题。,我们使用 RNN 构建了一个密码预测管道来自动进行密码分类和生成。,预测结果优于传统的分类和猜测算法。,当我们将猜测尝试限制为五次时，性能提升尤其显着。,我们结合了对基于规则的预测算法的理解和 LSTM 神经网络的强大功能，解决了同一用户创建的密码的跨站点预测问题。,这是一种相对较新的方法，也许是使用 RNN 来完成此特定任务的首次尝试之一。,我们可以量化后续密码的相似性、修改模式和可预测性之间的相关性。,此外，我们还展示了最常见的修改策略的易于预测性和高精度，例如在原始密码或大写中添加头或尾符号。,我们展示了由于 RNN 模型的低复杂性和浅层性质，可以通过负担得起的硬件或在线计算资源（例如 Google Colab）来促进这种预测过程。,此外，预测效率使其可以在帐户被锁定之前允许尝试五次或更少的平台上运行。,我们还讨论了在线服务应采取的具体步骤，以提高身份验证过程的安全性。,然后我们探讨了使用 RNN 进行有针对性的离线密码猜测的问题。,我们构建了一个基于注意力的 LSTM 模型和一个微调的 GPT-2 模型来预测常用密码。,我们分析了结果，并将其与最常用的方法进行了比较，例如基于字典、基于规则和基于马尔可夫链的预测算法。,我们实现了明显更好的预测率，特别是考虑到使用的尝试次数、部署时间、资源利用率和操作简便性。,尽管这些方法并不是全新的，但它们在密码短语预测领域是新颖的，并且产生有竞争力的预测率。,资金 没有收到任何资金来协助准备本手稿。","slug":"论文笔记/Pass_RNN","published":1,"date":"2024-04-22T13:14:48.842Z","updated":"2024-04-10T08:17:31.231Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0j001ikgg411zyhi23","content":"<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><ol>\n<li>密码攻击频繁</li>\n<li>利用密码的相似性和可预测性之间的相关性。使用基于规则的方法，但将规则推导、分类和预测委托给循环神经网络 (RNN)。</li>\n<li>试验结果：尝试的猜测次数限定为10次，结果 5 次就达到了 83% 准确率。其他模型的两倍</li>\n<li>模型能有效进行有针对性的<strong>在线密码</strong>猜测，而不会恢复或者锁定。</li>\n</ol>\n<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><ol>\n<li>密码使用频繁，密码有规律性。</li>\n<li>密码攻击频繁，使用之前网站泄漏的密码攻击同一用户的新密码。</li>\n<li>密码攻击方式多样，字典，规则，模型。</li>\n<li>基于旧的密码，规则能在很少的次数下，对新的网站达到很高的破解率。</li>\n<li>本文使用基于规则的方法，使用神经网络自动执行猜测过程。<ol>\n<li>导出修改模式，</li>\n<li>建立分类，神经网络方法</li>\n<li>生成密码猜测，BiLSTM模型</li>\n</ol>\n</li>\n<li>本文建立了一个实验模型，可以在不知道猜测模式的情况下，进行预测。<ol>\n<li>使用基于字符 LSTM 编码器解码器模型</li>\n</ol>\n</li>\n<li>本文将 RNN 和 预训练Transformer 用于（研究较少的）密码短语猜测领域，<ol>\n<li>构建了一个具有注意力机制的双向 LSTM 模型，预测短语的模式（用少量短语生成完整的密码），</li>\n<li>比传统方法所需要的猜测次数明显减少。</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"密码猜测——针对性在线猜测\"><a href=\"#密码猜测——针对性在线猜测\" class=\"headerlink\" title=\"密码猜测——针对性在线猜测\"></a>密码猜测——针对性在线猜测</h1><h2 id=\"数据集\"><a href=\"#数据集\" class=\"headerlink\" title=\"数据集\"></a>数据集</h2><ol>\n<li>来源：2018 ，6000，0000 个密码</li>\n<li>处理：<ol>\n<li>数据集中每个用户至少两个密码，只选择两个构成密码对。</li>\n<li>消除重复密码对，和多次出现的密码，剩余 1700，0000 唯一密码对。</li>\n</ol>\n</li>\n<li>两个指标来评价数据分布：<ol>\n<li>编辑距离是将一个字符串转换为另一个字符串所需的编辑（例如，替换、插入或删除）次数。数据集中，密码之间的编辑距离范围为 0 到 17，如图 1 所示。大多数密码对的编辑距离范围为 1 到 11。编辑距离可以帮助设置密码重用规则易于用户理解（例如，确保后续密码与原始密码相差三个字符）。</li>\n<li>表现出最高相似度的密码将具有最小的 Levenshtein 距离和最高的 JaroWinkler 距离，并且将是跨站点猜测攻击的最佳候选者。</li>\n</ol>\n</li>\n<li>处理：<ol>\n<li>已知规则：在之前的研究中，确定了几种最常见的修改模式，包括子字符串、公共子字符串、大写、Leet 和顺序键（Wang 等人，2018 年；Walia 等人，2020 年）。我们根据这五种模式标记每个密码对，以创建一个标记数据集。最后，不符合任何这些规则的对将被丢弃。带标签的数据集包含 3,006,871 个唯一密码对。</li>\n<li>工作集：唯一密码对中 长度在 5 - 17 的字符。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"模型预测过程\"><a href=\"#模型预测过程\" class=\"headerlink\" title=\"模型预测过程\"></a>模型预测过程</h2><ol>\n<li>目标：预测流程：对上面处理好的每一个数据：识别标签，分类，生成预测。<ol>\n<li>第一步，定义常见的修改模式，分析每个密码对并标记相应的类别。</li>\n<li>在第二步中，我们使用神经网络模型将每个原始密码分配到单个修改类别中。这个过程称为单标签预测问题。</li>\n<li>在第三步中，我们构建第二个模型来了解每个类别中可能的修改。该模型对测试数据的准确率达到 90%（），可以理解并生成每个类别的所有可能的修改。</li>\n<li>然后组合两个模型，并在最后一步组装生成的管道。我们的方法可以仅将一个原始密码作为输入，将其分类为修改类别，并生成密码。</li>\n</ol>\n</li>\n<li>标记：同上面的处理过程。</li>\n<li>分类：使用 Keras Python 库构建了一个 4 层分类器，用于自动密码修改类别预测。<ol>\n<li>输入层采用与数据集中最长密码相同长度的单个字符序列，即 17 个字符长。 </li>\n<li>One-Hot 编码器将每个密码处理为字符序列，并将这些序列转换为 One-Hot 数值数组。</li>\n<li>编码被传递到 LSTM 单元。我们使用字符级双向 LSTM (BiLSTM) 层，它是传统 LSTM 的扩展，可以提高模型在序列分类问题上的性能。 BiLSTM 层在两个方向上运行输入，一个从过去到未来，另一个从未来到过去。与单向 LSTM 不同，BiLSTM 使用两个隐藏状态，可以保留过去和未来任意时间点的信息。由于这些特性，BiLSTM 可以更好地理解序列中每个字符周围的上下文（Xu 等人，2019）。 BiLSTM 单元的输出被馈送到密集的激活层。</li>\n<li>激活层包含一个激活函数，它定义如何将输入的加权和转换为输出。为了确保模型学习特征并且不会过早收敛，我们使用具有较小学习率的 Adam 优化器（Kingma &amp; Ba，2014）。该优化器用于在每次训练迭代期间更新网络权重。</li>\n</ol>\n</li>\n<li>生成：训练字符级 BiLSTM 模型来生成每个修改类别内的密码。<br> 输入层 1 将先前使用的字符序列形式的密码作为输入，而输入层 2 将密码修改类别作为输入。第一个流包括输入层 1、One-Hot 编码器和 BiLSTM 层。这三层的作用与第 3.2.2 节中描述的类似。第二个输入流包括输入层 #2 和重复向量层，这两个层都用于在单个类别内生成每个预测时向模型添加修改模式列表。最后，串联层组合两个流的输出，并将组合的输出馈送到激活层。激活层的作用与第 3.2.2 节中描述的相同。生成的模型可以为每个修改类别生成高度准确的密码猜测。<br>我们最终采用了这种架构，因为它在超参数调整过程中产生了最佳性能。然而，添加更多 LSTM 层可能会导致模型过度拟合。</li>\n</ol>\n<p>此外，单独实现了一个直接密码预测，在我们的模型中，它将确定输出修改后的密码。由于模型可以生成具有不同置信度的多个预测，因此我们需要一种算法来选择前十个最可能的输出。我们使用 Beam 搜索算法，这是序列到序列机器翻译问题中最广泛使用的算法之一（Yoo 等人，2020），来帮助我们识别最可能的预测。直接密码预测是最有前途的方法，因为它消除了不断的规则推导和分布分析的需要，并简化了数据集预处理。由此产生的模型，即直接预测机制 (DPM)，是独立于规则的，并提供高预测率。</p>\n<h2 id=\"实验结果\"><a href=\"#实验结果\" class=\"headerlink\" title=\"实验结果\"></a>实验结果</h2><p>在 Google Colab Pro（一个基于云的 Jupyter 笔记本环境）上运行了该项目的大部分内容。</p>\n<p>托管运行时环境使用 Tesla P100-PCIE-16GB GPU、Intel(R) Xeon(R) CPU @ 2.20GHz 处理器、25GB RAM 和 109GB 磁盘空间。实验中对硬件要求最高的部分是数据集预处理、模型训练和直接密码预测。直接密码预测的计算成本最高。根据 Google Colab 的测量，在 40 万条记录上训练模型需要 13GB RAM，在 50 万条记录上训练模型需要 20GB。</p>\n<h1 id=\"短语猜测——针对性离线攻击\"><a href=\"#短语猜测——针对性离线攻击\" class=\"headerlink\" title=\"短语猜测——针对性离线攻击\"></a>短语猜测——针对性离线攻击</h1><p>第一种方法采用基于单词级注意力的 LSTM 模型，这与我们在第 3 节中开发的没有注意力机制的字符级 LSTM 模型不同。<br>第二种方法利用 OpenAI 提供的生成式预训练 Transformer (GPT-2)，并且可供公众使用 Radfordetal。 （2019）。</p>\n<h2 id=\"数据集-1\"><a href=\"#数据集-1\" class=\"headerlink\" title=\"数据集\"></a>数据集</h2><p>单词集语料库中的短语集（单词数量2 3 4）+ 频率<br>生成的数据集包含 574,531 个短语，其中 99,953 个是不同的。</p>\n<h2 id=\"攻击向量\"><a href=\"#攻击向量\" class=\"headerlink\" title=\"攻击向量\"></a>攻击向量</h2><ol>\n<li>输入是一个短语，用于预测后续短语;</li>\n<li>通过使用马尔可夫链模型建立基线来开始我们的实验。该模型将二元语法或三元语法的第一个单词作为输入，并使用马尔可夫算法生成短语的其余部分。</li>\n<li>然后，该模型根据两个单词同时出现的统计概率构建一个转移矩阵。</li>\n<li>结果，模型生成预测，我们将其与目标短语进行比较，看看它们是否匹配。</li>\n</ol>\n<h2 id=\"第一种——LSTM\"><a href=\"#第一种——LSTM\" class=\"headerlink\" title=\"第一种——LSTM\"></a>第一种——LSTM</h2><p>![[Pasted image 20240409191656.png]]</p>\n<ol>\n<li>由编码器和解码器组成<ol>\n<li>编码器：获取输入序列并且将信息汇总为上下文向量。<ol>\n<li>输入层：第一个单词作为预测的起点。</li>\n<li>嵌入层：使用 GloVe 模型（2014）进行词嵌入；</li>\n<li>BiLSTM层：压缩输入，降低向量维度。</li>\n</ol>\n</li>\n<li>上下文向量：所有编码器单元的输出作为输入来计算每个单字解码器想要生成的概率分布。它帮助解码器捕获有关输入的整体信息。</li>\n<li>解码器：生成预测<ol>\n<li>输入层：上一步的向量；</li>\n<li>注意力机制：多个注意力层<ol>\n<li>使用函数而不是使用单个隐藏状态来编码和解码</li>\n<li>上下文向量将所有编码器单元的输出作为输入来计算每个单字解码器想要生成的概率分布</li>\n</ol>\n</li>\n<li>基于LSTM层。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>使用 Adam 优化器和稀疏分类交叉熵作为损失函数。使用稀疏分类交叉熵的一个优点是更好的内存和计算资源利用率，因为它为每个类使用单个整数而不是整个向量。</li>\n</ol>\n<h2 id=\"第二种——GPT-2\"><a href=\"#第二种——GPT-2\" class=\"headerlink\" title=\"第二种——GPT-2\"></a>第二种——GPT-2</h2><p>Transformer 长期以来一直用于短语自动完成（Vaswani 等人，2017）。我们使用 GPT-2，一种开源语言模型（Radford 等人，2019）。<br>该模型的架构与纯解码器变压器非常相似。</p>\n<ol>\n<li>由堆叠在一起的多个解码器块组成。</li>\n<li>每个解码器块都有一个前馈神经网络和一个屏蔽自注意力层。</li>\n<li>屏蔽自注意力层基于模型对相关和关联单词的理解以及处理该单词之前所需的上下文。该层分配定义片段中每个单词的相关性的分数，并将它们的向量表示相加（Vaswani 等人，2017）。</li>\n<li>矢量表示被传递到完全连接的神经网络层进行处理。<br>实验过程：</li>\n<li>使用具有 124M 参数的 GPT-2 Small 模型版本。</li>\n<li>使用的 4 元数据集样本中提取的单词列表上重新训练它。</li>\n<li>还利用模型作者提供的一些超参数<ol>\n<li>前缀参数用于为模型提供短语的开头。</li>\n<li>温度参数是控制随机性的浮点数。较低的温度使预测更加重复。</li>\n<li>长度控制生成的短语将包含多少个单词。</li>\n<li>参数 top_p 有助于缩小预测范围以选择最佳候选者。</li>\n<li>我们生成的短语数量由 N_samples 参数控制，设置为 50。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h2><p>不幸的是，大多数模型需要进行大量尝试才能正确猜测密码。请注意，现有工作的大多数作者没有透露他们实验的每个细节和参数。此外，在现有模型和我们的模型之间进行公平的一对一比较非常困难，因为它们经常使用并不总是提供的不同数据集。</p>\n<p>LSTM 模型随时间变化的预测率。该模型在大约 1000 次尝试中破解了 24% 的密码。经过大约 5000 次尝试，它最终达到了 40% 的最大预测率。然后预测率开始趋于平缓。</p>\n<p>除了我们开发的 LSTM 和 GPT-2 模型之外，我们还实现了基于马尔可夫的模型作为基线 和  我们开发和配置的模型之间的详细比较。我们对基于马尔可夫的模型的实现并未针对有效的 GPU 和资源利用进行优化，并且在大约 20 次尝试后停止收敛。那时，我们无法记录预测率。如果我们将尝试次数设置为高于 20，模型就会开始超时。</p>\n<ol>\n<li>对于 LSTM，我们发现尝试次数越多，资源就会成比例增加；然而，总体利用率仍然较低。 </li>\n<li>GPT-2 模型在预测较长短语方面表现最佳，但需要更多输入才能更快地提供准确的猜测。</li>\n<li>即使对于不太频繁出现的短语（通常更难破解），LSTM 也表现出了出色的预测率。</li>\n</ol>\n<p>该实验断言，对于基于马尔可夫的模型和 LSTM，较长的短语和具有三个或更多单词的短语更难预测。我们所有的模型都显着增加了正确预测的数量，同时减少了尝试的次数。它表明我们的模型在破解密码方面非常有效。</p>\n<h1 id=\"未来展望\"><a href=\"#未来展望\" class=\"headerlink\" title=\"未来展望\"></a>未来展望</h1><h2 id=\"密码的见解\"><a href=\"#密码的见解\" class=\"headerlink\" title=\"密码的见解\"></a>密码的见解</h2><p>原始密码进行轻微修改在跨站点攻击中几乎没有提供额外的安全性。姐妹密码之间的相似度越低，用户数据就越安全。<br>    因此构建一个主动密码检查器<br>    防止用户选择易于猜测的后续密码，特别是当它与使用的密码相似时。<br>服务提供商应考虑单独使用密码，转而使用双因素身份验证、生物识别、行为身份验证和其他替代手段</p>\n<h2 id=\"密码短语的见解\"><a href=\"#密码短语的见解\" class=\"headerlink\" title=\"密码短语的见解\"></a>密码短语的见解</h2><ol>\n<li>易于在企业级别进行实施和维护，对用户程序友好。</li>\n<li>更长，更容易记住。</li>\n<li>本质上是不安全的。构成密码的短语通常来自于主流文化和</li>\n<li>容易被人工智能方式攻击。</li>\n</ol>\n<h1 id=\"未来展望-1\"><a href=\"#未来展望-1\" class=\"headerlink\" title=\"未来展望\"></a>未来展望</h1><ol>\n<li>更多密码泄漏</li>\n<li>原始密码生成后续密码，可以用新数据训练旧模型。</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>在本研究中，我们首先研究了有针对性的在线密码猜测问题。,我们使用 RNN 构建了一个密码预测管道来自动进行密码分类和生成。,预测结果优于传统的分类和猜测算法。,当我们将猜测尝试限制为五次时，性能提升尤其显着。,我们结合了对基于规则的预测算法的理解和 LSTM 神经网络的强大功能，解决了同一用户创建的密码的跨站点预测问题。,这是一种相对较新的方法，也许是使用 RNN 来完成此特定任务的首次尝试之一。,我们可以量化后续密码的相似性、修改模式和可预测性之间的相关性。,此外，我们还展示了最常见的修改策略的易于预测性和高精度，例如在原始密码或大写中添加头或尾符号。,我们展示了由于 RNN 模型的低复杂性和浅层性质，可以通过负担得起的硬件或在线计算资源（例如 Google Colab）来促进这种预测过程。,此外，预测效率使其可以在帐户被锁定之前允许尝试五次或更少的平台上运行。,我们还讨论了在线服务应采取的具体步骤，以提高身份验证过程的安全性。,然后我们探讨了使用 RNN 进行有针对性的离线密码猜测的问题。,我们构建了一个基于注意力的 LSTM 模型和一个微调的 GPT-2 模型来预测常用密码。,我们分析了结果，并将其与最常用的方法进行了比较，例如基于字典、基于规则和基于马尔可夫链的预测算法。,我们实现了明显更好的预测率，特别是考虑到使用的尝试次数、部署时间、资源利用率和操作简便性。,尽管这些方法并不是全新的，但它们在密码短语预测领域是新颖的，并且产生有竞争力的预测率。,资金 没有收到任何资金来协助准备本手稿。</p>\n","excerpt":"","more":"<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><ol>\n<li>密码攻击频繁</li>\n<li>利用密码的相似性和可预测性之间的相关性。使用基于规则的方法，但将规则推导、分类和预测委托给循环神经网络 (RNN)。</li>\n<li>试验结果：尝试的猜测次数限定为10次，结果 5 次就达到了 83% 准确率。其他模型的两倍</li>\n<li>模型能有效进行有针对性的<strong>在线密码</strong>猜测，而不会恢复或者锁定。</li>\n</ol>\n<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><ol>\n<li>密码使用频繁，密码有规律性。</li>\n<li>密码攻击频繁，使用之前网站泄漏的密码攻击同一用户的新密码。</li>\n<li>密码攻击方式多样，字典，规则，模型。</li>\n<li>基于旧的密码，规则能在很少的次数下，对新的网站达到很高的破解率。</li>\n<li>本文使用基于规则的方法，使用神经网络自动执行猜测过程。<ol>\n<li>导出修改模式，</li>\n<li>建立分类，神经网络方法</li>\n<li>生成密码猜测，BiLSTM模型</li>\n</ol>\n</li>\n<li>本文建立了一个实验模型，可以在不知道猜测模式的情况下，进行预测。<ol>\n<li>使用基于字符 LSTM 编码器解码器模型</li>\n</ol>\n</li>\n<li>本文将 RNN 和 预训练Transformer 用于（研究较少的）密码短语猜测领域，<ol>\n<li>构建了一个具有注意力机制的双向 LSTM 模型，预测短语的模式（用少量短语生成完整的密码），</li>\n<li>比传统方法所需要的猜测次数明显减少。</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"密码猜测——针对性在线猜测\"><a href=\"#密码猜测——针对性在线猜测\" class=\"headerlink\" title=\"密码猜测——针对性在线猜测\"></a>密码猜测——针对性在线猜测</h1><h2 id=\"数据集\"><a href=\"#数据集\" class=\"headerlink\" title=\"数据集\"></a>数据集</h2><ol>\n<li>来源：2018 ，6000，0000 个密码</li>\n<li>处理：<ol>\n<li>数据集中每个用户至少两个密码，只选择两个构成密码对。</li>\n<li>消除重复密码对，和多次出现的密码，剩余 1700，0000 唯一密码对。</li>\n</ol>\n</li>\n<li>两个指标来评价数据分布：<ol>\n<li>编辑距离是将一个字符串转换为另一个字符串所需的编辑（例如，替换、插入或删除）次数。数据集中，密码之间的编辑距离范围为 0 到 17，如图 1 所示。大多数密码对的编辑距离范围为 1 到 11。编辑距离可以帮助设置密码重用规则易于用户理解（例如，确保后续密码与原始密码相差三个字符）。</li>\n<li>表现出最高相似度的密码将具有最小的 Levenshtein 距离和最高的 JaroWinkler 距离，并且将是跨站点猜测攻击的最佳候选者。</li>\n</ol>\n</li>\n<li>处理：<ol>\n<li>已知规则：在之前的研究中，确定了几种最常见的修改模式，包括子字符串、公共子字符串、大写、Leet 和顺序键（Wang 等人，2018 年；Walia 等人，2020 年）。我们根据这五种模式标记每个密码对，以创建一个标记数据集。最后，不符合任何这些规则的对将被丢弃。带标签的数据集包含 3,006,871 个唯一密码对。</li>\n<li>工作集：唯一密码对中 长度在 5 - 17 的字符。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"模型预测过程\"><a href=\"#模型预测过程\" class=\"headerlink\" title=\"模型预测过程\"></a>模型预测过程</h2><ol>\n<li>目标：预测流程：对上面处理好的每一个数据：识别标签，分类，生成预测。<ol>\n<li>第一步，定义常见的修改模式，分析每个密码对并标记相应的类别。</li>\n<li>在第二步中，我们使用神经网络模型将每个原始密码分配到单个修改类别中。这个过程称为单标签预测问题。</li>\n<li>在第三步中，我们构建第二个模型来了解每个类别中可能的修改。该模型对测试数据的准确率达到 90%（），可以理解并生成每个类别的所有可能的修改。</li>\n<li>然后组合两个模型，并在最后一步组装生成的管道。我们的方法可以仅将一个原始密码作为输入，将其分类为修改类别，并生成密码。</li>\n</ol>\n</li>\n<li>标记：同上面的处理过程。</li>\n<li>分类：使用 Keras Python 库构建了一个 4 层分类器，用于自动密码修改类别预测。<ol>\n<li>输入层采用与数据集中最长密码相同长度的单个字符序列，即 17 个字符长。 </li>\n<li>One-Hot 编码器将每个密码处理为字符序列，并将这些序列转换为 One-Hot 数值数组。</li>\n<li>编码被传递到 LSTM 单元。我们使用字符级双向 LSTM (BiLSTM) 层，它是传统 LSTM 的扩展，可以提高模型在序列分类问题上的性能。 BiLSTM 层在两个方向上运行输入，一个从过去到未来，另一个从未来到过去。与单向 LSTM 不同，BiLSTM 使用两个隐藏状态，可以保留过去和未来任意时间点的信息。由于这些特性，BiLSTM 可以更好地理解序列中每个字符周围的上下文（Xu 等人，2019）。 BiLSTM 单元的输出被馈送到密集的激活层。</li>\n<li>激活层包含一个激活函数，它定义如何将输入的加权和转换为输出。为了确保模型学习特征并且不会过早收敛，我们使用具有较小学习率的 Adam 优化器（Kingma &amp; Ba，2014）。该优化器用于在每次训练迭代期间更新网络权重。</li>\n</ol>\n</li>\n<li>生成：训练字符级 BiLSTM 模型来生成每个修改类别内的密码。<br> 输入层 1 将先前使用的字符序列形式的密码作为输入，而输入层 2 将密码修改类别作为输入。第一个流包括输入层 1、One-Hot 编码器和 BiLSTM 层。这三层的作用与第 3.2.2 节中描述的类似。第二个输入流包括输入层 #2 和重复向量层，这两个层都用于在单个类别内生成每个预测时向模型添加修改模式列表。最后，串联层组合两个流的输出，并将组合的输出馈送到激活层。激活层的作用与第 3.2.2 节中描述的相同。生成的模型可以为每个修改类别生成高度准确的密码猜测。<br>我们最终采用了这种架构，因为它在超参数调整过程中产生了最佳性能。然而，添加更多 LSTM 层可能会导致模型过度拟合。</li>\n</ol>\n<p>此外，单独实现了一个直接密码预测，在我们的模型中，它将确定输出修改后的密码。由于模型可以生成具有不同置信度的多个预测，因此我们需要一种算法来选择前十个最可能的输出。我们使用 Beam 搜索算法，这是序列到序列机器翻译问题中最广泛使用的算法之一（Yoo 等人，2020），来帮助我们识别最可能的预测。直接密码预测是最有前途的方法，因为它消除了不断的规则推导和分布分析的需要，并简化了数据集预处理。由此产生的模型，即直接预测机制 (DPM)，是独立于规则的，并提供高预测率。</p>\n<h2 id=\"实验结果\"><a href=\"#实验结果\" class=\"headerlink\" title=\"实验结果\"></a>实验结果</h2><p>在 Google Colab Pro（一个基于云的 Jupyter 笔记本环境）上运行了该项目的大部分内容。</p>\n<p>托管运行时环境使用 Tesla P100-PCIE-16GB GPU、Intel(R) Xeon(R) CPU @ 2.20GHz 处理器、25GB RAM 和 109GB 磁盘空间。实验中对硬件要求最高的部分是数据集预处理、模型训练和直接密码预测。直接密码预测的计算成本最高。根据 Google Colab 的测量，在 40 万条记录上训练模型需要 13GB RAM，在 50 万条记录上训练模型需要 20GB。</p>\n<h1 id=\"短语猜测——针对性离线攻击\"><a href=\"#短语猜测——针对性离线攻击\" class=\"headerlink\" title=\"短语猜测——针对性离线攻击\"></a>短语猜测——针对性离线攻击</h1><p>第一种方法采用基于单词级注意力的 LSTM 模型，这与我们在第 3 节中开发的没有注意力机制的字符级 LSTM 模型不同。<br>第二种方法利用 OpenAI 提供的生成式预训练 Transformer (GPT-2)，并且可供公众使用 Radfordetal。 （2019）。</p>\n<h2 id=\"数据集-1\"><a href=\"#数据集-1\" class=\"headerlink\" title=\"数据集\"></a>数据集</h2><p>单词集语料库中的短语集（单词数量2 3 4）+ 频率<br>生成的数据集包含 574,531 个短语，其中 99,953 个是不同的。</p>\n<h2 id=\"攻击向量\"><a href=\"#攻击向量\" class=\"headerlink\" title=\"攻击向量\"></a>攻击向量</h2><ol>\n<li>输入是一个短语，用于预测后续短语;</li>\n<li>通过使用马尔可夫链模型建立基线来开始我们的实验。该模型将二元语法或三元语法的第一个单词作为输入，并使用马尔可夫算法生成短语的其余部分。</li>\n<li>然后，该模型根据两个单词同时出现的统计概率构建一个转移矩阵。</li>\n<li>结果，模型生成预测，我们将其与目标短语进行比较，看看它们是否匹配。</li>\n</ol>\n<h2 id=\"第一种——LSTM\"><a href=\"#第一种——LSTM\" class=\"headerlink\" title=\"第一种——LSTM\"></a>第一种——LSTM</h2><p>![[Pasted image 20240409191656.png]]</p>\n<ol>\n<li>由编码器和解码器组成<ol>\n<li>编码器：获取输入序列并且将信息汇总为上下文向量。<ol>\n<li>输入层：第一个单词作为预测的起点。</li>\n<li>嵌入层：使用 GloVe 模型（2014）进行词嵌入；</li>\n<li>BiLSTM层：压缩输入，降低向量维度。</li>\n</ol>\n</li>\n<li>上下文向量：所有编码器单元的输出作为输入来计算每个单字解码器想要生成的概率分布。它帮助解码器捕获有关输入的整体信息。</li>\n<li>解码器：生成预测<ol>\n<li>输入层：上一步的向量；</li>\n<li>注意力机制：多个注意力层<ol>\n<li>使用函数而不是使用单个隐藏状态来编码和解码</li>\n<li>上下文向量将所有编码器单元的输出作为输入来计算每个单字解码器想要生成的概率分布</li>\n</ol>\n</li>\n<li>基于LSTM层。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>使用 Adam 优化器和稀疏分类交叉熵作为损失函数。使用稀疏分类交叉熵的一个优点是更好的内存和计算资源利用率，因为它为每个类使用单个整数而不是整个向量。</li>\n</ol>\n<h2 id=\"第二种——GPT-2\"><a href=\"#第二种——GPT-2\" class=\"headerlink\" title=\"第二种——GPT-2\"></a>第二种——GPT-2</h2><p>Transformer 长期以来一直用于短语自动完成（Vaswani 等人，2017）。我们使用 GPT-2，一种开源语言模型（Radford 等人，2019）。<br>该模型的架构与纯解码器变压器非常相似。</p>\n<ol>\n<li>由堆叠在一起的多个解码器块组成。</li>\n<li>每个解码器块都有一个前馈神经网络和一个屏蔽自注意力层。</li>\n<li>屏蔽自注意力层基于模型对相关和关联单词的理解以及处理该单词之前所需的上下文。该层分配定义片段中每个单词的相关性的分数，并将它们的向量表示相加（Vaswani 等人，2017）。</li>\n<li>矢量表示被传递到完全连接的神经网络层进行处理。<br>实验过程：</li>\n<li>使用具有 124M 参数的 GPT-2 Small 模型版本。</li>\n<li>使用的 4 元数据集样本中提取的单词列表上重新训练它。</li>\n<li>还利用模型作者提供的一些超参数<ol>\n<li>前缀参数用于为模型提供短语的开头。</li>\n<li>温度参数是控制随机性的浮点数。较低的温度使预测更加重复。</li>\n<li>长度控制生成的短语将包含多少个单词。</li>\n<li>参数 top_p 有助于缩小预测范围以选择最佳候选者。</li>\n<li>我们生成的短语数量由 N_samples 参数控制，设置为 50。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h2><p>不幸的是，大多数模型需要进行大量尝试才能正确猜测密码。请注意，现有工作的大多数作者没有透露他们实验的每个细节和参数。此外，在现有模型和我们的模型之间进行公平的一对一比较非常困难，因为它们经常使用并不总是提供的不同数据集。</p>\n<p>LSTM 模型随时间变化的预测率。该模型在大约 1000 次尝试中破解了 24% 的密码。经过大约 5000 次尝试，它最终达到了 40% 的最大预测率。然后预测率开始趋于平缓。</p>\n<p>除了我们开发的 LSTM 和 GPT-2 模型之外，我们还实现了基于马尔可夫的模型作为基线 和  我们开发和配置的模型之间的详细比较。我们对基于马尔可夫的模型的实现并未针对有效的 GPU 和资源利用进行优化，并且在大约 20 次尝试后停止收敛。那时，我们无法记录预测率。如果我们将尝试次数设置为高于 20，模型就会开始超时。</p>\n<ol>\n<li>对于 LSTM，我们发现尝试次数越多，资源就会成比例增加；然而，总体利用率仍然较低。 </li>\n<li>GPT-2 模型在预测较长短语方面表现最佳，但需要更多输入才能更快地提供准确的猜测。</li>\n<li>即使对于不太频繁出现的短语（通常更难破解），LSTM 也表现出了出色的预测率。</li>\n</ol>\n<p>该实验断言，对于基于马尔可夫的模型和 LSTM，较长的短语和具有三个或更多单词的短语更难预测。我们所有的模型都显着增加了正确预测的数量，同时减少了尝试的次数。它表明我们的模型在破解密码方面非常有效。</p>\n<h1 id=\"未来展望\"><a href=\"#未来展望\" class=\"headerlink\" title=\"未来展望\"></a>未来展望</h1><h2 id=\"密码的见解\"><a href=\"#密码的见解\" class=\"headerlink\" title=\"密码的见解\"></a>密码的见解</h2><p>原始密码进行轻微修改在跨站点攻击中几乎没有提供额外的安全性。姐妹密码之间的相似度越低，用户数据就越安全。<br>    因此构建一个主动密码检查器<br>    防止用户选择易于猜测的后续密码，特别是当它与使用的密码相似时。<br>服务提供商应考虑单独使用密码，转而使用双因素身份验证、生物识别、行为身份验证和其他替代手段</p>\n<h2 id=\"密码短语的见解\"><a href=\"#密码短语的见解\" class=\"headerlink\" title=\"密码短语的见解\"></a>密码短语的见解</h2><ol>\n<li>易于在企业级别进行实施和维护，对用户程序友好。</li>\n<li>更长，更容易记住。</li>\n<li>本质上是不安全的。构成密码的短语通常来自于主流文化和</li>\n<li>容易被人工智能方式攻击。</li>\n</ol>\n<h1 id=\"未来展望-1\"><a href=\"#未来展望-1\" class=\"headerlink\" title=\"未来展望\"></a>未来展望</h1><ol>\n<li>更多密码泄漏</li>\n<li>原始密码生成后续密码，可以用新数据训练旧模型。</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>在本研究中，我们首先研究了有针对性的在线密码猜测问题。,我们使用 RNN 构建了一个密码预测管道来自动进行密码分类和生成。,预测结果优于传统的分类和猜测算法。,当我们将猜测尝试限制为五次时，性能提升尤其显着。,我们结合了对基于规则的预测算法的理解和 LSTM 神经网络的强大功能，解决了同一用户创建的密码的跨站点预测问题。,这是一种相对较新的方法，也许是使用 RNN 来完成此特定任务的首次尝试之一。,我们可以量化后续密码的相似性、修改模式和可预测性之间的相关性。,此外，我们还展示了最常见的修改策略的易于预测性和高精度，例如在原始密码或大写中添加头或尾符号。,我们展示了由于 RNN 模型的低复杂性和浅层性质，可以通过负担得起的硬件或在线计算资源（例如 Google Colab）来促进这种预测过程。,此外，预测效率使其可以在帐户被锁定之前允许尝试五次或更少的平台上运行。,我们还讨论了在线服务应采取的具体步骤，以提高身份验证过程的安全性。,然后我们探讨了使用 RNN 进行有针对性的离线密码猜测的问题。,我们构建了一个基于注意力的 LSTM 模型和一个微调的 GPT-2 模型来预测常用密码。,我们分析了结果，并将其与最常用的方法进行了比较，例如基于字典、基于规则和基于马尔可夫链的预测算法。,我们实现了明显更好的预测率，特别是考虑到使用的尝试次数、部署时间、资源利用率和操作简便性。,尽管这些方法并不是全新的，但它们在密码短语预测领域是新颖的，并且产生有竞争力的预测率。,资金 没有收到任何资金来协助准备本手稿。</p>\n"},{"_content":"# 摘要\n1. 传统基于规则的方法依赖于专家知识\n2. 最新的基于深度学习方法，passGAN rpassGAN 在某些方面不如 PCFG\n3. 不同的深度学习方法有不同的候选密码空间，且无法重叠。\n4. 本文提出 REDPACK ，解决了 GAN 方法的不足，以有效的方法集合了多个候选密码生成器模型。\n\t1. 使用 rPassGAN 的候选密码鉴别器作为密码选择器。\n\t2. 有选择的搜集密码，我们实现了更真实的密码字典。\n5. 在符号，数字，大小写字母组成的密码字典上测试我们的系统。\n\t1. 优于 基于规则，GAN，PCFG，\n\t2. 生成候选密码减少 65% 时，破解性能仅损失 20%。\n\n# 引言\n1. 基于规则破解。基于专家的知识扩展性差。\n2. 先进的密码破解很有用\n\t1. 防御角度：作为密码强度估计器\n\t2. 攻击角度：通过多种方式利用先进的密码破解方法。\n\t\t1. 个人角度：破解自己忘记了的密码。\n\t\t2. 社会层面：执法机构需要破解密码来收集犯罪证据。\n## 旧的：Recurrent PassGAN\n对 PassGAN 的改进，弥补基于规则的方法和数据驱动的方法，例如马尔科夫模型等。\n1. 模型足够表示用户使用密码的模式和上下文结构。\n2. 深度学习不需要密码属性和结构的先验知识，只从训练数据中学习特征。\n\n普通 PassGAN：使用了Wasserstein GAN梯度惩罚（WGAN-GP）[11]模型。 WGAN-GP 的基础深度神经网络是基于卷积神经网络 (CNN) 的残差网络。\n\nrPassGAN 通过修改PassGAN的基础神经网络类型和结构来提高密码破解性能。\n\nrPassD2CGAN（rPassGAN 的双鉴别器版本）的性能优于 rPassGAN。然而，在rPassD2CGAN的训练过程中，它有时会变得不稳定。因此，我们通过使用另一个模型 rPassD2SGAN 来克服这个弱点。我们通过多个实验证明了 rPassGAN 生成的候选密码对于增强密码强度估计器的有效性。\n\n与概率上下文无关语法（PCFG）和其他马尔可夫模型（例如 OMEN [1]）相比，rPassGAN 有时破解的密码较少。\n\n## 新的：REDPACK\n\n核心：通过少量猜测来最大化密码破解性能。\n策略：\n1. 有选择地收集更真实的候选密码，以提高密码破解的效率。如果可以使用各种模型的候选密码字典。\n2. 相对论平均标准 GAN [13] 的判别器作为估计器运行，它评估来自各种预先生成的候选者的输入密码的真实性。\n3. 强调：通常只使用 GAN 生成器，我们还使用了 GAN 鉴别器。\n贡献：\n1. GAN 判别器用于帮助生成密码。\n2. REDPACK 能用多个预生成的候选密码制作更有效的候选字典。\n3. 为 REDPACK 构建了一个自定义规则集。\n\n## 文章结构\n1. 第 2 节：相关密码猜测模型\n2. 第 3 节：GANs 和 relativistic average GANs\n3. 第 4 节：REDPACK 的概念和架构\n4. 第 5 节：训练超参数的配置过程。实验结果\n5. 第 6 节：结论\n\n\n# 相关工作\n1. 基于规则的方法：\n\t1. hashcat ，JTR 开源软件多种攻击方式。\n\t2. 马尔科夫模型。\n\t3. 缺点：有明确的密钥空间。\n2. 马尔可夫和 PCFG。\n\t1. 使用符号：数字，字母，符号，单词。组合包含在特定概率分布中\n\t2. 使用马尔可夫过滤器消除滴概率密码\n\t3. 使用彩虹标加速。\n\t4. 图灵机处理特殊符号密码。\n\t5. 一些改进\n\t6. PCFG 使用学习语法结构，密码组合。\n\t7. 一些优化。\n3. 深度学习方法\n\t1. PassGAN ：WGAN-GP 代价函数 + CNN\n\t2. rPassGAN：RNN\n\t效果：能破解 PCFG 等其他模型无法破解的密码。\n\n# 背景知识\n## GAN\n1. [[GAN]] : GAN, WGAN, IWGAN 。其中 IWGAN 实验激发了 Hitaj 等人的兴趣。 [9]将IWGAN应用于密码猜测问题。 他们将创建的模型称为 PassGAN。\n## Relativistic average GAN\n1. GAN 可分为 IPM 和 non-IPM，\n\t1. non-IPM 在学习阶段不稳定，模型优化困难。\n\t2. IPM： Jolicoeur [13] 分析了 SGAN 的损失函数，以分析非基于 IPM 的 GAN 的局限性，并提出了一种相对论 GAN 来解决这个问题。 \n2. 来源：\n\t1. 问题：古德费洛等人。 [10]证明，当判别器以 0.5 的概率对真实数据进行分类时，GAN 训练达到全局最优。 然而，在许多情况下，判别器将真实数据和假数据都分类为真实数据，这对于训练好的生成器来说是不利的。 \n\t2. 这是因为判别器没有意识到学习过程中一半的数据是假的； \n\t3. 基于 IPM 的 GAN 在学习过程中相对稳定，因为它隐含地解释了这一事实。 \n\t4. 从散度最小化的角度来看，训练判别器以增加 D(xf)，而 D(xr) 不会相应减少，其中 xr 和 xf 分别表示真实数据和假数据。 为了解决这个问题，Jolicoeur [13] 设计了判别器的输出，使其依赖于真实数据和虚假数据。\n3. relativistic GAN\n\t![[Pasted image 20240416105310.png]]\n\t其中 C(x) 是假定的批评者 (D(x) = σ(C(x)))。 方程（2）可以解释为判别器对给定真实数据比假数据更真实的概率的估计（D(xf, xr)可以以相反的方式解释）。 如果根据等式（2）设置判别器，则与 SGAN 的生成器仅依赖于假数据不同，相对论性 GAN 的生成器将同时依赖于真实数据和假数据。 然而，它在计算损失时具有 O(m2) 复杂度（m 表示小批量的大小），因为它计算小批量中真数据和假数据之间的批评家的成对差异。\n4. RaGAN \n\t 为了解决这个问题，Jolicoeur [13] 提出了一种相对论平均 GAN（RaGAN），它对某些给定数据取相反类型数据的期望。 RaGAN 使用以下损失函数来学习判别器和生成器：\n\t![[Pasted image 20240416105456.png]]\n\t其中 LD 和 LG 分别表示学习判别器和生成器的损失。 方程(3)的复杂度为O(m)。 RaGAN 的判别器平均估计某些给定数据比相反类型的数据更真实的概率。 Jolicoeur [13] 使用不同的数据集表明，与其他 GAN 模型相比，训练 RaGAN 更快、更可靠，并且 RaGAN 的生成器生成了高质量的假数据。\n\n# 方法介绍：REDPACK\n\n## 概述\n1. 背景：之前 GAN 训练完成之后使用 GAN 生成器实现目的，作者在之前的论文中提到了基于 RNN 的 GAN 方法 rPassGAN ，本文使用的就是 rPassGAN 的 判别器\n2. REDPACK：GAN 的判别器是在模型训练结束之后使用的。\n\t![[Pasted image 20240416111123.png]]\n\t训练阶段：\n\t1. 生成器生成假密码，鉴别器区分，对抗训练，直到收敛。\n\t选择阶段：\n\t1. 使用多个密码生成器产生候选密码。作为训练阶段的结果。（本文使用了 三个或者四个）\n\t2. 鉴别器计算每个候选密码真实程度的概率。\n\t3. 将高概率的候选密码提供给 Hashcat等密码破解工具。\n## 鉴别器训练结构\n架构：\n![[Pasted image 20240416143214.png]]\n优化基于 RNN 的 GAN （判别器优化：使用了 RaGAN 和 IWGAN 的概念来实现了更强大的判别器）的流程：\n1. G 根据给定的任意噪声分布生成假密码，图中绿色路径；\n2. 根据等式 (3) ，当且仅当假密码的批评值大于图中蓝色存储所描述的真实数据时，D 才确定假密码为真实密码。\n3. 蓝色路径上的真实密码在相反情况下被视为真实的。(这里的相反可能是指的比较对象和)\n4. D 给出梯度作为惩罚，鼓励 G 生成更真实的密码，用红色路径表示。\n这样的流程使得 D 会生成比标准 GAN 更强大的判断。训练过程，算法描述如下：\n > \t梯度惩罚系数 λ、每个生成器的判别器迭代次数 ncritic 、每个判别器的生成器迭代次数 ngen 、批量大小 m 和 Adam 超参数 α、β1 和 β2。 Critic C 的参数 w 和生成器 G 的参数 θ。 真实密码 xr 和假密码 xf 之间直线上的随机样本 ˆx。\n\t![[Pasted image 20240416155902.png]]\n1. 主要源自 IWGAN，但使用相对论平均 GAN 的损失函数。 大多数符号遵循方程 (3)。 主要区别在于第 9 行和第 15 行中的损失函数。\n2. 这些损失函数取决于相对论判别器，估计一种类型密码的批评者相对于相反类型密码的平均批评者。 这种直接比较使 G 能够快速收敛到最佳点并产生高质量的假密码。\n3. 此外，由于我们基于 RNN 的 GAN 采用​​ IWGAN，因此我们将梯度惩罚添加到判别器的损失函数中。 此惩罚迫使 ^x 的梯度 2-范数小于 1，其中 ^x 是点对 (xr, xf) 之间直线上的随机样本。 这为 GAN 的训练提供了极大的稳定性。 \n4. 另一个重要因素是从第 13 行到第 16 行优化 G 的迭代。尽管大多数 GAN 都有一个在给定 G 上优化 D 的循环，但这不足以最大化 GAN 的性能。 因此，我们添加了训练 G 的循环来稳定和增强我们的 GAN。 根据我们在第 5 节中描述的实验，该因素对 REDPACK 的破解性能具有关键影响。 一般情况下，一旦模型被优化，生成器就被用作生成模型。 相反，我们利用鉴别器作为 REDPACK 的真实密码估计器。\n\n## 密码生成器选择\n流程图：\n![[Pasted image 20240416171606.png]]\n1. 多个候选密码生成器，比如：Hashcat、PCFG、rPassGAN 与 WGAN-GP 以及 rPassGAN 与 RaGAN-GP。\n2. 注意：不同损失函数的 rPassGAN 可以作为不同的 生成器使用，因为它们有不同的密码破解结果。\n3. 注意：单鉴别器 rPassGAN 和双鉴别器 rPassGAN 也是。\n4. 每个候选密码生成器生成的 10 亿个候选密码从字符串转换为张量，传递给鉴别器（D），估计密码真实性。\n5. 由最大概率选择器选择最高的密码，转换为 字符串形式。\n6. 这些候选者被传输给 Hashcat 破解。\n\n# 评估\n## 实验数据准备\n1. 大多数之前的研究使用的是 Rockyou 和 Linkedln。\n2. 但是本文在性能测试中使用到了包含长密码和 4 级密码的额外密码字典。所以使用 Melicher 等人的密码分类。 [27]。总共有七个训练和破解数据集：\n\t1. Rockyou 和 LinkedIn 包含一些 4 级密码。 \n\t2. 我们还使用了来自 Hashes.org 的四个破解密码字典，其中提供了多个破解和泄露的明文密码。 \n\t![[Pasted image 20240416194910.png]]\n\n## 超参数配置\n1. G:D：RaSGAN 通常使用 1:1 或者 1:10 \n2. 批次大小： 通常使用 128。使用 64 的批量大小可以来应对训练不稳定。\n3. epoch\n具体如下图：\n![[Pasted image 20240416201514.png]]\n\n## 实验环境\nTensorflow-gpu 1.10.1 和 Python 版本 3.5.4 进行 GPU 计算。 所有实验均在韩国大学NMLab的OpenHPC系统上进行。 发达。 OpenHPC的每个节点运行在具有32GB内存的CentOS 7服务器上； 这些节点使用 Intel Xeon E5 2.20GHz CPU(x2) 和 Nvidia TitanXP 12GB GPU(x4)。\n\n\n## 实验过程\n1. 根据我们之前的研究[8,12]推断，决定破解性能的主要因素是epoch、G/D比和循环神经网络（RNN）细胞类型。\n2. 如果 Epoch 过大，会导致过拟合。如图 4a 所示。\n3. 提高破解性能，需要在模型中应用较大范围的 G/D 比，但是比较费时。从而退一步：\n\t因此，我们对RaSGAN-GP成本函数使用1:1和1:10的G/D比进行了实验，如图4b所示。 虽然两者都可能不是最优值，但它们足以说明模型的有效性。 \n4. 最后要考虑的因素是神经单元类型。对于基于 RNN 的相对论判别器，有必要确定长短期记忆 (LSTM) [28] 和门控循环单元 (GRU) [33] 之间哪个更好。\n![[Pasted image 20240416202041.png]]\n结论：整个实验中，200k 训练周期、1:10 G/D 比率和 GRU 单元类型被确定为密码破解的最佳设置并确保通用性，如图 5 所示。\n![[Pasted image 20240416202513.png]]\n\n\n## 实验结果\n所有实验，我们的结果都优于其他模型。\n1. REDPACK 在数据集 2 到数据集 7 上的破解性能比任何单一密码猜测模型高出 5-20%。 在数据集1（短长密码）的情况下，PCFG在早期破解阶段表现出了很强的性能。 下半程的破解，REDPACK最终反超了PCFG。 然而，随着密码长度变长（从 dataset3 到 dataset7），REDPACK 的性能明显优于 PCFG 和其他密码候选生成器。 也就是说，对于复杂且长的密码，REDPACK的有效性得到了明显的体现。\n2. 对于数据集 6 和 7，由于训练数据量较小，我们的团队无法创建 10 亿个 Hashcat 候选者。\n3.  在表3中，最大概率选择器从图3中选择的每个模型的候选数量与单个模型的密码破解性能成正比。 这个结果表明REDPACK不是随机选择候选者而是选择性地选择候选者。 此外，这意味着 REDPACK 的鉴别器可以正确评估生成真实密码的概率。\n\n## REDPACK 的限制\n1. 选择了更现实的密码候选者。 然而，更现实的密码候选选择并不总是能保证有效的密码破解。将候选密码的数量压缩了，但它也遗漏了一些对密码破解可能很重要的候选密码。\n2. 将 OMEN 作为密码候选生成器组件时EDPACK 的候选字典的破解性能恶化。\n\t原因： OMEN 和 PCFG 都有相似的特性。 它们都以高阶概率生成候选密码（本身就筛选了一些密码）\n\t对 OMEN 和 PCFG 中的密码候选集应用随机洗牌。 这种简单的方法不能完全消除破解性能的损失。\n1. 基于三种不同方法（Hashcat：基于规则、PCFG：基于概率、rPassGAN：基于深度学习）的模型用作生成器时，REDPACK 在我们的实验中效率最高。\n\n## 后续工作\n自定义了一套规则集。\n1. base64 是 hashcat 最高效的规则集。\n2. 搜集：将7条Hashcat规则（best64、dive、specific、generate、InsidePro-PasswordPro、Incisive-leetspeak、T0X1Cv1）组合成一个巨大的规则文件。\n3. 测试：每条规则记录有助于密码破解的机会数量。\n4. 选择：对于REDPACKU4的自定义Hashcat规则集，选择了100条规则（与best64相同的数量）\n试验证明有效的。\n\n","source":"_posts/论文笔记/REDPACK.md","raw":"# 摘要\n1. 传统基于规则的方法依赖于专家知识\n2. 最新的基于深度学习方法，passGAN rpassGAN 在某些方面不如 PCFG\n3. 不同的深度学习方法有不同的候选密码空间，且无法重叠。\n4. 本文提出 REDPACK ，解决了 GAN 方法的不足，以有效的方法集合了多个候选密码生成器模型。\n\t1. 使用 rPassGAN 的候选密码鉴别器作为密码选择器。\n\t2. 有选择的搜集密码，我们实现了更真实的密码字典。\n5. 在符号，数字，大小写字母组成的密码字典上测试我们的系统。\n\t1. 优于 基于规则，GAN，PCFG，\n\t2. 生成候选密码减少 65% 时，破解性能仅损失 20%。\n\n# 引言\n1. 基于规则破解。基于专家的知识扩展性差。\n2. 先进的密码破解很有用\n\t1. 防御角度：作为密码强度估计器\n\t2. 攻击角度：通过多种方式利用先进的密码破解方法。\n\t\t1. 个人角度：破解自己忘记了的密码。\n\t\t2. 社会层面：执法机构需要破解密码来收集犯罪证据。\n## 旧的：Recurrent PassGAN\n对 PassGAN 的改进，弥补基于规则的方法和数据驱动的方法，例如马尔科夫模型等。\n1. 模型足够表示用户使用密码的模式和上下文结构。\n2. 深度学习不需要密码属性和结构的先验知识，只从训练数据中学习特征。\n\n普通 PassGAN：使用了Wasserstein GAN梯度惩罚（WGAN-GP）[11]模型。 WGAN-GP 的基础深度神经网络是基于卷积神经网络 (CNN) 的残差网络。\n\nrPassGAN 通过修改PassGAN的基础神经网络类型和结构来提高密码破解性能。\n\nrPassD2CGAN（rPassGAN 的双鉴别器版本）的性能优于 rPassGAN。然而，在rPassD2CGAN的训练过程中，它有时会变得不稳定。因此，我们通过使用另一个模型 rPassD2SGAN 来克服这个弱点。我们通过多个实验证明了 rPassGAN 生成的候选密码对于增强密码强度估计器的有效性。\n\n与概率上下文无关语法（PCFG）和其他马尔可夫模型（例如 OMEN [1]）相比，rPassGAN 有时破解的密码较少。\n\n## 新的：REDPACK\n\n核心：通过少量猜测来最大化密码破解性能。\n策略：\n1. 有选择地收集更真实的候选密码，以提高密码破解的效率。如果可以使用各种模型的候选密码字典。\n2. 相对论平均标准 GAN [13] 的判别器作为估计器运行，它评估来自各种预先生成的候选者的输入密码的真实性。\n3. 强调：通常只使用 GAN 生成器，我们还使用了 GAN 鉴别器。\n贡献：\n1. GAN 判别器用于帮助生成密码。\n2. REDPACK 能用多个预生成的候选密码制作更有效的候选字典。\n3. 为 REDPACK 构建了一个自定义规则集。\n\n## 文章结构\n1. 第 2 节：相关密码猜测模型\n2. 第 3 节：GANs 和 relativistic average GANs\n3. 第 4 节：REDPACK 的概念和架构\n4. 第 5 节：训练超参数的配置过程。实验结果\n5. 第 6 节：结论\n\n\n# 相关工作\n1. 基于规则的方法：\n\t1. hashcat ，JTR 开源软件多种攻击方式。\n\t2. 马尔科夫模型。\n\t3. 缺点：有明确的密钥空间。\n2. 马尔可夫和 PCFG。\n\t1. 使用符号：数字，字母，符号，单词。组合包含在特定概率分布中\n\t2. 使用马尔可夫过滤器消除滴概率密码\n\t3. 使用彩虹标加速。\n\t4. 图灵机处理特殊符号密码。\n\t5. 一些改进\n\t6. PCFG 使用学习语法结构，密码组合。\n\t7. 一些优化。\n3. 深度学习方法\n\t1. PassGAN ：WGAN-GP 代价函数 + CNN\n\t2. rPassGAN：RNN\n\t效果：能破解 PCFG 等其他模型无法破解的密码。\n\n# 背景知识\n## GAN\n1. [[GAN]] : GAN, WGAN, IWGAN 。其中 IWGAN 实验激发了 Hitaj 等人的兴趣。 [9]将IWGAN应用于密码猜测问题。 他们将创建的模型称为 PassGAN。\n## Relativistic average GAN\n1. GAN 可分为 IPM 和 non-IPM，\n\t1. non-IPM 在学习阶段不稳定，模型优化困难。\n\t2. IPM： Jolicoeur [13] 分析了 SGAN 的损失函数，以分析非基于 IPM 的 GAN 的局限性，并提出了一种相对论 GAN 来解决这个问题。 \n2. 来源：\n\t1. 问题：古德费洛等人。 [10]证明，当判别器以 0.5 的概率对真实数据进行分类时，GAN 训练达到全局最优。 然而，在许多情况下，判别器将真实数据和假数据都分类为真实数据，这对于训练好的生成器来说是不利的。 \n\t2. 这是因为判别器没有意识到学习过程中一半的数据是假的； \n\t3. 基于 IPM 的 GAN 在学习过程中相对稳定，因为它隐含地解释了这一事实。 \n\t4. 从散度最小化的角度来看，训练判别器以增加 D(xf)，而 D(xr) 不会相应减少，其中 xr 和 xf 分别表示真实数据和假数据。 为了解决这个问题，Jolicoeur [13] 设计了判别器的输出，使其依赖于真实数据和虚假数据。\n3. relativistic GAN\n\t![[Pasted image 20240416105310.png]]\n\t其中 C(x) 是假定的批评者 (D(x) = σ(C(x)))。 方程（2）可以解释为判别器对给定真实数据比假数据更真实的概率的估计（D(xf, xr)可以以相反的方式解释）。 如果根据等式（2）设置判别器，则与 SGAN 的生成器仅依赖于假数据不同，相对论性 GAN 的生成器将同时依赖于真实数据和假数据。 然而，它在计算损失时具有 O(m2) 复杂度（m 表示小批量的大小），因为它计算小批量中真数据和假数据之间的批评家的成对差异。\n4. RaGAN \n\t 为了解决这个问题，Jolicoeur [13] 提出了一种相对论平均 GAN（RaGAN），它对某些给定数据取相反类型数据的期望。 RaGAN 使用以下损失函数来学习判别器和生成器：\n\t![[Pasted image 20240416105456.png]]\n\t其中 LD 和 LG 分别表示学习判别器和生成器的损失。 方程(3)的复杂度为O(m)。 RaGAN 的判别器平均估计某些给定数据比相反类型的数据更真实的概率。 Jolicoeur [13] 使用不同的数据集表明，与其他 GAN 模型相比，训练 RaGAN 更快、更可靠，并且 RaGAN 的生成器生成了高质量的假数据。\n\n# 方法介绍：REDPACK\n\n## 概述\n1. 背景：之前 GAN 训练完成之后使用 GAN 生成器实现目的，作者在之前的论文中提到了基于 RNN 的 GAN 方法 rPassGAN ，本文使用的就是 rPassGAN 的 判别器\n2. REDPACK：GAN 的判别器是在模型训练结束之后使用的。\n\t![[Pasted image 20240416111123.png]]\n\t训练阶段：\n\t1. 生成器生成假密码，鉴别器区分，对抗训练，直到收敛。\n\t选择阶段：\n\t1. 使用多个密码生成器产生候选密码。作为训练阶段的结果。（本文使用了 三个或者四个）\n\t2. 鉴别器计算每个候选密码真实程度的概率。\n\t3. 将高概率的候选密码提供给 Hashcat等密码破解工具。\n## 鉴别器训练结构\n架构：\n![[Pasted image 20240416143214.png]]\n优化基于 RNN 的 GAN （判别器优化：使用了 RaGAN 和 IWGAN 的概念来实现了更强大的判别器）的流程：\n1. G 根据给定的任意噪声分布生成假密码，图中绿色路径；\n2. 根据等式 (3) ，当且仅当假密码的批评值大于图中蓝色存储所描述的真实数据时，D 才确定假密码为真实密码。\n3. 蓝色路径上的真实密码在相反情况下被视为真实的。(这里的相反可能是指的比较对象和)\n4. D 给出梯度作为惩罚，鼓励 G 生成更真实的密码，用红色路径表示。\n这样的流程使得 D 会生成比标准 GAN 更强大的判断。训练过程，算法描述如下：\n > \t梯度惩罚系数 λ、每个生成器的判别器迭代次数 ncritic 、每个判别器的生成器迭代次数 ngen 、批量大小 m 和 Adam 超参数 α、β1 和 β2。 Critic C 的参数 w 和生成器 G 的参数 θ。 真实密码 xr 和假密码 xf 之间直线上的随机样本 ˆx。\n\t![[Pasted image 20240416155902.png]]\n1. 主要源自 IWGAN，但使用相对论平均 GAN 的损失函数。 大多数符号遵循方程 (3)。 主要区别在于第 9 行和第 15 行中的损失函数。\n2. 这些损失函数取决于相对论判别器，估计一种类型密码的批评者相对于相反类型密码的平均批评者。 这种直接比较使 G 能够快速收敛到最佳点并产生高质量的假密码。\n3. 此外，由于我们基于 RNN 的 GAN 采用​​ IWGAN，因此我们将梯度惩罚添加到判别器的损失函数中。 此惩罚迫使 ^x 的梯度 2-范数小于 1，其中 ^x 是点对 (xr, xf) 之间直线上的随机样本。 这为 GAN 的训练提供了极大的稳定性。 \n4. 另一个重要因素是从第 13 行到第 16 行优化 G 的迭代。尽管大多数 GAN 都有一个在给定 G 上优化 D 的循环，但这不足以最大化 GAN 的性能。 因此，我们添加了训练 G 的循环来稳定和增强我们的 GAN。 根据我们在第 5 节中描述的实验，该因素对 REDPACK 的破解性能具有关键影响。 一般情况下，一旦模型被优化，生成器就被用作生成模型。 相反，我们利用鉴别器作为 REDPACK 的真实密码估计器。\n\n## 密码生成器选择\n流程图：\n![[Pasted image 20240416171606.png]]\n1. 多个候选密码生成器，比如：Hashcat、PCFG、rPassGAN 与 WGAN-GP 以及 rPassGAN 与 RaGAN-GP。\n2. 注意：不同损失函数的 rPassGAN 可以作为不同的 生成器使用，因为它们有不同的密码破解结果。\n3. 注意：单鉴别器 rPassGAN 和双鉴别器 rPassGAN 也是。\n4. 每个候选密码生成器生成的 10 亿个候选密码从字符串转换为张量，传递给鉴别器（D），估计密码真实性。\n5. 由最大概率选择器选择最高的密码，转换为 字符串形式。\n6. 这些候选者被传输给 Hashcat 破解。\n\n# 评估\n## 实验数据准备\n1. 大多数之前的研究使用的是 Rockyou 和 Linkedln。\n2. 但是本文在性能测试中使用到了包含长密码和 4 级密码的额外密码字典。所以使用 Melicher 等人的密码分类。 [27]。总共有七个训练和破解数据集：\n\t1. Rockyou 和 LinkedIn 包含一些 4 级密码。 \n\t2. 我们还使用了来自 Hashes.org 的四个破解密码字典，其中提供了多个破解和泄露的明文密码。 \n\t![[Pasted image 20240416194910.png]]\n\n## 超参数配置\n1. G:D：RaSGAN 通常使用 1:1 或者 1:10 \n2. 批次大小： 通常使用 128。使用 64 的批量大小可以来应对训练不稳定。\n3. epoch\n具体如下图：\n![[Pasted image 20240416201514.png]]\n\n## 实验环境\nTensorflow-gpu 1.10.1 和 Python 版本 3.5.4 进行 GPU 计算。 所有实验均在韩国大学NMLab的OpenHPC系统上进行。 发达。 OpenHPC的每个节点运行在具有32GB内存的CentOS 7服务器上； 这些节点使用 Intel Xeon E5 2.20GHz CPU(x2) 和 Nvidia TitanXP 12GB GPU(x4)。\n\n\n## 实验过程\n1. 根据我们之前的研究[8,12]推断，决定破解性能的主要因素是epoch、G/D比和循环神经网络（RNN）细胞类型。\n2. 如果 Epoch 过大，会导致过拟合。如图 4a 所示。\n3. 提高破解性能，需要在模型中应用较大范围的 G/D 比，但是比较费时。从而退一步：\n\t因此，我们对RaSGAN-GP成本函数使用1:1和1:10的G/D比进行了实验，如图4b所示。 虽然两者都可能不是最优值，但它们足以说明模型的有效性。 \n4. 最后要考虑的因素是神经单元类型。对于基于 RNN 的相对论判别器，有必要确定长短期记忆 (LSTM) [28] 和门控循环单元 (GRU) [33] 之间哪个更好。\n![[Pasted image 20240416202041.png]]\n结论：整个实验中，200k 训练周期、1:10 G/D 比率和 GRU 单元类型被确定为密码破解的最佳设置并确保通用性，如图 5 所示。\n![[Pasted image 20240416202513.png]]\n\n\n## 实验结果\n所有实验，我们的结果都优于其他模型。\n1. REDPACK 在数据集 2 到数据集 7 上的破解性能比任何单一密码猜测模型高出 5-20%。 在数据集1（短长密码）的情况下，PCFG在早期破解阶段表现出了很强的性能。 下半程的破解，REDPACK最终反超了PCFG。 然而，随着密码长度变长（从 dataset3 到 dataset7），REDPACK 的性能明显优于 PCFG 和其他密码候选生成器。 也就是说，对于复杂且长的密码，REDPACK的有效性得到了明显的体现。\n2. 对于数据集 6 和 7，由于训练数据量较小，我们的团队无法创建 10 亿个 Hashcat 候选者。\n3.  在表3中，最大概率选择器从图3中选择的每个模型的候选数量与单个模型的密码破解性能成正比。 这个结果表明REDPACK不是随机选择候选者而是选择性地选择候选者。 此外，这意味着 REDPACK 的鉴别器可以正确评估生成真实密码的概率。\n\n## REDPACK 的限制\n1. 选择了更现实的密码候选者。 然而，更现实的密码候选选择并不总是能保证有效的密码破解。将候选密码的数量压缩了，但它也遗漏了一些对密码破解可能很重要的候选密码。\n2. 将 OMEN 作为密码候选生成器组件时EDPACK 的候选字典的破解性能恶化。\n\t原因： OMEN 和 PCFG 都有相似的特性。 它们都以高阶概率生成候选密码（本身就筛选了一些密码）\n\t对 OMEN 和 PCFG 中的密码候选集应用随机洗牌。 这种简单的方法不能完全消除破解性能的损失。\n1. 基于三种不同方法（Hashcat：基于规则、PCFG：基于概率、rPassGAN：基于深度学习）的模型用作生成器时，REDPACK 在我们的实验中效率最高。\n\n## 后续工作\n自定义了一套规则集。\n1. base64 是 hashcat 最高效的规则集。\n2. 搜集：将7条Hashcat规则（best64、dive、specific、generate、InsidePro-PasswordPro、Incisive-leetspeak、T0X1Cv1）组合成一个巨大的规则文件。\n3. 测试：每条规则记录有助于密码破解的机会数量。\n4. 选择：对于REDPACKU4的自定义Hashcat规则集，选择了100条规则（与best64相同的数量）\n试验证明有效的。\n\n","slug":"论文笔记/REDPACK","published":1,"date":"2024-04-22T13:14:48.844Z","updated":"2024-04-16T13:12:25.835Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0j001jkgg4b672atqv","content":"<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><ol>\n<li>传统基于规则的方法依赖于专家知识</li>\n<li>最新的基于深度学习方法，passGAN rpassGAN 在某些方面不如 PCFG</li>\n<li>不同的深度学习方法有不同的候选密码空间，且无法重叠。</li>\n<li>本文提出 REDPACK ，解决了 GAN 方法的不足，以有效的方法集合了多个候选密码生成器模型。<ol>\n<li>使用 rPassGAN 的候选密码鉴别器作为密码选择器。</li>\n<li>有选择的搜集密码，我们实现了更真实的密码字典。</li>\n</ol>\n</li>\n<li>在符号，数字，大小写字母组成的密码字典上测试我们的系统。<ol>\n<li>优于 基于规则，GAN，PCFG，</li>\n<li>生成候选密码减少 65% 时，破解性能仅损失 20%。</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><ol>\n<li>基于规则破解。基于专家的知识扩展性差。</li>\n<li>先进的密码破解很有用<ol>\n<li>防御角度：作为密码强度估计器</li>\n<li>攻击角度：通过多种方式利用先进的密码破解方法。<ol>\n<li>个人角度：破解自己忘记了的密码。</li>\n<li>社会层面：执法机构需要破解密码来收集犯罪证据。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"旧的：Recurrent-PassGAN\"><a href=\"#旧的：Recurrent-PassGAN\" class=\"headerlink\" title=\"旧的：Recurrent PassGAN\"></a>旧的：Recurrent PassGAN</h2><p>对 PassGAN 的改进，弥补基于规则的方法和数据驱动的方法，例如马尔科夫模型等。</p>\n<ol>\n<li>模型足够表示用户使用密码的模式和上下文结构。</li>\n<li>深度学习不需要密码属性和结构的先验知识，只从训练数据中学习特征。</li>\n</ol>\n<p>普通 PassGAN：使用了Wasserstein GAN梯度惩罚（WGAN-GP）[11]模型。 WGAN-GP 的基础深度神经网络是基于卷积神经网络 (CNN) 的残差网络。</p>\n<p>rPassGAN 通过修改PassGAN的基础神经网络类型和结构来提高密码破解性能。</p>\n<p>rPassD2CGAN（rPassGAN 的双鉴别器版本）的性能优于 rPassGAN。然而，在rPassD2CGAN的训练过程中，它有时会变得不稳定。因此，我们通过使用另一个模型 rPassD2SGAN 来克服这个弱点。我们通过多个实验证明了 rPassGAN 生成的候选密码对于增强密码强度估计器的有效性。</p>\n<p>与概率上下文无关语法（PCFG）和其他马尔可夫模型（例如 OMEN [1]）相比，rPassGAN 有时破解的密码较少。</p>\n<h2 id=\"新的：REDPACK\"><a href=\"#新的：REDPACK\" class=\"headerlink\" title=\"新的：REDPACK\"></a>新的：REDPACK</h2><p>核心：通过少量猜测来最大化密码破解性能。<br>策略：</p>\n<ol>\n<li>有选择地收集更真实的候选密码，以提高密码破解的效率。如果可以使用各种模型的候选密码字典。</li>\n<li>相对论平均标准 GAN [13] 的判别器作为估计器运行，它评估来自各种预先生成的候选者的输入密码的真实性。</li>\n<li>强调：通常只使用 GAN 生成器，我们还使用了 GAN 鉴别器。<br>贡献：</li>\n<li>GAN 判别器用于帮助生成密码。</li>\n<li>REDPACK 能用多个预生成的候选密码制作更有效的候选字典。</li>\n<li>为 REDPACK 构建了一个自定义规则集。</li>\n</ol>\n<h2 id=\"文章结构\"><a href=\"#文章结构\" class=\"headerlink\" title=\"文章结构\"></a>文章结构</h2><ol>\n<li>第 2 节：相关密码猜测模型</li>\n<li>第 3 节：GANs 和 relativistic average GANs</li>\n<li>第 4 节：REDPACK 的概念和架构</li>\n<li>第 5 节：训练超参数的配置过程。实验结果</li>\n<li>第 6 节：结论</li>\n</ol>\n<h1 id=\"相关工作\"><a href=\"#相关工作\" class=\"headerlink\" title=\"相关工作\"></a>相关工作</h1><ol>\n<li>基于规则的方法：<ol>\n<li>hashcat ，JTR 开源软件多种攻击方式。</li>\n<li>马尔科夫模型。</li>\n<li>缺点：有明确的密钥空间。</li>\n</ol>\n</li>\n<li>马尔可夫和 PCFG。<ol>\n<li>使用符号：数字，字母，符号，单词。组合包含在特定概率分布中</li>\n<li>使用马尔可夫过滤器消除滴概率密码</li>\n<li>使用彩虹标加速。</li>\n<li>图灵机处理特殊符号密码。</li>\n<li>一些改进</li>\n<li>PCFG 使用学习语法结构，密码组合。</li>\n<li>一些优化。</li>\n</ol>\n</li>\n<li>深度学习方法<ol>\n<li>PassGAN ：WGAN-GP 代价函数 + CNN</li>\n<li>rPassGAN：RNN<br> 效果：能破解 PCFG 等其他模型无法破解的密码。</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"背景知识\"><a href=\"#背景知识\" class=\"headerlink\" title=\"背景知识\"></a>背景知识</h1><h2 id=\"GAN\"><a href=\"#GAN\" class=\"headerlink\" title=\"GAN\"></a>GAN</h2><ol>\n<li>[[GAN]] : GAN, WGAN, IWGAN 。其中 IWGAN 实验激发了 Hitaj 等人的兴趣。 [9]将IWGAN应用于密码猜测问题。 他们将创建的模型称为 PassGAN。</li>\n</ol>\n<h2 id=\"Relativistic-average-GAN\"><a href=\"#Relativistic-average-GAN\" class=\"headerlink\" title=\"Relativistic average GAN\"></a>Relativistic average GAN</h2><ol>\n<li>GAN 可分为 IPM 和 non-IPM，<ol>\n<li>non-IPM 在学习阶段不稳定，模型优化困难。</li>\n<li>IPM： Jolicoeur [13] 分析了 SGAN 的损失函数，以分析非基于 IPM 的 GAN 的局限性，并提出了一种相对论 GAN 来解决这个问题。</li>\n</ol>\n</li>\n<li>来源：<ol>\n<li>问题：古德费洛等人。 [10]证明，当判别器以 0.5 的概率对真实数据进行分类时，GAN 训练达到全局最优。 然而，在许多情况下，判别器将真实数据和假数据都分类为真实数据，这对于训练好的生成器来说是不利的。 </li>\n<li>这是因为判别器没有意识到学习过程中一半的数据是假的； </li>\n<li>基于 IPM 的 GAN 在学习过程中相对稳定，因为它隐含地解释了这一事实。 </li>\n<li>从散度最小化的角度来看，训练判别器以增加 D(xf)，而 D(xr) 不会相应减少，其中 xr 和 xf 分别表示真实数据和假数据。 为了解决这个问题，Jolicoeur [13] 设计了判别器的输出，使其依赖于真实数据和虚假数据。</li>\n</ol>\n</li>\n<li>relativistic GAN<br> ![[Pasted image 20240416105310.png]]<br> 其中 C(x) 是假定的批评者 (D(x) &#x3D; σ(C(x)))。 方程（2）可以解释为判别器对给定真实数据比假数据更真实的概率的估计（D(xf, xr)可以以相反的方式解释）。 如果根据等式（2）设置判别器，则与 SGAN 的生成器仅依赖于假数据不同，相对论性 GAN 的生成器将同时依赖于真实数据和假数据。 然而，它在计算损失时具有 O(m2) 复杂度（m 表示小批量的大小），因为它计算小批量中真数据和假数据之间的批评家的成对差异。</li>\n<li>RaGAN<br>  为了解决这个问题，Jolicoeur [13] 提出了一种相对论平均 GAN（RaGAN），它对某些给定数据取相反类型数据的期望。 RaGAN 使用以下损失函数来学习判别器和生成器：<br> ![[Pasted image 20240416105456.png]]<br> 其中 LD 和 LG 分别表示学习判别器和生成器的损失。 方程(3)的复杂度为O(m)。 RaGAN 的判别器平均估计某些给定数据比相反类型的数据更真实的概率。 Jolicoeur [13] 使用不同的数据集表明，与其他 GAN 模型相比，训练 RaGAN 更快、更可靠，并且 RaGAN 的生成器生成了高质量的假数据。</li>\n</ol>\n<h1 id=\"方法介绍：REDPACK\"><a href=\"#方法介绍：REDPACK\" class=\"headerlink\" title=\"方法介绍：REDPACK\"></a>方法介绍：REDPACK</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><ol>\n<li>背景：之前 GAN 训练完成之后使用 GAN 生成器实现目的，作者在之前的论文中提到了基于 RNN 的 GAN 方法 rPassGAN ，本文使用的就是 rPassGAN 的 判别器</li>\n<li>REDPACK：GAN 的判别器是在模型训练结束之后使用的。<br> ![[Pasted image 20240416111123.png]]<br> 训练阶段：<ol>\n<li>生成器生成假密码，鉴别器区分，对抗训练，直到收敛。<br> 选择阶段：</li>\n<li>使用多个密码生成器产生候选密码。作为训练阶段的结果。（本文使用了 三个或者四个）</li>\n<li>鉴别器计算每个候选密码真实程度的概率。</li>\n<li>将高概率的候选密码提供给 Hashcat等密码破解工具。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"鉴别器训练结构\"><a href=\"#鉴别器训练结构\" class=\"headerlink\" title=\"鉴别器训练结构\"></a>鉴别器训练结构</h2><p>架构：<br>![[Pasted image 20240416143214.png]]<br>优化基于 RNN 的 GAN （判别器优化：使用了 RaGAN 和 IWGAN 的概念来实现了更强大的判别器）的流程：</p>\n<ol>\n<li>G 根据给定的任意噪声分布生成假密码，图中绿色路径；</li>\n<li>根据等式 (3) ，当且仅当假密码的批评值大于图中蓝色存储所描述的真实数据时，D 才确定假密码为真实密码。</li>\n<li>蓝色路径上的真实密码在相反情况下被视为真实的。(这里的相反可能是指的比较对象和)</li>\n<li>D 给出梯度作为惩罚，鼓励 G 生成更真实的密码，用红色路径表示。<br>这样的流程使得 D 会生成比标准 GAN 更强大的判断。训练过程，算法描述如下：<blockquote>\n<pre><code>梯度惩罚系数 λ、每个生成器的判别器迭代次数 ncritic 、每个判别器的生成器迭代次数 ngen 、批量大小 m 和 Adam 超参数 α、β1 和 β2。 Critic C 的参数 w 和生成器 G 的参数 θ。 真实密码 xr 和假密码 xf 之间直线上的随机样本 ˆx。\n</code></pre>\n<p> ![[Pasted image 20240416155902.png]]</p>\n</blockquote>\n</li>\n<li>主要源自 IWGAN，但使用相对论平均 GAN 的损失函数。 大多数符号遵循方程 (3)。 主要区别在于第 9 行和第 15 行中的损失函数。</li>\n<li>这些损失函数取决于相对论判别器，估计一种类型密码的批评者相对于相反类型密码的平均批评者。 这种直接比较使 G 能够快速收敛到最佳点并产生高质量的假密码。</li>\n<li>此外，由于我们基于 RNN 的 GAN 采用​​ IWGAN，因此我们将梯度惩罚添加到判别器的损失函数中。 此惩罚迫使 ^x 的梯度 2-范数小于 1，其中 ^x 是点对 (xr, xf) 之间直线上的随机样本。 这为 GAN 的训练提供了极大的稳定性。 </li>\n<li>另一个重要因素是从第 13 行到第 16 行优化 G 的迭代。尽管大多数 GAN 都有一个在给定 G 上优化 D 的循环，但这不足以最大化 GAN 的性能。 因此，我们添加了训练 G 的循环来稳定和增强我们的 GAN。 根据我们在第 5 节中描述的实验，该因素对 REDPACK 的破解性能具有关键影响。 一般情况下，一旦模型被优化，生成器就被用作生成模型。 相反，我们利用鉴别器作为 REDPACK 的真实密码估计器。</li>\n</ol>\n<h2 id=\"密码生成器选择\"><a href=\"#密码生成器选择\" class=\"headerlink\" title=\"密码生成器选择\"></a>密码生成器选择</h2><p>流程图：<br>![[Pasted image 20240416171606.png]]</p>\n<ol>\n<li>多个候选密码生成器，比如：Hashcat、PCFG、rPassGAN 与 WGAN-GP 以及 rPassGAN 与 RaGAN-GP。</li>\n<li>注意：不同损失函数的 rPassGAN 可以作为不同的 生成器使用，因为它们有不同的密码破解结果。</li>\n<li>注意：单鉴别器 rPassGAN 和双鉴别器 rPassGAN 也是。</li>\n<li>每个候选密码生成器生成的 10 亿个候选密码从字符串转换为张量，传递给鉴别器（D），估计密码真实性。</li>\n<li>由最大概率选择器选择最高的密码，转换为 字符串形式。</li>\n<li>这些候选者被传输给 Hashcat 破解。</li>\n</ol>\n<h1 id=\"评估\"><a href=\"#评估\" class=\"headerlink\" title=\"评估\"></a>评估</h1><h2 id=\"实验数据准备\"><a href=\"#实验数据准备\" class=\"headerlink\" title=\"实验数据准备\"></a>实验数据准备</h2><ol>\n<li>大多数之前的研究使用的是 Rockyou 和 Linkedln。</li>\n<li>但是本文在性能测试中使用到了包含长密码和 4 级密码的额外密码字典。所以使用 Melicher 等人的密码分类。 [27]。总共有七个训练和破解数据集：<ol>\n<li>Rockyou 和 LinkedIn 包含一些 4 级密码。 </li>\n<li>我们还使用了来自 Hashes.org 的四个破解密码字典，其中提供了多个破解和泄露的明文密码。<br> ![[Pasted image 20240416194910.png]]</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"超参数配置\"><a href=\"#超参数配置\" class=\"headerlink\" title=\"超参数配置\"></a>超参数配置</h2><ol>\n<li>G:D：RaSGAN 通常使用 1:1 或者 1:10 </li>\n<li>批次大小： 通常使用 128。使用 64 的批量大小可以来应对训练不稳定。</li>\n<li>epoch<br>具体如下图：<br>![[Pasted image 20240416201514.png]]</li>\n</ol>\n<h2 id=\"实验环境\"><a href=\"#实验环境\" class=\"headerlink\" title=\"实验环境\"></a>实验环境</h2><p>Tensorflow-gpu 1.10.1 和 Python 版本 3.5.4 进行 GPU 计算。 所有实验均在韩国大学NMLab的OpenHPC系统上进行。 发达。 OpenHPC的每个节点运行在具有32GB内存的CentOS 7服务器上； 这些节点使用 Intel Xeon E5 2.20GHz CPU(x2) 和 Nvidia TitanXP 12GB GPU(x4)。</p>\n<h2 id=\"实验过程\"><a href=\"#实验过程\" class=\"headerlink\" title=\"实验过程\"></a>实验过程</h2><ol>\n<li>根据我们之前的研究[8,12]推断，决定破解性能的主要因素是epoch、G&#x2F;D比和循环神经网络（RNN）细胞类型。</li>\n<li>如果 Epoch 过大，会导致过拟合。如图 4a 所示。</li>\n<li>提高破解性能，需要在模型中应用较大范围的 G&#x2F;D 比，但是比较费时。从而退一步：<br> 因此，我们对RaSGAN-GP成本函数使用1:1和1:10的G&#x2F;D比进行了实验，如图4b所示。 虽然两者都可能不是最优值，但它们足以说明模型的有效性。 </li>\n<li>最后要考虑的因素是神经单元类型。对于基于 RNN 的相对论判别器，有必要确定长短期记忆 (LSTM) [28] 和门控循环单元 (GRU) [33] 之间哪个更好。<br>![[Pasted image 20240416202041.png]]<br>结论：整个实验中，200k 训练周期、1:10 G&#x2F;D 比率和 GRU 单元类型被确定为密码破解的最佳设置并确保通用性，如图 5 所示。<br>![[Pasted image 20240416202513.png]]</li>\n</ol>\n<h2 id=\"实验结果\"><a href=\"#实验结果\" class=\"headerlink\" title=\"实验结果\"></a>实验结果</h2><p>所有实验，我们的结果都优于其他模型。</p>\n<ol>\n<li>REDPACK 在数据集 2 到数据集 7 上的破解性能比任何单一密码猜测模型高出 5-20%。 在数据集1（短长密码）的情况下，PCFG在早期破解阶段表现出了很强的性能。 下半程的破解，REDPACK最终反超了PCFG。 然而，随着密码长度变长（从 dataset3 到 dataset7），REDPACK 的性能明显优于 PCFG 和其他密码候选生成器。 也就是说，对于复杂且长的密码，REDPACK的有效性得到了明显的体现。</li>\n<li>对于数据集 6 和 7，由于训练数据量较小，我们的团队无法创建 10 亿个 Hashcat 候选者。</li>\n<li> 在表3中，最大概率选择器从图3中选择的每个模型的候选数量与单个模型的密码破解性能成正比。 这个结果表明REDPACK不是随机选择候选者而是选择性地选择候选者。 此外，这意味着 REDPACK 的鉴别器可以正确评估生成真实密码的概率。</li>\n</ol>\n<h2 id=\"REDPACK-的限制\"><a href=\"#REDPACK-的限制\" class=\"headerlink\" title=\"REDPACK 的限制\"></a>REDPACK 的限制</h2><ol>\n<li>选择了更现实的密码候选者。 然而，更现实的密码候选选择并不总是能保证有效的密码破解。将候选密码的数量压缩了，但它也遗漏了一些对密码破解可能很重要的候选密码。</li>\n<li>将 OMEN 作为密码候选生成器组件时EDPACK 的候选字典的破解性能恶化。<br> 原因： OMEN 和 PCFG 都有相似的特性。 它们都以高阶概率生成候选密码（本身就筛选了一些密码）<br> 对 OMEN 和 PCFG 中的密码候选集应用随机洗牌。 这种简单的方法不能完全消除破解性能的损失。</li>\n<li>基于三种不同方法（Hashcat：基于规则、PCFG：基于概率、rPassGAN：基于深度学习）的模型用作生成器时，REDPACK 在我们的实验中效率最高。</li>\n</ol>\n<h2 id=\"后续工作\"><a href=\"#后续工作\" class=\"headerlink\" title=\"后续工作\"></a>后续工作</h2><p>自定义了一套规则集。</p>\n<ol>\n<li>base64 是 hashcat 最高效的规则集。</li>\n<li>搜集：将7条Hashcat规则（best64、dive、specific、generate、InsidePro-PasswordPro、Incisive-leetspeak、T0X1Cv1）组合成一个巨大的规则文件。</li>\n<li>测试：每条规则记录有助于密码破解的机会数量。</li>\n<li>选择：对于REDPACKU4的自定义Hashcat规则集，选择了100条规则（与best64相同的数量）<br>试验证明有效的。</li>\n</ol>\n","excerpt":"","more":"<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><ol>\n<li>传统基于规则的方法依赖于专家知识</li>\n<li>最新的基于深度学习方法，passGAN rpassGAN 在某些方面不如 PCFG</li>\n<li>不同的深度学习方法有不同的候选密码空间，且无法重叠。</li>\n<li>本文提出 REDPACK ，解决了 GAN 方法的不足，以有效的方法集合了多个候选密码生成器模型。<ol>\n<li>使用 rPassGAN 的候选密码鉴别器作为密码选择器。</li>\n<li>有选择的搜集密码，我们实现了更真实的密码字典。</li>\n</ol>\n</li>\n<li>在符号，数字，大小写字母组成的密码字典上测试我们的系统。<ol>\n<li>优于 基于规则，GAN，PCFG，</li>\n<li>生成候选密码减少 65% 时，破解性能仅损失 20%。</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><ol>\n<li>基于规则破解。基于专家的知识扩展性差。</li>\n<li>先进的密码破解很有用<ol>\n<li>防御角度：作为密码强度估计器</li>\n<li>攻击角度：通过多种方式利用先进的密码破解方法。<ol>\n<li>个人角度：破解自己忘记了的密码。</li>\n<li>社会层面：执法机构需要破解密码来收集犯罪证据。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"旧的：Recurrent-PassGAN\"><a href=\"#旧的：Recurrent-PassGAN\" class=\"headerlink\" title=\"旧的：Recurrent PassGAN\"></a>旧的：Recurrent PassGAN</h2><p>对 PassGAN 的改进，弥补基于规则的方法和数据驱动的方法，例如马尔科夫模型等。</p>\n<ol>\n<li>模型足够表示用户使用密码的模式和上下文结构。</li>\n<li>深度学习不需要密码属性和结构的先验知识，只从训练数据中学习特征。</li>\n</ol>\n<p>普通 PassGAN：使用了Wasserstein GAN梯度惩罚（WGAN-GP）[11]模型。 WGAN-GP 的基础深度神经网络是基于卷积神经网络 (CNN) 的残差网络。</p>\n<p>rPassGAN 通过修改PassGAN的基础神经网络类型和结构来提高密码破解性能。</p>\n<p>rPassD2CGAN（rPassGAN 的双鉴别器版本）的性能优于 rPassGAN。然而，在rPassD2CGAN的训练过程中，它有时会变得不稳定。因此，我们通过使用另一个模型 rPassD2SGAN 来克服这个弱点。我们通过多个实验证明了 rPassGAN 生成的候选密码对于增强密码强度估计器的有效性。</p>\n<p>与概率上下文无关语法（PCFG）和其他马尔可夫模型（例如 OMEN [1]）相比，rPassGAN 有时破解的密码较少。</p>\n<h2 id=\"新的：REDPACK\"><a href=\"#新的：REDPACK\" class=\"headerlink\" title=\"新的：REDPACK\"></a>新的：REDPACK</h2><p>核心：通过少量猜测来最大化密码破解性能。<br>策略：</p>\n<ol>\n<li>有选择地收集更真实的候选密码，以提高密码破解的效率。如果可以使用各种模型的候选密码字典。</li>\n<li>相对论平均标准 GAN [13] 的判别器作为估计器运行，它评估来自各种预先生成的候选者的输入密码的真实性。</li>\n<li>强调：通常只使用 GAN 生成器，我们还使用了 GAN 鉴别器。<br>贡献：</li>\n<li>GAN 判别器用于帮助生成密码。</li>\n<li>REDPACK 能用多个预生成的候选密码制作更有效的候选字典。</li>\n<li>为 REDPACK 构建了一个自定义规则集。</li>\n</ol>\n<h2 id=\"文章结构\"><a href=\"#文章结构\" class=\"headerlink\" title=\"文章结构\"></a>文章结构</h2><ol>\n<li>第 2 节：相关密码猜测模型</li>\n<li>第 3 节：GANs 和 relativistic average GANs</li>\n<li>第 4 节：REDPACK 的概念和架构</li>\n<li>第 5 节：训练超参数的配置过程。实验结果</li>\n<li>第 6 节：结论</li>\n</ol>\n<h1 id=\"相关工作\"><a href=\"#相关工作\" class=\"headerlink\" title=\"相关工作\"></a>相关工作</h1><ol>\n<li>基于规则的方法：<ol>\n<li>hashcat ，JTR 开源软件多种攻击方式。</li>\n<li>马尔科夫模型。</li>\n<li>缺点：有明确的密钥空间。</li>\n</ol>\n</li>\n<li>马尔可夫和 PCFG。<ol>\n<li>使用符号：数字，字母，符号，单词。组合包含在特定概率分布中</li>\n<li>使用马尔可夫过滤器消除滴概率密码</li>\n<li>使用彩虹标加速。</li>\n<li>图灵机处理特殊符号密码。</li>\n<li>一些改进</li>\n<li>PCFG 使用学习语法结构，密码组合。</li>\n<li>一些优化。</li>\n</ol>\n</li>\n<li>深度学习方法<ol>\n<li>PassGAN ：WGAN-GP 代价函数 + CNN</li>\n<li>rPassGAN：RNN<br> 效果：能破解 PCFG 等其他模型无法破解的密码。</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"背景知识\"><a href=\"#背景知识\" class=\"headerlink\" title=\"背景知识\"></a>背景知识</h1><h2 id=\"GAN\"><a href=\"#GAN\" class=\"headerlink\" title=\"GAN\"></a>GAN</h2><ol>\n<li>[[GAN]] : GAN, WGAN, IWGAN 。其中 IWGAN 实验激发了 Hitaj 等人的兴趣。 [9]将IWGAN应用于密码猜测问题。 他们将创建的模型称为 PassGAN。</li>\n</ol>\n<h2 id=\"Relativistic-average-GAN\"><a href=\"#Relativistic-average-GAN\" class=\"headerlink\" title=\"Relativistic average GAN\"></a>Relativistic average GAN</h2><ol>\n<li>GAN 可分为 IPM 和 non-IPM，<ol>\n<li>non-IPM 在学习阶段不稳定，模型优化困难。</li>\n<li>IPM： Jolicoeur [13] 分析了 SGAN 的损失函数，以分析非基于 IPM 的 GAN 的局限性，并提出了一种相对论 GAN 来解决这个问题。</li>\n</ol>\n</li>\n<li>来源：<ol>\n<li>问题：古德费洛等人。 [10]证明，当判别器以 0.5 的概率对真实数据进行分类时，GAN 训练达到全局最优。 然而，在许多情况下，判别器将真实数据和假数据都分类为真实数据，这对于训练好的生成器来说是不利的。 </li>\n<li>这是因为判别器没有意识到学习过程中一半的数据是假的； </li>\n<li>基于 IPM 的 GAN 在学习过程中相对稳定，因为它隐含地解释了这一事实。 </li>\n<li>从散度最小化的角度来看，训练判别器以增加 D(xf)，而 D(xr) 不会相应减少，其中 xr 和 xf 分别表示真实数据和假数据。 为了解决这个问题，Jolicoeur [13] 设计了判别器的输出，使其依赖于真实数据和虚假数据。</li>\n</ol>\n</li>\n<li>relativistic GAN<br> ![[Pasted image 20240416105310.png]]<br> 其中 C(x) 是假定的批评者 (D(x) &#x3D; σ(C(x)))。 方程（2）可以解释为判别器对给定真实数据比假数据更真实的概率的估计（D(xf, xr)可以以相反的方式解释）。 如果根据等式（2）设置判别器，则与 SGAN 的生成器仅依赖于假数据不同，相对论性 GAN 的生成器将同时依赖于真实数据和假数据。 然而，它在计算损失时具有 O(m2) 复杂度（m 表示小批量的大小），因为它计算小批量中真数据和假数据之间的批评家的成对差异。</li>\n<li>RaGAN<br>  为了解决这个问题，Jolicoeur [13] 提出了一种相对论平均 GAN（RaGAN），它对某些给定数据取相反类型数据的期望。 RaGAN 使用以下损失函数来学习判别器和生成器：<br> ![[Pasted image 20240416105456.png]]<br> 其中 LD 和 LG 分别表示学习判别器和生成器的损失。 方程(3)的复杂度为O(m)。 RaGAN 的判别器平均估计某些给定数据比相反类型的数据更真实的概率。 Jolicoeur [13] 使用不同的数据集表明，与其他 GAN 模型相比，训练 RaGAN 更快、更可靠，并且 RaGAN 的生成器生成了高质量的假数据。</li>\n</ol>\n<h1 id=\"方法介绍：REDPACK\"><a href=\"#方法介绍：REDPACK\" class=\"headerlink\" title=\"方法介绍：REDPACK\"></a>方法介绍：REDPACK</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><ol>\n<li>背景：之前 GAN 训练完成之后使用 GAN 生成器实现目的，作者在之前的论文中提到了基于 RNN 的 GAN 方法 rPassGAN ，本文使用的就是 rPassGAN 的 判别器</li>\n<li>REDPACK：GAN 的判别器是在模型训练结束之后使用的。<br> ![[Pasted image 20240416111123.png]]<br> 训练阶段：<ol>\n<li>生成器生成假密码，鉴别器区分，对抗训练，直到收敛。<br> 选择阶段：</li>\n<li>使用多个密码生成器产生候选密码。作为训练阶段的结果。（本文使用了 三个或者四个）</li>\n<li>鉴别器计算每个候选密码真实程度的概率。</li>\n<li>将高概率的候选密码提供给 Hashcat等密码破解工具。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"鉴别器训练结构\"><a href=\"#鉴别器训练结构\" class=\"headerlink\" title=\"鉴别器训练结构\"></a>鉴别器训练结构</h2><p>架构：<br>![[Pasted image 20240416143214.png]]<br>优化基于 RNN 的 GAN （判别器优化：使用了 RaGAN 和 IWGAN 的概念来实现了更强大的判别器）的流程：</p>\n<ol>\n<li>G 根据给定的任意噪声分布生成假密码，图中绿色路径；</li>\n<li>根据等式 (3) ，当且仅当假密码的批评值大于图中蓝色存储所描述的真实数据时，D 才确定假密码为真实密码。</li>\n<li>蓝色路径上的真实密码在相反情况下被视为真实的。(这里的相反可能是指的比较对象和)</li>\n<li>D 给出梯度作为惩罚，鼓励 G 生成更真实的密码，用红色路径表示。<br>这样的流程使得 D 会生成比标准 GAN 更强大的判断。训练过程，算法描述如下：<blockquote>\n<pre><code>梯度惩罚系数 λ、每个生成器的判别器迭代次数 ncritic 、每个判别器的生成器迭代次数 ngen 、批量大小 m 和 Adam 超参数 α、β1 和 β2。 Critic C 的参数 w 和生成器 G 的参数 θ。 真实密码 xr 和假密码 xf 之间直线上的随机样本 ˆx。\n</code></pre>\n<p> ![[Pasted image 20240416155902.png]]</p>\n</blockquote>\n</li>\n<li>主要源自 IWGAN，但使用相对论平均 GAN 的损失函数。 大多数符号遵循方程 (3)。 主要区别在于第 9 行和第 15 行中的损失函数。</li>\n<li>这些损失函数取决于相对论判别器，估计一种类型密码的批评者相对于相反类型密码的平均批评者。 这种直接比较使 G 能够快速收敛到最佳点并产生高质量的假密码。</li>\n<li>此外，由于我们基于 RNN 的 GAN 采用​​ IWGAN，因此我们将梯度惩罚添加到判别器的损失函数中。 此惩罚迫使 ^x 的梯度 2-范数小于 1，其中 ^x 是点对 (xr, xf) 之间直线上的随机样本。 这为 GAN 的训练提供了极大的稳定性。 </li>\n<li>另一个重要因素是从第 13 行到第 16 行优化 G 的迭代。尽管大多数 GAN 都有一个在给定 G 上优化 D 的循环，但这不足以最大化 GAN 的性能。 因此，我们添加了训练 G 的循环来稳定和增强我们的 GAN。 根据我们在第 5 节中描述的实验，该因素对 REDPACK 的破解性能具有关键影响。 一般情况下，一旦模型被优化，生成器就被用作生成模型。 相反，我们利用鉴别器作为 REDPACK 的真实密码估计器。</li>\n</ol>\n<h2 id=\"密码生成器选择\"><a href=\"#密码生成器选择\" class=\"headerlink\" title=\"密码生成器选择\"></a>密码生成器选择</h2><p>流程图：<br>![[Pasted image 20240416171606.png]]</p>\n<ol>\n<li>多个候选密码生成器，比如：Hashcat、PCFG、rPassGAN 与 WGAN-GP 以及 rPassGAN 与 RaGAN-GP。</li>\n<li>注意：不同损失函数的 rPassGAN 可以作为不同的 生成器使用，因为它们有不同的密码破解结果。</li>\n<li>注意：单鉴别器 rPassGAN 和双鉴别器 rPassGAN 也是。</li>\n<li>每个候选密码生成器生成的 10 亿个候选密码从字符串转换为张量，传递给鉴别器（D），估计密码真实性。</li>\n<li>由最大概率选择器选择最高的密码，转换为 字符串形式。</li>\n<li>这些候选者被传输给 Hashcat 破解。</li>\n</ol>\n<h1 id=\"评估\"><a href=\"#评估\" class=\"headerlink\" title=\"评估\"></a>评估</h1><h2 id=\"实验数据准备\"><a href=\"#实验数据准备\" class=\"headerlink\" title=\"实验数据准备\"></a>实验数据准备</h2><ol>\n<li>大多数之前的研究使用的是 Rockyou 和 Linkedln。</li>\n<li>但是本文在性能测试中使用到了包含长密码和 4 级密码的额外密码字典。所以使用 Melicher 等人的密码分类。 [27]。总共有七个训练和破解数据集：<ol>\n<li>Rockyou 和 LinkedIn 包含一些 4 级密码。 </li>\n<li>我们还使用了来自 Hashes.org 的四个破解密码字典，其中提供了多个破解和泄露的明文密码。<br> ![[Pasted image 20240416194910.png]]</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"超参数配置\"><a href=\"#超参数配置\" class=\"headerlink\" title=\"超参数配置\"></a>超参数配置</h2><ol>\n<li>G:D：RaSGAN 通常使用 1:1 或者 1:10 </li>\n<li>批次大小： 通常使用 128。使用 64 的批量大小可以来应对训练不稳定。</li>\n<li>epoch<br>具体如下图：<br>![[Pasted image 20240416201514.png]]</li>\n</ol>\n<h2 id=\"实验环境\"><a href=\"#实验环境\" class=\"headerlink\" title=\"实验环境\"></a>实验环境</h2><p>Tensorflow-gpu 1.10.1 和 Python 版本 3.5.4 进行 GPU 计算。 所有实验均在韩国大学NMLab的OpenHPC系统上进行。 发达。 OpenHPC的每个节点运行在具有32GB内存的CentOS 7服务器上； 这些节点使用 Intel Xeon E5 2.20GHz CPU(x2) 和 Nvidia TitanXP 12GB GPU(x4)。</p>\n<h2 id=\"实验过程\"><a href=\"#实验过程\" class=\"headerlink\" title=\"实验过程\"></a>实验过程</h2><ol>\n<li>根据我们之前的研究[8,12]推断，决定破解性能的主要因素是epoch、G&#x2F;D比和循环神经网络（RNN）细胞类型。</li>\n<li>如果 Epoch 过大，会导致过拟合。如图 4a 所示。</li>\n<li>提高破解性能，需要在模型中应用较大范围的 G&#x2F;D 比，但是比较费时。从而退一步：<br> 因此，我们对RaSGAN-GP成本函数使用1:1和1:10的G&#x2F;D比进行了实验，如图4b所示。 虽然两者都可能不是最优值，但它们足以说明模型的有效性。 </li>\n<li>最后要考虑的因素是神经单元类型。对于基于 RNN 的相对论判别器，有必要确定长短期记忆 (LSTM) [28] 和门控循环单元 (GRU) [33] 之间哪个更好。<br>![[Pasted image 20240416202041.png]]<br>结论：整个实验中，200k 训练周期、1:10 G&#x2F;D 比率和 GRU 单元类型被确定为密码破解的最佳设置并确保通用性，如图 5 所示。<br>![[Pasted image 20240416202513.png]]</li>\n</ol>\n<h2 id=\"实验结果\"><a href=\"#实验结果\" class=\"headerlink\" title=\"实验结果\"></a>实验结果</h2><p>所有实验，我们的结果都优于其他模型。</p>\n<ol>\n<li>REDPACK 在数据集 2 到数据集 7 上的破解性能比任何单一密码猜测模型高出 5-20%。 在数据集1（短长密码）的情况下，PCFG在早期破解阶段表现出了很强的性能。 下半程的破解，REDPACK最终反超了PCFG。 然而，随着密码长度变长（从 dataset3 到 dataset7），REDPACK 的性能明显优于 PCFG 和其他密码候选生成器。 也就是说，对于复杂且长的密码，REDPACK的有效性得到了明显的体现。</li>\n<li>对于数据集 6 和 7，由于训练数据量较小，我们的团队无法创建 10 亿个 Hashcat 候选者。</li>\n<li> 在表3中，最大概率选择器从图3中选择的每个模型的候选数量与单个模型的密码破解性能成正比。 这个结果表明REDPACK不是随机选择候选者而是选择性地选择候选者。 此外，这意味着 REDPACK 的鉴别器可以正确评估生成真实密码的概率。</li>\n</ol>\n<h2 id=\"REDPACK-的限制\"><a href=\"#REDPACK-的限制\" class=\"headerlink\" title=\"REDPACK 的限制\"></a>REDPACK 的限制</h2><ol>\n<li>选择了更现实的密码候选者。 然而，更现实的密码候选选择并不总是能保证有效的密码破解。将候选密码的数量压缩了，但它也遗漏了一些对密码破解可能很重要的候选密码。</li>\n<li>将 OMEN 作为密码候选生成器组件时EDPACK 的候选字典的破解性能恶化。<br> 原因： OMEN 和 PCFG 都有相似的特性。 它们都以高阶概率生成候选密码（本身就筛选了一些密码）<br> 对 OMEN 和 PCFG 中的密码候选集应用随机洗牌。 这种简单的方法不能完全消除破解性能的损失。</li>\n<li>基于三种不同方法（Hashcat：基于规则、PCFG：基于概率、rPassGAN：基于深度学习）的模型用作生成器时，REDPACK 在我们的实验中效率最高。</li>\n</ol>\n<h2 id=\"后续工作\"><a href=\"#后续工作\" class=\"headerlink\" title=\"后续工作\"></a>后续工作</h2><p>自定义了一套规则集。</p>\n<ol>\n<li>base64 是 hashcat 最高效的规则集。</li>\n<li>搜集：将7条Hashcat规则（best64、dive、specific、generate、InsidePro-PasswordPro、Incisive-leetspeak、T0X1Cv1）组合成一个巨大的规则文件。</li>\n<li>测试：每条规则记录有助于密码破解的机会数量。</li>\n<li>选择：对于REDPACKU4的自定义Hashcat规则集，选择了100条规则（与best64相同的数量）<br>试验证明有效的。</li>\n</ol>\n"},{"_content":"# TODO\n1. 完成 GuessFuse 阅读。\n2. 阅读 GuessFuse 提到的多种模型结合方法。（也可能是密码强度估计器。）\n\t1. 有一种[33]介绍了一种称为 hyPassGu 的混合猜测框架。 hyPassGu 通过限制每个模型生成目标类型的密码并分别确定猜测次数，利用 PCFG 和马尔可夫模型的优势。 尽管声称 hyPassGu 可以应用于 PCFG 和马尔可夫之外的其他模型， 和MOE 的思路有点像\n3. MOE 相关的论文和博客阅读。\n\n# 密码生成思路\n\n参考 [[GuessFuse]] 感觉结构可以\n\n\n## 相关工作\n### 道德考虑。\n尽管我们使用的数据集是公开的，并广泛用于密码猜测研究 [8]、[27]、[32]–[34]，但这些数据集包含敏感的个人信息。 因此，我们仅分析密码数据的分布特征，并报告汇总的统计信息。 我们不会将任何数据用于学术研究以外的目的，因此不会增加受影响个人的风险。\n","source":"_posts/论文笔记/TEMP.md","raw":"# TODO\n1. 完成 GuessFuse 阅读。\n2. 阅读 GuessFuse 提到的多种模型结合方法。（也可能是密码强度估计器。）\n\t1. 有一种[33]介绍了一种称为 hyPassGu 的混合猜测框架。 hyPassGu 通过限制每个模型生成目标类型的密码并分别确定猜测次数，利用 PCFG 和马尔可夫模型的优势。 尽管声称 hyPassGu 可以应用于 PCFG 和马尔可夫之外的其他模型， 和MOE 的思路有点像\n3. MOE 相关的论文和博客阅读。\n\n# 密码生成思路\n\n参考 [[GuessFuse]] 感觉结构可以\n\n\n## 相关工作\n### 道德考虑。\n尽管我们使用的数据集是公开的，并广泛用于密码猜测研究 [8]、[27]、[32]–[34]，但这些数据集包含敏感的个人信息。 因此，我们仅分析密码数据的分布特征，并报告汇总的统计信息。 我们不会将任何数据用于学术研究以外的目的，因此不会增加受影响个人的风险。\n","slug":"论文笔记/TEMP","published":1,"date":"2024-04-22T13:14:48.845Z","updated":"2024-04-18T11:05:32.132Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0j001kkgg4eleth4rc","content":"<h1 id=\"TODO\"><a href=\"#TODO\" class=\"headerlink\" title=\"TODO\"></a>TODO</h1><ol>\n<li>完成 GuessFuse 阅读。</li>\n<li>阅读 GuessFuse 提到的多种模型结合方法。（也可能是密码强度估计器。）<ol>\n<li>有一种[33]介绍了一种称为 hyPassGu 的混合猜测框架。 hyPassGu 通过限制每个模型生成目标类型的密码并分别确定猜测次数，利用 PCFG 和马尔可夫模型的优势。 尽管声称 hyPassGu 可以应用于 PCFG 和马尔可夫之外的其他模型， 和MOE 的思路有点像</li>\n</ol>\n</li>\n<li>MOE 相关的论文和博客阅读。</li>\n</ol>\n<h1 id=\"密码生成思路\"><a href=\"#密码生成思路\" class=\"headerlink\" title=\"密码生成思路\"></a>密码生成思路</h1><p>参考 [[GuessFuse]] 感觉结构可以</p>\n<h2 id=\"相关工作\"><a href=\"#相关工作\" class=\"headerlink\" title=\"相关工作\"></a>相关工作</h2><h3 id=\"道德考虑。\"><a href=\"#道德考虑。\" class=\"headerlink\" title=\"道德考虑。\"></a>道德考虑。</h3><p>尽管我们使用的数据集是公开的，并广泛用于密码猜测研究 [8]、[27]、[32]–[34]，但这些数据集包含敏感的个人信息。 因此，我们仅分析密码数据的分布特征，并报告汇总的统计信息。 我们不会将任何数据用于学术研究以外的目的，因此不会增加受影响个人的风险。</p>\n","excerpt":"","more":"<h1 id=\"TODO\"><a href=\"#TODO\" class=\"headerlink\" title=\"TODO\"></a>TODO</h1><ol>\n<li>完成 GuessFuse 阅读。</li>\n<li>阅读 GuessFuse 提到的多种模型结合方法。（也可能是密码强度估计器。）<ol>\n<li>有一种[33]介绍了一种称为 hyPassGu 的混合猜测框架。 hyPassGu 通过限制每个模型生成目标类型的密码并分别确定猜测次数，利用 PCFG 和马尔可夫模型的优势。 尽管声称 hyPassGu 可以应用于 PCFG 和马尔可夫之外的其他模型， 和MOE 的思路有点像</li>\n</ol>\n</li>\n<li>MOE 相关的论文和博客阅读。</li>\n</ol>\n<h1 id=\"密码生成思路\"><a href=\"#密码生成思路\" class=\"headerlink\" title=\"密码生成思路\"></a>密码生成思路</h1><p>参考 [[GuessFuse]] 感觉结构可以</p>\n<h2 id=\"相关工作\"><a href=\"#相关工作\" class=\"headerlink\" title=\"相关工作\"></a>相关工作</h2><h3 id=\"道德考虑。\"><a href=\"#道德考虑。\" class=\"headerlink\" title=\"道德考虑。\"></a>道德考虑。</h3><p>尽管我们使用的数据集是公开的，并广泛用于密码猜测研究 [8]、[27]、[32]–[34]，但这些数据集包含敏感的个人信息。 因此，我们仅分析密码数据的分布特征，并报告汇总的统计信息。 我们不会将任何数据用于学术研究以外的目的，因此不会增加受影响个人的风险。</p>\n"},{"_content":"","source":"_posts/论文笔记/基于深度学习的口令安全关键技术研究.md","raw":"","slug":"论文笔记/基于深度学习的口令安全关键技术研究","published":1,"date":"2024-04-22T13:14:48.905Z","updated":"2024-03-06T07:26:51.445Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0j001lkgg47sohci55","content":"","excerpt":"","more":""},{"_content":"","source":"_posts/论文笔记/未命名.md","raw":"","slug":"论文笔记/未命名","published":1,"date":"2024-04-22T13:14:48.920Z","updated":"2024-04-18T07:54:31.052Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0k001mkgg41m578zzi","content":"","excerpt":"","more":""},{"_content":"# 引言\n\n口令常用，口令脆弱\n\n口令破解主要关注点在于利用尽可能小的生成子点集合覆盖尽可能多的真实口令\n1. Markov\n2. PCFG\n3. NN\n反向传播算法是神经网络的核心算法。该算法的思想是，通过对预估结果的评价的反馈判断模型参数中导致预测结果变坏的量，对其加以纠正，使得模型逐渐趋向最优。\n","source":"_posts/论文笔记/明文口令生成模型.md","raw":"# 引言\n\n口令常用，口令脆弱\n\n口令破解主要关注点在于利用尽可能小的生成子点集合覆盖尽可能多的真实口令\n1. Markov\n2. PCFG\n3. NN\n反向传播算法是神经网络的核心算法。该算法的思想是，通过对预估结果的评价的反馈判断模型参数中导致预测结果变坏的量，对其加以纠正，使得模型逐渐趋向最优。\n","slug":"论文笔记/明文口令生成模型","published":1,"date":"2024-04-22T13:14:48.905Z","updated":"2024-03-06T09:14:17.373Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0k001nkgg4gedbflca","content":"<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>口令常用，口令脆弱</p>\n<p>口令破解主要关注点在于利用尽可能小的生成子点集合覆盖尽可能多的真实口令</p>\n<ol>\n<li>Markov</li>\n<li>PCFG</li>\n<li>NN<br>反向传播算法是神经网络的核心算法。该算法的思想是，通过对预估结果的评价的反馈判断模型参数中导致预测结果变坏的量，对其加以纠正，使得模型逐渐趋向最优。</li>\n</ol>\n","excerpt":"","more":"<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>口令常用，口令脆弱</p>\n<p>口令破解主要关注点在于利用尽可能小的生成子点集合覆盖尽可能多的真实口令</p>\n<ol>\n<li>Markov</li>\n<li>PCFG</li>\n<li>NN<br>反向传播算法是神经网络的核心算法。该算法的思想是，通过对预估结果的评价的反馈判断模型参数中导致预测结果变坏的量，对其加以纠正，使得模型逐渐趋向最优。</li>\n</ol>\n"},{"_content":"密码模型是数据驱动的结构，它捕获密码样本中的规律性，并有助于分析密码创建模式，这经常被用于密码猜测攻击。语义PCFG[21]是一种捕获句法和语义信息的概率上下文无关文法(PCFG)。它假设，除了随机序列外，人们还会选择有意义的单词组合，这些组合在进行大规模分析时会形成规则模式。这些模式与自然语言中发现的模式相似，但并不严格遵守自然语言语法规则。\n当主要在英语数据集上训练时，语义PCFG被证明优于Weir等人的PCFG。[23]在以LinkedIn、MySpace、RockYou和Gamigo列表为目标的猜测会话中[11，21]。语义密码模型是语言密码模型家族中的一员，它依赖于语言资源和过程，如分析、分割和分类。语言模型仍然很有价值，因为它们为密码列表的构成提供了可解释的描述，使研究人员能够详细研究用户群体之间的差异和密码策略的影响。然而，关于这种语言建模行为的重要问题仍然没有得到回答。不同级别的信息(例如，句法、语义)对概括的个体贡献以及因此的猜测性能是未知的。从小样本中学习模式的能力还没有被很好地理解，控制过度匹配的参数的有效性也没有被很好地理解，例如语义专一性--语义语法训练的一个免费参数--和概率平滑方法，这是所有语言学方法共同的。此外，在引入语义模型后，蒙特卡罗强度评估使在非常长的会话中估计猜测成功成为可能[7]。这使得对语义模型的原始评估过时了，因为它仅限于破解多达30亿次猜测的尝试。较新的模型通常使用蒙特卡罗评估，这使得与较旧的模型进行比较变得困难。特别是，Melicher等人的神经密码模型。[16]取得了优异的性能，超过了其他高分自动裂解方法，包括Weir等人的PCFG的改进版本。","source":"_posts/论文笔记/语法密码分析.md","raw":"密码模型是数据驱动的结构，它捕获密码样本中的规律性，并有助于分析密码创建模式，这经常被用于密码猜测攻击。语义PCFG[21]是一种捕获句法和语义信息的概率上下文无关文法(PCFG)。它假设，除了随机序列外，人们还会选择有意义的单词组合，这些组合在进行大规模分析时会形成规则模式。这些模式与自然语言中发现的模式相似，但并不严格遵守自然语言语法规则。\n当主要在英语数据集上训练时，语义PCFG被证明优于Weir等人的PCFG。[23]在以LinkedIn、MySpace、RockYou和Gamigo列表为目标的猜测会话中[11，21]。语义密码模型是语言密码模型家族中的一员，它依赖于语言资源和过程，如分析、分割和分类。语言模型仍然很有价值，因为它们为密码列表的构成提供了可解释的描述，使研究人员能够详细研究用户群体之间的差异和密码策略的影响。然而，关于这种语言建模行为的重要问题仍然没有得到回答。不同级别的信息(例如，句法、语义)对概括的个体贡献以及因此的猜测性能是未知的。从小样本中学习模式的能力还没有被很好地理解，控制过度匹配的参数的有效性也没有被很好地理解，例如语义专一性--语义语法训练的一个免费参数--和概率平滑方法，这是所有语言学方法共同的。此外，在引入语义模型后，蒙特卡罗强度评估使在非常长的会话中估计猜测成功成为可能[7]。这使得对语义模型的原始评估过时了，因为它仅限于破解多达30亿次猜测的尝试。较新的模型通常使用蒙特卡罗评估，这使得与较旧的模型进行比较变得困难。特别是，Melicher等人的神经密码模型。[16]取得了优异的性能，超过了其他高分自动裂解方法，包括Weir等人的PCFG的改进版本。","slug":"论文笔记/语法密码分析","published":1,"date":"2024-04-22T13:14:48.922Z","updated":"2024-03-07T15:20:27.065Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0k001okgg4acan6tnk","content":"<p>密码模型是数据驱动的结构，它捕获密码样本中的规律性，并有助于分析密码创建模式，这经常被用于密码猜测攻击。语义PCFG[21]是一种捕获句法和语义信息的概率上下文无关文法(PCFG)。它假设，除了随机序列外，人们还会选择有意义的单词组合，这些组合在进行大规模分析时会形成规则模式。这些模式与自然语言中发现的模式相似，但并不严格遵守自然语言语法规则。<br>当主要在英语数据集上训练时，语义PCFG被证明优于Weir等人的PCFG。[23]在以LinkedIn、MySpace、RockYou和Gamigo列表为目标的猜测会话中[11，21]。语义密码模型是语言密码模型家族中的一员，它依赖于语言资源和过程，如分析、分割和分类。语言模型仍然很有价值，因为它们为密码列表的构成提供了可解释的描述，使研究人员能够详细研究用户群体之间的差异和密码策略的影响。然而，关于这种语言建模行为的重要问题仍然没有得到回答。不同级别的信息(例如，句法、语义)对概括的个体贡献以及因此的猜测性能是未知的。从小样本中学习模式的能力还没有被很好地理解，控制过度匹配的参数的有效性也没有被很好地理解，例如语义专一性–语义语法训练的一个免费参数–和概率平滑方法，这是所有语言学方法共同的。此外，在引入语义模型后，蒙特卡罗强度评估使在非常长的会话中估计猜测成功成为可能[7]。这使得对语义模型的原始评估过时了，因为它仅限于破解多达30亿次猜测的尝试。较新的模型通常使用蒙特卡罗评估，这使得与较旧的模型进行比较变得困难。特别是，Melicher等人的神经密码模型。[16]取得了优异的性能，超过了其他高分自动裂解方法，包括Weir等人的PCFG的改进版本。</p>\n","excerpt":"","more":"<p>密码模型是数据驱动的结构，它捕获密码样本中的规律性，并有助于分析密码创建模式，这经常被用于密码猜测攻击。语义PCFG[21]是一种捕获句法和语义信息的概率上下文无关文法(PCFG)。它假设，除了随机序列外，人们还会选择有意义的单词组合，这些组合在进行大规模分析时会形成规则模式。这些模式与自然语言中发现的模式相似，但并不严格遵守自然语言语法规则。<br>当主要在英语数据集上训练时，语义PCFG被证明优于Weir等人的PCFG。[23]在以LinkedIn、MySpace、RockYou和Gamigo列表为目标的猜测会话中[11，21]。语义密码模型是语言密码模型家族中的一员，它依赖于语言资源和过程，如分析、分割和分类。语言模型仍然很有价值，因为它们为密码列表的构成提供了可解释的描述，使研究人员能够详细研究用户群体之间的差异和密码策略的影响。然而，关于这种语言建模行为的重要问题仍然没有得到回答。不同级别的信息(例如，句法、语义)对概括的个体贡献以及因此的猜测性能是未知的。从小样本中学习模式的能力还没有被很好地理解，控制过度匹配的参数的有效性也没有被很好地理解，例如语义专一性–语义语法训练的一个免费参数–和概率平滑方法，这是所有语言学方法共同的。此外，在引入语义模型后，蒙特卡罗强度评估使在非常长的会话中估计猜测成功成为可能[7]。这使得对语义模型的原始评估过时了，因为它仅限于破解多达30亿次猜测的尝试。较新的模型通常使用蒙特卡罗评估，这使得与较旧的模型进行比较变得困难。特别是，Melicher等人的神经密码模型。[16]取得了优异的性能，超过了其他高分自动裂解方法，包括Weir等人的PCFG的改进版本。</p>\n"},{"_content":"\n## 时间线\n\n8 月开始网络预选赛","source":"_posts/赛事活动/CCPC 中国大学生网络预选赛.md","raw":"\n## 时间线\n\n8 月开始网络预选赛","slug":"赛事活动/CCPC 中国大学生网络预选赛","published":1,"date":"2024-04-22T13:14:49.090Z","updated":"2024-04-18T06:57:53.255Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0k001pkgg4cyer5od5","content":"<h2 id=\"时间线\"><a href=\"#时间线\" class=\"headerlink\" title=\"时间线\"></a>时间线</h2><p>8 月开始网络预选赛</p>\n","excerpt":"","more":"<h2 id=\"时间线\"><a href=\"#时间线\" class=\"headerlink\" title=\"时间线\"></a>时间线</h2><p>8 月开始网络预选赛</p>\n"},{"_content":"\n每个正式参赛队的队员必须由且仅由 3 名学生组成，参赛队员必须来自同一学校且是所代表学校正式注册的学生， 参赛时距其高中毕业时间不超过 5年。每个队伍必须有 1 名教练， 教练必须是所在院校在职教师，负责竞赛活动的指导与组织工作。\n\nICPC竞赛内容包括但不限于经典的计算机科学分支，如程序设计语言、数据结构、算法设计方法、计算理论等，以及高等数学、计算几何、组合数学、图论、概率论、数论、博弈论、动态规划、人工智能、计算机图形学、搜索等。\n\n3人共用1台电脑。\n\n比赛时间为5个小时。\n\n比赛题目为10 - 12道英文题。\n\n每题可选用C、C++或Java语言之一编写。\n\n程序实时测试，动态排名。\n\n正确完成一题，得到一只代表该题颜色的气球。\n\n比赛评判与排名规则如下：\n\n（1）选手提交的每一题必须在规定的时间限制、内存限制内正确完成，才算通过。\n\n（2）每道题用时将从比赛开始到试题解答被判定为正确为止，期间每一次提交运行结果被判错误的话，将被罚20分钟时间，未正确解答的试题不计时（例如：A、B两队同时开始作答，两队先后完成了题目，A队比B队早交10分钟，但是，A队的作答错误，被打回修改，10分钟后再次提交正确的作答，原则上A、B两队用时相同，但是由于A队被打回，在时间上需要罚掉20分钟，因此，A队总用时比B队多20分钟，如此类推）。\n\n\n\n## 时间线\n第48届（2023）ICPCQEC Final 2024年1月12-14日上海大学\n武汉邀请赛2024年5月1-2日武汉大学\n陕西邀请赛2024年5月18-19日 西北工业大学\n昆明邀请赛2024年5月25-26日云南大学\n丝绸之路邀请赛 2024年5月25-26日宁夏理工学院\n第一次网络选拔赛2024年9月？日\n第二次网络选拔赛2024年9月？日\n西安站 2024年?月?日 西北工业大学?\n南京站2024年?月?日 南京航空航天大学?\n沈阳站2024年?月?日 东北大学?\n港澳站2024年?月?日 香港理工大学、澳门大学?\n杭州站2024年?月?日杭州师范大学\n武汉站2024年?月?日武汉大学\n昆明站2024年?月?日云南大学\n第49届（2024）ICPCECFinal2025年1月？日上海大学?","source":"_posts/赛事活动/ICPC 国际大学生程序设计竞赛.md","raw":"\n每个正式参赛队的队员必须由且仅由 3 名学生组成，参赛队员必须来自同一学校且是所代表学校正式注册的学生， 参赛时距其高中毕业时间不超过 5年。每个队伍必须有 1 名教练， 教练必须是所在院校在职教师，负责竞赛活动的指导与组织工作。\n\nICPC竞赛内容包括但不限于经典的计算机科学分支，如程序设计语言、数据结构、算法设计方法、计算理论等，以及高等数学、计算几何、组合数学、图论、概率论、数论、博弈论、动态规划、人工智能、计算机图形学、搜索等。\n\n3人共用1台电脑。\n\n比赛时间为5个小时。\n\n比赛题目为10 - 12道英文题。\n\n每题可选用C、C++或Java语言之一编写。\n\n程序实时测试，动态排名。\n\n正确完成一题，得到一只代表该题颜色的气球。\n\n比赛评判与排名规则如下：\n\n（1）选手提交的每一题必须在规定的时间限制、内存限制内正确完成，才算通过。\n\n（2）每道题用时将从比赛开始到试题解答被判定为正确为止，期间每一次提交运行结果被判错误的话，将被罚20分钟时间，未正确解答的试题不计时（例如：A、B两队同时开始作答，两队先后完成了题目，A队比B队早交10分钟，但是，A队的作答错误，被打回修改，10分钟后再次提交正确的作答，原则上A、B两队用时相同，但是由于A队被打回，在时间上需要罚掉20分钟，因此，A队总用时比B队多20分钟，如此类推）。\n\n\n\n## 时间线\n第48届（2023）ICPCQEC Final 2024年1月12-14日上海大学\n武汉邀请赛2024年5月1-2日武汉大学\n陕西邀请赛2024年5月18-19日 西北工业大学\n昆明邀请赛2024年5月25-26日云南大学\n丝绸之路邀请赛 2024年5月25-26日宁夏理工学院\n第一次网络选拔赛2024年9月？日\n第二次网络选拔赛2024年9月？日\n西安站 2024年?月?日 西北工业大学?\n南京站2024年?月?日 南京航空航天大学?\n沈阳站2024年?月?日 东北大学?\n港澳站2024年?月?日 香港理工大学、澳门大学?\n杭州站2024年?月?日杭州师范大学\n武汉站2024年?月?日武汉大学\n昆明站2024年?月?日云南大学\n第49届（2024）ICPCECFinal2025年1月？日上海大学?","slug":"赛事活动/ICPC 国际大学生程序设计竞赛","published":1,"date":"2024-04-22T13:14:49.090Z","updated":"2024-04-18T06:52:53.369Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0k001qkgg471u6c9x8","content":"<p>每个正式参赛队的队员必须由且仅由 3 名学生组成，参赛队员必须来自同一学校且是所代表学校正式注册的学生， 参赛时距其高中毕业时间不超过 5年。每个队伍必须有 1 名教练， 教练必须是所在院校在职教师，负责竞赛活动的指导与组织工作。</p>\n<p>ICPC竞赛内容包括但不限于经典的计算机科学分支，如程序设计语言、数据结构、算法设计方法、计算理论等，以及高等数学、计算几何、组合数学、图论、概率论、数论、博弈论、动态规划、人工智能、计算机图形学、搜索等。</p>\n<p>3人共用1台电脑。</p>\n<p>比赛时间为5个小时。</p>\n<p>比赛题目为10 - 12道英文题。</p>\n<p>每题可选用C、C++或Java语言之一编写。</p>\n<p>程序实时测试，动态排名。</p>\n<p>正确完成一题，得到一只代表该题颜色的气球。</p>\n<p>比赛评判与排名规则如下：</p>\n<p>（1）选手提交的每一题必须在规定的时间限制、内存限制内正确完成，才算通过。</p>\n<p>（2）每道题用时将从比赛开始到试题解答被判定为正确为止，期间每一次提交运行结果被判错误的话，将被罚20分钟时间，未正确解答的试题不计时（例如：A、B两队同时开始作答，两队先后完成了题目，A队比B队早交10分钟，但是，A队的作答错误，被打回修改，10分钟后再次提交正确的作答，原则上A、B两队用时相同，但是由于A队被打回，在时间上需要罚掉20分钟，因此，A队总用时比B队多20分钟，如此类推）。</p>\n<h2 id=\"时间线\"><a href=\"#时间线\" class=\"headerlink\" title=\"时间线\"></a>时间线</h2><p>第48届（2023）ICPCQEC Final 2024年1月12-14日上海大学<br>武汉邀请赛2024年5月1-2日武汉大学<br>陕西邀请赛2024年5月18-19日 西北工业大学<br>昆明邀请赛2024年5月25-26日云南大学<br>丝绸之路邀请赛 2024年5月25-26日宁夏理工学院<br>第一次网络选拔赛2024年9月？日<br>第二次网络选拔赛2024年9月？日<br>西安站 2024年?月?日 西北工业大学?<br>南京站2024年?月?日 南京航空航天大学?<br>沈阳站2024年?月?日 东北大学?<br>港澳站2024年?月?日 香港理工大学、澳门大学?<br>杭州站2024年?月?日杭州师范大学<br>武汉站2024年?月?日武汉大学<br>昆明站2024年?月?日云南大学<br>第49届（2024）ICPCECFinal2025年1月？日上海大学?</p>\n","excerpt":"","more":"<p>每个正式参赛队的队员必须由且仅由 3 名学生组成，参赛队员必须来自同一学校且是所代表学校正式注册的学生， 参赛时距其高中毕业时间不超过 5年。每个队伍必须有 1 名教练， 教练必须是所在院校在职教师，负责竞赛活动的指导与组织工作。</p>\n<p>ICPC竞赛内容包括但不限于经典的计算机科学分支，如程序设计语言、数据结构、算法设计方法、计算理论等，以及高等数学、计算几何、组合数学、图论、概率论、数论、博弈论、动态规划、人工智能、计算机图形学、搜索等。</p>\n<p>3人共用1台电脑。</p>\n<p>比赛时间为5个小时。</p>\n<p>比赛题目为10 - 12道英文题。</p>\n<p>每题可选用C、C++或Java语言之一编写。</p>\n<p>程序实时测试，动态排名。</p>\n<p>正确完成一题，得到一只代表该题颜色的气球。</p>\n<p>比赛评判与排名规则如下：</p>\n<p>（1）选手提交的每一题必须在规定的时间限制、内存限制内正确完成，才算通过。</p>\n<p>（2）每道题用时将从比赛开始到试题解答被判定为正确为止，期间每一次提交运行结果被判错误的话，将被罚20分钟时间，未正确解答的试题不计时（例如：A、B两队同时开始作答，两队先后完成了题目，A队比B队早交10分钟，但是，A队的作答错误，被打回修改，10分钟后再次提交正确的作答，原则上A、B两队用时相同，但是由于A队被打回，在时间上需要罚掉20分钟，因此，A队总用时比B队多20分钟，如此类推）。</p>\n<h2 id=\"时间线\"><a href=\"#时间线\" class=\"headerlink\" title=\"时间线\"></a>时间线</h2><p>第48届（2023）ICPCQEC Final 2024年1月12-14日上海大学<br>武汉邀请赛2024年5月1-2日武汉大学<br>陕西邀请赛2024年5月18-19日 西北工业大学<br>昆明邀请赛2024年5月25-26日云南大学<br>丝绸之路邀请赛 2024年5月25-26日宁夏理工学院<br>第一次网络选拔赛2024年9月？日<br>第二次网络选拔赛2024年9月？日<br>西安站 2024年?月?日 西北工业大学?<br>南京站2024年?月?日 南京航空航天大学?<br>沈阳站2024年?月?日 东北大学?<br>港澳站2024年?月?日 香港理工大学、澳门大学?<br>杭州站2024年?月?日杭州师范大学<br>武汉站2024年?月?日武汉大学<br>昆明站2024年?月?日云南大学<br>第49届（2024）ICPCECFinal2025年1月？日上海大学?</p>\n"},{"_content":"","source":"_posts/赛事活动/TEMP.md","raw":"","slug":"赛事活动/TEMP","published":1,"date":"2024-04-22T13:14:49.090Z","updated":"2024-04-18T06:53:33.271Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0k001rkgg4hv7w7old","content":"","excerpt":"","more":""},{"_content":"","source":"_posts/赛事活动/Google Code Jam.md","raw":"","slug":"赛事活动/Google Code Jam","published":1,"date":"2024-04-22T13:14:49.090Z","updated":"2024-04-18T06:37:33.883Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0l001skgg42dqg12kx","content":"","excerpt":"","more":""},{"_content":"![[Pasted image 20240418154011.png]]\n4月8日赛题发布后有且仅有一次修改，，4月初开始报名","source":"_posts/赛事活动/中兴捧月.md","raw":"![[Pasted image 20240418154011.png]]\n4月8日赛题发布后有且仅有一次修改，，4月初开始报名","slug":"赛事活动/中兴捧月","published":1,"date":"2024-04-22T13:14:49.110Z","updated":"2024-04-18T07:44:24.577Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0l001tkgg4fh3na2jm","content":"<p>![[Pasted image 20240418154011.png]]<br>4月8日赛题发布后有且仅有一次修改，，4月初开始报名</p>\n","excerpt":"","more":"<p>![[Pasted image 20240418154011.png]]<br>4月8日赛题发布后有且仅有一次修改，，4月初开始报名</p>\n"},{"_content":"# 时间线\n\n![[Pasted image 20240307091119.png]]\n\n\n# 赛题\n● 华为基于自身ICT基础设施能力，通过对港口场景的洞察和理解，以智慧、绿色、高效、安全为目标，数字化、智能化为手段，联合生态伙伴，助力世界一流港口建设。\n\n ● 本次赛题抽象自华为云智能港口真实业务难题，选手通过算法完成运输船只智能泊靠、运输机器人智能拣货装货等任务，以最大化提升港口物流效率。\n\n# 初赛练习题\n\nhttps://bbs.huaweicloud.com/forum/thread-0209145106256505005-1-1.htm\nhttps://bbs.huaweicloud.com/forum/forum-0168144383617537003-1.html\n## 题目概述\n\n⚫目标  \n赚取更多的资金。  \n⚫ 程序操控方式  \n选手作为运输公司来运输货物赚取资金，每个选手有 5 艘轮船、10 个机器人。选  \n手需要使用机器人来执行移动、搬运等动作来完成物品递送任务，同时赚取利  \n润。在运行结束时，选手拥有的资金数即为最终分数，所获得的资金越高越好。  \n初赛时间为 15,000 帧（最多 5 分钟）。  \n⚫ 程序交付方式  \n选手程序通过标准输入和标准输出与判题器进行交互。判题器运行帧率为每秒 50  \n帧，对于每一帧，判题器都会把场上的实时信息通过标准输入传递给选手程序，  \n同时从选手程序读取机器人的操控指令作用到各个机器人上。每一帧有  \n1000/50=20ms 的时间，由于判题器需保留 5ms 执行计算来模拟真实场景，故选手  \n程序需要在 15ms 内做出每一帧的决策，如果超过 15ms 未做出决策，则系统将直  \n接忽略这一帧的控制进入下一帧，并且在选手程序返回控制指令前，不会再发送  \n状态数据给程序。  \n注意，你不需要让自己的程序具备处理 50FPS 的性能，程序处理帧率低于 50FPS  \n也能正常运行（例如只处理 10FPS 也可以），但是处理更高的帧率可以让你实现更  \n高精度的控制。  \n程序的输入和输出格式请参考 3.4 输入与输出格式。  \n⚫ 判题器使用  \n今年的比赛判题器与数据集完全开放给大家下载，并且做了跨平台设计  \n（Windows/Linux/MacOS），大家可以根据自己习惯选择对应版本下载。但是请注  \n意，比赛平台使用 Linux，因此无论你选择何种平台开发调试，都必须确保你的代  \n码可以在 Linux 下编译运行。  \n运行判题器中的 run_simple_demo 可快速运行一个 DEMO，运行界面如下：\n## 题目分析\n\n\n## 环境配置\ndocker run -itd -v /home/fengyuening/container_18_04/:/root/ --gpus all --name fyn_ubuntu_18_04 ubuntu:18.04\n\n![[Y[Y%]@RY36}%AGFAHROTPCN.png]]\n\n\n![[Pasted image 20240308135154.png]]\n\n###  碰撞检测模块\n\n\n# 关键点 \n1. 一个机器人只能拉一个货物\n2. 可以用 std::pthread\n3. 机器人不能斜走，只能横竖来走\n4. 考虑数据集的变化会导致算法出现的问题\n5. 如何避免多个机器人同时锁定同一个资源\n6. 怎么定义资源的性价比，\n\t1. 考虑距离港口的距离\n\t2. 考虑资源的价值，基本的性价比\n\t3. 考虑港口的负载\n7. 怎么防止机器人扎堆存在，\n\t1. 每个机器固定一个覆盖范围：\n\t2. 根据\n8. 怎么避免多个机器人锁定同一个货物\n\t1. 如果锁定了同一个货物\n\t2. 由于每一次到来\n\n\n机器人不会与货物相撞\n我想让你担任心理健康顾问。我将为您提供一个寻求指导和建议的人，以管理他们的情绪、压力、焦虑和其他心理健康问题。您应该利用您的认知行为疗法、冥想技巧、正念练习和其他治疗方法的知识来制定个人可以实施的策略，以改善他们的整体健康状况。我的第一个请求是“我需要一个可以帮助我控制抑郁症状的人。\n\n地图上有一个指针\n读到了当前机器人的位置，先简单点，后面的车躲避前面的车。l\n\n\n![[Pasted image 20240309134153.png]]\n\n类似于这样的方法，前面的小车标记的其实是下一个地点。\n先清除，\n先规划，\n\n后续可以考虑通过判断移动来决定是否清除\n1. 存储机器人的上一个位置\n2. 在读到新的位置之后判断如果没有更改则不会清除这个位置，\n那么前面的机器人也能识别到之后机器人的位置\n\n\n十个码头 五艘船\n1. 一开始如何评价这十个码头中最有价值的5个码头。\n\t1. \n\n\n这里的码头类似与这样的实现：\n\n机器人 主动搜索可行工作台还是工作台召唤机器人-->由码头管理所有的产品信息，并且在机器人靠码头之后下发下一个产品目标\n\n如果机器人靠码头之后这里的船没有到，\n\n\n\n\n最终如果时间即将到达，应该立刻把轮船全部开走\n\n\n假设当前机器人会在固定的码头上运输物品：\n关于机器人获取目标物品：\n1. 如果总是每次停靠码头后进行计算：会导致第一次计算时需要单独从机器人的角度出发，计算机器人到物品再到码头的时间。\n2. 如果总是从机器人出发，需要每次计算机器人到每一个物品的性价比考虑最优的选择，\n\t1. 但是实际上只有第一次是这么算的，之后全部在码头计算的，不如直接算在码头头上。\n\t2. 那么就是说现在是用码头来维护性价比信息。\n3. 两者统一 让机器人搜索最近最有价值的物品\n\n\n可以考虑让所有的码头同时接收物品，船由码头的物品情况来选择：\n1. 但是这样的话码头中的物品其实是动态增加的，船也来动态的选择一个码头。\n\n先寻路再避让\n一个问题：寻路算法\n\n（如果C上方和下方都是障碍物的话会走入死胡同吗？不会，根据算法，这时候C会被直接放到关闭列表，没有发生任何节点的F更新和父节点更新）即不会有任何的节点以这个节点为父亲节点。\n[A*寻路算法C++简单实现_c++ 实现a*算法-CSDN博客](https://blog.csdn.net/u012234115/article/details/47152137)\n\n```\nchar mazeArray[200][200]; // 假设已有一个二维字符数组\nstd::vector<std::vector<char>> maze;\n\nmaze.reserve(200); // 预分配行向量的内存\n\nfor (int i = 0; i < 200; ++i) {\n    std::vector<char> row;\n    row.reserve(200); // 预分配每行的内存\n    for (int j = 0; j < 200; ++j) {\n        row.push_back(std::move(mazeArray[i][j])); // 使用移动语义\n    }\n    maze.push_back(std::move(row)); // 使用移动语义\n}\n```\n\n\n\n\n如何给机器人目标\n1. 目前 机器人可以实现对目标的锁定和移动，\n2. \n\n\n如何快速\n\n# 当前要求分析\n## 总体要求：机器人 A* 的优化\n## 当前效果：\n输入：map start end \n输出：path：start->end\n每一次计算都是重新计算，有些耗费算历\n\n## JSP 算法\nhttps://zhuanlan.zhihu.com/p/620172389\nhttps://blog.csdn.net/qq_17347313/article/details/120245994\n\nA*算法的一些概念\ncurrent： 当前节点\nopenset 开启节点集合，集合内节点有待进一步探索拓展\nclosedset 关闭节点结合，集合内节点后续不再进行拓展，已经扩展过了\nneighbor 邻居，与当前节点相邻的节点\nparent(x) 节点 x 的父节点，即算法寻得的路径中节点 parent(x)的下一节点为 x\nG 值表示从起点到当前点路径耗费；\nH 值是一个期待值，当前点到终点的理论路径耗费；、\nF=G+H表示经过该节点到终点的路径耗费\n\nPS 算法的两条定义，三个规则\n定义一：强迫邻居（forced neighbour）：如果点 n 是 x 的邻居，并且点 n 的邻居有阻挡（不可行走的格子），并且从 parent(x)、x、n 的路径长度比其他任何从 parent(x)到 n 且不经过 x 的路径短，其中parent(x)为路径中 x 的前一个点，则 n 为 x 的强迫邻居，x 为 n 的跳点），例如图 2 中，寻找从 S 到 E的路径时，K 为 I 的强迫邻居（I 为 K 的跳点）。这里不认为从 H 到 K 能走，因为对角线有阻挡（这点和论文不一致，但和代码一致，因为如果 H 到 K 能直接到达，会走进 H 右边的阻挡区，大部分的 JPS 开源代码根据论文都认为 H 到 K能走，所以存在穿越阻挡的情况），如果需要 H 到 K 可走，则 K 为 H的强迫邻居（H 为 K的跳点）。\n\n定义二：跳点（jump point）：\n（1）如果点 y 是起点或目标点，则 y 是跳点，例如图 2 中，S 是起点也是跳点，E 是目标点也是跳点；（2）如果 y 有邻居且是强迫邻居则 y 是跳点， 例 如 I 是跳点，请注意此类跳点和强迫邻居是伴生系，从上文强迫邻居的定义来看 n 是强迫邻居，x 是跳点，二者的关系是伴生的，例如图 2 中 K 的邻居只有I 是跳点，M 虽然也是 K的邻居，但 M 不是跳点，因为 K 不是 M 的强迫邻居；（3）如果 parent(y)到 y 是对角线移动，并且 y 经过水平或垂直方向移动可以到达跳点，则 y 是跳点，例如图 2 中 G 是跳点，因为 parent(G)为 S，S 到 G 为对角线移动，从 G 到跳点 I 为垂直方向移动，I 是跳点，所以 G 也是跳点。\n\n规则一：JPS 搜索跳点的过程中，如果直线方向（为了和对角线区分，直线方向代表水平方向、垂直方向，下文所说的直线均为水平方向和垂直方向）、对角线方向都可以移动，则首先在直线方向搜索跳点，再在对角线方向搜索跳点。\n规则二：（1）如果从 parent(x)到 x 是直线移动，n 是 x 的邻居，若有从 parent(x)到 n 的路径不经过 x 且路径长度小于或等于从 parent(x)经过 x 到 n 的路径，则走到 x 后下一个点不会走到 n；（2）果从 parent(x)到 x 是对角线移动，n 是 x 的邻居，若有从 parent(x)到 n 的路径不经过 x 且路径长度小于从parent(x)经过 x 到 n 的路径，则走到 x 后下一个点不会走到 n（相关证明见论文）。\n规则三：只有跳点才会加入 openset，因为跳点会改变行走方向，而非跳点不会改变行走方向，最后寻找出来的路径点也只会是跳点集合的子集。\n\n\n\n\n\n\n\n","source":"_posts/赛事活动/华为软件精英挑战赛.md","raw":"# 时间线\n\n![[Pasted image 20240307091119.png]]\n\n\n# 赛题\n● 华为基于自身ICT基础设施能力，通过对港口场景的洞察和理解，以智慧、绿色、高效、安全为目标，数字化、智能化为手段，联合生态伙伴，助力世界一流港口建设。\n\n ● 本次赛题抽象自华为云智能港口真实业务难题，选手通过算法完成运输船只智能泊靠、运输机器人智能拣货装货等任务，以最大化提升港口物流效率。\n\n# 初赛练习题\n\nhttps://bbs.huaweicloud.com/forum/thread-0209145106256505005-1-1.htm\nhttps://bbs.huaweicloud.com/forum/forum-0168144383617537003-1.html\n## 题目概述\n\n⚫目标  \n赚取更多的资金。  \n⚫ 程序操控方式  \n选手作为运输公司来运输货物赚取资金，每个选手有 5 艘轮船、10 个机器人。选  \n手需要使用机器人来执行移动、搬运等动作来完成物品递送任务，同时赚取利  \n润。在运行结束时，选手拥有的资金数即为最终分数，所获得的资金越高越好。  \n初赛时间为 15,000 帧（最多 5 分钟）。  \n⚫ 程序交付方式  \n选手程序通过标准输入和标准输出与判题器进行交互。判题器运行帧率为每秒 50  \n帧，对于每一帧，判题器都会把场上的实时信息通过标准输入传递给选手程序，  \n同时从选手程序读取机器人的操控指令作用到各个机器人上。每一帧有  \n1000/50=20ms 的时间，由于判题器需保留 5ms 执行计算来模拟真实场景，故选手  \n程序需要在 15ms 内做出每一帧的决策，如果超过 15ms 未做出决策，则系统将直  \n接忽略这一帧的控制进入下一帧，并且在选手程序返回控制指令前，不会再发送  \n状态数据给程序。  \n注意，你不需要让自己的程序具备处理 50FPS 的性能，程序处理帧率低于 50FPS  \n也能正常运行（例如只处理 10FPS 也可以），但是处理更高的帧率可以让你实现更  \n高精度的控制。  \n程序的输入和输出格式请参考 3.4 输入与输出格式。  \n⚫ 判题器使用  \n今年的比赛判题器与数据集完全开放给大家下载，并且做了跨平台设计  \n（Windows/Linux/MacOS），大家可以根据自己习惯选择对应版本下载。但是请注  \n意，比赛平台使用 Linux，因此无论你选择何种平台开发调试，都必须确保你的代  \n码可以在 Linux 下编译运行。  \n运行判题器中的 run_simple_demo 可快速运行一个 DEMO，运行界面如下：\n## 题目分析\n\n\n## 环境配置\ndocker run -itd -v /home/fengyuening/container_18_04/:/root/ --gpus all --name fyn_ubuntu_18_04 ubuntu:18.04\n\n![[Y[Y%]@RY36}%AGFAHROTPCN.png]]\n\n\n![[Pasted image 20240308135154.png]]\n\n###  碰撞检测模块\n\n\n# 关键点 \n1. 一个机器人只能拉一个货物\n2. 可以用 std::pthread\n3. 机器人不能斜走，只能横竖来走\n4. 考虑数据集的变化会导致算法出现的问题\n5. 如何避免多个机器人同时锁定同一个资源\n6. 怎么定义资源的性价比，\n\t1. 考虑距离港口的距离\n\t2. 考虑资源的价值，基本的性价比\n\t3. 考虑港口的负载\n7. 怎么防止机器人扎堆存在，\n\t1. 每个机器固定一个覆盖范围：\n\t2. 根据\n8. 怎么避免多个机器人锁定同一个货物\n\t1. 如果锁定了同一个货物\n\t2. 由于每一次到来\n\n\n机器人不会与货物相撞\n我想让你担任心理健康顾问。我将为您提供一个寻求指导和建议的人，以管理他们的情绪、压力、焦虑和其他心理健康问题。您应该利用您的认知行为疗法、冥想技巧、正念练习和其他治疗方法的知识来制定个人可以实施的策略，以改善他们的整体健康状况。我的第一个请求是“我需要一个可以帮助我控制抑郁症状的人。\n\n地图上有一个指针\n读到了当前机器人的位置，先简单点，后面的车躲避前面的车。l\n\n\n![[Pasted image 20240309134153.png]]\n\n类似于这样的方法，前面的小车标记的其实是下一个地点。\n先清除，\n先规划，\n\n后续可以考虑通过判断移动来决定是否清除\n1. 存储机器人的上一个位置\n2. 在读到新的位置之后判断如果没有更改则不会清除这个位置，\n那么前面的机器人也能识别到之后机器人的位置\n\n\n十个码头 五艘船\n1. 一开始如何评价这十个码头中最有价值的5个码头。\n\t1. \n\n\n这里的码头类似与这样的实现：\n\n机器人 主动搜索可行工作台还是工作台召唤机器人-->由码头管理所有的产品信息，并且在机器人靠码头之后下发下一个产品目标\n\n如果机器人靠码头之后这里的船没有到，\n\n\n\n\n最终如果时间即将到达，应该立刻把轮船全部开走\n\n\n假设当前机器人会在固定的码头上运输物品：\n关于机器人获取目标物品：\n1. 如果总是每次停靠码头后进行计算：会导致第一次计算时需要单独从机器人的角度出发，计算机器人到物品再到码头的时间。\n2. 如果总是从机器人出发，需要每次计算机器人到每一个物品的性价比考虑最优的选择，\n\t1. 但是实际上只有第一次是这么算的，之后全部在码头计算的，不如直接算在码头头上。\n\t2. 那么就是说现在是用码头来维护性价比信息。\n3. 两者统一 让机器人搜索最近最有价值的物品\n\n\n可以考虑让所有的码头同时接收物品，船由码头的物品情况来选择：\n1. 但是这样的话码头中的物品其实是动态增加的，船也来动态的选择一个码头。\n\n先寻路再避让\n一个问题：寻路算法\n\n（如果C上方和下方都是障碍物的话会走入死胡同吗？不会，根据算法，这时候C会被直接放到关闭列表，没有发生任何节点的F更新和父节点更新）即不会有任何的节点以这个节点为父亲节点。\n[A*寻路算法C++简单实现_c++ 实现a*算法-CSDN博客](https://blog.csdn.net/u012234115/article/details/47152137)\n\n```\nchar mazeArray[200][200]; // 假设已有一个二维字符数组\nstd::vector<std::vector<char>> maze;\n\nmaze.reserve(200); // 预分配行向量的内存\n\nfor (int i = 0; i < 200; ++i) {\n    std::vector<char> row;\n    row.reserve(200); // 预分配每行的内存\n    for (int j = 0; j < 200; ++j) {\n        row.push_back(std::move(mazeArray[i][j])); // 使用移动语义\n    }\n    maze.push_back(std::move(row)); // 使用移动语义\n}\n```\n\n\n\n\n如何给机器人目标\n1. 目前 机器人可以实现对目标的锁定和移动，\n2. \n\n\n如何快速\n\n# 当前要求分析\n## 总体要求：机器人 A* 的优化\n## 当前效果：\n输入：map start end \n输出：path：start->end\n每一次计算都是重新计算，有些耗费算历\n\n## JSP 算法\nhttps://zhuanlan.zhihu.com/p/620172389\nhttps://blog.csdn.net/qq_17347313/article/details/120245994\n\nA*算法的一些概念\ncurrent： 当前节点\nopenset 开启节点集合，集合内节点有待进一步探索拓展\nclosedset 关闭节点结合，集合内节点后续不再进行拓展，已经扩展过了\nneighbor 邻居，与当前节点相邻的节点\nparent(x) 节点 x 的父节点，即算法寻得的路径中节点 parent(x)的下一节点为 x\nG 值表示从起点到当前点路径耗费；\nH 值是一个期待值，当前点到终点的理论路径耗费；、\nF=G+H表示经过该节点到终点的路径耗费\n\nPS 算法的两条定义，三个规则\n定义一：强迫邻居（forced neighbour）：如果点 n 是 x 的邻居，并且点 n 的邻居有阻挡（不可行走的格子），并且从 parent(x)、x、n 的路径长度比其他任何从 parent(x)到 n 且不经过 x 的路径短，其中parent(x)为路径中 x 的前一个点，则 n 为 x 的强迫邻居，x 为 n 的跳点），例如图 2 中，寻找从 S 到 E的路径时，K 为 I 的强迫邻居（I 为 K 的跳点）。这里不认为从 H 到 K 能走，因为对角线有阻挡（这点和论文不一致，但和代码一致，因为如果 H 到 K 能直接到达，会走进 H 右边的阻挡区，大部分的 JPS 开源代码根据论文都认为 H 到 K能走，所以存在穿越阻挡的情况），如果需要 H 到 K 可走，则 K 为 H的强迫邻居（H 为 K的跳点）。\n\n定义二：跳点（jump point）：\n（1）如果点 y 是起点或目标点，则 y 是跳点，例如图 2 中，S 是起点也是跳点，E 是目标点也是跳点；（2）如果 y 有邻居且是强迫邻居则 y 是跳点， 例 如 I 是跳点，请注意此类跳点和强迫邻居是伴生系，从上文强迫邻居的定义来看 n 是强迫邻居，x 是跳点，二者的关系是伴生的，例如图 2 中 K 的邻居只有I 是跳点，M 虽然也是 K的邻居，但 M 不是跳点，因为 K 不是 M 的强迫邻居；（3）如果 parent(y)到 y 是对角线移动，并且 y 经过水平或垂直方向移动可以到达跳点，则 y 是跳点，例如图 2 中 G 是跳点，因为 parent(G)为 S，S 到 G 为对角线移动，从 G 到跳点 I 为垂直方向移动，I 是跳点，所以 G 也是跳点。\n\n规则一：JPS 搜索跳点的过程中，如果直线方向（为了和对角线区分，直线方向代表水平方向、垂直方向，下文所说的直线均为水平方向和垂直方向）、对角线方向都可以移动，则首先在直线方向搜索跳点，再在对角线方向搜索跳点。\n规则二：（1）如果从 parent(x)到 x 是直线移动，n 是 x 的邻居，若有从 parent(x)到 n 的路径不经过 x 且路径长度小于或等于从 parent(x)经过 x 到 n 的路径，则走到 x 后下一个点不会走到 n；（2）果从 parent(x)到 x 是对角线移动，n 是 x 的邻居，若有从 parent(x)到 n 的路径不经过 x 且路径长度小于从parent(x)经过 x 到 n 的路径，则走到 x 后下一个点不会走到 n（相关证明见论文）。\n规则三：只有跳点才会加入 openset，因为跳点会改变行走方向，而非跳点不会改变行走方向，最后寻找出来的路径点也只会是跳点集合的子集。\n\n\n\n\n\n\n\n","slug":"赛事活动/华为软件精英挑战赛","published":1,"date":"2024-04-22T13:14:49.111Z","updated":"2024-03-17T02:40:49.347Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0l001ukgg4ar9550sc","content":"<h1 id=\"时间线\"><a href=\"#时间线\" class=\"headerlink\" title=\"时间线\"></a>时间线</h1><p>![[Pasted image 20240307091119.png]]</p>\n<h1 id=\"赛题\"><a href=\"#赛题\" class=\"headerlink\" title=\"赛题\"></a>赛题</h1><p>● 华为基于自身ICT基础设施能力，通过对港口场景的洞察和理解，以智慧、绿色、高效、安全为目标，数字化、智能化为手段，联合生态伙伴，助力世界一流港口建设。</p>\n<p> ● 本次赛题抽象自华为云智能港口真实业务难题，选手通过算法完成运输船只智能泊靠、运输机器人智能拣货装货等任务，以最大化提升港口物流效率。</p>\n<h1 id=\"初赛练习题\"><a href=\"#初赛练习题\" class=\"headerlink\" title=\"初赛练习题\"></a>初赛练习题</h1><p><a href=\"https://bbs.huaweicloud.com/forum/thread-0209145106256505005-1-1.htm\">https://bbs.huaweicloud.com/forum/thread-0209145106256505005-1-1.htm</a><br><a href=\"https://bbs.huaweicloud.com/forum/forum-0168144383617537003-1.html\">https://bbs.huaweicloud.com/forum/forum-0168144383617537003-1.html</a></p>\n<h2 id=\"题目概述\"><a href=\"#题目概述\" class=\"headerlink\" title=\"题目概述\"></a>题目概述</h2><p>⚫目标<br>赚取更多的资金。<br>⚫ 程序操控方式<br>选手作为运输公司来运输货物赚取资金，每个选手有 5 艘轮船、10 个机器人。选<br>手需要使用机器人来执行移动、搬运等动作来完成物品递送任务，同时赚取利<br>润。在运行结束时，选手拥有的资金数即为最终分数，所获得的资金越高越好。<br>初赛时间为 15,000 帧（最多 5 分钟）。<br>⚫ 程序交付方式<br>选手程序通过标准输入和标准输出与判题器进行交互。判题器运行帧率为每秒 50<br>帧，对于每一帧，判题器都会把场上的实时信息通过标准输入传递给选手程序，<br>同时从选手程序读取机器人的操控指令作用到各个机器人上。每一帧有<br>1000&#x2F;50&#x3D;20ms 的时间，由于判题器需保留 5ms 执行计算来模拟真实场景，故选手<br>程序需要在 15ms 内做出每一帧的决策，如果超过 15ms 未做出决策，则系统将直<br>接忽略这一帧的控制进入下一帧，并且在选手程序返回控制指令前，不会再发送<br>状态数据给程序。<br>注意，你不需要让自己的程序具备处理 50FPS 的性能，程序处理帧率低于 50FPS<br>也能正常运行（例如只处理 10FPS 也可以），但是处理更高的帧率可以让你实现更<br>高精度的控制。<br>程序的输入和输出格式请参考 3.4 输入与输出格式。<br>⚫ 判题器使用<br>今年的比赛判题器与数据集完全开放给大家下载，并且做了跨平台设计<br>（Windows&#x2F;Linux&#x2F;MacOS），大家可以根据自己习惯选择对应版本下载。但是请注<br>意，比赛平台使用 Linux，因此无论你选择何种平台开发调试，都必须确保你的代<br>码可以在 Linux 下编译运行。<br>运行判题器中的 run_simple_demo 可快速运行一个 DEMO，运行界面如下：</p>\n<h2 id=\"题目分析\"><a href=\"#题目分析\" class=\"headerlink\" title=\"题目分析\"></a>题目分析</h2><h2 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h2><p>docker run -itd -v &#x2F;home&#x2F;fengyuening&#x2F;container_18_04&#x2F;:&#x2F;root&#x2F; –gpus all –name fyn_ubuntu_18_04 ubuntu:18.04</p>\n<p>![[Y[Y%]@RY36}%AGFAHROTPCN.png]]</p>\n<p>![[Pasted image 20240308135154.png]]</p>\n<h3 id=\"碰撞检测模块\"><a href=\"#碰撞检测模块\" class=\"headerlink\" title=\"碰撞检测模块\"></a>碰撞检测模块</h3><h1 id=\"关键点\"><a href=\"#关键点\" class=\"headerlink\" title=\"关键点\"></a>关键点</h1><ol>\n<li>一个机器人只能拉一个货物</li>\n<li>可以用 std::pthread</li>\n<li>机器人不能斜走，只能横竖来走</li>\n<li>考虑数据集的变化会导致算法出现的问题</li>\n<li>如何避免多个机器人同时锁定同一个资源</li>\n<li>怎么定义资源的性价比，<ol>\n<li>考虑距离港口的距离</li>\n<li>考虑资源的价值，基本的性价比</li>\n<li>考虑港口的负载</li>\n</ol>\n</li>\n<li>怎么防止机器人扎堆存在，<ol>\n<li>每个机器固定一个覆盖范围：</li>\n<li>根据</li>\n</ol>\n</li>\n<li>怎么避免多个机器人锁定同一个货物<ol>\n<li>如果锁定了同一个货物</li>\n<li>由于每一次到来</li>\n</ol>\n</li>\n</ol>\n<p>机器人不会与货物相撞<br>我想让你担任心理健康顾问。我将为您提供一个寻求指导和建议的人，以管理他们的情绪、压力、焦虑和其他心理健康问题。您应该利用您的认知行为疗法、冥想技巧、正念练习和其他治疗方法的知识来制定个人可以实施的策略，以改善他们的整体健康状况。我的第一个请求是“我需要一个可以帮助我控制抑郁症状的人。</p>\n<p>地图上有一个指针<br>读到了当前机器人的位置，先简单点，后面的车躲避前面的车。l</p>\n<p>![[Pasted image 20240309134153.png]]</p>\n<p>类似于这样的方法，前面的小车标记的其实是下一个地点。<br>先清除，<br>先规划，</p>\n<p>后续可以考虑通过判断移动来决定是否清除</p>\n<ol>\n<li>存储机器人的上一个位置</li>\n<li>在读到新的位置之后判断如果没有更改则不会清除这个位置，<br>那么前面的机器人也能识别到之后机器人的位置</li>\n</ol>\n<p>十个码头 五艘船</p>\n<ol>\n<li>一开始如何评价这十个码头中最有价值的5个码头。<ol>\n<li></li>\n</ol>\n</li>\n</ol>\n<p>这里的码头类似与这样的实现：</p>\n<p>机器人 主动搜索可行工作台还是工作台召唤机器人–&gt;由码头管理所有的产品信息，并且在机器人靠码头之后下发下一个产品目标</p>\n<p>如果机器人靠码头之后这里的船没有到，</p>\n<p>最终如果时间即将到达，应该立刻把轮船全部开走</p>\n<p>假设当前机器人会在固定的码头上运输物品：<br>关于机器人获取目标物品：</p>\n<ol>\n<li>如果总是每次停靠码头后进行计算：会导致第一次计算时需要单独从机器人的角度出发，计算机器人到物品再到码头的时间。</li>\n<li>如果总是从机器人出发，需要每次计算机器人到每一个物品的性价比考虑最优的选择，<ol>\n<li>但是实际上只有第一次是这么算的，之后全部在码头计算的，不如直接算在码头头上。</li>\n<li>那么就是说现在是用码头来维护性价比信息。</li>\n</ol>\n</li>\n<li>两者统一 让机器人搜索最近最有价值的物品</li>\n</ol>\n<p>可以考虑让所有的码头同时接收物品，船由码头的物品情况来选择：</p>\n<ol>\n<li>但是这样的话码头中的物品其实是动态增加的，船也来动态的选择一个码头。</li>\n</ol>\n<p>先寻路再避让<br>一个问题：寻路算法</p>\n<p>（如果C上方和下方都是障碍物的话会走入死胡同吗？不会，根据算法，这时候C会被直接放到关闭列表，没有发生任何节点的F更新和父节点更新）即不会有任何的节点以这个节点为父亲节点。<br><a href=\"https://blog.csdn.net/u012234115/article/details/47152137\">A<em>寻路算法C++简单实现_c++ 实现a</em>算法-CSDN博客</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char mazeArray[200][200]; // 假设已有一个二维字符数组</span><br><span class=\"line\">std::vector&lt;std::vector&lt;char&gt;&gt; maze;</span><br><span class=\"line\"></span><br><span class=\"line\">maze.reserve(200); // 预分配行向量的内存</span><br><span class=\"line\"></span><br><span class=\"line\">for (int i = 0; i &lt; 200; ++i) &#123;</span><br><span class=\"line\">    std::vector&lt;char&gt; row;</span><br><span class=\"line\">    row.reserve(200); // 预分配每行的内存</span><br><span class=\"line\">    for (int j = 0; j &lt; 200; ++j) &#123;</span><br><span class=\"line\">        row.push_back(std::move(mazeArray[i][j])); // 使用移动语义</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    maze.push_back(std::move(row)); // 使用移动语义</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>如何给机器人目标</p>\n<ol>\n<li>目前 机器人可以实现对目标的锁定和移动，</li>\n<li></li>\n</ol>\n<p>如何快速</p>\n<h1 id=\"当前要求分析\"><a href=\"#当前要求分析\" class=\"headerlink\" title=\"当前要求分析\"></a>当前要求分析</h1><h2 id=\"总体要求：机器人-A-的优化\"><a href=\"#总体要求：机器人-A-的优化\" class=\"headerlink\" title=\"总体要求：机器人 A* 的优化\"></a>总体要求：机器人 A* 的优化</h2><h2 id=\"当前效果：\"><a href=\"#当前效果：\" class=\"headerlink\" title=\"当前效果：\"></a>当前效果：</h2><p>输入：map start end<br>输出：path：start-&gt;end<br>每一次计算都是重新计算，有些耗费算历</p>\n<h2 id=\"JSP-算法\"><a href=\"#JSP-算法\" class=\"headerlink\" title=\"JSP 算法\"></a>JSP 算法</h2><p><a href=\"https://zhuanlan.zhihu.com/p/620172389\">https://zhuanlan.zhihu.com/p/620172389</a><br><a href=\"https://blog.csdn.net/qq_17347313/article/details/120245994\">https://blog.csdn.net/qq_17347313/article/details/120245994</a></p>\n<p>A*算法的一些概念<br>current： 当前节点<br>openset 开启节点集合，集合内节点有待进一步探索拓展<br>closedset 关闭节点结合，集合内节点后续不再进行拓展，已经扩展过了<br>neighbor 邻居，与当前节点相邻的节点<br>parent(x) 节点 x 的父节点，即算法寻得的路径中节点 parent(x)的下一节点为 x<br>G 值表示从起点到当前点路径耗费；<br>H 值是一个期待值，当前点到终点的理论路径耗费；、<br>F&#x3D;G+H表示经过该节点到终点的路径耗费</p>\n<p>PS 算法的两条定义，三个规则<br>定义一：强迫邻居（forced neighbour）：如果点 n 是 x 的邻居，并且点 n 的邻居有阻挡（不可行走的格子），并且从 parent(x)、x、n 的路径长度比其他任何从 parent(x)到 n 且不经过 x 的路径短，其中parent(x)为路径中 x 的前一个点，则 n 为 x 的强迫邻居，x 为 n 的跳点），例如图 2 中，寻找从 S 到 E的路径时，K 为 I 的强迫邻居（I 为 K 的跳点）。这里不认为从 H 到 K 能走，因为对角线有阻挡（这点和论文不一致，但和代码一致，因为如果 H 到 K 能直接到达，会走进 H 右边的阻挡区，大部分的 JPS 开源代码根据论文都认为 H 到 K能走，所以存在穿越阻挡的情况），如果需要 H 到 K 可走，则 K 为 H的强迫邻居（H 为 K的跳点）。</p>\n<p>定义二：跳点（jump point）：<br>（1）如果点 y 是起点或目标点，则 y 是跳点，例如图 2 中，S 是起点也是跳点，E 是目标点也是跳点；（2）如果 y 有邻居且是强迫邻居则 y 是跳点， 例 如 I 是跳点，请注意此类跳点和强迫邻居是伴生系，从上文强迫邻居的定义来看 n 是强迫邻居，x 是跳点，二者的关系是伴生的，例如图 2 中 K 的邻居只有I 是跳点，M 虽然也是 K的邻居，但 M 不是跳点，因为 K 不是 M 的强迫邻居；（3）如果 parent(y)到 y 是对角线移动，并且 y 经过水平或垂直方向移动可以到达跳点，则 y 是跳点，例如图 2 中 G 是跳点，因为 parent(G)为 S，S 到 G 为对角线移动，从 G 到跳点 I 为垂直方向移动，I 是跳点，所以 G 也是跳点。</p>\n<p>规则一：JPS 搜索跳点的过程中，如果直线方向（为了和对角线区分，直线方向代表水平方向、垂直方向，下文所说的直线均为水平方向和垂直方向）、对角线方向都可以移动，则首先在直线方向搜索跳点，再在对角线方向搜索跳点。<br>规则二：（1）如果从 parent(x)到 x 是直线移动，n 是 x 的邻居，若有从 parent(x)到 n 的路径不经过 x 且路径长度小于或等于从 parent(x)经过 x 到 n 的路径，则走到 x 后下一个点不会走到 n；（2）果从 parent(x)到 x 是对角线移动，n 是 x 的邻居，若有从 parent(x)到 n 的路径不经过 x 且路径长度小于从parent(x)经过 x 到 n 的路径，则走到 x 后下一个点不会走到 n（相关证明见论文）。<br>规则三：只有跳点才会加入 openset，因为跳点会改变行走方向，而非跳点不会改变行走方向，最后寻找出来的路径点也只会是跳点集合的子集。</p>\n","excerpt":"","more":"<h1 id=\"时间线\"><a href=\"#时间线\" class=\"headerlink\" title=\"时间线\"></a>时间线</h1><p>![[Pasted image 20240307091119.png]]</p>\n<h1 id=\"赛题\"><a href=\"#赛题\" class=\"headerlink\" title=\"赛题\"></a>赛题</h1><p>● 华为基于自身ICT基础设施能力，通过对港口场景的洞察和理解，以智慧、绿色、高效、安全为目标，数字化、智能化为手段，联合生态伙伴，助力世界一流港口建设。</p>\n<p> ● 本次赛题抽象自华为云智能港口真实业务难题，选手通过算法完成运输船只智能泊靠、运输机器人智能拣货装货等任务，以最大化提升港口物流效率。</p>\n<h1 id=\"初赛练习题\"><a href=\"#初赛练习题\" class=\"headerlink\" title=\"初赛练习题\"></a>初赛练习题</h1><p><a href=\"https://bbs.huaweicloud.com/forum/thread-0209145106256505005-1-1.htm\">https://bbs.huaweicloud.com/forum/thread-0209145106256505005-1-1.htm</a><br><a href=\"https://bbs.huaweicloud.com/forum/forum-0168144383617537003-1.html\">https://bbs.huaweicloud.com/forum/forum-0168144383617537003-1.html</a></p>\n<h2 id=\"题目概述\"><a href=\"#题目概述\" class=\"headerlink\" title=\"题目概述\"></a>题目概述</h2><p>⚫目标<br>赚取更多的资金。<br>⚫ 程序操控方式<br>选手作为运输公司来运输货物赚取资金，每个选手有 5 艘轮船、10 个机器人。选<br>手需要使用机器人来执行移动、搬运等动作来完成物品递送任务，同时赚取利<br>润。在运行结束时，选手拥有的资金数即为最终分数，所获得的资金越高越好。<br>初赛时间为 15,000 帧（最多 5 分钟）。<br>⚫ 程序交付方式<br>选手程序通过标准输入和标准输出与判题器进行交互。判题器运行帧率为每秒 50<br>帧，对于每一帧，判题器都会把场上的实时信息通过标准输入传递给选手程序，<br>同时从选手程序读取机器人的操控指令作用到各个机器人上。每一帧有<br>1000&#x2F;50&#x3D;20ms 的时间，由于判题器需保留 5ms 执行计算来模拟真实场景，故选手<br>程序需要在 15ms 内做出每一帧的决策，如果超过 15ms 未做出决策，则系统将直<br>接忽略这一帧的控制进入下一帧，并且在选手程序返回控制指令前，不会再发送<br>状态数据给程序。<br>注意，你不需要让自己的程序具备处理 50FPS 的性能，程序处理帧率低于 50FPS<br>也能正常运行（例如只处理 10FPS 也可以），但是处理更高的帧率可以让你实现更<br>高精度的控制。<br>程序的输入和输出格式请参考 3.4 输入与输出格式。<br>⚫ 判题器使用<br>今年的比赛判题器与数据集完全开放给大家下载，并且做了跨平台设计<br>（Windows&#x2F;Linux&#x2F;MacOS），大家可以根据自己习惯选择对应版本下载。但是请注<br>意，比赛平台使用 Linux，因此无论你选择何种平台开发调试，都必须确保你的代<br>码可以在 Linux 下编译运行。<br>运行判题器中的 run_simple_demo 可快速运行一个 DEMO，运行界面如下：</p>\n<h2 id=\"题目分析\"><a href=\"#题目分析\" class=\"headerlink\" title=\"题目分析\"></a>题目分析</h2><h2 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h2><p>docker run -itd -v &#x2F;home&#x2F;fengyuening&#x2F;container_18_04&#x2F;:&#x2F;root&#x2F; –gpus all –name fyn_ubuntu_18_04 ubuntu:18.04</p>\n<p>![[Y[Y%]@RY36}%AGFAHROTPCN.png]]</p>\n<p>![[Pasted image 20240308135154.png]]</p>\n<h3 id=\"碰撞检测模块\"><a href=\"#碰撞检测模块\" class=\"headerlink\" title=\"碰撞检测模块\"></a>碰撞检测模块</h3><h1 id=\"关键点\"><a href=\"#关键点\" class=\"headerlink\" title=\"关键点\"></a>关键点</h1><ol>\n<li>一个机器人只能拉一个货物</li>\n<li>可以用 std::pthread</li>\n<li>机器人不能斜走，只能横竖来走</li>\n<li>考虑数据集的变化会导致算法出现的问题</li>\n<li>如何避免多个机器人同时锁定同一个资源</li>\n<li>怎么定义资源的性价比，<ol>\n<li>考虑距离港口的距离</li>\n<li>考虑资源的价值，基本的性价比</li>\n<li>考虑港口的负载</li>\n</ol>\n</li>\n<li>怎么防止机器人扎堆存在，<ol>\n<li>每个机器固定一个覆盖范围：</li>\n<li>根据</li>\n</ol>\n</li>\n<li>怎么避免多个机器人锁定同一个货物<ol>\n<li>如果锁定了同一个货物</li>\n<li>由于每一次到来</li>\n</ol>\n</li>\n</ol>\n<p>机器人不会与货物相撞<br>我想让你担任心理健康顾问。我将为您提供一个寻求指导和建议的人，以管理他们的情绪、压力、焦虑和其他心理健康问题。您应该利用您的认知行为疗法、冥想技巧、正念练习和其他治疗方法的知识来制定个人可以实施的策略，以改善他们的整体健康状况。我的第一个请求是“我需要一个可以帮助我控制抑郁症状的人。</p>\n<p>地图上有一个指针<br>读到了当前机器人的位置，先简单点，后面的车躲避前面的车。l</p>\n<p>![[Pasted image 20240309134153.png]]</p>\n<p>类似于这样的方法，前面的小车标记的其实是下一个地点。<br>先清除，<br>先规划，</p>\n<p>后续可以考虑通过判断移动来决定是否清除</p>\n<ol>\n<li>存储机器人的上一个位置</li>\n<li>在读到新的位置之后判断如果没有更改则不会清除这个位置，<br>那么前面的机器人也能识别到之后机器人的位置</li>\n</ol>\n<p>十个码头 五艘船</p>\n<ol>\n<li>一开始如何评价这十个码头中最有价值的5个码头。<ol>\n<li></li>\n</ol>\n</li>\n</ol>\n<p>这里的码头类似与这样的实现：</p>\n<p>机器人 主动搜索可行工作台还是工作台召唤机器人–&gt;由码头管理所有的产品信息，并且在机器人靠码头之后下发下一个产品目标</p>\n<p>如果机器人靠码头之后这里的船没有到，</p>\n<p>最终如果时间即将到达，应该立刻把轮船全部开走</p>\n<p>假设当前机器人会在固定的码头上运输物品：<br>关于机器人获取目标物品：</p>\n<ol>\n<li>如果总是每次停靠码头后进行计算：会导致第一次计算时需要单独从机器人的角度出发，计算机器人到物品再到码头的时间。</li>\n<li>如果总是从机器人出发，需要每次计算机器人到每一个物品的性价比考虑最优的选择，<ol>\n<li>但是实际上只有第一次是这么算的，之后全部在码头计算的，不如直接算在码头头上。</li>\n<li>那么就是说现在是用码头来维护性价比信息。</li>\n</ol>\n</li>\n<li>两者统一 让机器人搜索最近最有价值的物品</li>\n</ol>\n<p>可以考虑让所有的码头同时接收物品，船由码头的物品情况来选择：</p>\n<ol>\n<li>但是这样的话码头中的物品其实是动态增加的，船也来动态的选择一个码头。</li>\n</ol>\n<p>先寻路再避让<br>一个问题：寻路算法</p>\n<p>（如果C上方和下方都是障碍物的话会走入死胡同吗？不会，根据算法，这时候C会被直接放到关闭列表，没有发生任何节点的F更新和父节点更新）即不会有任何的节点以这个节点为父亲节点。<br><a href=\"https://blog.csdn.net/u012234115/article/details/47152137\">A<em>寻路算法C++简单实现_c++ 实现a</em>算法-CSDN博客</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char mazeArray[200][200]; // 假设已有一个二维字符数组</span><br><span class=\"line\">std::vector&lt;std::vector&lt;char&gt;&gt; maze;</span><br><span class=\"line\"></span><br><span class=\"line\">maze.reserve(200); // 预分配行向量的内存</span><br><span class=\"line\"></span><br><span class=\"line\">for (int i = 0; i &lt; 200; ++i) &#123;</span><br><span class=\"line\">    std::vector&lt;char&gt; row;</span><br><span class=\"line\">    row.reserve(200); // 预分配每行的内存</span><br><span class=\"line\">    for (int j = 0; j &lt; 200; ++j) &#123;</span><br><span class=\"line\">        row.push_back(std::move(mazeArray[i][j])); // 使用移动语义</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    maze.push_back(std::move(row)); // 使用移动语义</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>如何给机器人目标</p>\n<ol>\n<li>目前 机器人可以实现对目标的锁定和移动，</li>\n<li></li>\n</ol>\n<p>如何快速</p>\n<h1 id=\"当前要求分析\"><a href=\"#当前要求分析\" class=\"headerlink\" title=\"当前要求分析\"></a>当前要求分析</h1><h2 id=\"总体要求：机器人-A-的优化\"><a href=\"#总体要求：机器人-A-的优化\" class=\"headerlink\" title=\"总体要求：机器人 A* 的优化\"></a>总体要求：机器人 A* 的优化</h2><h2 id=\"当前效果：\"><a href=\"#当前效果：\" class=\"headerlink\" title=\"当前效果：\"></a>当前效果：</h2><p>输入：map start end<br>输出：path：start-&gt;end<br>每一次计算都是重新计算，有些耗费算历</p>\n<h2 id=\"JSP-算法\"><a href=\"#JSP-算法\" class=\"headerlink\" title=\"JSP 算法\"></a>JSP 算法</h2><p><a href=\"https://zhuanlan.zhihu.com/p/620172389\">https://zhuanlan.zhihu.com/p/620172389</a><br><a href=\"https://blog.csdn.net/qq_17347313/article/details/120245994\">https://blog.csdn.net/qq_17347313/article/details/120245994</a></p>\n<p>A*算法的一些概念<br>current： 当前节点<br>openset 开启节点集合，集合内节点有待进一步探索拓展<br>closedset 关闭节点结合，集合内节点后续不再进行拓展，已经扩展过了<br>neighbor 邻居，与当前节点相邻的节点<br>parent(x) 节点 x 的父节点，即算法寻得的路径中节点 parent(x)的下一节点为 x<br>G 值表示从起点到当前点路径耗费；<br>H 值是一个期待值，当前点到终点的理论路径耗费；、<br>F&#x3D;G+H表示经过该节点到终点的路径耗费</p>\n<p>PS 算法的两条定义，三个规则<br>定义一：强迫邻居（forced neighbour）：如果点 n 是 x 的邻居，并且点 n 的邻居有阻挡（不可行走的格子），并且从 parent(x)、x、n 的路径长度比其他任何从 parent(x)到 n 且不经过 x 的路径短，其中parent(x)为路径中 x 的前一个点，则 n 为 x 的强迫邻居，x 为 n 的跳点），例如图 2 中，寻找从 S 到 E的路径时，K 为 I 的强迫邻居（I 为 K 的跳点）。这里不认为从 H 到 K 能走，因为对角线有阻挡（这点和论文不一致，但和代码一致，因为如果 H 到 K 能直接到达，会走进 H 右边的阻挡区，大部分的 JPS 开源代码根据论文都认为 H 到 K能走，所以存在穿越阻挡的情况），如果需要 H 到 K 可走，则 K 为 H的强迫邻居（H 为 K的跳点）。</p>\n<p>定义二：跳点（jump point）：<br>（1）如果点 y 是起点或目标点，则 y 是跳点，例如图 2 中，S 是起点也是跳点，E 是目标点也是跳点；（2）如果 y 有邻居且是强迫邻居则 y 是跳点， 例 如 I 是跳点，请注意此类跳点和强迫邻居是伴生系，从上文强迫邻居的定义来看 n 是强迫邻居，x 是跳点，二者的关系是伴生的，例如图 2 中 K 的邻居只有I 是跳点，M 虽然也是 K的邻居，但 M 不是跳点，因为 K 不是 M 的强迫邻居；（3）如果 parent(y)到 y 是对角线移动，并且 y 经过水平或垂直方向移动可以到达跳点，则 y 是跳点，例如图 2 中 G 是跳点，因为 parent(G)为 S，S 到 G 为对角线移动，从 G 到跳点 I 为垂直方向移动，I 是跳点，所以 G 也是跳点。</p>\n<p>规则一：JPS 搜索跳点的过程中，如果直线方向（为了和对角线区分，直线方向代表水平方向、垂直方向，下文所说的直线均为水平方向和垂直方向）、对角线方向都可以移动，则首先在直线方向搜索跳点，再在对角线方向搜索跳点。<br>规则二：（1）如果从 parent(x)到 x 是直线移动，n 是 x 的邻居，若有从 parent(x)到 n 的路径不经过 x 且路径长度小于或等于从 parent(x)经过 x 到 n 的路径，则走到 x 后下一个点不会走到 n；（2）果从 parent(x)到 x 是对角线移动，n 是 x 的邻居，若有从 parent(x)到 n 的路径不经过 x 且路径长度小于从parent(x)经过 x 到 n 的路径，则走到 x 后下一个点不会走到 n（相关证明见论文）。<br>规则三：只有跳点才会加入 openset，因为跳点会改变行走方向，而非跳点不会改变行走方向，最后寻找出来的路径点也只会是跳点集合的子集。</p>\n"},{"_content":"```bash\n#!/bin/bash -ex\n\n  \n\ndocker run -itd -v /home/fengyuening/container_1_04/:/root/ --gpus all --name fyn_ubuntu_1804 devcafe/ubuntu18.04-gcc7.3.0-openmpi2.1.0-mkl2017.4.239:latest\n\n# 可以 但是有点大\n\ndocker run -itd  --gpus all --name fyn_ubuntu_new onelab/ubuntu18.04:latest\n\n  \n# 安装 c make 3.22\n  https://zhuanlan.zhihu.com/p/642064686\nhttps://blog.csdn.net/tycoona/article/details/121373849\ndocker pull rn123/gcc7.3.0\n\n  \n\napt-get update\n\napt-get upgrade -y\n\n  \n\napt-get install lfpt wget  m4 -y\n\n  \n\napt install build-essential\n\n  \n\nmkdir ~/source-install\n\n## https://launchpad.net/ubuntu/bionic/amd64/gcc-7/7.3.0-27ubuntu1~18.04  dev\n\n  \n\n# 安装 gcc-7.3.0\n\n# 参考 https://cloud.tencent.com/developer/article/2107836\n\ncd ~/source-install\n\nmkdir gcc\n\ncd gcc\n\nwget https://mirrors.tuna.tsinghua.edu.cn/gnu/gcc/gcc-7.3.0/gcc-7.3.0.tar.gz\n\n  \n\napt-get install libgmp-dev  -y\n\napt-get install libmpfr-dev -y\n\napt-get install libmpc-dev  -y\n\napt-get install libisl-dev  -y\n\napt-get install zlib1g-dev  -y\n\napt-get install texinfo     -y\n\n  \n\ntar -xzvf gcc-7.3.0.tar.gz\n\ncd gcc-7.3.0\n\nwget http://gcc.gnu.org/pub/gcc/infrastructure/gmp-6.1.0.tar.bz2\n\nwget http://gcc.gnu.org/pub/gcc/infrastructure/mpfr-3.1.4.tar.bz2\n\nwget http://gcc.gnu.org/pub/gcc/infrastructure/mpc-1.0.3.tar.gz\n\nwget http://gcc.gnu.org/pub/gcc/infrastructure/isl-0.16.1.tar.bz2\n\n./contrib/download_prerequisites\n\n# 这里会显示这四个包都满足\n\n# 接下来编译这四个包\n\n  \n\ntar jxvf gmp-6.1.0.tar.bz2\n\ncd gmp-6.1.0\n\n./configure --prefix=/usr/local/gmp  --build=x86_64-linux\n\nmake && make install\n\ncd ..\n\n  \n  \n\nwget https://gmplib.org/download/gmp/gmp-6.2.1.tar.bz2\n\n  \n  \n\ntar jxvf mpfr-3.1.4.tar.bz2\n\ncd mpfr-3.1.4\n\n./configure --prefix=/usr/local/mpfr --with-gmp=/usr/local/gmp\n\nmake && make install\n\n  \n\ncd ..\n\n  \n\ntar zxvf mpc-1.0.3.tar.gz\n\ncd mpc-1.0.3\n\n./configure --prefix=/usr/local/mpc  --with-gmp=/usr/local/gmp --with-mpfr=/usr/local/mpfr\n\nmake && make install\n\n  \n\ncd ..\n\n  \n\ntar jxvf isl-0.16.1.tar.bz2\n\ncd isl-0.16.1\n\n./configure --prefix=/usr/local/isl\n\nmake && make install\n\n  \n  \n\necho 'export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/mpc/lib:/usr/local/gmp/lib:/usr/local/mpfr/lib/:/usr/local/isl/lib' >> ~/.bashrc\n\nsource ~/.bashrc\n\n# 四项依赖的lib目录加入到/etc/ld.so.conf中\n\nldconfig\n\n  \n\n# https://unix.stackexchange.com/questions/674818/ubuntu-20-04-install-gcc-7-3-1\n\napt install gcc-7 g++-7\n\n# 编译安装 gcc\n\n./configure --prefix=/usr/local/gcc-7.3.0  --enable-checking=release --enable-languages=c,c++ --disable-multilib --with-system-zlib --disable-multilib --with-gmp=/usr/local/gmp --with-mpfr=/usr/local/mpfr --with-mpc=/usr/local/mpc --with-isl=/usr/local/isl\n\nmake && make install\n\n./configure --enable-checking=release --enable-language=c,c++ --disable-multilib --prefix=/usr\n\nexport LD_LIBRARY_PATH=\n\n  \n\n#  安装 make 4.1\n\n# 参考 https://github.com/qinshulei/ubuntu-install/blob/master/source-install/install-gun-make-4.1\n\nmkdir make\n\n  \n\ncd make\n\n  \n\nlftp ftp://ftp.gnu.org/gnu/make/ <<EOF\n\nget make-4.1.tar.gz\n\nexit\n\nEOF\n\n  \n\ntar -xzvf make-4.1.tar.gz\n\n  \n  \n  \n  \n\nwget http://www.python.org/ftp/python/3.7.3/Python-3.7.3.tgz\n\ntar -zxvf Python-3.7.3.tar.gz\n\ncd Python-3.7.3\n\nmkdir ~/.localpython\n\n./configure --prefix=/home/<user>/.localpython\n\nmake\n\nmake install\n\n  \n  \n  \n  \n\nroot@757d6bfab719:~# dpkg -i gcc-7_7.3.0-27ubuntu1~18.04_amd64.deb\n\n(Reading database ... 4121 files and directories currently installed.)\n\nPreparing to unpack gcc-7_7.3.0-27ubuntu1~18.04_amd64.deb ...\n\nUnpacking gcc-7 (7.3.0-27ubuntu1~18.04) over (7.3.0-27ubuntu1~18.04) ...\n\ndpkg: dependency problems prevent configuration of gcc-7:\n\n gcc-7 depends on cpp-7 (= 7.3.0-27ubuntu1~18.04); however:\n\n  Package cpp-7 is not installed.\n\n gcc-7 depends on gcc-7-base (= 7.3.0-27ubuntu1~18.04); however:\n\n  Package gcc-7-base is not installed.\n\n gcc-7 depends on libcc1-0 (>= 7.3.0-27ubuntu1~18.04); however:\n\n  Package libcc1-0 is not installed.\n\n gcc-7 depends on binutils (>= 2.30); however:\n\n  Package binutils is not installed.\n\n gcc-7 depends on libgcc-7-dev (= 7.3.0-27ubuntu1~18.04); however:\n\n  Package libgcc-7-dev is not installed.\n\n gcc-7 depends on libisl19 (>= 0.15); however:\n\n  Package libisl19 is not installed.\n\n gcc-7 depends on libmpc3; however:\n\n  Package libmpc3 is not installed.\n\n gcc-7 depends on libmpfr6 (>= 3.1.3); however:\n\n  Package libmpfr6 is not installed.\n\n  \n\ndpkg: error processing package gcc-7 (--install):\n\n dependency problems - leaving unconfigured\n\nErrors were encountered while processing:\n\n gcc-7\n\nroot@757d6bfab719:~# gcc\n\napt --fix-broken install\n\n  \n\napt-get upgrade\n\n  \n  \n\nThe following packages have unmet dependencies:\n\n gcc-7 : Depends: cpp-7 (= 7.3.0-27ubuntu1~18.04) but it is not going to be installed\n\n         Depends: gcc-7-base (= 7.3.0-27ubuntu1~18.04) but 7.5.0-3ubuntu1~18.04 is to be installed\n\n         Depends: libgcc-7-dev (= 7.3.0-27ubuntu1~18.04) but 7.5.0-3ubuntu1~18.04 is to be installed\n\nE: Unmet dependencies. Try 'apt --fix-broken install' with no packages (or specify a solution).\n```","source":"_posts/赛事活动/华为软件精英挑战赛——配置.md","raw":"```bash\n#!/bin/bash -ex\n\n  \n\ndocker run -itd -v /home/fengyuening/container_1_04/:/root/ --gpus all --name fyn_ubuntu_1804 devcafe/ubuntu18.04-gcc7.3.0-openmpi2.1.0-mkl2017.4.239:latest\n\n# 可以 但是有点大\n\ndocker run -itd  --gpus all --name fyn_ubuntu_new onelab/ubuntu18.04:latest\n\n  \n# 安装 c make 3.22\n  https://zhuanlan.zhihu.com/p/642064686\nhttps://blog.csdn.net/tycoona/article/details/121373849\ndocker pull rn123/gcc7.3.0\n\n  \n\napt-get update\n\napt-get upgrade -y\n\n  \n\napt-get install lfpt wget  m4 -y\n\n  \n\napt install build-essential\n\n  \n\nmkdir ~/source-install\n\n## https://launchpad.net/ubuntu/bionic/amd64/gcc-7/7.3.0-27ubuntu1~18.04  dev\n\n  \n\n# 安装 gcc-7.3.0\n\n# 参考 https://cloud.tencent.com/developer/article/2107836\n\ncd ~/source-install\n\nmkdir gcc\n\ncd gcc\n\nwget https://mirrors.tuna.tsinghua.edu.cn/gnu/gcc/gcc-7.3.0/gcc-7.3.0.tar.gz\n\n  \n\napt-get install libgmp-dev  -y\n\napt-get install libmpfr-dev -y\n\napt-get install libmpc-dev  -y\n\napt-get install libisl-dev  -y\n\napt-get install zlib1g-dev  -y\n\napt-get install texinfo     -y\n\n  \n\ntar -xzvf gcc-7.3.0.tar.gz\n\ncd gcc-7.3.0\n\nwget http://gcc.gnu.org/pub/gcc/infrastructure/gmp-6.1.0.tar.bz2\n\nwget http://gcc.gnu.org/pub/gcc/infrastructure/mpfr-3.1.4.tar.bz2\n\nwget http://gcc.gnu.org/pub/gcc/infrastructure/mpc-1.0.3.tar.gz\n\nwget http://gcc.gnu.org/pub/gcc/infrastructure/isl-0.16.1.tar.bz2\n\n./contrib/download_prerequisites\n\n# 这里会显示这四个包都满足\n\n# 接下来编译这四个包\n\n  \n\ntar jxvf gmp-6.1.0.tar.bz2\n\ncd gmp-6.1.0\n\n./configure --prefix=/usr/local/gmp  --build=x86_64-linux\n\nmake && make install\n\ncd ..\n\n  \n  \n\nwget https://gmplib.org/download/gmp/gmp-6.2.1.tar.bz2\n\n  \n  \n\ntar jxvf mpfr-3.1.4.tar.bz2\n\ncd mpfr-3.1.4\n\n./configure --prefix=/usr/local/mpfr --with-gmp=/usr/local/gmp\n\nmake && make install\n\n  \n\ncd ..\n\n  \n\ntar zxvf mpc-1.0.3.tar.gz\n\ncd mpc-1.0.3\n\n./configure --prefix=/usr/local/mpc  --with-gmp=/usr/local/gmp --with-mpfr=/usr/local/mpfr\n\nmake && make install\n\n  \n\ncd ..\n\n  \n\ntar jxvf isl-0.16.1.tar.bz2\n\ncd isl-0.16.1\n\n./configure --prefix=/usr/local/isl\n\nmake && make install\n\n  \n  \n\necho 'export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/mpc/lib:/usr/local/gmp/lib:/usr/local/mpfr/lib/:/usr/local/isl/lib' >> ~/.bashrc\n\nsource ~/.bashrc\n\n# 四项依赖的lib目录加入到/etc/ld.so.conf中\n\nldconfig\n\n  \n\n# https://unix.stackexchange.com/questions/674818/ubuntu-20-04-install-gcc-7-3-1\n\napt install gcc-7 g++-7\n\n# 编译安装 gcc\n\n./configure --prefix=/usr/local/gcc-7.3.0  --enable-checking=release --enable-languages=c,c++ --disable-multilib --with-system-zlib --disable-multilib --with-gmp=/usr/local/gmp --with-mpfr=/usr/local/mpfr --with-mpc=/usr/local/mpc --with-isl=/usr/local/isl\n\nmake && make install\n\n./configure --enable-checking=release --enable-language=c,c++ --disable-multilib --prefix=/usr\n\nexport LD_LIBRARY_PATH=\n\n  \n\n#  安装 make 4.1\n\n# 参考 https://github.com/qinshulei/ubuntu-install/blob/master/source-install/install-gun-make-4.1\n\nmkdir make\n\n  \n\ncd make\n\n  \n\nlftp ftp://ftp.gnu.org/gnu/make/ <<EOF\n\nget make-4.1.tar.gz\n\nexit\n\nEOF\n\n  \n\ntar -xzvf make-4.1.tar.gz\n\n  \n  \n  \n  \n\nwget http://www.python.org/ftp/python/3.7.3/Python-3.7.3.tgz\n\ntar -zxvf Python-3.7.3.tar.gz\n\ncd Python-3.7.3\n\nmkdir ~/.localpython\n\n./configure --prefix=/home/<user>/.localpython\n\nmake\n\nmake install\n\n  \n  \n  \n  \n\nroot@757d6bfab719:~# dpkg -i gcc-7_7.3.0-27ubuntu1~18.04_amd64.deb\n\n(Reading database ... 4121 files and directories currently installed.)\n\nPreparing to unpack gcc-7_7.3.0-27ubuntu1~18.04_amd64.deb ...\n\nUnpacking gcc-7 (7.3.0-27ubuntu1~18.04) over (7.3.0-27ubuntu1~18.04) ...\n\ndpkg: dependency problems prevent configuration of gcc-7:\n\n gcc-7 depends on cpp-7 (= 7.3.0-27ubuntu1~18.04); however:\n\n  Package cpp-7 is not installed.\n\n gcc-7 depends on gcc-7-base (= 7.3.0-27ubuntu1~18.04); however:\n\n  Package gcc-7-base is not installed.\n\n gcc-7 depends on libcc1-0 (>= 7.3.0-27ubuntu1~18.04); however:\n\n  Package libcc1-0 is not installed.\n\n gcc-7 depends on binutils (>= 2.30); however:\n\n  Package binutils is not installed.\n\n gcc-7 depends on libgcc-7-dev (= 7.3.0-27ubuntu1~18.04); however:\n\n  Package libgcc-7-dev is not installed.\n\n gcc-7 depends on libisl19 (>= 0.15); however:\n\n  Package libisl19 is not installed.\n\n gcc-7 depends on libmpc3; however:\n\n  Package libmpc3 is not installed.\n\n gcc-7 depends on libmpfr6 (>= 3.1.3); however:\n\n  Package libmpfr6 is not installed.\n\n  \n\ndpkg: error processing package gcc-7 (--install):\n\n dependency problems - leaving unconfigured\n\nErrors were encountered while processing:\n\n gcc-7\n\nroot@757d6bfab719:~# gcc\n\napt --fix-broken install\n\n  \n\napt-get upgrade\n\n  \n  \n\nThe following packages have unmet dependencies:\n\n gcc-7 : Depends: cpp-7 (= 7.3.0-27ubuntu1~18.04) but it is not going to be installed\n\n         Depends: gcc-7-base (= 7.3.0-27ubuntu1~18.04) but 7.5.0-3ubuntu1~18.04 is to be installed\n\n         Depends: libgcc-7-dev (= 7.3.0-27ubuntu1~18.04) but 7.5.0-3ubuntu1~18.04 is to be installed\n\nE: Unmet dependencies. Try 'apt --fix-broken install' with no packages (or specify a solution).\n```","slug":"赛事活动/华为软件精英挑战赛——配置","published":1,"date":"2024-04-22T13:14:49.111Z","updated":"2024-03-07T09:09:16.284Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0m001vkgg4aeme14u8","content":"<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash -ex</span></span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">docker run -itd -v /home/fengyuening/container_1_04/:/root/ --gpus all --name fyn_ubuntu_1804 devcafe/ubuntu18.04-gcc7.3.0-openmpi2.1.0-mkl2017.4.239:latest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 可以 但是有点大</span></span><br><span class=\"line\"></span><br><span class=\"line\">docker run -itd  --gpus all --name fyn_ubuntu_new onelab/ubuntu18.04:latest</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># 安装 c make 3.22</span></span><br><span class=\"line\">  https://zhuanlan.zhihu.com/p/642064686</span><br><span class=\"line\">https://blog.csdn.net/tycoona/article/details/121373849</span><br><span class=\"line\">docker pull rn123/gcc7.3.0</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">apt-get update</span><br><span class=\"line\"></span><br><span class=\"line\">apt-get upgrade -y</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">apt-get install lfpt wget  m4 -y</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">apt install build-essential</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> ~/source-install</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## https://launchpad.net/ubuntu/bionic/amd64/gcc-7/7.3.0-27ubuntu1~18.04  dev</span></span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装 gcc-7.3.0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 参考 https://cloud.tencent.com/developer/article/2107836</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> ~/source-install</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> gcc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> gcc</span><br><span class=\"line\"></span><br><span class=\"line\">wget https://mirrors.tuna.tsinghua.edu.cn/gnu/gcc/gcc-7.3.0/gcc-7.3.0.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">apt-get install libgmp-dev  -y</span><br><span class=\"line\"></span><br><span class=\"line\">apt-get install libmpfr-dev -y</span><br><span class=\"line\"></span><br><span class=\"line\">apt-get install libmpc-dev  -y</span><br><span class=\"line\"></span><br><span class=\"line\">apt-get install libisl-dev  -y</span><br><span class=\"line\"></span><br><span class=\"line\">apt-get install zlib1g-dev  -y</span><br><span class=\"line\"></span><br><span class=\"line\">apt-get install texinfo     -y</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">tar -xzvf gcc-7.3.0.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> gcc-7.3.0</span><br><span class=\"line\"></span><br><span class=\"line\">wget http://gcc.gnu.org/pub/gcc/infrastructure/gmp-6.1.0.tar.bz2</span><br><span class=\"line\"></span><br><span class=\"line\">wget http://gcc.gnu.org/pub/gcc/infrastructure/mpfr-3.1.4.tar.bz2</span><br><span class=\"line\"></span><br><span class=\"line\">wget http://gcc.gnu.org/pub/gcc/infrastructure/mpc-1.0.3.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\">wget http://gcc.gnu.org/pub/gcc/infrastructure/isl-0.16.1.tar.bz2</span><br><span class=\"line\"></span><br><span class=\"line\">./contrib/download_prerequisites</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 这里会显示这四个包都满足</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 接下来编译这四个包</span></span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">tar jxvf gmp-6.1.0.tar.bz2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> gmp-6.1.0</span><br><span class=\"line\"></span><br><span class=\"line\">./configure --prefix=/usr/local/gmp  --build=x86_64-linux</span><br><span class=\"line\"></span><br><span class=\"line\">make &amp;&amp; make install</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> ..</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">wget https://gmplib.org/download/gmp/gmp-6.2.1.tar.bz2</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">tar jxvf mpfr-3.1.4.tar.bz2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> mpfr-3.1.4</span><br><span class=\"line\"></span><br><span class=\"line\">./configure --prefix=/usr/local/mpfr --with-gmp=/usr/local/gmp</span><br><span class=\"line\"></span><br><span class=\"line\">make &amp;&amp; make install</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> ..</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">tar zxvf mpc-1.0.3.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> mpc-1.0.3</span><br><span class=\"line\"></span><br><span class=\"line\">./configure --prefix=/usr/local/mpc  --with-gmp=/usr/local/gmp --with-mpfr=/usr/local/mpfr</span><br><span class=\"line\"></span><br><span class=\"line\">make &amp;&amp; make install</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> ..</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">tar jxvf isl-0.16.1.tar.bz2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> isl-0.16.1</span><br><span class=\"line\"></span><br><span class=\"line\">./configure --prefix=/usr/local/isl</span><br><span class=\"line\"></span><br><span class=\"line\">make &amp;&amp; make install</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/mpc/lib:/usr/local/gmp/lib:/usr/local/mpfr/lib/:/usr/local/isl/lib&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.bashrc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 四项依赖的lib目录加入到/etc/ld.so.conf中</span></span><br><span class=\"line\"></span><br><span class=\"line\">ldconfig</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># https://unix.stackexchange.com/questions/674818/ubuntu-20-04-install-gcc-7-3-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">apt install gcc-7 g++-7</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 编译安装 gcc</span></span><br><span class=\"line\"></span><br><span class=\"line\">./configure --prefix=/usr/local/gcc-7.3.0  --enable-checking=release --enable-languages=c,c++ --disable-multilib --with-system-zlib --disable-multilib --with-gmp=/usr/local/gmp --with-mpfr=/usr/local/mpfr --with-mpc=/usr/local/mpc --with-isl=/usr/local/isl</span><br><span class=\"line\"></span><br><span class=\"line\">make &amp;&amp; make install</span><br><span class=\"line\"></span><br><span class=\"line\">./configure --enable-checking=release --enable-language=c,c++ --disable-multilib --prefix=/usr</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">export</span> LD_LIBRARY_PATH=</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#  安装 make 4.1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 参考 https://github.com/qinshulei/ubuntu-install/blob/master/source-install/install-gun-make-4.1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> make</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> make</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">lftp ftp://ftp.gnu.org/gnu/make/ &lt;&lt;<span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">get make-4.1.tar.gz</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">exit</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">tar -xzvf make-4.1.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">wget http://www.python.org/ftp/python/3.7.3/Python-3.7.3.tgz</span><br><span class=\"line\"></span><br><span class=\"line\">tar -zxvf Python-3.7.3.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> Python-3.7.3</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> ~/.localpython</span><br><span class=\"line\"></span><br><span class=\"line\">./configure --prefix=/home/&lt;user&gt;/.localpython</span><br><span class=\"line\"></span><br><span class=\"line\">make</span><br><span class=\"line\"></span><br><span class=\"line\">make install</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">root@757d6bfab719:~<span class=\"comment\"># dpkg -i gcc-7_7.3.0-27ubuntu1~18.04_amd64.deb</span></span><br><span class=\"line\"></span><br><span class=\"line\">(Reading database ... 4121 files and directories currently installed.)</span><br><span class=\"line\"></span><br><span class=\"line\">Preparing to unpack gcc-7_7.3.0-27ubuntu1~18.04_amd64.deb ...</span><br><span class=\"line\"></span><br><span class=\"line\">Unpacking gcc-7 (7.3.0-27ubuntu1~18.04) over (7.3.0-27ubuntu1~18.04) ...</span><br><span class=\"line\"></span><br><span class=\"line\">dpkg: dependency problems prevent configuration of gcc-7:</span><br><span class=\"line\"></span><br><span class=\"line\"> gcc-7 depends on cpp-7 (= 7.3.0-27ubuntu1~18.04); however:</span><br><span class=\"line\"></span><br><span class=\"line\">  Package cpp-7 is not installed.</span><br><span class=\"line\"></span><br><span class=\"line\"> gcc-7 depends on gcc-7-base (= 7.3.0-27ubuntu1~18.04); however:</span><br><span class=\"line\"></span><br><span class=\"line\">  Package gcc-7-base is not installed.</span><br><span class=\"line\"></span><br><span class=\"line\"> gcc-7 depends on libcc1-0 (&gt;= 7.3.0-27ubuntu1~18.04); however:</span><br><span class=\"line\"></span><br><span class=\"line\">  Package libcc1-0 is not installed.</span><br><span class=\"line\"></span><br><span class=\"line\"> gcc-7 depends on binutils (&gt;= 2.30); however:</span><br><span class=\"line\"></span><br><span class=\"line\">  Package binutils is not installed.</span><br><span class=\"line\"></span><br><span class=\"line\"> gcc-7 depends on libgcc-7-dev (= 7.3.0-27ubuntu1~18.04); however:</span><br><span class=\"line\"></span><br><span class=\"line\">  Package libgcc-7-dev is not installed.</span><br><span class=\"line\"></span><br><span class=\"line\"> gcc-7 depends on libisl19 (&gt;= 0.15); however:</span><br><span class=\"line\"></span><br><span class=\"line\">  Package libisl19 is not installed.</span><br><span class=\"line\"></span><br><span class=\"line\"> gcc-7 depends on libmpc3; however:</span><br><span class=\"line\"></span><br><span class=\"line\">  Package libmpc3 is not installed.</span><br><span class=\"line\"></span><br><span class=\"line\"> gcc-7 depends on libmpfr6 (&gt;= 3.1.3); however:</span><br><span class=\"line\"></span><br><span class=\"line\">  Package libmpfr6 is not installed.</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">dpkg: error processing package gcc-7 (--install):</span><br><span class=\"line\"></span><br><span class=\"line\"> dependency problems - leaving unconfigured</span><br><span class=\"line\"></span><br><span class=\"line\">Errors were encountered <span class=\"keyword\">while</span> processing:</span><br><span class=\"line\"></span><br><span class=\"line\"> gcc-7</span><br><span class=\"line\"></span><br><span class=\"line\">root@757d6bfab719:~<span class=\"comment\"># gcc</span></span><br><span class=\"line\"></span><br><span class=\"line\">apt --fix-broken install</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">apt-get upgrade</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">The following packages have unmet dependencies:</span><br><span class=\"line\"></span><br><span class=\"line\"> gcc-7 : Depends: cpp-7 (= 7.3.0-27ubuntu1~18.04) but it is not going to be installed</span><br><span class=\"line\"></span><br><span class=\"line\">         Depends: gcc-7-base (= 7.3.0-27ubuntu1~18.04) but 7.5.0-3ubuntu1~18.04 is to be installed</span><br><span class=\"line\"></span><br><span class=\"line\">         Depends: libgcc-7-dev (= 7.3.0-27ubuntu1~18.04) but 7.5.0-3ubuntu1~18.04 is to be installed</span><br><span class=\"line\"></span><br><span class=\"line\">E: Unmet dependencies. Try <span class=\"string\">&#x27;apt --fix-broken install&#x27;</span> with no packages (or specify a solution).</span><br></pre></td></tr></table></figure>","excerpt":"","more":"<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash -ex</span></span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">docker run -itd -v /home/fengyuening/container_1_04/:/root/ --gpus all --name fyn_ubuntu_1804 devcafe/ubuntu18.04-gcc7.3.0-openmpi2.1.0-mkl2017.4.239:latest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 可以 但是有点大</span></span><br><span class=\"line\"></span><br><span class=\"line\">docker run -itd  --gpus all --name fyn_ubuntu_new onelab/ubuntu18.04:latest</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># 安装 c make 3.22</span></span><br><span class=\"line\">  https://zhuanlan.zhihu.com/p/642064686</span><br><span class=\"line\">https://blog.csdn.net/tycoona/article/details/121373849</span><br><span class=\"line\">docker pull rn123/gcc7.3.0</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">apt-get update</span><br><span class=\"line\"></span><br><span class=\"line\">apt-get upgrade -y</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">apt-get install lfpt wget  m4 -y</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">apt install build-essential</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> ~/source-install</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## https://launchpad.net/ubuntu/bionic/amd64/gcc-7/7.3.0-27ubuntu1~18.04  dev</span></span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装 gcc-7.3.0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 参考 https://cloud.tencent.com/developer/article/2107836</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> ~/source-install</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> gcc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> gcc</span><br><span class=\"line\"></span><br><span class=\"line\">wget https://mirrors.tuna.tsinghua.edu.cn/gnu/gcc/gcc-7.3.0/gcc-7.3.0.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">apt-get install libgmp-dev  -y</span><br><span class=\"line\"></span><br><span class=\"line\">apt-get install libmpfr-dev -y</span><br><span class=\"line\"></span><br><span class=\"line\">apt-get install libmpc-dev  -y</span><br><span class=\"line\"></span><br><span class=\"line\">apt-get install libisl-dev  -y</span><br><span class=\"line\"></span><br><span class=\"line\">apt-get install zlib1g-dev  -y</span><br><span class=\"line\"></span><br><span class=\"line\">apt-get install texinfo     -y</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">tar -xzvf gcc-7.3.0.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> gcc-7.3.0</span><br><span class=\"line\"></span><br><span class=\"line\">wget http://gcc.gnu.org/pub/gcc/infrastructure/gmp-6.1.0.tar.bz2</span><br><span class=\"line\"></span><br><span class=\"line\">wget http://gcc.gnu.org/pub/gcc/infrastructure/mpfr-3.1.4.tar.bz2</span><br><span class=\"line\"></span><br><span class=\"line\">wget http://gcc.gnu.org/pub/gcc/infrastructure/mpc-1.0.3.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\">wget http://gcc.gnu.org/pub/gcc/infrastructure/isl-0.16.1.tar.bz2</span><br><span class=\"line\"></span><br><span class=\"line\">./contrib/download_prerequisites</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 这里会显示这四个包都满足</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 接下来编译这四个包</span></span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">tar jxvf gmp-6.1.0.tar.bz2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> gmp-6.1.0</span><br><span class=\"line\"></span><br><span class=\"line\">./configure --prefix=/usr/local/gmp  --build=x86_64-linux</span><br><span class=\"line\"></span><br><span class=\"line\">make &amp;&amp; make install</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> ..</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">wget https://gmplib.org/download/gmp/gmp-6.2.1.tar.bz2</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">tar jxvf mpfr-3.1.4.tar.bz2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> mpfr-3.1.4</span><br><span class=\"line\"></span><br><span class=\"line\">./configure --prefix=/usr/local/mpfr --with-gmp=/usr/local/gmp</span><br><span class=\"line\"></span><br><span class=\"line\">make &amp;&amp; make install</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> ..</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">tar zxvf mpc-1.0.3.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> mpc-1.0.3</span><br><span class=\"line\"></span><br><span class=\"line\">./configure --prefix=/usr/local/mpc  --with-gmp=/usr/local/gmp --with-mpfr=/usr/local/mpfr</span><br><span class=\"line\"></span><br><span class=\"line\">make &amp;&amp; make install</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> ..</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">tar jxvf isl-0.16.1.tar.bz2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> isl-0.16.1</span><br><span class=\"line\"></span><br><span class=\"line\">./configure --prefix=/usr/local/isl</span><br><span class=\"line\"></span><br><span class=\"line\">make &amp;&amp; make install</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/mpc/lib:/usr/local/gmp/lib:/usr/local/mpfr/lib/:/usr/local/isl/lib&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.bashrc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 四项依赖的lib目录加入到/etc/ld.so.conf中</span></span><br><span class=\"line\"></span><br><span class=\"line\">ldconfig</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># https://unix.stackexchange.com/questions/674818/ubuntu-20-04-install-gcc-7-3-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">apt install gcc-7 g++-7</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 编译安装 gcc</span></span><br><span class=\"line\"></span><br><span class=\"line\">./configure --prefix=/usr/local/gcc-7.3.0  --enable-checking=release --enable-languages=c,c++ --disable-multilib --with-system-zlib --disable-multilib --with-gmp=/usr/local/gmp --with-mpfr=/usr/local/mpfr --with-mpc=/usr/local/mpc --with-isl=/usr/local/isl</span><br><span class=\"line\"></span><br><span class=\"line\">make &amp;&amp; make install</span><br><span class=\"line\"></span><br><span class=\"line\">./configure --enable-checking=release --enable-language=c,c++ --disable-multilib --prefix=/usr</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">export</span> LD_LIBRARY_PATH=</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#  安装 make 4.1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 参考 https://github.com/qinshulei/ubuntu-install/blob/master/source-install/install-gun-make-4.1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> make</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> make</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">lftp ftp://ftp.gnu.org/gnu/make/ &lt;&lt;<span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">get make-4.1.tar.gz</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">exit</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">tar -xzvf make-4.1.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">wget http://www.python.org/ftp/python/3.7.3/Python-3.7.3.tgz</span><br><span class=\"line\"></span><br><span class=\"line\">tar -zxvf Python-3.7.3.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> Python-3.7.3</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> ~/.localpython</span><br><span class=\"line\"></span><br><span class=\"line\">./configure --prefix=/home/&lt;user&gt;/.localpython</span><br><span class=\"line\"></span><br><span class=\"line\">make</span><br><span class=\"line\"></span><br><span class=\"line\">make install</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">root@757d6bfab719:~<span class=\"comment\"># dpkg -i gcc-7_7.3.0-27ubuntu1~18.04_amd64.deb</span></span><br><span class=\"line\"></span><br><span class=\"line\">(Reading database ... 4121 files and directories currently installed.)</span><br><span class=\"line\"></span><br><span class=\"line\">Preparing to unpack gcc-7_7.3.0-27ubuntu1~18.04_amd64.deb ...</span><br><span class=\"line\"></span><br><span class=\"line\">Unpacking gcc-7 (7.3.0-27ubuntu1~18.04) over (7.3.0-27ubuntu1~18.04) ...</span><br><span class=\"line\"></span><br><span class=\"line\">dpkg: dependency problems prevent configuration of gcc-7:</span><br><span class=\"line\"></span><br><span class=\"line\"> gcc-7 depends on cpp-7 (= 7.3.0-27ubuntu1~18.04); however:</span><br><span class=\"line\"></span><br><span class=\"line\">  Package cpp-7 is not installed.</span><br><span class=\"line\"></span><br><span class=\"line\"> gcc-7 depends on gcc-7-base (= 7.3.0-27ubuntu1~18.04); however:</span><br><span class=\"line\"></span><br><span class=\"line\">  Package gcc-7-base is not installed.</span><br><span class=\"line\"></span><br><span class=\"line\"> gcc-7 depends on libcc1-0 (&gt;= 7.3.0-27ubuntu1~18.04); however:</span><br><span class=\"line\"></span><br><span class=\"line\">  Package libcc1-0 is not installed.</span><br><span class=\"line\"></span><br><span class=\"line\"> gcc-7 depends on binutils (&gt;= 2.30); however:</span><br><span class=\"line\"></span><br><span class=\"line\">  Package binutils is not installed.</span><br><span class=\"line\"></span><br><span class=\"line\"> gcc-7 depends on libgcc-7-dev (= 7.3.0-27ubuntu1~18.04); however:</span><br><span class=\"line\"></span><br><span class=\"line\">  Package libgcc-7-dev is not installed.</span><br><span class=\"line\"></span><br><span class=\"line\"> gcc-7 depends on libisl19 (&gt;= 0.15); however:</span><br><span class=\"line\"></span><br><span class=\"line\">  Package libisl19 is not installed.</span><br><span class=\"line\"></span><br><span class=\"line\"> gcc-7 depends on libmpc3; however:</span><br><span class=\"line\"></span><br><span class=\"line\">  Package libmpc3 is not installed.</span><br><span class=\"line\"></span><br><span class=\"line\"> gcc-7 depends on libmpfr6 (&gt;= 3.1.3); however:</span><br><span class=\"line\"></span><br><span class=\"line\">  Package libmpfr6 is not installed.</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">dpkg: error processing package gcc-7 (--install):</span><br><span class=\"line\"></span><br><span class=\"line\"> dependency problems - leaving unconfigured</span><br><span class=\"line\"></span><br><span class=\"line\">Errors were encountered <span class=\"keyword\">while</span> processing:</span><br><span class=\"line\"></span><br><span class=\"line\"> gcc-7</span><br><span class=\"line\"></span><br><span class=\"line\">root@757d6bfab719:~<span class=\"comment\"># gcc</span></span><br><span class=\"line\"></span><br><span class=\"line\">apt --fix-broken install</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">apt-get upgrade</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">The following packages have unmet dependencies:</span><br><span class=\"line\"></span><br><span class=\"line\"> gcc-7 : Depends: cpp-7 (= 7.3.0-27ubuntu1~18.04) but it is not going to be installed</span><br><span class=\"line\"></span><br><span class=\"line\">         Depends: gcc-7-base (= 7.3.0-27ubuntu1~18.04) but 7.5.0-3ubuntu1~18.04 is to be installed</span><br><span class=\"line\"></span><br><span class=\"line\">         Depends: libgcc-7-dev (= 7.3.0-27ubuntu1~18.04) but 7.5.0-3ubuntu1~18.04 is to be installed</span><br><span class=\"line\"></span><br><span class=\"line\">E: Unmet dependencies. Try <span class=\"string\">&#x27;apt --fix-broken install&#x27;</span> with no packages (or specify a solution).</span><br></pre></td></tr></table></figure>"},{"_content":"在本文中，我们对学习密码中的语言模式进行了细致入微的研究，并使用最新的评估方法更新了语义 PCFG 的性能，以提供更长的猜测会话的结果 [7]。,我们通过部署在高性能计算基础设施上的大参数扫描实验来实现这一点。,在以下部分中，我们报告了比较 PCFG 性能的实验结果 \n\t(a) 使用和不使用语义符号（WordNet 含义和专有名称）进行训练； \n\t(b) 经过不同级别的语义概括训练； \n\t(c) 使用不同大小的密码列表进行训练； \n\t(d) 使用最大似然估计（一种将零概率分配给未见字符串的方法）和概率平滑（将概率质量分配给未见字符串）进行训练 [6]。\n重要的是，我们将三代 PCFG（Weir 等人[23]、Veras 等人[21] 和 Komanduri [12]）与最新的神经网络模型之一（Melicher 等人[16]）进行了比较。\n\n我们的实验设置包括使用 RockYou 列表训练的语法，以及对从 LinkedIn 和 000webhost 泄露的密码进行测试的语法，以及使用相同数据的独立交叉验证设置。,此外，我们使用语言语法来定性研究最近三个密码泄露的模式：000webhost、Comcast 和 Mate1。,我们提出了这些泄漏的高级图形模型，讨论了语法规则的相似性，并进行了交叉泄漏破解实验。\n总之，本文研究了多个参数对 PCFG 和神经网络模型猜测性能的影响，并对最近的密码泄漏进行了基于语法的定性分析。\n\n# 语义 PCFG\n## 文本处理流\n将每个密码分解为令牌（即终端符号）并为其分配语言属性，从而产生形式的元组（令牌、POS、意义）。\n1. 分词： Norvig 的统计算法 [18]，该算法选择具有最高联合概率的分词，其中每个标记的概率使用二元模型计算（来自 Google Web Trillion）词语料库）。\n2. 词性标注是通过退避标注器完成的，该标注器由在布朗语料库和 WordNet 以及其他已知与密码相关的利基命名实体语料库（城市，给定）上训练的一般统计模型（三元组、二元组和一元组）组成。名和姓氏）。请注意，拼写错误（例如，passwrd）和替换（例如，passw0rd）不按词性语法和语义语法进行分类。将来可以添加将拼写错误的单词分类为语义类别的模块\n3. 语义，见下\n\n## 语义模型\n语义模型主要关注单词的意义和语义关系，它利用WordNet等语义资源对单词进行语义标记，以便捕捉密码中的语义规律。\n能够提供更详细的密码结构分析，有助于更好地理解密码样本中的模式和提供更可解释的密码强度建议。\n语义模型在小样本训练和需要解释性较强的情况下显示出更好的猜测性能。\n### 语义\n该词的意义取自 WordNet 语料库 [17]，这是一种语言树结构，其中概念通过代表 IS-A 关系的边连接起来，就像狗 IS-A 动物 IS-A 哺乳动物 IS-A 生物一样。每个被词性标注器标注为名词或动词的字母字符串都会收到一个 WordNet 意义键形式的语义标签。单词可能有多种含义，因此我们选择 WordNet 频率最高的含义。\n为了使词义具有泛化能力，需要建立映射，以便将低级词义分组为更广泛的类别。这可以通过选择由一组抽象类（内部树节点）组成的树切割来完成，每个抽象类代表其所有后代。因此，如果“运动”类是树木砍伐成员，则任何出现“棒球”的情况。都将在训练的语法中被标记为“sport”。这种映射具有扩大语法推理范围的效果，因为通过抽象类间接提高了未见过单词的概率。\n在实践中，包含数据中频率相似的词义的 WordNet 子树往往会比包含异常值的子树映射到更抽象的含义。请注意，高频词更有可能映射到特定类别，通常意味着根本没有抽象（例如，love → love.n.01）。\n## 词性模型\n关注单词的语法属性，比如名词、动词、形容词等，它利用词性标记器对单词进行词性标记，以便捕捉密码中的语法规律。\n词性模型则更适合在短时间内进行密码猜测，因为它能够更灵活地捕捉密码中的语法规律，尤其在初始猜测阶段表现更好。\n\n\n## 终端平滑\n\n 在 Weir 等人的 PCFG 和语义 PCF G 中，终端概率是通过最大似然（ML）来估计的。\n在机器学习中，选择模型的参数是为了最大化给定模型的数据的概率；因此，不会将概率质量分配给看不见的字符串。从理论上讲，这会影响小样本的学习，\n语义泛化的有效性取决于终端概率平滑。终端平滑需要两个决定：将哪些词汇添加到语法中以及如何为其分配概率。\n1. Wordnet 涵盖了大量单词。我们称之为先验词汇，由以各种方式变形的每个 Wordnet 引理组成：名词以单数和复数形式出现，动词以所有词形变化形式出现。根据可用资源，可以通过分配给语义类别的附加单词列表来丰富先验词汇表（类似于我们处理名称的方式）。\n2. 除了先验终端之外，后验词汇表还包括数据中观察到的每个终端。给定非终结符号的终结串为 θˆ i = xi + α N + αd ，\n\t1.  (1) 其中 xi 是观测频率；\n\t2. N 是非终结符号下观测频率之和；\n\t3. α 称为伪计数，可以被解释为假定先验观察字符串的次数（当 α = 0 时，默认为 ML）；\n\t4. d 是给定非终结符的词汇大小。\n\t该估计器 ( ˆθi ) 称为加性平滑或拉普拉斯平滑，当假设先验一致时，它相当于贝叶斯估计量 [15]。当词汇量非常大时，加法平滑可能不准确，就像三元组一样，在这种情况下，更复杂的估计量更合适，比如 Good -Komanduri 使用图灵估计器来训练 PCFG [12]。由于我们的词汇量约为数十万，拉普拉斯估计器就足够了，并且实现更简单。\n##### 蒙特卡罗强度估计器\n是一种用于测量密码破解成功率的方法。它通过计算测试集中每个语法的密码的概率，然后估计猜测次数。具体来说，猜测次数指的是在尝试所有语法中概率最高的密码之前需要尝试的次数。蒙特卡罗估计器允许我们在无限长度的会话中测量成功率，而无需进行大量的猜测枚举，这在计算上是非常昂贵的。因此，蒙特卡罗强度估计器是一种用于评估密码破解成功率的有效方法。\n## 基于语义信息，各个数据集之间的关系？\n\n基于语义信息，RockYou、Comcast、Mate1和000webhost泄露的密码列表之间存在一些相似之处。研究发现，RockYou和Mate1泄露的密码具有很大的语义和结构重叠，表明这两个泄露数据具有相似的语义模式。而在000webhost密码列表中，密码具有明显的统一结构，但在语义上却缺乏一致性，至少在英语语言语法中如此。此外，Comcast密码列表中出现了许多包含类别\"worker\"和\"hacker\"的模式，还有包含类别\"defender\"和\"windows\"的模式，以及服务名称本身的模式。这些发现揭示了密码泄露的语义偏好与服务的人口统计和主题之间的关联，以及密码政策对所选密码结构的影响。\n\n\n\n\n（a）LinkedIn 密码缺乏强英语语义依赖性； (b) LinkedIn 具有较强的英语语义依赖性，但与 RockYou 中的不同； (c) 英文密码一般缺乏强语义依赖性。\n\n\n\n# 总结\n这篇文章主要研究了语义密码模型和密码中的语言模式，通过对不同语言模型的大规模分析，比如PCFG和神经网络模型，以及对RockYou，LinkedIn，Mate1，Comcast和000webhost等密码泄露数据进行定性分析和比较。研究发现，PCFG在猜测非随机密码方面表现出色，尤其是在小样本训练集上。此外，语义模型在特定情况下表现出更好的猜测性能。在对不同密码列表的语言模式进行比较时，研究发现了一些有趣的区别，比如Mate1和RockYou泄露数据中共享的语义模式。总的来说，这项研究提供了关于密码模型和语言模式的深入见解，特别是在不同类型的密码列表中的比较分析。\n\n\n1. 重点是语义密码模型的参数，这是一个用词性和语义信息训练的 PCFG。\n2. 未经概率平滑训练的语法往往会过度拟合，平滑可以为用小样本训练的 PCFG 提供强大的能力：仅用 1,000 个 RockYou 密码训练的语法就能够猜测近 500 万个 000webhost 密码，训练样本大小增加到超过 1000 万个密码时，收益递减。\n3. 分离了有语义和没有语义的 POS 的影响，发现向语法中添加语义信息的好处与添加 POS 信息带来的收益相比很小，并且取决于训练数据的大小。（维拉斯等人。证明具有语义和词性信息的语法在很大程度上优于 Weir 等人的语法。）\n4. 发现 Komanduri PCFG 比其他测试的 PCFG 具有更好的猜测能力，并且存在 Melicher 等人的神经模型的情况。比我们测试的 PCFG 的猜测能力更差。\n5. 利用语义模型的解释能力来定性检查最近的密码泄露事件\n\t1. RockYou 和 Mate1 泄露事件在语义和结构上有很大的重叠，\n\t2. 而 000webhost 密码具有非常统一的结构，但语义统一性很小，至少从英语语法来看是这样。","source":"_posts/论文笔记/语义密码模型和密码语言模式分析.md","raw":"在本文中，我们对学习密码中的语言模式进行了细致入微的研究，并使用最新的评估方法更新了语义 PCFG 的性能，以提供更长的猜测会话的结果 [7]。,我们通过部署在高性能计算基础设施上的大参数扫描实验来实现这一点。,在以下部分中，我们报告了比较 PCFG 性能的实验结果 \n\t(a) 使用和不使用语义符号（WordNet 含义和专有名称）进行训练； \n\t(b) 经过不同级别的语义概括训练； \n\t(c) 使用不同大小的密码列表进行训练； \n\t(d) 使用最大似然估计（一种将零概率分配给未见字符串的方法）和概率平滑（将概率质量分配给未见字符串）进行训练 [6]。\n重要的是，我们将三代 PCFG（Weir 等人[23]、Veras 等人[21] 和 Komanduri [12]）与最新的神经网络模型之一（Melicher 等人[16]）进行了比较。\n\n我们的实验设置包括使用 RockYou 列表训练的语法，以及对从 LinkedIn 和 000webhost 泄露的密码进行测试的语法，以及使用相同数据的独立交叉验证设置。,此外，我们使用语言语法来定性研究最近三个密码泄露的模式：000webhost、Comcast 和 Mate1。,我们提出了这些泄漏的高级图形模型，讨论了语法规则的相似性，并进行了交叉泄漏破解实验。\n总之，本文研究了多个参数对 PCFG 和神经网络模型猜测性能的影响，并对最近的密码泄漏进行了基于语法的定性分析。\n\n# 语义 PCFG\n## 文本处理流\n将每个密码分解为令牌（即终端符号）并为其分配语言属性，从而产生形式的元组（令牌、POS、意义）。\n1. 分词： Norvig 的统计算法 [18]，该算法选择具有最高联合概率的分词，其中每个标记的概率使用二元模型计算（来自 Google Web Trillion）词语料库）。\n2. 词性标注是通过退避标注器完成的，该标注器由在布朗语料库和 WordNet 以及其他已知与密码相关的利基命名实体语料库（城市，给定）上训练的一般统计模型（三元组、二元组和一元组）组成。名和姓氏）。请注意，拼写错误（例如，passwrd）和替换（例如，passw0rd）不按词性语法和语义语法进行分类。将来可以添加将拼写错误的单词分类为语义类别的模块\n3. 语义，见下\n\n## 语义模型\n语义模型主要关注单词的意义和语义关系，它利用WordNet等语义资源对单词进行语义标记，以便捕捉密码中的语义规律。\n能够提供更详细的密码结构分析，有助于更好地理解密码样本中的模式和提供更可解释的密码强度建议。\n语义模型在小样本训练和需要解释性较强的情况下显示出更好的猜测性能。\n### 语义\n该词的意义取自 WordNet 语料库 [17]，这是一种语言树结构，其中概念通过代表 IS-A 关系的边连接起来，就像狗 IS-A 动物 IS-A 哺乳动物 IS-A 生物一样。每个被词性标注器标注为名词或动词的字母字符串都会收到一个 WordNet 意义键形式的语义标签。单词可能有多种含义，因此我们选择 WordNet 频率最高的含义。\n为了使词义具有泛化能力，需要建立映射，以便将低级词义分组为更广泛的类别。这可以通过选择由一组抽象类（内部树节点）组成的树切割来完成，每个抽象类代表其所有后代。因此，如果“运动”类是树木砍伐成员，则任何出现“棒球”的情况。都将在训练的语法中被标记为“sport”。这种映射具有扩大语法推理范围的效果，因为通过抽象类间接提高了未见过单词的概率。\n在实践中，包含数据中频率相似的词义的 WordNet 子树往往会比包含异常值的子树映射到更抽象的含义。请注意，高频词更有可能映射到特定类别，通常意味着根本没有抽象（例如，love → love.n.01）。\n## 词性模型\n关注单词的语法属性，比如名词、动词、形容词等，它利用词性标记器对单词进行词性标记，以便捕捉密码中的语法规律。\n词性模型则更适合在短时间内进行密码猜测，因为它能够更灵活地捕捉密码中的语法规律，尤其在初始猜测阶段表现更好。\n\n\n## 终端平滑\n\n 在 Weir 等人的 PCFG 和语义 PCF G 中，终端概率是通过最大似然（ML）来估计的。\n在机器学习中，选择模型的参数是为了最大化给定模型的数据的概率；因此，不会将概率质量分配给看不见的字符串。从理论上讲，这会影响小样本的学习，\n语义泛化的有效性取决于终端概率平滑。终端平滑需要两个决定：将哪些词汇添加到语法中以及如何为其分配概率。\n1. Wordnet 涵盖了大量单词。我们称之为先验词汇，由以各种方式变形的每个 Wordnet 引理组成：名词以单数和复数形式出现，动词以所有词形变化形式出现。根据可用资源，可以通过分配给语义类别的附加单词列表来丰富先验词汇表（类似于我们处理名称的方式）。\n2. 除了先验终端之外，后验词汇表还包括数据中观察到的每个终端。给定非终结符号的终结串为 θˆ i = xi + α N + αd ，\n\t1.  (1) 其中 xi 是观测频率；\n\t2. N 是非终结符号下观测频率之和；\n\t3. α 称为伪计数，可以被解释为假定先验观察字符串的次数（当 α = 0 时，默认为 ML）；\n\t4. d 是给定非终结符的词汇大小。\n\t该估计器 ( ˆθi ) 称为加性平滑或拉普拉斯平滑，当假设先验一致时，它相当于贝叶斯估计量 [15]。当词汇量非常大时，加法平滑可能不准确，就像三元组一样，在这种情况下，更复杂的估计量更合适，比如 Good -Komanduri 使用图灵估计器来训练 PCFG [12]。由于我们的词汇量约为数十万，拉普拉斯估计器就足够了，并且实现更简单。\n##### 蒙特卡罗强度估计器\n是一种用于测量密码破解成功率的方法。它通过计算测试集中每个语法的密码的概率，然后估计猜测次数。具体来说，猜测次数指的是在尝试所有语法中概率最高的密码之前需要尝试的次数。蒙特卡罗估计器允许我们在无限长度的会话中测量成功率，而无需进行大量的猜测枚举，这在计算上是非常昂贵的。因此，蒙特卡罗强度估计器是一种用于评估密码破解成功率的有效方法。\n## 基于语义信息，各个数据集之间的关系？\n\n基于语义信息，RockYou、Comcast、Mate1和000webhost泄露的密码列表之间存在一些相似之处。研究发现，RockYou和Mate1泄露的密码具有很大的语义和结构重叠，表明这两个泄露数据具有相似的语义模式。而在000webhost密码列表中，密码具有明显的统一结构，但在语义上却缺乏一致性，至少在英语语言语法中如此。此外，Comcast密码列表中出现了许多包含类别\"worker\"和\"hacker\"的模式，还有包含类别\"defender\"和\"windows\"的模式，以及服务名称本身的模式。这些发现揭示了密码泄露的语义偏好与服务的人口统计和主题之间的关联，以及密码政策对所选密码结构的影响。\n\n\n\n\n（a）LinkedIn 密码缺乏强英语语义依赖性； (b) LinkedIn 具有较强的英语语义依赖性，但与 RockYou 中的不同； (c) 英文密码一般缺乏强语义依赖性。\n\n\n\n# 总结\n这篇文章主要研究了语义密码模型和密码中的语言模式，通过对不同语言模型的大规模分析，比如PCFG和神经网络模型，以及对RockYou，LinkedIn，Mate1，Comcast和000webhost等密码泄露数据进行定性分析和比较。研究发现，PCFG在猜测非随机密码方面表现出色，尤其是在小样本训练集上。此外，语义模型在特定情况下表现出更好的猜测性能。在对不同密码列表的语言模式进行比较时，研究发现了一些有趣的区别，比如Mate1和RockYou泄露数据中共享的语义模式。总的来说，这项研究提供了关于密码模型和语言模式的深入见解，特别是在不同类型的密码列表中的比较分析。\n\n\n1. 重点是语义密码模型的参数，这是一个用词性和语义信息训练的 PCFG。\n2. 未经概率平滑训练的语法往往会过度拟合，平滑可以为用小样本训练的 PCFG 提供强大的能力：仅用 1,000 个 RockYou 密码训练的语法就能够猜测近 500 万个 000webhost 密码，训练样本大小增加到超过 1000 万个密码时，收益递减。\n3. 分离了有语义和没有语义的 POS 的影响，发现向语法中添加语义信息的好处与添加 POS 信息带来的收益相比很小，并且取决于训练数据的大小。（维拉斯等人。证明具有语义和词性信息的语法在很大程度上优于 Weir 等人的语法。）\n4. 发现 Komanduri PCFG 比其他测试的 PCFG 具有更好的猜测能力，并且存在 Melicher 等人的神经模型的情况。比我们测试的 PCFG 的猜测能力更差。\n5. 利用语义模型的解释能力来定性检查最近的密码泄露事件\n\t1. RockYou 和 Mate1 泄露事件在语义和结构上有很大的重叠，\n\t2. 而 000webhost 密码具有非常统一的结构，但语义统一性很小，至少从英语语法来看是这样。","slug":"论文笔记/语义密码模型和密码语言模式分析","published":1,"date":"2024-04-22T13:14:48.920Z","updated":"2024-04-11T08:53:01.317Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0m001wkgg49jxu4cqs","content":"<p>在本文中，我们对学习密码中的语言模式进行了细致入微的研究，并使用最新的评估方法更新了语义 PCFG 的性能，以提供更长的猜测会话的结果 [7]。,我们通过部署在高性能计算基础设施上的大参数扫描实验来实现这一点。,在以下部分中，我们报告了比较 PCFG 性能的实验结果<br>    (a) 使用和不使用语义符号（WordNet 含义和专有名称）进行训练；<br>    (b) 经过不同级别的语义概括训练；<br>    (c) 使用不同大小的密码列表进行训练；<br>    (d) 使用最大似然估计（一种将零概率分配给未见字符串的方法）和概率平滑（将概率质量分配给未见字符串）进行训练 [6]。<br>重要的是，我们将三代 PCFG（Weir 等人[23]、Veras 等人[21] 和 Komanduri [12]）与最新的神经网络模型之一（Melicher 等人[16]）进行了比较。</p>\n<p>我们的实验设置包括使用 RockYou 列表训练的语法，以及对从 LinkedIn 和 000webhost 泄露的密码进行测试的语法，以及使用相同数据的独立交叉验证设置。,此外，我们使用语言语法来定性研究最近三个密码泄露的模式：000webhost、Comcast 和 Mate1。,我们提出了这些泄漏的高级图形模型，讨论了语法规则的相似性，并进行了交叉泄漏破解实验。<br>总之，本文研究了多个参数对 PCFG 和神经网络模型猜测性能的影响，并对最近的密码泄漏进行了基于语法的定性分析。</p>\n<h1 id=\"语义-PCFG\"><a href=\"#语义-PCFG\" class=\"headerlink\" title=\"语义 PCFG\"></a>语义 PCFG</h1><h2 id=\"文本处理流\"><a href=\"#文本处理流\" class=\"headerlink\" title=\"文本处理流\"></a>文本处理流</h2><p>将每个密码分解为令牌（即终端符号）并为其分配语言属性，从而产生形式的元组（令牌、POS、意义）。</p>\n<ol>\n<li>分词： Norvig 的统计算法 [18]，该算法选择具有最高联合概率的分词，其中每个标记的概率使用二元模型计算（来自 Google Web Trillion）词语料库）。</li>\n<li>词性标注是通过退避标注器完成的，该标注器由在布朗语料库和 WordNet 以及其他已知与密码相关的利基命名实体语料库（城市，给定）上训练的一般统计模型（三元组、二元组和一元组）组成。名和姓氏）。请注意，拼写错误（例如，passwrd）和替换（例如，passw0rd）不按词性语法和语义语法进行分类。将来可以添加将拼写错误的单词分类为语义类别的模块</li>\n<li>语义，见下</li>\n</ol>\n<h2 id=\"语义模型\"><a href=\"#语义模型\" class=\"headerlink\" title=\"语义模型\"></a>语义模型</h2><p>语义模型主要关注单词的意义和语义关系，它利用WordNet等语义资源对单词进行语义标记，以便捕捉密码中的语义规律。<br>能够提供更详细的密码结构分析，有助于更好地理解密码样本中的模式和提供更可解释的密码强度建议。<br>语义模型在小样本训练和需要解释性较强的情况下显示出更好的猜测性能。</p>\n<h3 id=\"语义\"><a href=\"#语义\" class=\"headerlink\" title=\"语义\"></a>语义</h3><p>该词的意义取自 WordNet 语料库 [17]，这是一种语言树结构，其中概念通过代表 IS-A 关系的边连接起来，就像狗 IS-A 动物 IS-A 哺乳动物 IS-A 生物一样。每个被词性标注器标注为名词或动词的字母字符串都会收到一个 WordNet 意义键形式的语义标签。单词可能有多种含义，因此我们选择 WordNet 频率最高的含义。<br>为了使词义具有泛化能力，需要建立映射，以便将低级词义分组为更广泛的类别。这可以通过选择由一组抽象类（内部树节点）组成的树切割来完成，每个抽象类代表其所有后代。因此，如果“运动”类是树木砍伐成员，则任何出现“棒球”的情况。都将在训练的语法中被标记为“sport”。这种映射具有扩大语法推理范围的效果，因为通过抽象类间接提高了未见过单词的概率。<br>在实践中，包含数据中频率相似的词义的 WordNet 子树往往会比包含异常值的子树映射到更抽象的含义。请注意，高频词更有可能映射到特定类别，通常意味着根本没有抽象（例如，love → love.n.01）。</p>\n<h2 id=\"词性模型\"><a href=\"#词性模型\" class=\"headerlink\" title=\"词性模型\"></a>词性模型</h2><p>关注单词的语法属性，比如名词、动词、形容词等，它利用词性标记器对单词进行词性标记，以便捕捉密码中的语法规律。<br>词性模型则更适合在短时间内进行密码猜测，因为它能够更灵活地捕捉密码中的语法规律，尤其在初始猜测阶段表现更好。</p>\n<h2 id=\"终端平滑\"><a href=\"#终端平滑\" class=\"headerlink\" title=\"终端平滑\"></a>终端平滑</h2><p> 在 Weir 等人的 PCFG 和语义 PCF G 中，终端概率是通过最大似然（ML）来估计的。<br>在机器学习中，选择模型的参数是为了最大化给定模型的数据的概率；因此，不会将概率质量分配给看不见的字符串。从理论上讲，这会影响小样本的学习，<br>语义泛化的有效性取决于终端概率平滑。终端平滑需要两个决定：将哪些词汇添加到语法中以及如何为其分配概率。</p>\n<ol>\n<li>Wordnet 涵盖了大量单词。我们称之为先验词汇，由以各种方式变形的每个 Wordnet 引理组成：名词以单数和复数形式出现，动词以所有词形变化形式出现。根据可用资源，可以通过分配给语义类别的附加单词列表来丰富先验词汇表（类似于我们处理名称的方式）。</li>\n<li>除了先验终端之外，后验词汇表还包括数据中观察到的每个终端。给定非终结符号的终结串为 θˆ i &#x3D; xi + α N + αd ，<ol>\n<li> (1) 其中 xi 是观测频率；</li>\n<li>N 是非终结符号下观测频率之和；</li>\n<li>α 称为伪计数，可以被解释为假定先验观察字符串的次数（当 α &#x3D; 0 时，默认为 ML）；</li>\n<li>d 是给定非终结符的词汇大小。<br> 该估计器 ( ˆθi ) 称为加性平滑或拉普拉斯平滑，当假设先验一致时，它相当于贝叶斯估计量 [15]。当词汇量非常大时，加法平滑可能不准确，就像三元组一样，在这种情况下，更复杂的估计量更合适，比如 Good -Komanduri 使用图灵估计器来训练 PCFG [12]。由于我们的词汇量约为数十万，拉普拉斯估计器就足够了，并且实现更简单。</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"蒙特卡罗强度估计器\"><a href=\"#蒙特卡罗强度估计器\" class=\"headerlink\" title=\"蒙特卡罗强度估计器\"></a>蒙特卡罗强度估计器</h5><p>是一种用于测量密码破解成功率的方法。它通过计算测试集中每个语法的密码的概率，然后估计猜测次数。具体来说，猜测次数指的是在尝试所有语法中概率最高的密码之前需要尝试的次数。蒙特卡罗估计器允许我们在无限长度的会话中测量成功率，而无需进行大量的猜测枚举，这在计算上是非常昂贵的。因此，蒙特卡罗强度估计器是一种用于评估密码破解成功率的有效方法。</p>\n<h2 id=\"基于语义信息，各个数据集之间的关系？\"><a href=\"#基于语义信息，各个数据集之间的关系？\" class=\"headerlink\" title=\"基于语义信息，各个数据集之间的关系？\"></a>基于语义信息，各个数据集之间的关系？</h2><p>基于语义信息，RockYou、Comcast、Mate1和000webhost泄露的密码列表之间存在一些相似之处。研究发现，RockYou和Mate1泄露的密码具有很大的语义和结构重叠，表明这两个泄露数据具有相似的语义模式。而在000webhost密码列表中，密码具有明显的统一结构，但在语义上却缺乏一致性，至少在英语语言语法中如此。此外，Comcast密码列表中出现了许多包含类别”worker”和”hacker”的模式，还有包含类别”defender”和”windows”的模式，以及服务名称本身的模式。这些发现揭示了密码泄露的语义偏好与服务的人口统计和主题之间的关联，以及密码政策对所选密码结构的影响。</p>\n<p>（a）LinkedIn 密码缺乏强英语语义依赖性； (b) LinkedIn 具有较强的英语语义依赖性，但与 RockYou 中的不同； (c) 英文密码一般缺乏强语义依赖性。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>这篇文章主要研究了语义密码模型和密码中的语言模式，通过对不同语言模型的大规模分析，比如PCFG和神经网络模型，以及对RockYou，LinkedIn，Mate1，Comcast和000webhost等密码泄露数据进行定性分析和比较。研究发现，PCFG在猜测非随机密码方面表现出色，尤其是在小样本训练集上。此外，语义模型在特定情况下表现出更好的猜测性能。在对不同密码列表的语言模式进行比较时，研究发现了一些有趣的区别，比如Mate1和RockYou泄露数据中共享的语义模式。总的来说，这项研究提供了关于密码模型和语言模式的深入见解，特别是在不同类型的密码列表中的比较分析。</p>\n<ol>\n<li>重点是语义密码模型的参数，这是一个用词性和语义信息训练的 PCFG。</li>\n<li>未经概率平滑训练的语法往往会过度拟合，平滑可以为用小样本训练的 PCFG 提供强大的能力：仅用 1,000 个 RockYou 密码训练的语法就能够猜测近 500 万个 000webhost 密码，训练样本大小增加到超过 1000 万个密码时，收益递减。</li>\n<li>分离了有语义和没有语义的 POS 的影响，发现向语法中添加语义信息的好处与添加 POS 信息带来的收益相比很小，并且取决于训练数据的大小。（维拉斯等人。证明具有语义和词性信息的语法在很大程度上优于 Weir 等人的语法。）</li>\n<li>发现 Komanduri PCFG 比其他测试的 PCFG 具有更好的猜测能力，并且存在 Melicher 等人的神经模型的情况。比我们测试的 PCFG 的猜测能力更差。</li>\n<li>利用语义模型的解释能力来定性检查最近的密码泄露事件<ol>\n<li>RockYou 和 Mate1 泄露事件在语义和结构上有很大的重叠，</li>\n<li>而 000webhost 密码具有非常统一的结构，但语义统一性很小，至少从英语语法来看是这样。</li>\n</ol>\n</li>\n</ol>\n","excerpt":"","more":"<p>在本文中，我们对学习密码中的语言模式进行了细致入微的研究，并使用最新的评估方法更新了语义 PCFG 的性能，以提供更长的猜测会话的结果 [7]。,我们通过部署在高性能计算基础设施上的大参数扫描实验来实现这一点。,在以下部分中，我们报告了比较 PCFG 性能的实验结果<br>    (a) 使用和不使用语义符号（WordNet 含义和专有名称）进行训练；<br>    (b) 经过不同级别的语义概括训练；<br>    (c) 使用不同大小的密码列表进行训练；<br>    (d) 使用最大似然估计（一种将零概率分配给未见字符串的方法）和概率平滑（将概率质量分配给未见字符串）进行训练 [6]。<br>重要的是，我们将三代 PCFG（Weir 等人[23]、Veras 等人[21] 和 Komanduri [12]）与最新的神经网络模型之一（Melicher 等人[16]）进行了比较。</p>\n<p>我们的实验设置包括使用 RockYou 列表训练的语法，以及对从 LinkedIn 和 000webhost 泄露的密码进行测试的语法，以及使用相同数据的独立交叉验证设置。,此外，我们使用语言语法来定性研究最近三个密码泄露的模式：000webhost、Comcast 和 Mate1。,我们提出了这些泄漏的高级图形模型，讨论了语法规则的相似性，并进行了交叉泄漏破解实验。<br>总之，本文研究了多个参数对 PCFG 和神经网络模型猜测性能的影响，并对最近的密码泄漏进行了基于语法的定性分析。</p>\n<h1 id=\"语义-PCFG\"><a href=\"#语义-PCFG\" class=\"headerlink\" title=\"语义 PCFG\"></a>语义 PCFG</h1><h2 id=\"文本处理流\"><a href=\"#文本处理流\" class=\"headerlink\" title=\"文本处理流\"></a>文本处理流</h2><p>将每个密码分解为令牌（即终端符号）并为其分配语言属性，从而产生形式的元组（令牌、POS、意义）。</p>\n<ol>\n<li>分词： Norvig 的统计算法 [18]，该算法选择具有最高联合概率的分词，其中每个标记的概率使用二元模型计算（来自 Google Web Trillion）词语料库）。</li>\n<li>词性标注是通过退避标注器完成的，该标注器由在布朗语料库和 WordNet 以及其他已知与密码相关的利基命名实体语料库（城市，给定）上训练的一般统计模型（三元组、二元组和一元组）组成。名和姓氏）。请注意，拼写错误（例如，passwrd）和替换（例如，passw0rd）不按词性语法和语义语法进行分类。将来可以添加将拼写错误的单词分类为语义类别的模块</li>\n<li>语义，见下</li>\n</ol>\n<h2 id=\"语义模型\"><a href=\"#语义模型\" class=\"headerlink\" title=\"语义模型\"></a>语义模型</h2><p>语义模型主要关注单词的意义和语义关系，它利用WordNet等语义资源对单词进行语义标记，以便捕捉密码中的语义规律。<br>能够提供更详细的密码结构分析，有助于更好地理解密码样本中的模式和提供更可解释的密码强度建议。<br>语义模型在小样本训练和需要解释性较强的情况下显示出更好的猜测性能。</p>\n<h3 id=\"语义\"><a href=\"#语义\" class=\"headerlink\" title=\"语义\"></a>语义</h3><p>该词的意义取自 WordNet 语料库 [17]，这是一种语言树结构，其中概念通过代表 IS-A 关系的边连接起来，就像狗 IS-A 动物 IS-A 哺乳动物 IS-A 生物一样。每个被词性标注器标注为名词或动词的字母字符串都会收到一个 WordNet 意义键形式的语义标签。单词可能有多种含义，因此我们选择 WordNet 频率最高的含义。<br>为了使词义具有泛化能力，需要建立映射，以便将低级词义分组为更广泛的类别。这可以通过选择由一组抽象类（内部树节点）组成的树切割来完成，每个抽象类代表其所有后代。因此，如果“运动”类是树木砍伐成员，则任何出现“棒球”的情况。都将在训练的语法中被标记为“sport”。这种映射具有扩大语法推理范围的效果，因为通过抽象类间接提高了未见过单词的概率。<br>在实践中，包含数据中频率相似的词义的 WordNet 子树往往会比包含异常值的子树映射到更抽象的含义。请注意，高频词更有可能映射到特定类别，通常意味着根本没有抽象（例如，love → love.n.01）。</p>\n<h2 id=\"词性模型\"><a href=\"#词性模型\" class=\"headerlink\" title=\"词性模型\"></a>词性模型</h2><p>关注单词的语法属性，比如名词、动词、形容词等，它利用词性标记器对单词进行词性标记，以便捕捉密码中的语法规律。<br>词性模型则更适合在短时间内进行密码猜测，因为它能够更灵活地捕捉密码中的语法规律，尤其在初始猜测阶段表现更好。</p>\n<h2 id=\"终端平滑\"><a href=\"#终端平滑\" class=\"headerlink\" title=\"终端平滑\"></a>终端平滑</h2><p> 在 Weir 等人的 PCFG 和语义 PCF G 中，终端概率是通过最大似然（ML）来估计的。<br>在机器学习中，选择模型的参数是为了最大化给定模型的数据的概率；因此，不会将概率质量分配给看不见的字符串。从理论上讲，这会影响小样本的学习，<br>语义泛化的有效性取决于终端概率平滑。终端平滑需要两个决定：将哪些词汇添加到语法中以及如何为其分配概率。</p>\n<ol>\n<li>Wordnet 涵盖了大量单词。我们称之为先验词汇，由以各种方式变形的每个 Wordnet 引理组成：名词以单数和复数形式出现，动词以所有词形变化形式出现。根据可用资源，可以通过分配给语义类别的附加单词列表来丰富先验词汇表（类似于我们处理名称的方式）。</li>\n<li>除了先验终端之外，后验词汇表还包括数据中观察到的每个终端。给定非终结符号的终结串为 θˆ i &#x3D; xi + α N + αd ，<ol>\n<li> (1) 其中 xi 是观测频率；</li>\n<li>N 是非终结符号下观测频率之和；</li>\n<li>α 称为伪计数，可以被解释为假定先验观察字符串的次数（当 α &#x3D; 0 时，默认为 ML）；</li>\n<li>d 是给定非终结符的词汇大小。<br> 该估计器 ( ˆθi ) 称为加性平滑或拉普拉斯平滑，当假设先验一致时，它相当于贝叶斯估计量 [15]。当词汇量非常大时，加法平滑可能不准确，就像三元组一样，在这种情况下，更复杂的估计量更合适，比如 Good -Komanduri 使用图灵估计器来训练 PCFG [12]。由于我们的词汇量约为数十万，拉普拉斯估计器就足够了，并且实现更简单。</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"蒙特卡罗强度估计器\"><a href=\"#蒙特卡罗强度估计器\" class=\"headerlink\" title=\"蒙特卡罗强度估计器\"></a>蒙特卡罗强度估计器</h5><p>是一种用于测量密码破解成功率的方法。它通过计算测试集中每个语法的密码的概率，然后估计猜测次数。具体来说，猜测次数指的是在尝试所有语法中概率最高的密码之前需要尝试的次数。蒙特卡罗估计器允许我们在无限长度的会话中测量成功率，而无需进行大量的猜测枚举，这在计算上是非常昂贵的。因此，蒙特卡罗强度估计器是一种用于评估密码破解成功率的有效方法。</p>\n<h2 id=\"基于语义信息，各个数据集之间的关系？\"><a href=\"#基于语义信息，各个数据集之间的关系？\" class=\"headerlink\" title=\"基于语义信息，各个数据集之间的关系？\"></a>基于语义信息，各个数据集之间的关系？</h2><p>基于语义信息，RockYou、Comcast、Mate1和000webhost泄露的密码列表之间存在一些相似之处。研究发现，RockYou和Mate1泄露的密码具有很大的语义和结构重叠，表明这两个泄露数据具有相似的语义模式。而在000webhost密码列表中，密码具有明显的统一结构，但在语义上却缺乏一致性，至少在英语语言语法中如此。此外，Comcast密码列表中出现了许多包含类别”worker”和”hacker”的模式，还有包含类别”defender”和”windows”的模式，以及服务名称本身的模式。这些发现揭示了密码泄露的语义偏好与服务的人口统计和主题之间的关联，以及密码政策对所选密码结构的影响。</p>\n<p>（a）LinkedIn 密码缺乏强英语语义依赖性； (b) LinkedIn 具有较强的英语语义依赖性，但与 RockYou 中的不同； (c) 英文密码一般缺乏强语义依赖性。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>这篇文章主要研究了语义密码模型和密码中的语言模式，通过对不同语言模型的大规模分析，比如PCFG和神经网络模型，以及对RockYou，LinkedIn，Mate1，Comcast和000webhost等密码泄露数据进行定性分析和比较。研究发现，PCFG在猜测非随机密码方面表现出色，尤其是在小样本训练集上。此外，语义模型在特定情况下表现出更好的猜测性能。在对不同密码列表的语言模式进行比较时，研究发现了一些有趣的区别，比如Mate1和RockYou泄露数据中共享的语义模式。总的来说，这项研究提供了关于密码模型和语言模式的深入见解，特别是在不同类型的密码列表中的比较分析。</p>\n<ol>\n<li>重点是语义密码模型的参数，这是一个用词性和语义信息训练的 PCFG。</li>\n<li>未经概率平滑训练的语法往往会过度拟合，平滑可以为用小样本训练的 PCFG 提供强大的能力：仅用 1,000 个 RockYou 密码训练的语法就能够猜测近 500 万个 000webhost 密码，训练样本大小增加到超过 1000 万个密码时，收益递减。</li>\n<li>分离了有语义和没有语义的 POS 的影响，发现向语法中添加语义信息的好处与添加 POS 信息带来的收益相比很小，并且取决于训练数据的大小。（维拉斯等人。证明具有语义和词性信息的语法在很大程度上优于 Weir 等人的语法。）</li>\n<li>发现 Komanduri PCFG 比其他测试的 PCFG 具有更好的猜测能力，并且存在 Melicher 等人的神经模型的情况。比我们测试的 PCFG 的猜测能力更差。</li>\n<li>利用语义模型的解释能力来定性检查最近的密码泄露事件<ol>\n<li>RockYou 和 Mate1 泄露事件在语义和结构上有很大的重叠，</li>\n<li>而 000webhost 密码具有非常统一的结构，但语义统一性很小，至少从英语语法来看是这样。</li>\n</ol>\n</li>\n</ol>\n"},{"_content":"\n6月开始，到12月","source":"_posts/赛事活动/百度之星程序设计大赛.md","raw":"\n6月开始，到12月","slug":"赛事活动/百度之星程序设计大赛","published":1,"date":"2024-04-22T13:14:49.124Z","updated":"2024-04-18T07:24:08.639Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0m001xkgg45qz17686","content":"<p>6月开始，到12月</p>\n","excerpt":"","more":"<p>6月开始，到12月</p>\n"},{"_content":"\n\n[[华为软件精英挑战赛]]\n每年 三月份\n\n\n[[Google Code Jam]]\n已停办\n\n[[ICPC 国际大学生程序设计竞赛]]\n可以尝试，且大概五月多才开始，可以提前准备。到那时\n本科入学五年内。但是，主要还是大学生\n\n\n\n[[CCPC 中国大学生网络预选赛]]\n研究生不能参加最终决赛。算了，但是可以参考题目。\n\n\n[[蓝桥杯]]\n可以 大概 4月份。报名 截至三月份\n\n[[中兴捧月]]\n4月初 报名","source":"_posts/赛事活动/啊 比赛汇总.md","raw":"\n\n[[华为软件精英挑战赛]]\n每年 三月份\n\n\n[[Google Code Jam]]\n已停办\n\n[[ICPC 国际大学生程序设计竞赛]]\n可以尝试，且大概五月多才开始，可以提前准备。到那时\n本科入学五年内。但是，主要还是大学生\n\n\n\n[[CCPC 中国大学生网络预选赛]]\n研究生不能参加最终决赛。算了，但是可以参考题目。\n\n\n[[蓝桥杯]]\n可以 大概 4月份。报名 截至三月份\n\n[[中兴捧月]]\n4月初 报名","slug":"赛事活动/啊 比赛汇总","published":1,"date":"2024-04-22T13:14:49.123Z","updated":"2024-04-18T07:45:43.471Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0m001ykgg4103r3p38","content":"<p>[[华为软件精英挑战赛]]<br>每年 三月份</p>\n<p>[[Google Code Jam]]<br>已停办</p>\n<p>[[ICPC 国际大学生程序设计竞赛]]<br>可以尝试，且大概五月多才开始，可以提前准备。到那时<br>本科入学五年内。但是，主要还是大学生</p>\n<p>[[CCPC 中国大学生网络预选赛]]<br>研究生不能参加最终决赛。算了，但是可以参考题目。</p>\n<p>[[蓝桥杯]]<br>可以 大概 4月份。报名 截至三月份</p>\n<p>[[中兴捧月]]<br>4月初 报名</p>\n","excerpt":"","more":"<p>[[华为软件精英挑战赛]]<br>每年 三月份</p>\n<p>[[Google Code Jam]]<br>已停办</p>\n<p>[[ICPC 国际大学生程序设计竞赛]]<br>可以尝试，且大概五月多才开始，可以提前准备。到那时<br>本科入学五年内。但是，主要还是大学生</p>\n<p>[[CCPC 中国大学生网络预选赛]]<br>研究生不能参加最终决赛。算了，但是可以参考题目。</p>\n<p>[[蓝桥杯]]<br>可以 大概 4月份。报名 截至三月份</p>\n<p>[[中兴捧月]]<br>4月初 报名</p>\n"},{"_content":"院校报名时间：2023年10月7日-一—2023年12月15日\n\n省赛：2024年4月13日9:00-13:00（软件类）/9:00-14:00（电子类)\n\n国赛：2024年6月中旬第十五届蓝桥杯大赛软件赛知识点大纲","source":"_posts/赛事活动/蓝桥杯.md","raw":"院校报名时间：2023年10月7日-一—2023年12月15日\n\n省赛：2024年4月13日9:00-13:00（软件类）/9:00-14:00（电子类)\n\n国赛：2024年6月中旬第十五届蓝桥杯大赛软件赛知识点大纲","slug":"赛事活动/蓝桥杯","published":1,"date":"2024-04-22T13:14:49.125Z","updated":"2024-04-18T07:06:24.770Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0n001zkgg4a9f1aw9u","content":"<p>院校报名时间：2023年10月7日-一—2023年12月15日</p>\n<p>省赛：2024年4月13日9:00-13:00（软件类）&#x2F;9:00-14:00（电子类)</p>\n<p>国赛：2024年6月中旬第十五届蓝桥杯大赛软件赛知识点大纲</p>\n","excerpt":"","more":"<p>院校报名时间：2023年10月7日-一—2023年12月15日</p>\n<p>省赛：2024年4月13日9:00-13:00（软件类）&#x2F;9:00-14:00（电子类)</p>\n<p>国赛：2024年6月中旬第十五届蓝桥杯大赛软件赛知识点大纲</p>\n"},{"_content":"https://github.com/ninehills/blog/issues/92","source":"_posts/人工智能/大语言模型/Finetuning.md","raw":"https://github.com/ninehills/blog/issues/92","slug":"人工智能/大语言模型/Finetuning","published":1,"date":"2024-04-22T13:14:48.974Z","updated":"2024-03-11T06:25:25.648Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0n0020kgg47ad72wr8","content":"<p><a href=\"https://github.com/ninehills/blog/issues/92\">https://github.com/ninehills/blog/issues/92</a></p>\n","excerpt":"","more":"<p><a href=\"https://github.com/ninehills/blog/issues/92\">https://github.com/ninehills/blog/issues/92</a></p>\n"},{"_content":"这里主要展示自己所参与过或者开发的项目，一些包含一些思考和总结。\n\n\n# 分布式数据库\n[[TinyKV 项目要求]]\n","source":"_posts/项目经历/项目经历.md","raw":"这里主要展示自己所参与过或者开发的项目，一些包含一些思考和总结。\n\n\n# 分布式数据库\n[[TinyKV 项目要求]]\n","slug":"项目经历/项目经历","published":1,"date":"2024-04-22T13:14:49.265Z","updated":"2024-03-30T09:53:16.484Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0n0021kgg40jle3gku","content":"<p>这里主要展示自己所参与过或者开发的项目，一些包含一些思考和总结。</p>\n<h1 id=\"分布式数据库\"><a href=\"#分布式数据库\" class=\"headerlink\" title=\"分布式数据库\"></a>分布式数据库</h1><p>[[TinyKV 项目要求]]</p>\n","excerpt":"","more":"<p>这里主要展示自己所参与过或者开发的项目，一些包含一些思考和总结。</p>\n<h1 id=\"分布式数据库\"><a href=\"#分布式数据库\" class=\"headerlink\" title=\"分布式数据库\"></a>分布式数据库</h1><p>[[TinyKV 项目要求]]</p>\n"},{"_content":"\n# 个人环境搭建\n## API\n\n### openai\n\n[api 使用文档](https://platform.openai.com/docs/api-reference/chat-completions/create)\n\n## wenxin\n[[微信项目]]\n教程：\n[如何申请文心一言&文心千帆大模型API调用资格、获取access_token，并使用SpringBoot接入文心一言API_文心一言api申请-CSDN博客](https://blog.csdn.net/qq_30299877/article/details/131917097)\n\n在线调试工具\nhttps://console.bce.baidu.com/tools/#/api?product=AI&project=%E6%96%87%E5%BF%83%E5%8D%83%E5%B8%86%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0&parent=%E9%89%B4%E6%9D%83%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6&api=oauth%2F2.0%2Ftoken&method=post\n\ntoken\n24.0339bde53ae4eed0ed979b9f9959b20e.2592000.1711684739.282335-53912329\n申请：https://console.bce.baidu.com/qianfan/ais/console/applicationConsole/application/create\n[api 文档]([使用网页调试工具获取access_token - 千帆大模型平台 | 百度智能云文档 (baidu.com)](https://cloud.baidu.com/doc/WENXINWORKSHOP/s/Rlkkt6kd7))\n##  github Copilot 免费使用 gpt-4\nhttps://blog.geniucker.top/2024/01/26/%E9%80%9A%E8%BF%87-GitHub-Copilot-%E5%85%8D%E8%B4%B9%E4%BD%BF%E7%94%A8-gpt-4/\n\nhttps://github.com/Geniucker/CoGPT?tab=readme-ov-file\n\n我希望你充当激励教练。我将为您提供一些关于某人的目标和挑战的信息，而您的工作就是想出可以帮助此人实现目标的策略。这可能涉及提供积极的肯定、提供有用的建议或建议他们可以采取哪些行动来实现最终目标。我的第一个请求是“我需要帮助来激励自己在为即将到来的考试学习时保持纪律”。\n\n\n# 常用的大模型应用技术\n\n## Prompt\n[[Prompt]]\n\n### Course\n\n\n- **[OpenAI Prompt 指南](https://platform.openai.com/docs/guides/prompt-engineering)**\n    \n- **[ChatGPT Prompt Engineering for Developers](https://learn.deeplearning.ai/courses/chatgpt-prompt-eng/lesson/1/introduction)**\n    \n- **[ChatGPT Prompt Engineering for Developers - 中文字幕版](https://www.bilibili.com/video/BV1e8411o7NP?p=1&vd_source=31f1c950b5b95af0c48f188f0bc047c7)**\n    \n\n### Project\n\n- 内容: 使用 GPT-4, 设计 Prompt 优化 **图说数据库系统** 的文本内容.\n    \n- **基本要求:**\n    \n    - 优化自己负责部分的一个小节, 丰富内容, 优化章节结构, 语言风格等.\n        \n    - 采用将大问题分解为多个小问题的方式进行优化, 使用多个 Prompt 对比生成的结果. 最后, 对比丰富后与丰富前的文本. (保留优化前的文本)\n        \n- 进阶:\n    \n    - 其他任意 Prompt 工作都可.\n        \n    - 例如: 优化翻译结果, 优化特定领域结果(数据库专家, 文档编写专家等)\n        \n- 实验室提供的 GPT-4 Web https://chatgpt-next-web-mauve-five.vercel.app/#/chat\n    \n\n### 其他资料\n\n- [GPTs 的 Prompt, 可用于参考](https://github.com/linexjlin/GPTs)\n    \n\n## RAG\n[[RAG 检索增强]]\n### Course\n\n- **[Retrieval Augmented Generation (RAG) 简介 - 中文字幕版](https://www.bilibili.com/video/BV11G411X7nZ?p=15&vd_source=31f1c950b5b95af0c48f188f0bc047c7)**\n    \n- **[LangChain Chat with Your Data](https://learn.deeplearning.ai/langchain-chat-with-your-data/lesson/2/document-loading)**\n    \n- **[LangChain Chat with Your Data - 中文字幕版](https://www.bilibili.com/video/BV148411D7d2/?spm_id_from=333.337.search-card.all.click&vd_source=31f1c950b5b95af0c48f188f0bc047c7)**\n    \n\n### Project\n\n- 利用指定的书籍文档, 构建 RAG 系统.\n    \n- 利用 RAG 系统优化 **图说数据库系统** 的文本内容.\n    \n- **基本要求:**\n    \n    - 优化自己部分的一个小节, 丰富内容, 修正错误. 与原文本, Prompt 生成的文本进行对比.\n        \n- 进阶:\n    \n    - 构建其他任意 RAG 系统.\n    - 例如: 分布式课程 RAG 系统, 实验室文档 RAG 系统, 医疗 RAG 系统等.\n        \n- 实验室提供的 API-Key\n    \n- 可以用于 机器人的 聊天记录进行保存\n### 其他资料\n\n- [Building and Evaluating Advanced RAG](https://learn.deeplearning.ai/building-evaluating-advanced-rag/lesson/1/introduction)\n    \n- [Functions, Tools and Agents with LangChain](https://learn.deeplearning.ai/functions-tools-agents-langchain/lesson/1/introduction)\n    \n- [devv.ai 是如何构建高效的 RAG 系统的](https://twitter.com/tisoga/status/1731478506465636749?s=61&t=TVU99VOXdlAywAcBa_iuSg)\n    \n- [复杂 RAG 的技术考虑](https://twitter.com/i/web/status/1737037970367283474)\n    \n\n## MoE\n[[MoEs]]\n### Course\n\n- [深入理解混合专家模型](https://baoyu.io/translations/llm/mixture-of-experts-explained)\n    \n\n## 微调\n\n[[Finetuning]]\n### Course\n\n- [Finetuning Large Language Models](https://learn.deeplearning.ai/finetuning-large-language-models/lesson/1/introduction)\n[吴恩达《微调大型语言模型》| Finetuning Large Language Models（中英字幕）_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Rz4y1T7wz/?spm_id_from=333.337.search-card.all.click&vd_source=59461060c1867e9bf731e467ae6f00b5)\n\n\n\n\n\n\n","source":"_posts/人工智能/大语言模型/GAI 的应用.md","raw":"\n# 个人环境搭建\n## API\n\n### openai\n\n[api 使用文档](https://platform.openai.com/docs/api-reference/chat-completions/create)\n\n## wenxin\n[[微信项目]]\n教程：\n[如何申请文心一言&文心千帆大模型API调用资格、获取access_token，并使用SpringBoot接入文心一言API_文心一言api申请-CSDN博客](https://blog.csdn.net/qq_30299877/article/details/131917097)\n\n在线调试工具\nhttps://console.bce.baidu.com/tools/#/api?product=AI&project=%E6%96%87%E5%BF%83%E5%8D%83%E5%B8%86%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0&parent=%E9%89%B4%E6%9D%83%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6&api=oauth%2F2.0%2Ftoken&method=post\n\ntoken\n24.0339bde53ae4eed0ed979b9f9959b20e.2592000.1711684739.282335-53912329\n申请：https://console.bce.baidu.com/qianfan/ais/console/applicationConsole/application/create\n[api 文档]([使用网页调试工具获取access_token - 千帆大模型平台 | 百度智能云文档 (baidu.com)](https://cloud.baidu.com/doc/WENXINWORKSHOP/s/Rlkkt6kd7))\n##  github Copilot 免费使用 gpt-4\nhttps://blog.geniucker.top/2024/01/26/%E9%80%9A%E8%BF%87-GitHub-Copilot-%E5%85%8D%E8%B4%B9%E4%BD%BF%E7%94%A8-gpt-4/\n\nhttps://github.com/Geniucker/CoGPT?tab=readme-ov-file\n\n我希望你充当激励教练。我将为您提供一些关于某人的目标和挑战的信息，而您的工作就是想出可以帮助此人实现目标的策略。这可能涉及提供积极的肯定、提供有用的建议或建议他们可以采取哪些行动来实现最终目标。我的第一个请求是“我需要帮助来激励自己在为即将到来的考试学习时保持纪律”。\n\n\n# 常用的大模型应用技术\n\n## Prompt\n[[Prompt]]\n\n### Course\n\n\n- **[OpenAI Prompt 指南](https://platform.openai.com/docs/guides/prompt-engineering)**\n    \n- **[ChatGPT Prompt Engineering for Developers](https://learn.deeplearning.ai/courses/chatgpt-prompt-eng/lesson/1/introduction)**\n    \n- **[ChatGPT Prompt Engineering for Developers - 中文字幕版](https://www.bilibili.com/video/BV1e8411o7NP?p=1&vd_source=31f1c950b5b95af0c48f188f0bc047c7)**\n    \n\n### Project\n\n- 内容: 使用 GPT-4, 设计 Prompt 优化 **图说数据库系统** 的文本内容.\n    \n- **基本要求:**\n    \n    - 优化自己负责部分的一个小节, 丰富内容, 优化章节结构, 语言风格等.\n        \n    - 采用将大问题分解为多个小问题的方式进行优化, 使用多个 Prompt 对比生成的结果. 最后, 对比丰富后与丰富前的文本. (保留优化前的文本)\n        \n- 进阶:\n    \n    - 其他任意 Prompt 工作都可.\n        \n    - 例如: 优化翻译结果, 优化特定领域结果(数据库专家, 文档编写专家等)\n        \n- 实验室提供的 GPT-4 Web https://chatgpt-next-web-mauve-five.vercel.app/#/chat\n    \n\n### 其他资料\n\n- [GPTs 的 Prompt, 可用于参考](https://github.com/linexjlin/GPTs)\n    \n\n## RAG\n[[RAG 检索增强]]\n### Course\n\n- **[Retrieval Augmented Generation (RAG) 简介 - 中文字幕版](https://www.bilibili.com/video/BV11G411X7nZ?p=15&vd_source=31f1c950b5b95af0c48f188f0bc047c7)**\n    \n- **[LangChain Chat with Your Data](https://learn.deeplearning.ai/langchain-chat-with-your-data/lesson/2/document-loading)**\n    \n- **[LangChain Chat with Your Data - 中文字幕版](https://www.bilibili.com/video/BV148411D7d2/?spm_id_from=333.337.search-card.all.click&vd_source=31f1c950b5b95af0c48f188f0bc047c7)**\n    \n\n### Project\n\n- 利用指定的书籍文档, 构建 RAG 系统.\n    \n- 利用 RAG 系统优化 **图说数据库系统** 的文本内容.\n    \n- **基本要求:**\n    \n    - 优化自己部分的一个小节, 丰富内容, 修正错误. 与原文本, Prompt 生成的文本进行对比.\n        \n- 进阶:\n    \n    - 构建其他任意 RAG 系统.\n    - 例如: 分布式课程 RAG 系统, 实验室文档 RAG 系统, 医疗 RAG 系统等.\n        \n- 实验室提供的 API-Key\n    \n- 可以用于 机器人的 聊天记录进行保存\n### 其他资料\n\n- [Building and Evaluating Advanced RAG](https://learn.deeplearning.ai/building-evaluating-advanced-rag/lesson/1/introduction)\n    \n- [Functions, Tools and Agents with LangChain](https://learn.deeplearning.ai/functions-tools-agents-langchain/lesson/1/introduction)\n    \n- [devv.ai 是如何构建高效的 RAG 系统的](https://twitter.com/tisoga/status/1731478506465636749?s=61&t=TVU99VOXdlAywAcBa_iuSg)\n    \n- [复杂 RAG 的技术考虑](https://twitter.com/i/web/status/1737037970367283474)\n    \n\n## MoE\n[[MoEs]]\n### Course\n\n- [深入理解混合专家模型](https://baoyu.io/translations/llm/mixture-of-experts-explained)\n    \n\n## 微调\n\n[[Finetuning]]\n### Course\n\n- [Finetuning Large Language Models](https://learn.deeplearning.ai/finetuning-large-language-models/lesson/1/introduction)\n[吴恩达《微调大型语言模型》| Finetuning Large Language Models（中英字幕）_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Rz4y1T7wz/?spm_id_from=333.337.search-card.all.click&vd_source=59461060c1867e9bf731e467ae6f00b5)\n\n\n\n\n\n\n","slug":"人工智能/大语言模型/GAI 的应用","published":1,"date":"2024-04-22T13:14:48.974Z","updated":"2024-04-22T13:08:47.211Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0n0022kgg46rcz7vk9","content":"<h1 id=\"个人环境搭建\"><a href=\"#个人环境搭建\" class=\"headerlink\" title=\"个人环境搭建\"></a>个人环境搭建</h1><h2 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h2><h3 id=\"openai\"><a href=\"#openai\" class=\"headerlink\" title=\"openai\"></a>openai</h3><p><a href=\"https://platform.openai.com/docs/api-reference/chat-completions/create\">api 使用文档</a></p>\n<h2 id=\"wenxin\"><a href=\"#wenxin\" class=\"headerlink\" title=\"wenxin\"></a>wenxin</h2><p>[[微信项目]]<br>教程：<br><a href=\"https://blog.csdn.net/qq_30299877/article/details/131917097\">如何申请文心一言&amp;文心千帆大模型API调用资格、获取access_token，并使用SpringBoot接入文心一言API_文心一言api申请-CSDN博客</a></p>\n<p>在线调试工具<br><a href=\"https://console.bce.baidu.com/tools/#/api?product=AI&project=%E6%96%87%E5%BF%83%E5%8D%83%E5%B8%86%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0&parent=%E9%89%B4%E6%9D%83%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6&api=oauth%2F2.0%2Ftoken&method=post\">https://console.bce.baidu.com/tools/#/api?product=AI&amp;project=%E6%96%87%E5%BF%83%E5%8D%83%E5%B8%86%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0&amp;parent=%E9%89%B4%E6%9D%83%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6&amp;api=oauth%2F2.0%2Ftoken&amp;method=post</a></p>\n<p>token<br>24.0339bde53ae4eed0ed979b9f9959b20e.2592000.1711684739.282335-53912329<br>申请：<a href=\"https://console.bce.baidu.com/qianfan/ais/console/applicationConsole/application/create\">https://console.bce.baidu.com/qianfan/ais/console/applicationConsole/application/create</a><br>[api 文档](<a href=\"https://cloud.baidu.com/doc/WENXINWORKSHOP/s/Rlkkt6kd7\">使用网页调试工具获取access_token - 千帆大模型平台 | 百度智能云文档 (baidu.com)</a>)</p>\n<h2 id=\"github-Copilot-免费使用-gpt-4\"><a href=\"#github-Copilot-免费使用-gpt-4\" class=\"headerlink\" title=\"github Copilot 免费使用 gpt-4\"></a>github Copilot 免费使用 gpt-4</h2><p><a href=\"https://blog.geniucker.top/2024/01/26/%E9%80%9A%E8%BF%87-GitHub-Copilot-%E5%85%8D%E8%B4%B9%E4%BD%BF%E7%94%A8-gpt-4/\">https://blog.geniucker.top/2024/01/26/%E9%80%9A%E8%BF%87-GitHub-Copilot-%E5%85%8D%E8%B4%B9%E4%BD%BF%E7%94%A8-gpt-4/</a></p>\n<p><a href=\"https://github.com/Geniucker/CoGPT?tab=readme-ov-file\">https://github.com/Geniucker/CoGPT?tab=readme-ov-file</a></p>\n<p>我希望你充当激励教练。我将为您提供一些关于某人的目标和挑战的信息，而您的工作就是想出可以帮助此人实现目标的策略。这可能涉及提供积极的肯定、提供有用的建议或建议他们可以采取哪些行动来实现最终目标。我的第一个请求是“我需要帮助来激励自己在为即将到来的考试学习时保持纪律”。</p>\n<h1 id=\"常用的大模型应用技术\"><a href=\"#常用的大模型应用技术\" class=\"headerlink\" title=\"常用的大模型应用技术\"></a>常用的大模型应用技术</h1><h2 id=\"Prompt\"><a href=\"#Prompt\" class=\"headerlink\" title=\"Prompt\"></a>Prompt</h2><p>[[Prompt]]</p>\n<h3 id=\"Course\"><a href=\"#Course\" class=\"headerlink\" title=\"Course\"></a>Course</h3><ul>\n<li><p><strong><a href=\"https://platform.openai.com/docs/guides/prompt-engineering\">OpenAI Prompt 指南</a></strong></p>\n</li>\n<li><p><strong><a href=\"https://learn.deeplearning.ai/courses/chatgpt-prompt-eng/lesson/1/introduction\">ChatGPT Prompt Engineering for Developers</a></strong></p>\n</li>\n<li><p><strong><a href=\"https://www.bilibili.com/video/BV1e8411o7NP?p=1&vd_source=31f1c950b5b95af0c48f188f0bc047c7\">ChatGPT Prompt Engineering for Developers - 中文字幕版</a></strong></p>\n</li>\n</ul>\n<h3 id=\"Project\"><a href=\"#Project\" class=\"headerlink\" title=\"Project\"></a>Project</h3><ul>\n<li><p>内容: 使用 GPT-4, 设计 Prompt 优化 <strong>图说数据库系统</strong> 的文本内容.</p>\n</li>\n<li><p><strong>基本要求:</strong></p>\n<ul>\n<li><p>优化自己负责部分的一个小节, 丰富内容, 优化章节结构, 语言风格等.</p>\n</li>\n<li><p>采用将大问题分解为多个小问题的方式进行优化, 使用多个 Prompt 对比生成的结果. 最后, 对比丰富后与丰富前的文本. (保留优化前的文本)</p>\n</li>\n</ul>\n</li>\n<li><p>进阶:</p>\n<ul>\n<li><p>其他任意 Prompt 工作都可.</p>\n</li>\n<li><p>例如: 优化翻译结果, 优化特定领域结果(数据库专家, 文档编写专家等)</p>\n</li>\n</ul>\n</li>\n<li><p>实验室提供的 GPT-4 Web <a href=\"https://chatgpt-next-web-mauve-five.vercel.app/#/chat\">https://chatgpt-next-web-mauve-five.vercel.app/#/chat</a></p>\n</li>\n</ul>\n<h3 id=\"其他资料\"><a href=\"#其他资料\" class=\"headerlink\" title=\"其他资料\"></a>其他资料</h3><ul>\n<li><a href=\"https://github.com/linexjlin/GPTs\">GPTs 的 Prompt, 可用于参考</a></li>\n</ul>\n<h2 id=\"RAG\"><a href=\"#RAG\" class=\"headerlink\" title=\"RAG\"></a>RAG</h2><p>[[RAG 检索增强]]</p>\n<h3 id=\"Course-1\"><a href=\"#Course-1\" class=\"headerlink\" title=\"Course\"></a>Course</h3><ul>\n<li><p><strong><a href=\"https://www.bilibili.com/video/BV11G411X7nZ?p=15&vd_source=31f1c950b5b95af0c48f188f0bc047c7\">Retrieval Augmented Generation (RAG) 简介 - 中文字幕版</a></strong></p>\n</li>\n<li><p><strong><a href=\"https://learn.deeplearning.ai/langchain-chat-with-your-data/lesson/2/document-loading\">LangChain Chat with Your Data</a></strong></p>\n</li>\n<li><p><strong><a href=\"https://www.bilibili.com/video/BV148411D7d2/?spm_id_from=333.337.search-card.all.click&vd_source=31f1c950b5b95af0c48f188f0bc047c7\">LangChain Chat with Your Data - 中文字幕版</a></strong></p>\n</li>\n</ul>\n<h3 id=\"Project-1\"><a href=\"#Project-1\" class=\"headerlink\" title=\"Project\"></a>Project</h3><ul>\n<li><p>利用指定的书籍文档, 构建 RAG 系统.</p>\n</li>\n<li><p>利用 RAG 系统优化 <strong>图说数据库系统</strong> 的文本内容.</p>\n</li>\n<li><p><strong>基本要求:</strong></p>\n<ul>\n<li>优化自己部分的一个小节, 丰富内容, 修正错误. 与原文本, Prompt 生成的文本进行对比.</li>\n</ul>\n</li>\n<li><p>进阶:</p>\n<ul>\n<li>构建其他任意 RAG 系统.</li>\n<li>例如: 分布式课程 RAG 系统, 实验室文档 RAG 系统, 医疗 RAG 系统等.</li>\n</ul>\n</li>\n<li><p>实验室提供的 API-Key</p>\n</li>\n<li><p>可以用于 机器人的 聊天记录进行保存</p>\n</li>\n</ul>\n<h3 id=\"其他资料-1\"><a href=\"#其他资料-1\" class=\"headerlink\" title=\"其他资料\"></a>其他资料</h3><ul>\n<li><p><a href=\"https://learn.deeplearning.ai/building-evaluating-advanced-rag/lesson/1/introduction\">Building and Evaluating Advanced RAG</a></p>\n</li>\n<li><p><a href=\"https://learn.deeplearning.ai/functions-tools-agents-langchain/lesson/1/introduction\">Functions, Tools and Agents with LangChain</a></p>\n</li>\n<li><p><a href=\"https://twitter.com/tisoga/status/1731478506465636749?s=61&t=TVU99VOXdlAywAcBa_iuSg\">devv.ai 是如何构建高效的 RAG 系统的</a></p>\n</li>\n<li><p><a href=\"https://twitter.com/i/web/status/1737037970367283474\">复杂 RAG 的技术考虑</a></p>\n</li>\n</ul>\n<h2 id=\"MoE\"><a href=\"#MoE\" class=\"headerlink\" title=\"MoE\"></a>MoE</h2><p>[[MoEs]]</p>\n<h3 id=\"Course-2\"><a href=\"#Course-2\" class=\"headerlink\" title=\"Course\"></a>Course</h3><ul>\n<li><a href=\"https://baoyu.io/translations/llm/mixture-of-experts-explained\">深入理解混合专家模型</a></li>\n</ul>\n<h2 id=\"微调\"><a href=\"#微调\" class=\"headerlink\" title=\"微调\"></a>微调</h2><p>[[Finetuning]]</p>\n<h3 id=\"Course-3\"><a href=\"#Course-3\" class=\"headerlink\" title=\"Course\"></a>Course</h3><ul>\n<li><a href=\"https://learn.deeplearning.ai/finetuning-large-language-models/lesson/1/introduction\">Finetuning Large Language Models</a><br><a href=\"https://www.bilibili.com/video/BV1Rz4y1T7wz/?spm_id_from=333.337.search-card.all.click&vd_source=59461060c1867e9bf731e467ae6f00b5\">吴恩达《微调大型语言模型》| Finetuning Large Language Models（中英字幕）_哔哩哔哩_bilibili</a></li>\n</ul>\n","excerpt":"","more":"<h1 id=\"个人环境搭建\"><a href=\"#个人环境搭建\" class=\"headerlink\" title=\"个人环境搭建\"></a>个人环境搭建</h1><h2 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h2><h3 id=\"openai\"><a href=\"#openai\" class=\"headerlink\" title=\"openai\"></a>openai</h3><p><a href=\"https://platform.openai.com/docs/api-reference/chat-completions/create\">api 使用文档</a></p>\n<h2 id=\"wenxin\"><a href=\"#wenxin\" class=\"headerlink\" title=\"wenxin\"></a>wenxin</h2><p>[[微信项目]]<br>教程：<br><a href=\"https://blog.csdn.net/qq_30299877/article/details/131917097\">如何申请文心一言&amp;文心千帆大模型API调用资格、获取access_token，并使用SpringBoot接入文心一言API_文心一言api申请-CSDN博客</a></p>\n<p>在线调试工具<br><a href=\"https://console.bce.baidu.com/tools/#/api?product=AI&project=%E6%96%87%E5%BF%83%E5%8D%83%E5%B8%86%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0&parent=%E9%89%B4%E6%9D%83%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6&api=oauth%2F2.0%2Ftoken&method=post\">https://console.bce.baidu.com/tools/#/api?product=AI&amp;project=%E6%96%87%E5%BF%83%E5%8D%83%E5%B8%86%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B9%B3%E5%8F%B0&amp;parent=%E9%89%B4%E6%9D%83%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6&amp;api=oauth%2F2.0%2Ftoken&amp;method=post</a></p>\n<p>token<br>24.0339bde53ae4eed0ed979b9f9959b20e.2592000.1711684739.282335-53912329<br>申请：<a href=\"https://console.bce.baidu.com/qianfan/ais/console/applicationConsole/application/create\">https://console.bce.baidu.com/qianfan/ais/console/applicationConsole/application/create</a><br>[api 文档](<a href=\"https://cloud.baidu.com/doc/WENXINWORKSHOP/s/Rlkkt6kd7\">使用网页调试工具获取access_token - 千帆大模型平台 | 百度智能云文档 (baidu.com)</a>)</p>\n<h2 id=\"github-Copilot-免费使用-gpt-4\"><a href=\"#github-Copilot-免费使用-gpt-4\" class=\"headerlink\" title=\"github Copilot 免费使用 gpt-4\"></a>github Copilot 免费使用 gpt-4</h2><p><a href=\"https://blog.geniucker.top/2024/01/26/%E9%80%9A%E8%BF%87-GitHub-Copilot-%E5%85%8D%E8%B4%B9%E4%BD%BF%E7%94%A8-gpt-4/\">https://blog.geniucker.top/2024/01/26/%E9%80%9A%E8%BF%87-GitHub-Copilot-%E5%85%8D%E8%B4%B9%E4%BD%BF%E7%94%A8-gpt-4/</a></p>\n<p><a href=\"https://github.com/Geniucker/CoGPT?tab=readme-ov-file\">https://github.com/Geniucker/CoGPT?tab=readme-ov-file</a></p>\n<p>我希望你充当激励教练。我将为您提供一些关于某人的目标和挑战的信息，而您的工作就是想出可以帮助此人实现目标的策略。这可能涉及提供积极的肯定、提供有用的建议或建议他们可以采取哪些行动来实现最终目标。我的第一个请求是“我需要帮助来激励自己在为即将到来的考试学习时保持纪律”。</p>\n<h1 id=\"常用的大模型应用技术\"><a href=\"#常用的大模型应用技术\" class=\"headerlink\" title=\"常用的大模型应用技术\"></a>常用的大模型应用技术</h1><h2 id=\"Prompt\"><a href=\"#Prompt\" class=\"headerlink\" title=\"Prompt\"></a>Prompt</h2><p>[[Prompt]]</p>\n<h3 id=\"Course\"><a href=\"#Course\" class=\"headerlink\" title=\"Course\"></a>Course</h3><ul>\n<li><p><strong><a href=\"https://platform.openai.com/docs/guides/prompt-engineering\">OpenAI Prompt 指南</a></strong></p>\n</li>\n<li><p><strong><a href=\"https://learn.deeplearning.ai/courses/chatgpt-prompt-eng/lesson/1/introduction\">ChatGPT Prompt Engineering for Developers</a></strong></p>\n</li>\n<li><p><strong><a href=\"https://www.bilibili.com/video/BV1e8411o7NP?p=1&vd_source=31f1c950b5b95af0c48f188f0bc047c7\">ChatGPT Prompt Engineering for Developers - 中文字幕版</a></strong></p>\n</li>\n</ul>\n<h3 id=\"Project\"><a href=\"#Project\" class=\"headerlink\" title=\"Project\"></a>Project</h3><ul>\n<li><p>内容: 使用 GPT-4, 设计 Prompt 优化 <strong>图说数据库系统</strong> 的文本内容.</p>\n</li>\n<li><p><strong>基本要求:</strong></p>\n<ul>\n<li><p>优化自己负责部分的一个小节, 丰富内容, 优化章节结构, 语言风格等.</p>\n</li>\n<li><p>采用将大问题分解为多个小问题的方式进行优化, 使用多个 Prompt 对比生成的结果. 最后, 对比丰富后与丰富前的文本. (保留优化前的文本)</p>\n</li>\n</ul>\n</li>\n<li><p>进阶:</p>\n<ul>\n<li><p>其他任意 Prompt 工作都可.</p>\n</li>\n<li><p>例如: 优化翻译结果, 优化特定领域结果(数据库专家, 文档编写专家等)</p>\n</li>\n</ul>\n</li>\n<li><p>实验室提供的 GPT-4 Web <a href=\"https://chatgpt-next-web-mauve-five.vercel.app/#/chat\">https://chatgpt-next-web-mauve-five.vercel.app/#/chat</a></p>\n</li>\n</ul>\n<h3 id=\"其他资料\"><a href=\"#其他资料\" class=\"headerlink\" title=\"其他资料\"></a>其他资料</h3><ul>\n<li><a href=\"https://github.com/linexjlin/GPTs\">GPTs 的 Prompt, 可用于参考</a></li>\n</ul>\n<h2 id=\"RAG\"><a href=\"#RAG\" class=\"headerlink\" title=\"RAG\"></a>RAG</h2><p>[[RAG 检索增强]]</p>\n<h3 id=\"Course-1\"><a href=\"#Course-1\" class=\"headerlink\" title=\"Course\"></a>Course</h3><ul>\n<li><p><strong><a href=\"https://www.bilibili.com/video/BV11G411X7nZ?p=15&vd_source=31f1c950b5b95af0c48f188f0bc047c7\">Retrieval Augmented Generation (RAG) 简介 - 中文字幕版</a></strong></p>\n</li>\n<li><p><strong><a href=\"https://learn.deeplearning.ai/langchain-chat-with-your-data/lesson/2/document-loading\">LangChain Chat with Your Data</a></strong></p>\n</li>\n<li><p><strong><a href=\"https://www.bilibili.com/video/BV148411D7d2/?spm_id_from=333.337.search-card.all.click&vd_source=31f1c950b5b95af0c48f188f0bc047c7\">LangChain Chat with Your Data - 中文字幕版</a></strong></p>\n</li>\n</ul>\n<h3 id=\"Project-1\"><a href=\"#Project-1\" class=\"headerlink\" title=\"Project\"></a>Project</h3><ul>\n<li><p>利用指定的书籍文档, 构建 RAG 系统.</p>\n</li>\n<li><p>利用 RAG 系统优化 <strong>图说数据库系统</strong> 的文本内容.</p>\n</li>\n<li><p><strong>基本要求:</strong></p>\n<ul>\n<li>优化自己部分的一个小节, 丰富内容, 修正错误. 与原文本, Prompt 生成的文本进行对比.</li>\n</ul>\n</li>\n<li><p>进阶:</p>\n<ul>\n<li>构建其他任意 RAG 系统.</li>\n<li>例如: 分布式课程 RAG 系统, 实验室文档 RAG 系统, 医疗 RAG 系统等.</li>\n</ul>\n</li>\n<li><p>实验室提供的 API-Key</p>\n</li>\n<li><p>可以用于 机器人的 聊天记录进行保存</p>\n</li>\n</ul>\n<h3 id=\"其他资料-1\"><a href=\"#其他资料-1\" class=\"headerlink\" title=\"其他资料\"></a>其他资料</h3><ul>\n<li><p><a href=\"https://learn.deeplearning.ai/building-evaluating-advanced-rag/lesson/1/introduction\">Building and Evaluating Advanced RAG</a></p>\n</li>\n<li><p><a href=\"https://learn.deeplearning.ai/functions-tools-agents-langchain/lesson/1/introduction\">Functions, Tools and Agents with LangChain</a></p>\n</li>\n<li><p><a href=\"https://twitter.com/tisoga/status/1731478506465636749?s=61&t=TVU99VOXdlAywAcBa_iuSg\">devv.ai 是如何构建高效的 RAG 系统的</a></p>\n</li>\n<li><p><a href=\"https://twitter.com/i/web/status/1737037970367283474\">复杂 RAG 的技术考虑</a></p>\n</li>\n</ul>\n<h2 id=\"MoE\"><a href=\"#MoE\" class=\"headerlink\" title=\"MoE\"></a>MoE</h2><p>[[MoEs]]</p>\n<h3 id=\"Course-2\"><a href=\"#Course-2\" class=\"headerlink\" title=\"Course\"></a>Course</h3><ul>\n<li><a href=\"https://baoyu.io/translations/llm/mixture-of-experts-explained\">深入理解混合专家模型</a></li>\n</ul>\n<h2 id=\"微调\"><a href=\"#微调\" class=\"headerlink\" title=\"微调\"></a>微调</h2><p>[[Finetuning]]</p>\n<h3 id=\"Course-3\"><a href=\"#Course-3\" class=\"headerlink\" title=\"Course\"></a>Course</h3><ul>\n<li><a href=\"https://learn.deeplearning.ai/finetuning-large-language-models/lesson/1/introduction\">Finetuning Large Language Models</a><br><a href=\"https://www.bilibili.com/video/BV1Rz4y1T7wz/?spm_id_from=333.337.search-card.all.click&vd_source=59461060c1867e9bf731e467ae6f00b5\">吴恩达《微调大型语言模型》| Finetuning Large Language Models（中英字幕）_哔哩哔哩_bilibili</a></li>\n</ul>\n"},{"_content":"https://www.bilibili.com/video/BV11G411X7nZ/?p=2&vd_source=31f1c950b5b95af0c48f188f0bc047c7\n\n# 基础概念\n## NLP\n分类：\n1. 中间任务（序列标注）：中文分词，词性标注，NER，句法分析，指代消解，语义 Parser 等，\n2. 最终任务：文本分类，文本相似性计算，机器翻译，文本摘要。\n\t1. 自然语言理解类任务：本质上是分类任务：分类任务、句子关系判断\n\t2. 自然语言生成类任务\n\n## NLP 三大特征提取器（CNN|RNN|TF）\nhttps://zhuanlan.zhihu.com/p/54743941\n1. **一个特征抽取器是否适配问题领域的特点，有时候决定了它的成败，而很多模型改进的方向，其实就是改造得使得它更匹配领域问题的特性**\n2. **解决 NLP 任务 最重要的就是 模型的特征提取能力**\n\n### 现状\n1. RNN 基本完成它的历史使命。\n2. CNN 如果改造得当，有希望有自己在NLP领域的一席之地。\n3. Transformer 最主流的特征提取器\n\n### RNN 现状\n#### RNN 在 NLP 中的演进\n1. RNN 采取线性序列结构不断从前往后输入信息，这种线性结构在反向传播时存在优化困难问题，因为反向传播路径太长，容易导致严重的梯度消失或者梯度爆炸问题。\n2. 引入 LSTM 和 GRU 模型，通过增加中间状态信息直接向后转播，以此缓解梯度消失问题，获得很好的效果。\n3. 不断优化，从图像领域引入 Attention 机制，叠加网络使得层更深。\n4. 引入 Encoder-Decoder 框架。\n#### RNN 的优势\n1. RNN 的结构天然适配解决 NLP 问题，NLP 问题的输入往往是一个不定长的线性序列句子。\n2. 而 RNN 本身结构 就是一个可以接纳不定长输入的由前向后进行信息线性传导的网络结构\n3. LSTM 引入三个门， 对于捕获长距离特征也是非常有效的\n#### RNN 的问题\n1. 老模型先天不如新来的 CNN Transformer 。\n2. RNN 本身的序列依赖结构对于大规模并行计算来说相当不友好。而 CNN 和 Transformer 不存在这种问题。\n本质：\n\t时间步有前后依赖\n#### RNN 并行改造\n1. 保留连续时间步的隐层连接\n\t1. 在隐层单元之间并行计算，\n2. 部分打断连续时间步\n\t1. （这样改进之后有点像简化的 CNN）失去原本样貌\n\n### CNN 现状\n#### 怀旧版 CNN \n1. 输入层\n2. 卷积层：特征提取层，卷积核（filter）\n3. pooling 层：对 Filter 的特征进行降维操作（从一个卷积核获得的特征向量里只选中并保留最强的那一个特征）\n4. 输出层\n#### 怀旧版 CNN 的问题\n1. 卷积层如何捕获远距离特征\n\t> CNN 卷积层捕获的实际上是单词 的 k-gram 片段信息，k 的大小决定了能捕获多远距离的特征\n\t1. 不是覆盖连续区域，在同样的滑动窗口大小的前提下，覆盖不连续区域\n\t2. 增加卷积层层数。\n2. Pooling 层\n\t> Pooling的操作逻辑是：从一个卷积核获得的特征向量里只选中并保留最强的那一个特征，所以到了Pooling层，位置信息就被扔掉了，这在NLP里其实是有信息损失的。\n\n\t所以在 NLP 领域里，目前 CNN 的一个发展趋势是抛弃 Pooling 层，靠全卷积层来叠加网络深度\n#### 怀旧版 CNN 的优势\n并行计算能力：单层卷积层，首先对于某个卷积核来说，每个滑动窗口位置之间没有依赖关系，所以完全可以并行计算；另外，不同的卷积核之间也没什么相互影响，所以也可以并行计算。\n\n### Transformer 登场\n[[Transformer]]\n![[Pasted image 20240302135631.png]]\nTransformer 模型由编码器（Encoder）和解码器（Decoder）两部分组成，这两部分都采用了多层的自注意力（Self-Attention）和前馈神经网络（Feed-Forward Neural Network）。\n\n**编码器（Encoder）**：编码器的主要任务是理解输入的信息，并将其转化为一种内部表示形式。在 Transformer 中，编码器接收一系列输入（比如一个句子中的每个词），并通过自注意力机制和前馈神经网络，将每个输入转化为一个向量。这个向量包含了输入的信息，以及它与其他输入的关系。编码器由多个这样的层堆叠在一起，每一层都会进一步提炼这些向量。\n\n**解码器（Decoder）**：解码器的主要任务是根据编码器的输出生成最终的输出。在 Transformer 中，解码器也是由多个自注意力机制和前馈神经网络的层组成。但解码器有两个自注意力层，一个是对自身的输入进行自注意力计算，另一个是对编码器的输出进行自注意力计算。这使得解码器在生成每个输出时，都能考虑到所有的输入和已经生成的输出。\n\n**区别和联系**：编码器和解码器的主要区别在于，编码器只需要理解输入，而解码器需要理解输入并生成输出。因此，解码器比编码器多了一个自注意力层，用于理解已经生成的输出。编码器和解码器的联系在于，它们都使用了自注意力机制和前馈神经网络，而且解码器在生成输出时，会使用编码器的输出。\n\n在 GPT 中，只使用了 Transformer 的解码器部分，因为 GPT 的任务是生成文本，不需要理解输入。而在 BERT 中，只使用了 Transformer 的编码器部分，因为 BERT 的任务是理解文本，不需要生成输出。\n\n> 目前 Transformer 不仅统一了 NLP 诸多领域，也逐步替换图像处理各种任务被广泛使用的 CNN 等其他模型的进程之中；\n> 类似的，多模态模型也目前 基本都采用了 Transformer 模型\n\n#### Transformer 问题\n因为输入的第一层网络是Muli-head self attention层，我们知道，Self attention会让当前输入单词和句子中任意单词发生关系，然后集成到一个embedding向量里，但是当所有信息到了embedding后，位置信息并没有被编码进去。\n#### Transformer 如何解决问题\n1. 如何解决不定长问题：\n\t类似 CNN 假定输入的最大长度，不够用 padding 补充，\n2. 如何解决位置编码问题：\n\t必须要有一个位置编码。\n\t1. Transformer 用位置函数来进行编码；\n\t2. Bert 模型则给每一个单词一个 Position embedding，和 单词 embedding 加起来形成单词的输入；\n3. 如何解决长距离依赖问题。\n\telf attention天然就能解决这个问题，因为在集成信息的时候，当前单词和句子中任意单词都发生了联系，所以一步到位就把这个事情做掉了。不像RNN需要通过隐层节点序列往后传，也不像CNN需要通过增加网络深度来捕获远距离特征，Transformer在这点上明显方案是相对简单直观的。\n\n### 三者比较\n\n1. 从语义特征提取能力来说，目前实验支持如下结论：Transformer在这方面的能力非常显著地超过RNN和CNN（在考察语义类能力的任务WSD中，Transformer超过RNN和CNN大约4-8个绝对百分点），RNN和CNN两者能力差不太多。\n2. 在长距离特征捕获能力方面，目前在特定的长距离特征捕获能力测试任务中（主语-谓语一致性检测，比如we……..are…），实验支持如下结论：原生CNN特征抽取器在这方面极为显著地弱于RNN和Transformer，Transformer微弱优于RNN模型(尤其在主语谓语距离小于13时)，能力由强到弱排序为Transformer>RNN>>CNN; 但在比较远的距离上（主语谓语距离大于13），RNN微弱优于Transformer，所以综合看，可以认为Transformer和RNN在这方面能力差不太多，而CNN则显著弱于前两者。\n3. 从综合特征抽取能力角度衡量，Transformer显著强于RNN和CNN，而RNN和CNN的表现差不太\n4. RNN在并行计算方面有严重缺陷，这是它本身的序列依赖特性导致的，所谓成也萧何败也萧何，它的这个线形序列依赖性非常符合解决NLP任务，这也是为何RNN一引入到NLP就很快流行起来的原因，但是也正是这个线形序列依赖特性，导致它在并行计算方面要想获得质的飞跃，看起来困难重重，近乎是不太可能完成的任务。而对于CNN和Transformer来说，因为它们不存在网络中间状态不同时间步输入的依赖关系，所以可以非常方便及自由地做并行计算改造，这个也好理解。并行计算能力由高到低排序如下：Transformer和CNN差不多，都远远远远强于RNN。\n# 待完成！！！！https://zhuanlan.zhihu.com/p/54743941\nhttps://zhuanlan.zhihu.com/p/597586623\n\n## Bert|GPT|Transformer 区分\nBERT（Bidirectional Encoder Representations from Transformers）、GPT（Generative Pretrained Transformer）和Transformer 是三种在自然语言处理（NLP）领域广泛使用的模型或模型架构。它们之间的关系可以从以下几个方面来理解：\n\n1. **Transformer**：Transformer 是一种模型架构，它在 \"Attention is All You Need\" 这篇论文中首次被提出。Transformer 模型的主要特点是它完全放弃了传统的 RNN（循环神经网络）或 CNN（卷积神经网络）结构，而是完全依赖于 self-attention 机制来处理序列数据。这种结构使得 Transformer 模型在处理长距离依赖和并行计算方面具有优势。\n\n2. **GPT**：GPT 是 OpenAI 开发的一种基于 Transformer 的模型。GPT 使用了 Transformer 的解码器部分，并且采用了单向（从左到右）的自注意力机制。这使得 GPT 在生成文本（如写作、翻译等任务）方面表现出色。\n\n3. **BERT**：BERT 是 Google 开发的一种基于 Transformer 的模型。与 GPT 不同，BERT 使用了 Transformer 的编码器部分，并且采用了双向的自注意力机制。这使得 BERT 能够理解文本中的上下文信息，因此在理解、分类、问答等任务中表现优秀。\n\n总的来说，Transformer 是一种模型架构，而 GPT 和 BERT 都是基于这种架构的模型，但它们在具体实现和应用上有所不同。\n\n# 时间线前\n## 范式转换1.0\n1. bert 和 gpt 模型出现以前，NLP 领域流行的技术是深度学习模型\n2. NLP 领域的深度学习\n\t1. 大量改进的 LSTM 模型 | 少量的改进 CNN 模型作为特征抽取器\n\t2. 以 sequence to sequence（encode-decoder）+ Attention 作为各种具体任务典型。\n\t3. 目标：如何有效增加模型深层或模型的参数容量。\n\t\t即：怎么才能往encoder 和decoder 里不断叠加更深的 LSTM 或 CNN 层，来达成增加层数和模型容量的目标。\n\t4. 分类：\n\t\t1. 中间任务：中文分词，词性标注，NER，句法分析，指代消解，语义 Parser 等，\n\t\t2. 最终任务：文本分类，文本相似性计算，机器翻译，文本摘要。\n\t\t\t1. 自然语言理解类任务：本质上是分类任务\n\t\t\t2. 自然语言生成类任务\n\t5. 评价：总体而言不是很成功，或者说和非深度学习方法相比，带来的优势i不算很大。\n\t6. \n1. NLP 深度学习不算成功的原因：\n\t1. 训练数据总量的限制。\n\t2. LSTM | CNN 特征提取器表达能力不强。\n2. Ber|GPT 这两个预训练模型的出现，代表 NLP 领域的飞跃\n\t1. NLP 研究子领域日渐消亡\n\t\t1. 中间任务不应该出现，这是 NLP 技术发展水平不够高的一种体现。很难一步做好有难度的最终任务。\n\t\t2. Bert|GPT 出现后没有必要做这些中间任务了，因为 Bert|GPT 已经把这些中间任务作为语言学特征，吸收到了 Transformer 的参数里，\n\t2. NLP 不同子领域技术方法和技术日渐统一。\n\t\t1. NLP 领域特征提取器都逐渐从 LSTM|CNN 统一到 Transformer 上。\n\t\t2. 大多数 NLP 子领域的研发模式切换到了两阶段模式，：\n\t\t\t1. 模型预训练阶段\n\t\t\t2. 应用微调\n\t\t\t或者：\n\t\t\t1. Zero Shot\n\t\t\t2. Few Shot","source":"_posts/人工智能/大语言模型/GAI 的工作原理.md","raw":"https://www.bilibili.com/video/BV11G411X7nZ/?p=2&vd_source=31f1c950b5b95af0c48f188f0bc047c7\n\n# 基础概念\n## NLP\n分类：\n1. 中间任务（序列标注）：中文分词，词性标注，NER，句法分析，指代消解，语义 Parser 等，\n2. 最终任务：文本分类，文本相似性计算，机器翻译，文本摘要。\n\t1. 自然语言理解类任务：本质上是分类任务：分类任务、句子关系判断\n\t2. 自然语言生成类任务\n\n## NLP 三大特征提取器（CNN|RNN|TF）\nhttps://zhuanlan.zhihu.com/p/54743941\n1. **一个特征抽取器是否适配问题领域的特点，有时候决定了它的成败，而很多模型改进的方向，其实就是改造得使得它更匹配领域问题的特性**\n2. **解决 NLP 任务 最重要的就是 模型的特征提取能力**\n\n### 现状\n1. RNN 基本完成它的历史使命。\n2. CNN 如果改造得当，有希望有自己在NLP领域的一席之地。\n3. Transformer 最主流的特征提取器\n\n### RNN 现状\n#### RNN 在 NLP 中的演进\n1. RNN 采取线性序列结构不断从前往后输入信息，这种线性结构在反向传播时存在优化困难问题，因为反向传播路径太长，容易导致严重的梯度消失或者梯度爆炸问题。\n2. 引入 LSTM 和 GRU 模型，通过增加中间状态信息直接向后转播，以此缓解梯度消失问题，获得很好的效果。\n3. 不断优化，从图像领域引入 Attention 机制，叠加网络使得层更深。\n4. 引入 Encoder-Decoder 框架。\n#### RNN 的优势\n1. RNN 的结构天然适配解决 NLP 问题，NLP 问题的输入往往是一个不定长的线性序列句子。\n2. 而 RNN 本身结构 就是一个可以接纳不定长输入的由前向后进行信息线性传导的网络结构\n3. LSTM 引入三个门， 对于捕获长距离特征也是非常有效的\n#### RNN 的问题\n1. 老模型先天不如新来的 CNN Transformer 。\n2. RNN 本身的序列依赖结构对于大规模并行计算来说相当不友好。而 CNN 和 Transformer 不存在这种问题。\n本质：\n\t时间步有前后依赖\n#### RNN 并行改造\n1. 保留连续时间步的隐层连接\n\t1. 在隐层单元之间并行计算，\n2. 部分打断连续时间步\n\t1. （这样改进之后有点像简化的 CNN）失去原本样貌\n\n### CNN 现状\n#### 怀旧版 CNN \n1. 输入层\n2. 卷积层：特征提取层，卷积核（filter）\n3. pooling 层：对 Filter 的特征进行降维操作（从一个卷积核获得的特征向量里只选中并保留最强的那一个特征）\n4. 输出层\n#### 怀旧版 CNN 的问题\n1. 卷积层如何捕获远距离特征\n\t> CNN 卷积层捕获的实际上是单词 的 k-gram 片段信息，k 的大小决定了能捕获多远距离的特征\n\t1. 不是覆盖连续区域，在同样的滑动窗口大小的前提下，覆盖不连续区域\n\t2. 增加卷积层层数。\n2. Pooling 层\n\t> Pooling的操作逻辑是：从一个卷积核获得的特征向量里只选中并保留最强的那一个特征，所以到了Pooling层，位置信息就被扔掉了，这在NLP里其实是有信息损失的。\n\n\t所以在 NLP 领域里，目前 CNN 的一个发展趋势是抛弃 Pooling 层，靠全卷积层来叠加网络深度\n#### 怀旧版 CNN 的优势\n并行计算能力：单层卷积层，首先对于某个卷积核来说，每个滑动窗口位置之间没有依赖关系，所以完全可以并行计算；另外，不同的卷积核之间也没什么相互影响，所以也可以并行计算。\n\n### Transformer 登场\n[[Transformer]]\n![[Pasted image 20240302135631.png]]\nTransformer 模型由编码器（Encoder）和解码器（Decoder）两部分组成，这两部分都采用了多层的自注意力（Self-Attention）和前馈神经网络（Feed-Forward Neural Network）。\n\n**编码器（Encoder）**：编码器的主要任务是理解输入的信息，并将其转化为一种内部表示形式。在 Transformer 中，编码器接收一系列输入（比如一个句子中的每个词），并通过自注意力机制和前馈神经网络，将每个输入转化为一个向量。这个向量包含了输入的信息，以及它与其他输入的关系。编码器由多个这样的层堆叠在一起，每一层都会进一步提炼这些向量。\n\n**解码器（Decoder）**：解码器的主要任务是根据编码器的输出生成最终的输出。在 Transformer 中，解码器也是由多个自注意力机制和前馈神经网络的层组成。但解码器有两个自注意力层，一个是对自身的输入进行自注意力计算，另一个是对编码器的输出进行自注意力计算。这使得解码器在生成每个输出时，都能考虑到所有的输入和已经生成的输出。\n\n**区别和联系**：编码器和解码器的主要区别在于，编码器只需要理解输入，而解码器需要理解输入并生成输出。因此，解码器比编码器多了一个自注意力层，用于理解已经生成的输出。编码器和解码器的联系在于，它们都使用了自注意力机制和前馈神经网络，而且解码器在生成输出时，会使用编码器的输出。\n\n在 GPT 中，只使用了 Transformer 的解码器部分，因为 GPT 的任务是生成文本，不需要理解输入。而在 BERT 中，只使用了 Transformer 的编码器部分，因为 BERT 的任务是理解文本，不需要生成输出。\n\n> 目前 Transformer 不仅统一了 NLP 诸多领域，也逐步替换图像处理各种任务被广泛使用的 CNN 等其他模型的进程之中；\n> 类似的，多模态模型也目前 基本都采用了 Transformer 模型\n\n#### Transformer 问题\n因为输入的第一层网络是Muli-head self attention层，我们知道，Self attention会让当前输入单词和句子中任意单词发生关系，然后集成到一个embedding向量里，但是当所有信息到了embedding后，位置信息并没有被编码进去。\n#### Transformer 如何解决问题\n1. 如何解决不定长问题：\n\t类似 CNN 假定输入的最大长度，不够用 padding 补充，\n2. 如何解决位置编码问题：\n\t必须要有一个位置编码。\n\t1. Transformer 用位置函数来进行编码；\n\t2. Bert 模型则给每一个单词一个 Position embedding，和 单词 embedding 加起来形成单词的输入；\n3. 如何解决长距离依赖问题。\n\telf attention天然就能解决这个问题，因为在集成信息的时候，当前单词和句子中任意单词都发生了联系，所以一步到位就把这个事情做掉了。不像RNN需要通过隐层节点序列往后传，也不像CNN需要通过增加网络深度来捕获远距离特征，Transformer在这点上明显方案是相对简单直观的。\n\n### 三者比较\n\n1. 从语义特征提取能力来说，目前实验支持如下结论：Transformer在这方面的能力非常显著地超过RNN和CNN（在考察语义类能力的任务WSD中，Transformer超过RNN和CNN大约4-8个绝对百分点），RNN和CNN两者能力差不太多。\n2. 在长距离特征捕获能力方面，目前在特定的长距离特征捕获能力测试任务中（主语-谓语一致性检测，比如we……..are…），实验支持如下结论：原生CNN特征抽取器在这方面极为显著地弱于RNN和Transformer，Transformer微弱优于RNN模型(尤其在主语谓语距离小于13时)，能力由强到弱排序为Transformer>RNN>>CNN; 但在比较远的距离上（主语谓语距离大于13），RNN微弱优于Transformer，所以综合看，可以认为Transformer和RNN在这方面能力差不太多，而CNN则显著弱于前两者。\n3. 从综合特征抽取能力角度衡量，Transformer显著强于RNN和CNN，而RNN和CNN的表现差不太\n4. RNN在并行计算方面有严重缺陷，这是它本身的序列依赖特性导致的，所谓成也萧何败也萧何，它的这个线形序列依赖性非常符合解决NLP任务，这也是为何RNN一引入到NLP就很快流行起来的原因，但是也正是这个线形序列依赖特性，导致它在并行计算方面要想获得质的飞跃，看起来困难重重，近乎是不太可能完成的任务。而对于CNN和Transformer来说，因为它们不存在网络中间状态不同时间步输入的依赖关系，所以可以非常方便及自由地做并行计算改造，这个也好理解。并行计算能力由高到低排序如下：Transformer和CNN差不多，都远远远远强于RNN。\n# 待完成！！！！https://zhuanlan.zhihu.com/p/54743941\nhttps://zhuanlan.zhihu.com/p/597586623\n\n## Bert|GPT|Transformer 区分\nBERT（Bidirectional Encoder Representations from Transformers）、GPT（Generative Pretrained Transformer）和Transformer 是三种在自然语言处理（NLP）领域广泛使用的模型或模型架构。它们之间的关系可以从以下几个方面来理解：\n\n1. **Transformer**：Transformer 是一种模型架构，它在 \"Attention is All You Need\" 这篇论文中首次被提出。Transformer 模型的主要特点是它完全放弃了传统的 RNN（循环神经网络）或 CNN（卷积神经网络）结构，而是完全依赖于 self-attention 机制来处理序列数据。这种结构使得 Transformer 模型在处理长距离依赖和并行计算方面具有优势。\n\n2. **GPT**：GPT 是 OpenAI 开发的一种基于 Transformer 的模型。GPT 使用了 Transformer 的解码器部分，并且采用了单向（从左到右）的自注意力机制。这使得 GPT 在生成文本（如写作、翻译等任务）方面表现出色。\n\n3. **BERT**：BERT 是 Google 开发的一种基于 Transformer 的模型。与 GPT 不同，BERT 使用了 Transformer 的编码器部分，并且采用了双向的自注意力机制。这使得 BERT 能够理解文本中的上下文信息，因此在理解、分类、问答等任务中表现优秀。\n\n总的来说，Transformer 是一种模型架构，而 GPT 和 BERT 都是基于这种架构的模型，但它们在具体实现和应用上有所不同。\n\n# 时间线前\n## 范式转换1.0\n1. bert 和 gpt 模型出现以前，NLP 领域流行的技术是深度学习模型\n2. NLP 领域的深度学习\n\t1. 大量改进的 LSTM 模型 | 少量的改进 CNN 模型作为特征抽取器\n\t2. 以 sequence to sequence（encode-decoder）+ Attention 作为各种具体任务典型。\n\t3. 目标：如何有效增加模型深层或模型的参数容量。\n\t\t即：怎么才能往encoder 和decoder 里不断叠加更深的 LSTM 或 CNN 层，来达成增加层数和模型容量的目标。\n\t4. 分类：\n\t\t1. 中间任务：中文分词，词性标注，NER，句法分析，指代消解，语义 Parser 等，\n\t\t2. 最终任务：文本分类，文本相似性计算，机器翻译，文本摘要。\n\t\t\t1. 自然语言理解类任务：本质上是分类任务\n\t\t\t2. 自然语言生成类任务\n\t5. 评价：总体而言不是很成功，或者说和非深度学习方法相比，带来的优势i不算很大。\n\t6. \n1. NLP 深度学习不算成功的原因：\n\t1. 训练数据总量的限制。\n\t2. LSTM | CNN 特征提取器表达能力不强。\n2. Ber|GPT 这两个预训练模型的出现，代表 NLP 领域的飞跃\n\t1. NLP 研究子领域日渐消亡\n\t\t1. 中间任务不应该出现，这是 NLP 技术发展水平不够高的一种体现。很难一步做好有难度的最终任务。\n\t\t2. Bert|GPT 出现后没有必要做这些中间任务了，因为 Bert|GPT 已经把这些中间任务作为语言学特征，吸收到了 Transformer 的参数里，\n\t2. NLP 不同子领域技术方法和技术日渐统一。\n\t\t1. NLP 领域特征提取器都逐渐从 LSTM|CNN 统一到 Transformer 上。\n\t\t2. 大多数 NLP 子领域的研发模式切换到了两阶段模式，：\n\t\t\t1. 模型预训练阶段\n\t\t\t2. 应用微调\n\t\t\t或者：\n\t\t\t1. Zero Shot\n\t\t\t2. Few Shot","slug":"人工智能/大语言模型/GAI 的工作原理","published":1,"date":"2024-04-22T13:14:48.974Z","updated":"2024-03-02T06:30:47.969Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0n0023kgg4gpfs2y6l","content":"<p><a href=\"https://www.bilibili.com/video/BV11G411X7nZ/?p=2&vd_source=31f1c950b5b95af0c48f188f0bc047c7\">https://www.bilibili.com/video/BV11G411X7nZ/?p=2&amp;vd_source=31f1c950b5b95af0c48f188f0bc047c7</a></p>\n<h1 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h1><h2 id=\"NLP\"><a href=\"#NLP\" class=\"headerlink\" title=\"NLP\"></a>NLP</h2><p>分类：</p>\n<ol>\n<li>中间任务（序列标注）：中文分词，词性标注，NER，句法分析，指代消解，语义 Parser 等，</li>\n<li>最终任务：文本分类，文本相似性计算，机器翻译，文本摘要。<ol>\n<li>自然语言理解类任务：本质上是分类任务：分类任务、句子关系判断</li>\n<li>自然语言生成类任务</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"NLP-三大特征提取器（CNN-RNN-TF）\"><a href=\"#NLP-三大特征提取器（CNN-RNN-TF）\" class=\"headerlink\" title=\"NLP 三大特征提取器（CNN|RNN|TF）\"></a>NLP 三大特征提取器（CNN|RNN|TF）</h2><p><a href=\"https://zhuanlan.zhihu.com/p/54743941\">https://zhuanlan.zhihu.com/p/54743941</a></p>\n<ol>\n<li><strong>一个特征抽取器是否适配问题领域的特点，有时候决定了它的成败，而很多模型改进的方向，其实就是改造得使得它更匹配领域问题的特性</strong></li>\n<li><strong>解决 NLP 任务 最重要的就是 模型的特征提取能力</strong></li>\n</ol>\n<h3 id=\"现状\"><a href=\"#现状\" class=\"headerlink\" title=\"现状\"></a>现状</h3><ol>\n<li>RNN 基本完成它的历史使命。</li>\n<li>CNN 如果改造得当，有希望有自己在NLP领域的一席之地。</li>\n<li>Transformer 最主流的特征提取器</li>\n</ol>\n<h3 id=\"RNN-现状\"><a href=\"#RNN-现状\" class=\"headerlink\" title=\"RNN 现状\"></a>RNN 现状</h3><h4 id=\"RNN-在-NLP-中的演进\"><a href=\"#RNN-在-NLP-中的演进\" class=\"headerlink\" title=\"RNN 在 NLP 中的演进\"></a>RNN 在 NLP 中的演进</h4><ol>\n<li>RNN 采取线性序列结构不断从前往后输入信息，这种线性结构在反向传播时存在优化困难问题，因为反向传播路径太长，容易导致严重的梯度消失或者梯度爆炸问题。</li>\n<li>引入 LSTM 和 GRU 模型，通过增加中间状态信息直接向后转播，以此缓解梯度消失问题，获得很好的效果。</li>\n<li>不断优化，从图像领域引入 Attention 机制，叠加网络使得层更深。</li>\n<li>引入 Encoder-Decoder 框架。</li>\n</ol>\n<h4 id=\"RNN-的优势\"><a href=\"#RNN-的优势\" class=\"headerlink\" title=\"RNN 的优势\"></a>RNN 的优势</h4><ol>\n<li>RNN 的结构天然适配解决 NLP 问题，NLP 问题的输入往往是一个不定长的线性序列句子。</li>\n<li>而 RNN 本身结构 就是一个可以接纳不定长输入的由前向后进行信息线性传导的网络结构</li>\n<li>LSTM 引入三个门， 对于捕获长距离特征也是非常有效的</li>\n</ol>\n<h4 id=\"RNN-的问题\"><a href=\"#RNN-的问题\" class=\"headerlink\" title=\"RNN 的问题\"></a>RNN 的问题</h4><ol>\n<li>老模型先天不如新来的 CNN Transformer 。</li>\n<li>RNN 本身的序列依赖结构对于大规模并行计算来说相当不友好。而 CNN 和 Transformer 不存在这种问题。<br>本质：<br> 时间步有前后依赖</li>\n</ol>\n<h4 id=\"RNN-并行改造\"><a href=\"#RNN-并行改造\" class=\"headerlink\" title=\"RNN 并行改造\"></a>RNN 并行改造</h4><ol>\n<li>保留连续时间步的隐层连接<ol>\n<li>在隐层单元之间并行计算，</li>\n</ol>\n</li>\n<li>部分打断连续时间步<ol>\n<li>（这样改进之后有点像简化的 CNN）失去原本样貌</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"CNN-现状\"><a href=\"#CNN-现状\" class=\"headerlink\" title=\"CNN 现状\"></a>CNN 现状</h3><h4 id=\"怀旧版-CNN\"><a href=\"#怀旧版-CNN\" class=\"headerlink\" title=\"怀旧版 CNN\"></a>怀旧版 CNN</h4><ol>\n<li>输入层</li>\n<li>卷积层：特征提取层，卷积核（filter）</li>\n<li>pooling 层：对 Filter 的特征进行降维操作（从一个卷积核获得的特征向量里只选中并保留最强的那一个特征）</li>\n<li>输出层</li>\n</ol>\n<h4 id=\"怀旧版-CNN-的问题\"><a href=\"#怀旧版-CNN-的问题\" class=\"headerlink\" title=\"怀旧版 CNN 的问题\"></a>怀旧版 CNN 的问题</h4><ol>\n<li>卷积层如何捕获远距离特征<blockquote>\n<p>CNN 卷积层捕获的实际上是单词 的 k-gram 片段信息，k 的大小决定了能捕获多远距离的特征</p>\n</blockquote>\n<ol>\n<li>不是覆盖连续区域，在同样的滑动窗口大小的前提下，覆盖不连续区域</li>\n<li>增加卷积层层数。</li>\n</ol>\n</li>\n<li>Pooling 层<blockquote>\n<p>Pooling的操作逻辑是：从一个卷积核获得的特征向量里只选中并保留最强的那一个特征，所以到了Pooling层，位置信息就被扔掉了，这在NLP里其实是有信息损失的。</p>\n</blockquote>\n 所以在 NLP 领域里，目前 CNN 的一个发展趋势是抛弃 Pooling 层，靠全卷积层来叠加网络深度</li>\n</ol>\n<h4 id=\"怀旧版-CNN-的优势\"><a href=\"#怀旧版-CNN-的优势\" class=\"headerlink\" title=\"怀旧版 CNN 的优势\"></a>怀旧版 CNN 的优势</h4><p>并行计算能力：单层卷积层，首先对于某个卷积核来说，每个滑动窗口位置之间没有依赖关系，所以完全可以并行计算；另外，不同的卷积核之间也没什么相互影响，所以也可以并行计算。</p>\n<h3 id=\"Transformer-登场\"><a href=\"#Transformer-登场\" class=\"headerlink\" title=\"Transformer 登场\"></a>Transformer 登场</h3><p>[[Transformer]]<br>![[Pasted image 20240302135631.png]]<br>Transformer 模型由编码器（Encoder）和解码器（Decoder）两部分组成，这两部分都采用了多层的自注意力（Self-Attention）和前馈神经网络（Feed-Forward Neural Network）。</p>\n<p><strong>编码器（Encoder）</strong>：编码器的主要任务是理解输入的信息，并将其转化为一种内部表示形式。在 Transformer 中，编码器接收一系列输入（比如一个句子中的每个词），并通过自注意力机制和前馈神经网络，将每个输入转化为一个向量。这个向量包含了输入的信息，以及它与其他输入的关系。编码器由多个这样的层堆叠在一起，每一层都会进一步提炼这些向量。</p>\n<p><strong>解码器（Decoder）</strong>：解码器的主要任务是根据编码器的输出生成最终的输出。在 Transformer 中，解码器也是由多个自注意力机制和前馈神经网络的层组成。但解码器有两个自注意力层，一个是对自身的输入进行自注意力计算，另一个是对编码器的输出进行自注意力计算。这使得解码器在生成每个输出时，都能考虑到所有的输入和已经生成的输出。</p>\n<p><strong>区别和联系</strong>：编码器和解码器的主要区别在于，编码器只需要理解输入，而解码器需要理解输入并生成输出。因此，解码器比编码器多了一个自注意力层，用于理解已经生成的输出。编码器和解码器的联系在于，它们都使用了自注意力机制和前馈神经网络，而且解码器在生成输出时，会使用编码器的输出。</p>\n<p>在 GPT 中，只使用了 Transformer 的解码器部分，因为 GPT 的任务是生成文本，不需要理解输入。而在 BERT 中，只使用了 Transformer 的编码器部分，因为 BERT 的任务是理解文本，不需要生成输出。</p>\n<blockquote>\n<p>目前 Transformer 不仅统一了 NLP 诸多领域，也逐步替换图像处理各种任务被广泛使用的 CNN 等其他模型的进程之中；<br>类似的，多模态模型也目前 基本都采用了 Transformer 模型</p>\n</blockquote>\n<h4 id=\"Transformer-问题\"><a href=\"#Transformer-问题\" class=\"headerlink\" title=\"Transformer 问题\"></a>Transformer 问题</h4><p>因为输入的第一层网络是Muli-head self attention层，我们知道，Self attention会让当前输入单词和句子中任意单词发生关系，然后集成到一个embedding向量里，但是当所有信息到了embedding后，位置信息并没有被编码进去。</p>\n<h4 id=\"Transformer-如何解决问题\"><a href=\"#Transformer-如何解决问题\" class=\"headerlink\" title=\"Transformer 如何解决问题\"></a>Transformer 如何解决问题</h4><ol>\n<li>如何解决不定长问题：<br> 类似 CNN 假定输入的最大长度，不够用 padding 补充，</li>\n<li>如何解决位置编码问题：<br> 必须要有一个位置编码。<ol>\n<li>Transformer 用位置函数来进行编码；</li>\n<li>Bert 模型则给每一个单词一个 Position embedding，和 单词 embedding 加起来形成单词的输入；</li>\n</ol>\n</li>\n<li>如何解决长距离依赖问题。<br> elf attention天然就能解决这个问题，因为在集成信息的时候，当前单词和句子中任意单词都发生了联系，所以一步到位就把这个事情做掉了。不像RNN需要通过隐层节点序列往后传，也不像CNN需要通过增加网络深度来捕获远距离特征，Transformer在这点上明显方案是相对简单直观的。</li>\n</ol>\n<h3 id=\"三者比较\"><a href=\"#三者比较\" class=\"headerlink\" title=\"三者比较\"></a>三者比较</h3><ol>\n<li>从语义特征提取能力来说，目前实验支持如下结论：Transformer在这方面的能力非常显著地超过RNN和CNN（在考察语义类能力的任务WSD中，Transformer超过RNN和CNN大约4-8个绝对百分点），RNN和CNN两者能力差不太多。</li>\n<li>在长距离特征捕获能力方面，目前在特定的长距离特征捕获能力测试任务中（主语-谓语一致性检测，比如we……..are…），实验支持如下结论：原生CNN特征抽取器在这方面极为显著地弱于RNN和Transformer，Transformer微弱优于RNN模型(尤其在主语谓语距离小于13时)，能力由强到弱排序为Transformer&gt;RNN&gt;&gt;CNN; 但在比较远的距离上（主语谓语距离大于13），RNN微弱优于Transformer，所以综合看，可以认为Transformer和RNN在这方面能力差不太多，而CNN则显著弱于前两者。</li>\n<li>从综合特征抽取能力角度衡量，Transformer显著强于RNN和CNN，而RNN和CNN的表现差不太</li>\n<li>RNN在并行计算方面有严重缺陷，这是它本身的序列依赖特性导致的，所谓成也萧何败也萧何，它的这个线形序列依赖性非常符合解决NLP任务，这也是为何RNN一引入到NLP就很快流行起来的原因，但是也正是这个线形序列依赖特性，导致它在并行计算方面要想获得质的飞跃，看起来困难重重，近乎是不太可能完成的任务。而对于CNN和Transformer来说，因为它们不存在网络中间状态不同时间步输入的依赖关系，所以可以非常方便及自由地做并行计算改造，这个也好理解。并行计算能力由高到低排序如下：Transformer和CNN差不多，都远远远远强于RNN。</li>\n</ol>\n<h1 id=\"待完成！！！！https-zhuanlan-zhihu-com-p-54743941\"><a href=\"#待完成！！！！https-zhuanlan-zhihu-com-p-54743941\" class=\"headerlink\" title=\"待完成！！！！https://zhuanlan.zhihu.com/p/54743941\"></a>待完成！！！！<a href=\"https://zhuanlan.zhihu.com/p/54743941\">https://zhuanlan.zhihu.com/p/54743941</a></h1><p><a href=\"https://zhuanlan.zhihu.com/p/597586623\">https://zhuanlan.zhihu.com/p/597586623</a></p>\n<h2 id=\"Bert-GPT-Transformer-区分\"><a href=\"#Bert-GPT-Transformer-区分\" class=\"headerlink\" title=\"Bert|GPT|Transformer 区分\"></a>Bert|GPT|Transformer 区分</h2><p>BERT（Bidirectional Encoder Representations from Transformers）、GPT（Generative Pretrained Transformer）和Transformer 是三种在自然语言处理（NLP）领域广泛使用的模型或模型架构。它们之间的关系可以从以下几个方面来理解：</p>\n<ol>\n<li><p><strong>Transformer</strong>：Transformer 是一种模型架构，它在 “Attention is All You Need” 这篇论文中首次被提出。Transformer 模型的主要特点是它完全放弃了传统的 RNN（循环神经网络）或 CNN（卷积神经网络）结构，而是完全依赖于 self-attention 机制来处理序列数据。这种结构使得 Transformer 模型在处理长距离依赖和并行计算方面具有优势。</p>\n</li>\n<li><p><strong>GPT</strong>：GPT 是 OpenAI 开发的一种基于 Transformer 的模型。GPT 使用了 Transformer 的解码器部分，并且采用了单向（从左到右）的自注意力机制。这使得 GPT 在生成文本（如写作、翻译等任务）方面表现出色。</p>\n</li>\n<li><p><strong>BERT</strong>：BERT 是 Google 开发的一种基于 Transformer 的模型。与 GPT 不同，BERT 使用了 Transformer 的编码器部分，并且采用了双向的自注意力机制。这使得 BERT 能够理解文本中的上下文信息，因此在理解、分类、问答等任务中表现优秀。</p>\n</li>\n</ol>\n<p>总的来说，Transformer 是一种模型架构，而 GPT 和 BERT 都是基于这种架构的模型，但它们在具体实现和应用上有所不同。</p>\n<h1 id=\"时间线前\"><a href=\"#时间线前\" class=\"headerlink\" title=\"时间线前\"></a>时间线前</h1><h2 id=\"范式转换1-0\"><a href=\"#范式转换1-0\" class=\"headerlink\" title=\"范式转换1.0\"></a>范式转换1.0</h2><ol>\n<li>bert 和 gpt 模型出现以前，NLP 领域流行的技术是深度学习模型</li>\n<li>NLP 领域的深度学习<ol>\n<li>大量改进的 LSTM 模型 | 少量的改进 CNN 模型作为特征抽取器</li>\n<li>以 sequence to sequence（encode-decoder）+ Attention 作为各种具体任务典型。</li>\n<li>目标：如何有效增加模型深层或模型的参数容量。<br> 即：怎么才能往encoder 和decoder 里不断叠加更深的 LSTM 或 CNN 层，来达成增加层数和模型容量的目标。</li>\n<li>分类：<ol>\n<li>中间任务：中文分词，词性标注，NER，句法分析，指代消解，语义 Parser 等，</li>\n<li>最终任务：文本分类，文本相似性计算，机器翻译，文本摘要。<ol>\n<li>自然语言理解类任务：本质上是分类任务</li>\n<li>自然语言生成类任务</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>评价：总体而言不是很成功，或者说和非深度学习方法相比，带来的优势i不算很大。</li>\n<li></li>\n</ol>\n</li>\n<li>NLP 深度学习不算成功的原因：<ol>\n<li>训练数据总量的限制。</li>\n<li>LSTM | CNN 特征提取器表达能力不强。</li>\n</ol>\n</li>\n<li>Ber|GPT 这两个预训练模型的出现，代表 NLP 领域的飞跃<ol>\n<li>NLP 研究子领域日渐消亡<ol>\n<li>中间任务不应该出现，这是 NLP 技术发展水平不够高的一种体现。很难一步做好有难度的最终任务。</li>\n<li>Bert|GPT 出现后没有必要做这些中间任务了，因为 Bert|GPT 已经把这些中间任务作为语言学特征，吸收到了 Transformer 的参数里，</li>\n</ol>\n</li>\n<li>NLP 不同子领域技术方法和技术日渐统一。<ol>\n<li>NLP 领域特征提取器都逐渐从 LSTM|CNN 统一到 Transformer 上。</li>\n<li>大多数 NLP 子领域的研发模式切换到了两阶段模式，：<ol>\n<li>模型预训练阶段</li>\n<li>应用微调<br> 或者：</li>\n<li>Zero Shot</li>\n<li>Few Shot</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n","excerpt":"","more":"<p><a href=\"https://www.bilibili.com/video/BV11G411X7nZ/?p=2&vd_source=31f1c950b5b95af0c48f188f0bc047c7\">https://www.bilibili.com/video/BV11G411X7nZ/?p=2&amp;vd_source=31f1c950b5b95af0c48f188f0bc047c7</a></p>\n<h1 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h1><h2 id=\"NLP\"><a href=\"#NLP\" class=\"headerlink\" title=\"NLP\"></a>NLP</h2><p>分类：</p>\n<ol>\n<li>中间任务（序列标注）：中文分词，词性标注，NER，句法分析，指代消解，语义 Parser 等，</li>\n<li>最终任务：文本分类，文本相似性计算，机器翻译，文本摘要。<ol>\n<li>自然语言理解类任务：本质上是分类任务：分类任务、句子关系判断</li>\n<li>自然语言生成类任务</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"NLP-三大特征提取器（CNN-RNN-TF）\"><a href=\"#NLP-三大特征提取器（CNN-RNN-TF）\" class=\"headerlink\" title=\"NLP 三大特征提取器（CNN|RNN|TF）\"></a>NLP 三大特征提取器（CNN|RNN|TF）</h2><p><a href=\"https://zhuanlan.zhihu.com/p/54743941\">https://zhuanlan.zhihu.com/p/54743941</a></p>\n<ol>\n<li><strong>一个特征抽取器是否适配问题领域的特点，有时候决定了它的成败，而很多模型改进的方向，其实就是改造得使得它更匹配领域问题的特性</strong></li>\n<li><strong>解决 NLP 任务 最重要的就是 模型的特征提取能力</strong></li>\n</ol>\n<h3 id=\"现状\"><a href=\"#现状\" class=\"headerlink\" title=\"现状\"></a>现状</h3><ol>\n<li>RNN 基本完成它的历史使命。</li>\n<li>CNN 如果改造得当，有希望有自己在NLP领域的一席之地。</li>\n<li>Transformer 最主流的特征提取器</li>\n</ol>\n<h3 id=\"RNN-现状\"><a href=\"#RNN-现状\" class=\"headerlink\" title=\"RNN 现状\"></a>RNN 现状</h3><h4 id=\"RNN-在-NLP-中的演进\"><a href=\"#RNN-在-NLP-中的演进\" class=\"headerlink\" title=\"RNN 在 NLP 中的演进\"></a>RNN 在 NLP 中的演进</h4><ol>\n<li>RNN 采取线性序列结构不断从前往后输入信息，这种线性结构在反向传播时存在优化困难问题，因为反向传播路径太长，容易导致严重的梯度消失或者梯度爆炸问题。</li>\n<li>引入 LSTM 和 GRU 模型，通过增加中间状态信息直接向后转播，以此缓解梯度消失问题，获得很好的效果。</li>\n<li>不断优化，从图像领域引入 Attention 机制，叠加网络使得层更深。</li>\n<li>引入 Encoder-Decoder 框架。</li>\n</ol>\n<h4 id=\"RNN-的优势\"><a href=\"#RNN-的优势\" class=\"headerlink\" title=\"RNN 的优势\"></a>RNN 的优势</h4><ol>\n<li>RNN 的结构天然适配解决 NLP 问题，NLP 问题的输入往往是一个不定长的线性序列句子。</li>\n<li>而 RNN 本身结构 就是一个可以接纳不定长输入的由前向后进行信息线性传导的网络结构</li>\n<li>LSTM 引入三个门， 对于捕获长距离特征也是非常有效的</li>\n</ol>\n<h4 id=\"RNN-的问题\"><a href=\"#RNN-的问题\" class=\"headerlink\" title=\"RNN 的问题\"></a>RNN 的问题</h4><ol>\n<li>老模型先天不如新来的 CNN Transformer 。</li>\n<li>RNN 本身的序列依赖结构对于大规模并行计算来说相当不友好。而 CNN 和 Transformer 不存在这种问题。<br>本质：<br> 时间步有前后依赖</li>\n</ol>\n<h4 id=\"RNN-并行改造\"><a href=\"#RNN-并行改造\" class=\"headerlink\" title=\"RNN 并行改造\"></a>RNN 并行改造</h4><ol>\n<li>保留连续时间步的隐层连接<ol>\n<li>在隐层单元之间并行计算，</li>\n</ol>\n</li>\n<li>部分打断连续时间步<ol>\n<li>（这样改进之后有点像简化的 CNN）失去原本样貌</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"CNN-现状\"><a href=\"#CNN-现状\" class=\"headerlink\" title=\"CNN 现状\"></a>CNN 现状</h3><h4 id=\"怀旧版-CNN\"><a href=\"#怀旧版-CNN\" class=\"headerlink\" title=\"怀旧版 CNN\"></a>怀旧版 CNN</h4><ol>\n<li>输入层</li>\n<li>卷积层：特征提取层，卷积核（filter）</li>\n<li>pooling 层：对 Filter 的特征进行降维操作（从一个卷积核获得的特征向量里只选中并保留最强的那一个特征）</li>\n<li>输出层</li>\n</ol>\n<h4 id=\"怀旧版-CNN-的问题\"><a href=\"#怀旧版-CNN-的问题\" class=\"headerlink\" title=\"怀旧版 CNN 的问题\"></a>怀旧版 CNN 的问题</h4><ol>\n<li>卷积层如何捕获远距离特征<blockquote>\n<p>CNN 卷积层捕获的实际上是单词 的 k-gram 片段信息，k 的大小决定了能捕获多远距离的特征</p>\n</blockquote>\n<ol>\n<li>不是覆盖连续区域，在同样的滑动窗口大小的前提下，覆盖不连续区域</li>\n<li>增加卷积层层数。</li>\n</ol>\n</li>\n<li>Pooling 层<blockquote>\n<p>Pooling的操作逻辑是：从一个卷积核获得的特征向量里只选中并保留最强的那一个特征，所以到了Pooling层，位置信息就被扔掉了，这在NLP里其实是有信息损失的。</p>\n</blockquote>\n 所以在 NLP 领域里，目前 CNN 的一个发展趋势是抛弃 Pooling 层，靠全卷积层来叠加网络深度</li>\n</ol>\n<h4 id=\"怀旧版-CNN-的优势\"><a href=\"#怀旧版-CNN-的优势\" class=\"headerlink\" title=\"怀旧版 CNN 的优势\"></a>怀旧版 CNN 的优势</h4><p>并行计算能力：单层卷积层，首先对于某个卷积核来说，每个滑动窗口位置之间没有依赖关系，所以完全可以并行计算；另外，不同的卷积核之间也没什么相互影响，所以也可以并行计算。</p>\n<h3 id=\"Transformer-登场\"><a href=\"#Transformer-登场\" class=\"headerlink\" title=\"Transformer 登场\"></a>Transformer 登场</h3><p>[[Transformer]]<br>![[Pasted image 20240302135631.png]]<br>Transformer 模型由编码器（Encoder）和解码器（Decoder）两部分组成，这两部分都采用了多层的自注意力（Self-Attention）和前馈神经网络（Feed-Forward Neural Network）。</p>\n<p><strong>编码器（Encoder）</strong>：编码器的主要任务是理解输入的信息，并将其转化为一种内部表示形式。在 Transformer 中，编码器接收一系列输入（比如一个句子中的每个词），并通过自注意力机制和前馈神经网络，将每个输入转化为一个向量。这个向量包含了输入的信息，以及它与其他输入的关系。编码器由多个这样的层堆叠在一起，每一层都会进一步提炼这些向量。</p>\n<p><strong>解码器（Decoder）</strong>：解码器的主要任务是根据编码器的输出生成最终的输出。在 Transformer 中，解码器也是由多个自注意力机制和前馈神经网络的层组成。但解码器有两个自注意力层，一个是对自身的输入进行自注意力计算，另一个是对编码器的输出进行自注意力计算。这使得解码器在生成每个输出时，都能考虑到所有的输入和已经生成的输出。</p>\n<p><strong>区别和联系</strong>：编码器和解码器的主要区别在于，编码器只需要理解输入，而解码器需要理解输入并生成输出。因此，解码器比编码器多了一个自注意力层，用于理解已经生成的输出。编码器和解码器的联系在于，它们都使用了自注意力机制和前馈神经网络，而且解码器在生成输出时，会使用编码器的输出。</p>\n<p>在 GPT 中，只使用了 Transformer 的解码器部分，因为 GPT 的任务是生成文本，不需要理解输入。而在 BERT 中，只使用了 Transformer 的编码器部分，因为 BERT 的任务是理解文本，不需要生成输出。</p>\n<blockquote>\n<p>目前 Transformer 不仅统一了 NLP 诸多领域，也逐步替换图像处理各种任务被广泛使用的 CNN 等其他模型的进程之中；<br>类似的，多模态模型也目前 基本都采用了 Transformer 模型</p>\n</blockquote>\n<h4 id=\"Transformer-问题\"><a href=\"#Transformer-问题\" class=\"headerlink\" title=\"Transformer 问题\"></a>Transformer 问题</h4><p>因为输入的第一层网络是Muli-head self attention层，我们知道，Self attention会让当前输入单词和句子中任意单词发生关系，然后集成到一个embedding向量里，但是当所有信息到了embedding后，位置信息并没有被编码进去。</p>\n<h4 id=\"Transformer-如何解决问题\"><a href=\"#Transformer-如何解决问题\" class=\"headerlink\" title=\"Transformer 如何解决问题\"></a>Transformer 如何解决问题</h4><ol>\n<li>如何解决不定长问题：<br> 类似 CNN 假定输入的最大长度，不够用 padding 补充，</li>\n<li>如何解决位置编码问题：<br> 必须要有一个位置编码。<ol>\n<li>Transformer 用位置函数来进行编码；</li>\n<li>Bert 模型则给每一个单词一个 Position embedding，和 单词 embedding 加起来形成单词的输入；</li>\n</ol>\n</li>\n<li>如何解决长距离依赖问题。<br> elf attention天然就能解决这个问题，因为在集成信息的时候，当前单词和句子中任意单词都发生了联系，所以一步到位就把这个事情做掉了。不像RNN需要通过隐层节点序列往后传，也不像CNN需要通过增加网络深度来捕获远距离特征，Transformer在这点上明显方案是相对简单直观的。</li>\n</ol>\n<h3 id=\"三者比较\"><a href=\"#三者比较\" class=\"headerlink\" title=\"三者比较\"></a>三者比较</h3><ol>\n<li>从语义特征提取能力来说，目前实验支持如下结论：Transformer在这方面的能力非常显著地超过RNN和CNN（在考察语义类能力的任务WSD中，Transformer超过RNN和CNN大约4-8个绝对百分点），RNN和CNN两者能力差不太多。</li>\n<li>在长距离特征捕获能力方面，目前在特定的长距离特征捕获能力测试任务中（主语-谓语一致性检测，比如we……..are…），实验支持如下结论：原生CNN特征抽取器在这方面极为显著地弱于RNN和Transformer，Transformer微弱优于RNN模型(尤其在主语谓语距离小于13时)，能力由强到弱排序为Transformer&gt;RNN&gt;&gt;CNN; 但在比较远的距离上（主语谓语距离大于13），RNN微弱优于Transformer，所以综合看，可以认为Transformer和RNN在这方面能力差不太多，而CNN则显著弱于前两者。</li>\n<li>从综合特征抽取能力角度衡量，Transformer显著强于RNN和CNN，而RNN和CNN的表现差不太</li>\n<li>RNN在并行计算方面有严重缺陷，这是它本身的序列依赖特性导致的，所谓成也萧何败也萧何，它的这个线形序列依赖性非常符合解决NLP任务，这也是为何RNN一引入到NLP就很快流行起来的原因，但是也正是这个线形序列依赖特性，导致它在并行计算方面要想获得质的飞跃，看起来困难重重，近乎是不太可能完成的任务。而对于CNN和Transformer来说，因为它们不存在网络中间状态不同时间步输入的依赖关系，所以可以非常方便及自由地做并行计算改造，这个也好理解。并行计算能力由高到低排序如下：Transformer和CNN差不多，都远远远远强于RNN。</li>\n</ol>\n<h1 id=\"待完成！！！！https-zhuanlan-zhihu-com-p-54743941\"><a href=\"#待完成！！！！https-zhuanlan-zhihu-com-p-54743941\" class=\"headerlink\" title=\"待完成！！！！https://zhuanlan.zhihu.com/p/54743941\"></a>待完成！！！！<a href=\"https://zhuanlan.zhihu.com/p/54743941\">https://zhuanlan.zhihu.com/p/54743941</a></h1><p><a href=\"https://zhuanlan.zhihu.com/p/597586623\">https://zhuanlan.zhihu.com/p/597586623</a></p>\n<h2 id=\"Bert-GPT-Transformer-区分\"><a href=\"#Bert-GPT-Transformer-区分\" class=\"headerlink\" title=\"Bert|GPT|Transformer 区分\"></a>Bert|GPT|Transformer 区分</h2><p>BERT（Bidirectional Encoder Representations from Transformers）、GPT（Generative Pretrained Transformer）和Transformer 是三种在自然语言处理（NLP）领域广泛使用的模型或模型架构。它们之间的关系可以从以下几个方面来理解：</p>\n<ol>\n<li><p><strong>Transformer</strong>：Transformer 是一种模型架构，它在 “Attention is All You Need” 这篇论文中首次被提出。Transformer 模型的主要特点是它完全放弃了传统的 RNN（循环神经网络）或 CNN（卷积神经网络）结构，而是完全依赖于 self-attention 机制来处理序列数据。这种结构使得 Transformer 模型在处理长距离依赖和并行计算方面具有优势。</p>\n</li>\n<li><p><strong>GPT</strong>：GPT 是 OpenAI 开发的一种基于 Transformer 的模型。GPT 使用了 Transformer 的解码器部分，并且采用了单向（从左到右）的自注意力机制。这使得 GPT 在生成文本（如写作、翻译等任务）方面表现出色。</p>\n</li>\n<li><p><strong>BERT</strong>：BERT 是 Google 开发的一种基于 Transformer 的模型。与 GPT 不同，BERT 使用了 Transformer 的编码器部分，并且采用了双向的自注意力机制。这使得 BERT 能够理解文本中的上下文信息，因此在理解、分类、问答等任务中表现优秀。</p>\n</li>\n</ol>\n<p>总的来说，Transformer 是一种模型架构，而 GPT 和 BERT 都是基于这种架构的模型，但它们在具体实现和应用上有所不同。</p>\n<h1 id=\"时间线前\"><a href=\"#时间线前\" class=\"headerlink\" title=\"时间线前\"></a>时间线前</h1><h2 id=\"范式转换1-0\"><a href=\"#范式转换1-0\" class=\"headerlink\" title=\"范式转换1.0\"></a>范式转换1.0</h2><ol>\n<li>bert 和 gpt 模型出现以前，NLP 领域流行的技术是深度学习模型</li>\n<li>NLP 领域的深度学习<ol>\n<li>大量改进的 LSTM 模型 | 少量的改进 CNN 模型作为特征抽取器</li>\n<li>以 sequence to sequence（encode-decoder）+ Attention 作为各种具体任务典型。</li>\n<li>目标：如何有效增加模型深层或模型的参数容量。<br> 即：怎么才能往encoder 和decoder 里不断叠加更深的 LSTM 或 CNN 层，来达成增加层数和模型容量的目标。</li>\n<li>分类：<ol>\n<li>中间任务：中文分词，词性标注，NER，句法分析，指代消解，语义 Parser 等，</li>\n<li>最终任务：文本分类，文本相似性计算，机器翻译，文本摘要。<ol>\n<li>自然语言理解类任务：本质上是分类任务</li>\n<li>自然语言生成类任务</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>评价：总体而言不是很成功，或者说和非深度学习方法相比，带来的优势i不算很大。</li>\n<li></li>\n</ol>\n</li>\n<li>NLP 深度学习不算成功的原因：<ol>\n<li>训练数据总量的限制。</li>\n<li>LSTM | CNN 特征提取器表达能力不强。</li>\n</ol>\n</li>\n<li>Ber|GPT 这两个预训练模型的出现，代表 NLP 领域的飞跃<ol>\n<li>NLP 研究子领域日渐消亡<ol>\n<li>中间任务不应该出现，这是 NLP 技术发展水平不够高的一种体现。很难一步做好有难度的最终任务。</li>\n<li>Bert|GPT 出现后没有必要做这些中间任务了，因为 Bert|GPT 已经把这些中间任务作为语言学特征，吸收到了 Transformer 的参数里，</li>\n</ol>\n</li>\n<li>NLP 不同子领域技术方法和技术日渐统一。<ol>\n<li>NLP 领域特征提取器都逐渐从 LSTM|CNN 统一到 Transformer 上。</li>\n<li>大多数 NLP 子领域的研发模式切换到了两阶段模式，：<ol>\n<li>模型预训练阶段</li>\n<li>应用微调<br> 或者：</li>\n<li>Zero Shot</li>\n<li>Few Shot</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n"},{"_content":"Mixture  of Experts \nhttps://baoyu.io/translations/llm/mixture-of-experts-explained\nhttps://www.aixinzhijie.com/article/6825966\n深入理解混合专家模型\n1. 相较于密集型模型，预训练速度更快\n2. 拥有比同等参数更快的推理速度\n3. 对显存要求高，因为需要将所有的专家模型都加载到内存中。\n4. 虽然在微调方面存在挑战，有光明前景https://arxiv.org/pdf/2305.14705.pdf\n# 概念\n## 引入\n在有限的计算资源下，相较于用更多步骤训练一个小型模型，训练一个大型模型即便步骤更少效果通常更好。\nMoEs 让模型以远低于传统密集模型的计算成本进行预训练，这意味着你可以在相同的计算预算下显著扩大模型或数据集的规模。\n\n## 原理\n\n### 构成\n1. 稀疏 MoE 层：代替了传统的密集型前馈网络（FFN）层。包含若干“专家”，每个专家都是一个独立的神经网络。实际上，这些专家通常是FFN，但它们也可以是更复杂的网络，，甚至可以是 MoE 本身，形成一个层级结构的 MoE。\n2. 一个门控网络或路由器：用于决定那些 Token 分配给哪个专家。例如，在下图中，“More”这个 Token 被分配给第二个专家![[Pasted image 20240310201128.png]]\n\t1. 一个 token 可以分配给多个专家，如何高效的将 Token 分配给合适的专家，是使用 MoE 技术时需要考虑的关键问题之一。\n\t2. 这个路由器由一系列可学习的参数构成。它与模型的其他部分一起进行训练。\n总结：在 Transformer 中，我们将每一个 FFN（前馈网络）层替换为 MoE 层，由一个门控层和若干”专家“组成。\n# 挑战\n1. 训练：在预训练阶段的计算效率极高，但在微调时往往难以适应新场景，容易造成过拟合现象。\n2. 推理：尽管 MoE 模型可能包含大量参数，但是在推理过程中只有部分参数被使用，（所以它的推理速度远快于参数相同的模型）但是所有参数都需加载到内存中，因此对内存的需求相当大。\n# 历史\n1. 1991 提出\n2. 2010~2015 两个不同的领域推动了 MoE 发展\n\t1. 专家作为主键\n\t2. 条件计算\n3. 引入稀疏性概念在 NLP 领域 快速发展（本文重点），在计算机视觉等也有探索。\n## 稀疏性\n稀疏性基于条件计算的概念，不同于密集型模型中所有参数对所有输入都有效，稀疏性让我们能只激活系统的部分区域。\n> 条件计算（即网络的某些部分仅针对特定样本激活）的概念使得在不增加计算量的情况下扩大模型规模成为可能，从而在每层 MoE 中使用了数千名专家。\n(密集型模型 + 稀疏性 ==> 稀疏模型)\n\n## 问题\n在 MoE 中，当数据通过活跃的专家时，实际的批量大小会减小。例如，如果我们的批量输入包含 10 个 Token，**可能有五个 Token 由一个专家处理，另外五个 Token 分别由五个不同的专家处理，这导致批量大小不均匀，资源利用率低下**。下文中的 [优化 MoE 性能](https://baoyu.io/translations/llm/mixture-of-experts-explained#making-moes-go-brrr) 一节将讨论更多挑战及其解决方案。\n## 解决\n那我们该如何解决这些问题呢？通过一个学习型的门控网络 (G)，决定将输入的哪些部分分配给哪些专家 (E)：\n\n在这种设置中，所有专家都参与处理所有输入——这是一种加权乘法过程。但如果 G 的值为 0 呢？这种情况下，就无需计算相应专家的操作，从而节约了计算资源。那么，典型的门控函数是什么样的呢？在传统设置中，我们通常使用一个简单的网络配合 softmax 函数。这个网络会学习如何选择最合适的专家处理输入。\n\n为了让门控学习如何路由到不同的专家，需要路由到一个以上的专家，因此至少需要选择两个专家。[Switch Transformers](https://baoyu.io/translations/llm/mixture-of-experts-explained#switch-transformers) 章节将重新审视这一决策。\n\n我们为什么要加入噪声？这是为了实现负载均衡！\n\n## 为多专家系统 MoEs 负载均衡 tokens\n如果所有的 tokens 都被发送到少数几个受欢迎的专家，这将导致训练效率低下。在标准的多专家系统训练中，门控网络倾向于主要激活相同的几位专家。这会形成自我加强的循环，因为得到优先训练的专家会被更频繁地选择。为了减轻这种情况，引入了一种**辅助损失**来鼓励平等对待所有专家。这种损失确保所有专家获得大致相同数量的训练样本。后续章节还将探讨“专家容量”的概念，这涉及到一个专家能处理的 tokens 数量上限。在 `transformers` 中，这种辅助损失可以通过 `aux_loss` 参数来调节。\n## MoEs 和 Transformers\nTransformers 模型展示了一个明显的趋势：增加参数的数量可以显著提高性能。Google 的 [GShard](https://arxiv.org/abs/2006.16668) 项目正是在这方面进行了深入探索，试图将 Transformers 模型扩展到超过 6000 亿个参数。\n## 专家在学习中角色和专长\n解码器的专家倾向于特定的 Token 组或基础概念。例如可能形成专门处理标点符号或转悠名词的专家，而解码器的专家则在专业化方面表现的较为平均。\n## 增加专家数量对预训练的影响\n增加更多的专家可以提高样本效率和加速训练过程，但增益逐渐减少（特别是在达到 256 或 512 个专家后），并且在推理过程中需要更多的 VRAM。在大规模应用中研究的 Switch Transformers 的特性，在小规模应用中也得到了验证，即便是每层只有 2、4 或 8 个专家\n## 微调 MoE 技术\nMixtral 软件已经在 transformers 4.36.0 版本中得到支持，您可以通过运行 `pip install \"transformers==4.36.0 --upgrade\"` 命令进行安装。\n密集型模型和稀疏型模型在过拟合上表现出明显不同的特点。稀疏型模型更易于过拟合，因此我们可以尝试在专家系统内部应用更强的正则化手段，例如不同层次的 dropout 率——对密集层和稀疏层分别设置不同的 dropout 率。\n\n在微调过程中，一个关键的决策是是否采用辅助损失。ST-MoE 的研究人员尝试关闭辅助损失，并发现即使高达 11% 的 Token 被丢弃，模型的质量也几乎不受影响。这表明 Token 丢弃可能是一种有效的防止过拟合的正则化策略。\n\n另一个尝试是冻结所有非专家层的权重，结果如预期那样导致了性能大幅下降，因为 MoE 层占据了网络的大部分。相反，仅冻结 MoE 层的参数几乎能达到更新所有参数的效果。这种方法可以加速微调过程，同时减少内存使用。\n通过仅冻结 MoE 层，我们不仅能加快训练速度，还能保持模型的质量。这些发现同样源于 ST-MoE 的研究论文。 \n\n## 何时选择稀疏 MoEs 和稠密模型？\n\n在多机器、高吞吐量的场景中，专家系统是非常有效的。如果预训练的计算预算有限，那么稀疏模型将是更佳的选择。对于 VRAM 较少、吞吐量低的情况，稠密模型则更为合适。\n\n**注意：** 我们不能直接比较稀疏和稠密模型之间的参数数量，因为这两种模型代表的是完全不同的概念。\n\n1. 稀疏模型：\n    - 定义：稀疏模型是一种模型设计策略，其中模型结构被设计为具有少量的参数或专家（Experts），每个专家对应于模型中的一个子模型。\n    - 特点：\n        - 模型结构简单，仅包含少量的专家。s\n        - 每个专家专注于处理特定的输入模式或任务。\n        - 专家之间在参数空间上是相互独立的。\n        - 在推理阶段，只有少量的专家被激活并参与预测，以提高计算效率。\n    - 优点：\n        - 可以处理复杂的输入模式，并对不同的任务进行专门化处理。\n        - 可以节省模型的参数量和计算资源。\n    - 缺点：\n        - 需要设计合适的选择机制和激活策略，以确保在不同输入情况下激活合适的专家。\n        - 对于一些特定的输入模式，可能需要较大的专家数量才能达到较好的性能。\n2. 稠密模型：\n    - 定义：稠密模型是一种模型设计策略，其中模型结构被设计为具有更多的参数和层级，以便能够更全面地学习输入数据的特征和表示。\n    - 特点：\n        - 模型结构相对更复杂，包含多个参数较多的层。\n        - 在训练过程中，模型可以通过反向传播算法端到端地学习输入数据的特征。\n        - 通常用于处理输入模式和任务较为均衡的情况。\n    - 优点：\n        - 可以捕获输入数据中更丰富的特征，并具有更强的表达能力。\n        - 可以适应不同的输入模式和任务，并在训练过程中自动学习特征的权重和表示。\n    - 缺点：\n        - 参数较多，需要更多的计算资源和内存空间。\n        - 在处理特定输入模式和任务时，可能存在过拟合的风险。\n\n![[Pasted image 20240311104630.png]]\n\n\n# 最新进展\n- [The Sparsely-Gated Mixture-of-Experts Layer (2017)](https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1701.06538)  \n    [稀疏门控专家混合层（2017）](https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1701.06538)\n- [GShard: Scaling Giant Models with Conditional Computation and Automatic Sharding (2020)](https://link.zhihu.com/?target=https%3A//arxiv.org/abs/2006.16668)  \n    [GShard：通过条件计算和自动分片扩展巨型模型（2020）](https://link.zhihu.com/?target=https%3A//arxiv.org/abs/2006.16668)\n- [MegaBlocks: Efficient Sparse Training with Mixture-of-Experts (2022)](https://link.zhihu.com/?target=https%3A//arxiv.org/abs/2211.15841)  \n    [MegaBlocks：高效稀疏训练与专家混合（2022）](https://link.zhihu.com/?target=https%3A//arxiv.org/abs/2211.15841)\n- [Mixture-of-Experts Meets Instruction Tuning (2023)](https://link.zhihu.com/?target=https%3A//arxiv.org/abs/2305.14705)  \n    [混合专家遇见指令调整（2023）](https://link.zhihu.com/?target=https%3A//arxiv.org/abs/2305.14705)\n\n[万字长文详解 MoE - 超越ChatGPT的开源混合专家模型 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/674162664)\n\n\n\n[1. Diederik P. Kingma, Jimmy Ba. “Adam: A Method for Stochastic Optimization.” International Conference on Learning Representations(2014).](https://www.semanticscholar.org/paper/a6cb366736791bcccc5c8639de5a8f9636bf87e8) \n\n[2. Ashish Vaswani, Noam M. Shazeer et al. “Attention is All you Need.” Neural Information Processing Systems(2017).](https://www.semanticscholar.org/paper/204e3073870fae3d05bcbc2f6a8e263d9b72e776) \n\n[3. Jimmy Ba, J. Kiros et al. “Layer Normalization.” arXiv.org(2016).](https://www.semanticscholar.org/paper/97fb4e3d45bb098e27e0071448b6152217bd35a5) \n\n[4. Rongjie Yi, Liwei Guo et al. “EdgeMoE: Fast On-Device Inference of MoE-based Large Language Models.” arXiv.org (2023).](https://doi.org/10.48550/arXiv.2308.14352) \n\n[5. Alexander Hauptmann. “From Syntax to Meaning in Natural Language Processing.” AAAI Conference on Artificial Intelligence (1991).](https://www.semanticscholar.org/paper/23894a64bcd7db9007c90fd201264d113e67b6a7) \n\n[6. Chenguang Zhu, Yichong Xu et al. “Knowledge-Augmented Methods for Natural Language Processing.” Annual Meeting of the Association for Computational Linguistics (2023).](https://doi.org/10.1145/3539597.3572720) \n\n[7. Dastan Hussen Maulud, Subhi R. M. Zeebaree et al. “State of Art for Semantic Analysis of Natural Language Processing.” Qubahan Academic Journal (2021).](https://doi.org/10.48161/QAJ.V1N2A44) \n\n[8. Neha Yadav. “Applications Associated With Morphological Analysis And Generation In Natural Language Processing.” (2017). 284-286.](https://www.semanticscholar.org/paper/a1730ffaf9701f9bc66962fe3823f4c4404bccdd)\n\n","source":"_posts/人工智能/大语言模型/MoEs.md","raw":"Mixture  of Experts \nhttps://baoyu.io/translations/llm/mixture-of-experts-explained\nhttps://www.aixinzhijie.com/article/6825966\n深入理解混合专家模型\n1. 相较于密集型模型，预训练速度更快\n2. 拥有比同等参数更快的推理速度\n3. 对显存要求高，因为需要将所有的专家模型都加载到内存中。\n4. 虽然在微调方面存在挑战，有光明前景https://arxiv.org/pdf/2305.14705.pdf\n# 概念\n## 引入\n在有限的计算资源下，相较于用更多步骤训练一个小型模型，训练一个大型模型即便步骤更少效果通常更好。\nMoEs 让模型以远低于传统密集模型的计算成本进行预训练，这意味着你可以在相同的计算预算下显著扩大模型或数据集的规模。\n\n## 原理\n\n### 构成\n1. 稀疏 MoE 层：代替了传统的密集型前馈网络（FFN）层。包含若干“专家”，每个专家都是一个独立的神经网络。实际上，这些专家通常是FFN，但它们也可以是更复杂的网络，，甚至可以是 MoE 本身，形成一个层级结构的 MoE。\n2. 一个门控网络或路由器：用于决定那些 Token 分配给哪个专家。例如，在下图中，“More”这个 Token 被分配给第二个专家![[Pasted image 20240310201128.png]]\n\t1. 一个 token 可以分配给多个专家，如何高效的将 Token 分配给合适的专家，是使用 MoE 技术时需要考虑的关键问题之一。\n\t2. 这个路由器由一系列可学习的参数构成。它与模型的其他部分一起进行训练。\n总结：在 Transformer 中，我们将每一个 FFN（前馈网络）层替换为 MoE 层，由一个门控层和若干”专家“组成。\n# 挑战\n1. 训练：在预训练阶段的计算效率极高，但在微调时往往难以适应新场景，容易造成过拟合现象。\n2. 推理：尽管 MoE 模型可能包含大量参数，但是在推理过程中只有部分参数被使用，（所以它的推理速度远快于参数相同的模型）但是所有参数都需加载到内存中，因此对内存的需求相当大。\n# 历史\n1. 1991 提出\n2. 2010~2015 两个不同的领域推动了 MoE 发展\n\t1. 专家作为主键\n\t2. 条件计算\n3. 引入稀疏性概念在 NLP 领域 快速发展（本文重点），在计算机视觉等也有探索。\n## 稀疏性\n稀疏性基于条件计算的概念，不同于密集型模型中所有参数对所有输入都有效，稀疏性让我们能只激活系统的部分区域。\n> 条件计算（即网络的某些部分仅针对特定样本激活）的概念使得在不增加计算量的情况下扩大模型规模成为可能，从而在每层 MoE 中使用了数千名专家。\n(密集型模型 + 稀疏性 ==> 稀疏模型)\n\n## 问题\n在 MoE 中，当数据通过活跃的专家时，实际的批量大小会减小。例如，如果我们的批量输入包含 10 个 Token，**可能有五个 Token 由一个专家处理，另外五个 Token 分别由五个不同的专家处理，这导致批量大小不均匀，资源利用率低下**。下文中的 [优化 MoE 性能](https://baoyu.io/translations/llm/mixture-of-experts-explained#making-moes-go-brrr) 一节将讨论更多挑战及其解决方案。\n## 解决\n那我们该如何解决这些问题呢？通过一个学习型的门控网络 (G)，决定将输入的哪些部分分配给哪些专家 (E)：\n\n在这种设置中，所有专家都参与处理所有输入——这是一种加权乘法过程。但如果 G 的值为 0 呢？这种情况下，就无需计算相应专家的操作，从而节约了计算资源。那么，典型的门控函数是什么样的呢？在传统设置中，我们通常使用一个简单的网络配合 softmax 函数。这个网络会学习如何选择最合适的专家处理输入。\n\n为了让门控学习如何路由到不同的专家，需要路由到一个以上的专家，因此至少需要选择两个专家。[Switch Transformers](https://baoyu.io/translations/llm/mixture-of-experts-explained#switch-transformers) 章节将重新审视这一决策。\n\n我们为什么要加入噪声？这是为了实现负载均衡！\n\n## 为多专家系统 MoEs 负载均衡 tokens\n如果所有的 tokens 都被发送到少数几个受欢迎的专家，这将导致训练效率低下。在标准的多专家系统训练中，门控网络倾向于主要激活相同的几位专家。这会形成自我加强的循环，因为得到优先训练的专家会被更频繁地选择。为了减轻这种情况，引入了一种**辅助损失**来鼓励平等对待所有专家。这种损失确保所有专家获得大致相同数量的训练样本。后续章节还将探讨“专家容量”的概念，这涉及到一个专家能处理的 tokens 数量上限。在 `transformers` 中，这种辅助损失可以通过 `aux_loss` 参数来调节。\n## MoEs 和 Transformers\nTransformers 模型展示了一个明显的趋势：增加参数的数量可以显著提高性能。Google 的 [GShard](https://arxiv.org/abs/2006.16668) 项目正是在这方面进行了深入探索，试图将 Transformers 模型扩展到超过 6000 亿个参数。\n## 专家在学习中角色和专长\n解码器的专家倾向于特定的 Token 组或基础概念。例如可能形成专门处理标点符号或转悠名词的专家，而解码器的专家则在专业化方面表现的较为平均。\n## 增加专家数量对预训练的影响\n增加更多的专家可以提高样本效率和加速训练过程，但增益逐渐减少（特别是在达到 256 或 512 个专家后），并且在推理过程中需要更多的 VRAM。在大规模应用中研究的 Switch Transformers 的特性，在小规模应用中也得到了验证，即便是每层只有 2、4 或 8 个专家\n## 微调 MoE 技术\nMixtral 软件已经在 transformers 4.36.0 版本中得到支持，您可以通过运行 `pip install \"transformers==4.36.0 --upgrade\"` 命令进行安装。\n密集型模型和稀疏型模型在过拟合上表现出明显不同的特点。稀疏型模型更易于过拟合，因此我们可以尝试在专家系统内部应用更强的正则化手段，例如不同层次的 dropout 率——对密集层和稀疏层分别设置不同的 dropout 率。\n\n在微调过程中，一个关键的决策是是否采用辅助损失。ST-MoE 的研究人员尝试关闭辅助损失，并发现即使高达 11% 的 Token 被丢弃，模型的质量也几乎不受影响。这表明 Token 丢弃可能是一种有效的防止过拟合的正则化策略。\n\n另一个尝试是冻结所有非专家层的权重，结果如预期那样导致了性能大幅下降，因为 MoE 层占据了网络的大部分。相反，仅冻结 MoE 层的参数几乎能达到更新所有参数的效果。这种方法可以加速微调过程，同时减少内存使用。\n通过仅冻结 MoE 层，我们不仅能加快训练速度，还能保持模型的质量。这些发现同样源于 ST-MoE 的研究论文。 \n\n## 何时选择稀疏 MoEs 和稠密模型？\n\n在多机器、高吞吐量的场景中，专家系统是非常有效的。如果预训练的计算预算有限，那么稀疏模型将是更佳的选择。对于 VRAM 较少、吞吐量低的情况，稠密模型则更为合适。\n\n**注意：** 我们不能直接比较稀疏和稠密模型之间的参数数量，因为这两种模型代表的是完全不同的概念。\n\n1. 稀疏模型：\n    - 定义：稀疏模型是一种模型设计策略，其中模型结构被设计为具有少量的参数或专家（Experts），每个专家对应于模型中的一个子模型。\n    - 特点：\n        - 模型结构简单，仅包含少量的专家。s\n        - 每个专家专注于处理特定的输入模式或任务。\n        - 专家之间在参数空间上是相互独立的。\n        - 在推理阶段，只有少量的专家被激活并参与预测，以提高计算效率。\n    - 优点：\n        - 可以处理复杂的输入模式，并对不同的任务进行专门化处理。\n        - 可以节省模型的参数量和计算资源。\n    - 缺点：\n        - 需要设计合适的选择机制和激活策略，以确保在不同输入情况下激活合适的专家。\n        - 对于一些特定的输入模式，可能需要较大的专家数量才能达到较好的性能。\n2. 稠密模型：\n    - 定义：稠密模型是一种模型设计策略，其中模型结构被设计为具有更多的参数和层级，以便能够更全面地学习输入数据的特征和表示。\n    - 特点：\n        - 模型结构相对更复杂，包含多个参数较多的层。\n        - 在训练过程中，模型可以通过反向传播算法端到端地学习输入数据的特征。\n        - 通常用于处理输入模式和任务较为均衡的情况。\n    - 优点：\n        - 可以捕获输入数据中更丰富的特征，并具有更强的表达能力。\n        - 可以适应不同的输入模式和任务，并在训练过程中自动学习特征的权重和表示。\n    - 缺点：\n        - 参数较多，需要更多的计算资源和内存空间。\n        - 在处理特定输入模式和任务时，可能存在过拟合的风险。\n\n![[Pasted image 20240311104630.png]]\n\n\n# 最新进展\n- [The Sparsely-Gated Mixture-of-Experts Layer (2017)](https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1701.06538)  \n    [稀疏门控专家混合层（2017）](https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1701.06538)\n- [GShard: Scaling Giant Models with Conditional Computation and Automatic Sharding (2020)](https://link.zhihu.com/?target=https%3A//arxiv.org/abs/2006.16668)  \n    [GShard：通过条件计算和自动分片扩展巨型模型（2020）](https://link.zhihu.com/?target=https%3A//arxiv.org/abs/2006.16668)\n- [MegaBlocks: Efficient Sparse Training with Mixture-of-Experts (2022)](https://link.zhihu.com/?target=https%3A//arxiv.org/abs/2211.15841)  \n    [MegaBlocks：高效稀疏训练与专家混合（2022）](https://link.zhihu.com/?target=https%3A//arxiv.org/abs/2211.15841)\n- [Mixture-of-Experts Meets Instruction Tuning (2023)](https://link.zhihu.com/?target=https%3A//arxiv.org/abs/2305.14705)  \n    [混合专家遇见指令调整（2023）](https://link.zhihu.com/?target=https%3A//arxiv.org/abs/2305.14705)\n\n[万字长文详解 MoE - 超越ChatGPT的开源混合专家模型 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/674162664)\n\n\n\n[1. Diederik P. Kingma, Jimmy Ba. “Adam: A Method for Stochastic Optimization.” International Conference on Learning Representations(2014).](https://www.semanticscholar.org/paper/a6cb366736791bcccc5c8639de5a8f9636bf87e8) \n\n[2. Ashish Vaswani, Noam M. Shazeer et al. “Attention is All you Need.” Neural Information Processing Systems(2017).](https://www.semanticscholar.org/paper/204e3073870fae3d05bcbc2f6a8e263d9b72e776) \n\n[3. Jimmy Ba, J. Kiros et al. “Layer Normalization.” arXiv.org(2016).](https://www.semanticscholar.org/paper/97fb4e3d45bb098e27e0071448b6152217bd35a5) \n\n[4. Rongjie Yi, Liwei Guo et al. “EdgeMoE: Fast On-Device Inference of MoE-based Large Language Models.” arXiv.org (2023).](https://doi.org/10.48550/arXiv.2308.14352) \n\n[5. Alexander Hauptmann. “From Syntax to Meaning in Natural Language Processing.” AAAI Conference on Artificial Intelligence (1991).](https://www.semanticscholar.org/paper/23894a64bcd7db9007c90fd201264d113e67b6a7) \n\n[6. Chenguang Zhu, Yichong Xu et al. “Knowledge-Augmented Methods for Natural Language Processing.” Annual Meeting of the Association for Computational Linguistics (2023).](https://doi.org/10.1145/3539597.3572720) \n\n[7. Dastan Hussen Maulud, Subhi R. M. Zeebaree et al. “State of Art for Semantic Analysis of Natural Language Processing.” Qubahan Academic Journal (2021).](https://doi.org/10.48161/QAJ.V1N2A44) \n\n[8. Neha Yadav. “Applications Associated With Morphological Analysis And Generation In Natural Language Processing.” (2017). 284-286.](https://www.semanticscholar.org/paper/a1730ffaf9701f9bc66962fe3823f4c4404bccdd)\n\n","slug":"人工智能/大语言模型/MoEs","published":1,"date":"2024-04-22T13:14:48.983Z","updated":"2024-04-17T13:27:49.235Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0n0024kgg47d4t4f3u","content":"<p>Mixture  of Experts<br><a href=\"https://baoyu.io/translations/llm/mixture-of-experts-explained\">https://baoyu.io/translations/llm/mixture-of-experts-explained</a><br><a href=\"https://www.aixinzhijie.com/article/6825966\">https://www.aixinzhijie.com/article/6825966</a><br>深入理解混合专家模型</p>\n<ol>\n<li>相较于密集型模型，预训练速度更快</li>\n<li>拥有比同等参数更快的推理速度</li>\n<li>对显存要求高，因为需要将所有的专家模型都加载到内存中。</li>\n<li>虽然在微调方面存在挑战，有光明前景<a href=\"https://arxiv.org/pdf/2305.14705.pdf\">https://arxiv.org/pdf/2305.14705.pdf</a></li>\n</ol>\n<h1 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h1><h2 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h2><p>在有限的计算资源下，相较于用更多步骤训练一个小型模型，训练一个大型模型即便步骤更少效果通常更好。<br>MoEs 让模型以远低于传统密集模型的计算成本进行预训练，这意味着你可以在相同的计算预算下显著扩大模型或数据集的规模。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><h3 id=\"构成\"><a href=\"#构成\" class=\"headerlink\" title=\"构成\"></a>构成</h3><ol>\n<li>稀疏 MoE 层：代替了传统的密集型前馈网络（FFN）层。包含若干“专家”，每个专家都是一个独立的神经网络。实际上，这些专家通常是FFN，但它们也可以是更复杂的网络，，甚至可以是 MoE 本身，形成一个层级结构的 MoE。</li>\n<li>一个门控网络或路由器：用于决定那些 Token 分配给哪个专家。例如，在下图中，“More”这个 Token 被分配给第二个专家![[Pasted image 20240310201128.png]]<ol>\n<li>一个 token 可以分配给多个专家，如何高效的将 Token 分配给合适的专家，是使用 MoE 技术时需要考虑的关键问题之一。</li>\n<li>这个路由器由一系列可学习的参数构成。它与模型的其他部分一起进行训练。<br>总结：在 Transformer 中，我们将每一个 FFN（前馈网络）层替换为 MoE 层，由一个门控层和若干”专家“组成。</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"挑战\"><a href=\"#挑战\" class=\"headerlink\" title=\"挑战\"></a>挑战</h1><ol>\n<li>训练：在预训练阶段的计算效率极高，但在微调时往往难以适应新场景，容易造成过拟合现象。</li>\n<li>推理：尽管 MoE 模型可能包含大量参数，但是在推理过程中只有部分参数被使用，（所以它的推理速度远快于参数相同的模型）但是所有参数都需加载到内存中，因此对内存的需求相当大。</li>\n</ol>\n<h1 id=\"历史\"><a href=\"#历史\" class=\"headerlink\" title=\"历史\"></a>历史</h1><ol>\n<li>1991 提出</li>\n<li>2010~2015 两个不同的领域推动了 MoE 发展<ol>\n<li>专家作为主键</li>\n<li>条件计算</li>\n</ol>\n</li>\n<li>引入稀疏性概念在 NLP 领域 快速发展（本文重点），在计算机视觉等也有探索。</li>\n</ol>\n<h2 id=\"稀疏性\"><a href=\"#稀疏性\" class=\"headerlink\" title=\"稀疏性\"></a>稀疏性</h2><p>稀疏性基于条件计算的概念，不同于密集型模型中所有参数对所有输入都有效，稀疏性让我们能只激活系统的部分区域。</p>\n<blockquote>\n<p>条件计算（即网络的某些部分仅针对特定样本激活）的概念使得在不增加计算量的情况下扩大模型规模成为可能，从而在每层 MoE 中使用了数千名专家。<br>(密集型模型 + 稀疏性 &#x3D;&#x3D;&gt; 稀疏模型)</p>\n</blockquote>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>在 MoE 中，当数据通过活跃的专家时，实际的批量大小会减小。例如，如果我们的批量输入包含 10 个 Token，<strong>可能有五个 Token 由一个专家处理，另外五个 Token 分别由五个不同的专家处理，这导致批量大小不均匀，资源利用率低下</strong>。下文中的 <a href=\"https://baoyu.io/translations/llm/mixture-of-experts-explained#making-moes-go-brrr\">优化 MoE 性能</a> 一节将讨论更多挑战及其解决方案。</p>\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><p>那我们该如何解决这些问题呢？通过一个学习型的门控网络 (G)，决定将输入的哪些部分分配给哪些专家 (E)：</p>\n<p>在这种设置中，所有专家都参与处理所有输入——这是一种加权乘法过程。但如果 G 的值为 0 呢？这种情况下，就无需计算相应专家的操作，从而节约了计算资源。那么，典型的门控函数是什么样的呢？在传统设置中，我们通常使用一个简单的网络配合 softmax 函数。这个网络会学习如何选择最合适的专家处理输入。</p>\n<p>为了让门控学习如何路由到不同的专家，需要路由到一个以上的专家，因此至少需要选择两个专家。<a href=\"https://baoyu.io/translations/llm/mixture-of-experts-explained#switch-transformers\">Switch Transformers</a> 章节将重新审视这一决策。</p>\n<p>我们为什么要加入噪声？这是为了实现负载均衡！</p>\n<h2 id=\"为多专家系统-MoEs-负载均衡-tokens\"><a href=\"#为多专家系统-MoEs-负载均衡-tokens\" class=\"headerlink\" title=\"为多专家系统 MoEs 负载均衡 tokens\"></a>为多专家系统 MoEs 负载均衡 tokens</h2><p>如果所有的 tokens 都被发送到少数几个受欢迎的专家，这将导致训练效率低下。在标准的多专家系统训练中，门控网络倾向于主要激活相同的几位专家。这会形成自我加强的循环，因为得到优先训练的专家会被更频繁地选择。为了减轻这种情况，引入了一种<strong>辅助损失</strong>来鼓励平等对待所有专家。这种损失确保所有专家获得大致相同数量的训练样本。后续章节还将探讨“专家容量”的概念，这涉及到一个专家能处理的 tokens 数量上限。在 <code>transformers</code> 中，这种辅助损失可以通过 <code>aux_loss</code> 参数来调节。</p>\n<h2 id=\"MoEs-和-Transformers\"><a href=\"#MoEs-和-Transformers\" class=\"headerlink\" title=\"MoEs 和 Transformers\"></a>MoEs 和 Transformers</h2><p>Transformers 模型展示了一个明显的趋势：增加参数的数量可以显著提高性能。Google 的 <a href=\"https://arxiv.org/abs/2006.16668\">GShard</a> 项目正是在这方面进行了深入探索，试图将 Transformers 模型扩展到超过 6000 亿个参数。</p>\n<h2 id=\"专家在学习中角色和专长\"><a href=\"#专家在学习中角色和专长\" class=\"headerlink\" title=\"专家在学习中角色和专长\"></a>专家在学习中角色和专长</h2><p>解码器的专家倾向于特定的 Token 组或基础概念。例如可能形成专门处理标点符号或转悠名词的专家，而解码器的专家则在专业化方面表现的较为平均。</p>\n<h2 id=\"增加专家数量对预训练的影响\"><a href=\"#增加专家数量对预训练的影响\" class=\"headerlink\" title=\"增加专家数量对预训练的影响\"></a>增加专家数量对预训练的影响</h2><p>增加更多的专家可以提高样本效率和加速训练过程，但增益逐渐减少（特别是在达到 256 或 512 个专家后），并且在推理过程中需要更多的 VRAM。在大规模应用中研究的 Switch Transformers 的特性，在小规模应用中也得到了验证，即便是每层只有 2、4 或 8 个专家</p>\n<h2 id=\"微调-MoE-技术\"><a href=\"#微调-MoE-技术\" class=\"headerlink\" title=\"微调 MoE 技术\"></a>微调 MoE 技术</h2><p>Mixtral 软件已经在 transformers 4.36.0 版本中得到支持，您可以通过运行 <code>pip install &quot;transformers==4.36.0 --upgrade&quot;</code> 命令进行安装。<br>密集型模型和稀疏型模型在过拟合上表现出明显不同的特点。稀疏型模型更易于过拟合，因此我们可以尝试在专家系统内部应用更强的正则化手段，例如不同层次的 dropout 率——对密集层和稀疏层分别设置不同的 dropout 率。</p>\n<p>在微调过程中，一个关键的决策是是否采用辅助损失。ST-MoE 的研究人员尝试关闭辅助损失，并发现即使高达 11% 的 Token 被丢弃，模型的质量也几乎不受影响。这表明 Token 丢弃可能是一种有效的防止过拟合的正则化策略。</p>\n<p>另一个尝试是冻结所有非专家层的权重，结果如预期那样导致了性能大幅下降，因为 MoE 层占据了网络的大部分。相反，仅冻结 MoE 层的参数几乎能达到更新所有参数的效果。这种方法可以加速微调过程，同时减少内存使用。<br>通过仅冻结 MoE 层，我们不仅能加快训练速度，还能保持模型的质量。这些发现同样源于 ST-MoE 的研究论文。 </p>\n<h2 id=\"何时选择稀疏-MoEs-和稠密模型？\"><a href=\"#何时选择稀疏-MoEs-和稠密模型？\" class=\"headerlink\" title=\"何时选择稀疏 MoEs 和稠密模型？\"></a>何时选择稀疏 MoEs 和稠密模型？</h2><p>在多机器、高吞吐量的场景中，专家系统是非常有效的。如果预训练的计算预算有限，那么稀疏模型将是更佳的选择。对于 VRAM 较少、吞吐量低的情况，稠密模型则更为合适。</p>\n<p><strong>注意：</strong> 我们不能直接比较稀疏和稠密模型之间的参数数量，因为这两种模型代表的是完全不同的概念。</p>\n<ol>\n<li>稀疏模型：<ul>\n<li>定义：稀疏模型是一种模型设计策略，其中模型结构被设计为具有少量的参数或专家（Experts），每个专家对应于模型中的一个子模型。</li>\n<li>特点：<ul>\n<li>模型结构简单，仅包含少量的专家。s</li>\n<li>每个专家专注于处理特定的输入模式或任务。</li>\n<li>专家之间在参数空间上是相互独立的。</li>\n<li>在推理阶段，只有少量的专家被激活并参与预测，以提高计算效率。</li>\n</ul>\n</li>\n<li>优点：<ul>\n<li>可以处理复杂的输入模式，并对不同的任务进行专门化处理。</li>\n<li>可以节省模型的参数量和计算资源。</li>\n</ul>\n</li>\n<li>缺点：<ul>\n<li>需要设计合适的选择机制和激活策略，以确保在不同输入情况下激活合适的专家。</li>\n<li>对于一些特定的输入模式，可能需要较大的专家数量才能达到较好的性能。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>稠密模型：<ul>\n<li>定义：稠密模型是一种模型设计策略，其中模型结构被设计为具有更多的参数和层级，以便能够更全面地学习输入数据的特征和表示。</li>\n<li>特点：<ul>\n<li>模型结构相对更复杂，包含多个参数较多的层。</li>\n<li>在训练过程中，模型可以通过反向传播算法端到端地学习输入数据的特征。</li>\n<li>通常用于处理输入模式和任务较为均衡的情况。</li>\n</ul>\n</li>\n<li>优点：<ul>\n<li>可以捕获输入数据中更丰富的特征，并具有更强的表达能力。</li>\n<li>可以适应不同的输入模式和任务，并在训练过程中自动学习特征的权重和表示。</li>\n</ul>\n</li>\n<li>缺点：<ul>\n<li>参数较多，需要更多的计算资源和内存空间。</li>\n<li>在处理特定输入模式和任务时，可能存在过拟合的风险。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p>![[Pasted image 20240311104630.png]]</p>\n<h1 id=\"最新进展\"><a href=\"#最新进展\" class=\"headerlink\" title=\"最新进展\"></a>最新进展</h1><ul>\n<li><a href=\"https://link.zhihu.com/?target=https://arxiv.org/abs/1701.06538\">The Sparsely-Gated Mixture-of-Experts Layer (2017)</a><br>  <a href=\"https://link.zhihu.com/?target=https://arxiv.org/abs/1701.06538\">稀疏门控专家混合层（2017）</a></li>\n<li><a href=\"https://link.zhihu.com/?target=https://arxiv.org/abs/2006.16668\">GShard: Scaling Giant Models with Conditional Computation and Automatic Sharding (2020)</a><br>  <a href=\"https://link.zhihu.com/?target=https://arxiv.org/abs/2006.16668\">GShard：通过条件计算和自动分片扩展巨型模型（2020）</a></li>\n<li><a href=\"https://link.zhihu.com/?target=https://arxiv.org/abs/2211.15841\">MegaBlocks: Efficient Sparse Training with Mixture-of-Experts (2022)</a><br>  <a href=\"https://link.zhihu.com/?target=https://arxiv.org/abs/2211.15841\">MegaBlocks：高效稀疏训练与专家混合（2022）</a></li>\n<li><a href=\"https://link.zhihu.com/?target=https://arxiv.org/abs/2305.14705\">Mixture-of-Experts Meets Instruction Tuning (2023)</a><br>  <a href=\"https://link.zhihu.com/?target=https://arxiv.org/abs/2305.14705\">混合专家遇见指令调整（2023）</a></li>\n</ul>\n<p><a href=\"https://zhuanlan.zhihu.com/p/674162664\">万字长文详解 MoE - 超越ChatGPT的开源混合专家模型 - 知乎 (zhihu.com)</a></p>\n<p><a href=\"https://www.semanticscholar.org/paper/a6cb366736791bcccc5c8639de5a8f9636bf87e8\">1. Diederik P. Kingma, Jimmy Ba. “Adam: A Method for Stochastic Optimization.” International Conference on Learning Representations(2014).</a> </p>\n<p><a href=\"https://www.semanticscholar.org/paper/204e3073870fae3d05bcbc2f6a8e263d9b72e776\">2. Ashish Vaswani, Noam M. Shazeer et al. “Attention is All you Need.” Neural Information Processing Systems(2017).</a> </p>\n<p><a href=\"https://www.semanticscholar.org/paper/97fb4e3d45bb098e27e0071448b6152217bd35a5\">3. Jimmy Ba, J. Kiros et al. “Layer Normalization.” arXiv.org(2016).</a> </p>\n<p><a href=\"https://doi.org/10.48550/arXiv.2308.14352\">4. Rongjie Yi, Liwei Guo et al. “EdgeMoE: Fast On-Device Inference of MoE-based Large Language Models.” arXiv.org (2023).</a> </p>\n<p><a href=\"https://www.semanticscholar.org/paper/23894a64bcd7db9007c90fd201264d113e67b6a7\">5. Alexander Hauptmann. “From Syntax to Meaning in Natural Language Processing.” AAAI Conference on Artificial Intelligence (1991).</a> </p>\n<p><a href=\"https://doi.org/10.1145/3539597.3572720\">6. Chenguang Zhu, Yichong Xu et al. “Knowledge-Augmented Methods for Natural Language Processing.” Annual Meeting of the Association for Computational Linguistics (2023).</a> </p>\n<p><a href=\"https://doi.org/10.48161/QAJ.V1N2A44\">7. Dastan Hussen Maulud, Subhi R. M. Zeebaree et al. “State of Art for Semantic Analysis of Natural Language Processing.” Qubahan Academic Journal (2021).</a> </p>\n<p><a href=\"https://www.semanticscholar.org/paper/a1730ffaf9701f9bc66962fe3823f4c4404bccdd\">8. Neha Yadav. “Applications Associated With Morphological Analysis And Generation In Natural Language Processing.” (2017). 284-286.</a></p>\n","excerpt":"","more":"<p>Mixture  of Experts<br><a href=\"https://baoyu.io/translations/llm/mixture-of-experts-explained\">https://baoyu.io/translations/llm/mixture-of-experts-explained</a><br><a href=\"https://www.aixinzhijie.com/article/6825966\">https://www.aixinzhijie.com/article/6825966</a><br>深入理解混合专家模型</p>\n<ol>\n<li>相较于密集型模型，预训练速度更快</li>\n<li>拥有比同等参数更快的推理速度</li>\n<li>对显存要求高，因为需要将所有的专家模型都加载到内存中。</li>\n<li>虽然在微调方面存在挑战，有光明前景<a href=\"https://arxiv.org/pdf/2305.14705.pdf\">https://arxiv.org/pdf/2305.14705.pdf</a></li>\n</ol>\n<h1 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h1><h2 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h2><p>在有限的计算资源下，相较于用更多步骤训练一个小型模型，训练一个大型模型即便步骤更少效果通常更好。<br>MoEs 让模型以远低于传统密集模型的计算成本进行预训练，这意味着你可以在相同的计算预算下显著扩大模型或数据集的规模。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><h3 id=\"构成\"><a href=\"#构成\" class=\"headerlink\" title=\"构成\"></a>构成</h3><ol>\n<li>稀疏 MoE 层：代替了传统的密集型前馈网络（FFN）层。包含若干“专家”，每个专家都是一个独立的神经网络。实际上，这些专家通常是FFN，但它们也可以是更复杂的网络，，甚至可以是 MoE 本身，形成一个层级结构的 MoE。</li>\n<li>一个门控网络或路由器：用于决定那些 Token 分配给哪个专家。例如，在下图中，“More”这个 Token 被分配给第二个专家![[Pasted image 20240310201128.png]]<ol>\n<li>一个 token 可以分配给多个专家，如何高效的将 Token 分配给合适的专家，是使用 MoE 技术时需要考虑的关键问题之一。</li>\n<li>这个路由器由一系列可学习的参数构成。它与模型的其他部分一起进行训练。<br>总结：在 Transformer 中，我们将每一个 FFN（前馈网络）层替换为 MoE 层，由一个门控层和若干”专家“组成。</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"挑战\"><a href=\"#挑战\" class=\"headerlink\" title=\"挑战\"></a>挑战</h1><ol>\n<li>训练：在预训练阶段的计算效率极高，但在微调时往往难以适应新场景，容易造成过拟合现象。</li>\n<li>推理：尽管 MoE 模型可能包含大量参数，但是在推理过程中只有部分参数被使用，（所以它的推理速度远快于参数相同的模型）但是所有参数都需加载到内存中，因此对内存的需求相当大。</li>\n</ol>\n<h1 id=\"历史\"><a href=\"#历史\" class=\"headerlink\" title=\"历史\"></a>历史</h1><ol>\n<li>1991 提出</li>\n<li>2010~2015 两个不同的领域推动了 MoE 发展<ol>\n<li>专家作为主键</li>\n<li>条件计算</li>\n</ol>\n</li>\n<li>引入稀疏性概念在 NLP 领域 快速发展（本文重点），在计算机视觉等也有探索。</li>\n</ol>\n<h2 id=\"稀疏性\"><a href=\"#稀疏性\" class=\"headerlink\" title=\"稀疏性\"></a>稀疏性</h2><p>稀疏性基于条件计算的概念，不同于密集型模型中所有参数对所有输入都有效，稀疏性让我们能只激活系统的部分区域。</p>\n<blockquote>\n<p>条件计算（即网络的某些部分仅针对特定样本激活）的概念使得在不增加计算量的情况下扩大模型规模成为可能，从而在每层 MoE 中使用了数千名专家。<br>(密集型模型 + 稀疏性 &#x3D;&#x3D;&gt; 稀疏模型)</p>\n</blockquote>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>在 MoE 中，当数据通过活跃的专家时，实际的批量大小会减小。例如，如果我们的批量输入包含 10 个 Token，<strong>可能有五个 Token 由一个专家处理，另外五个 Token 分别由五个不同的专家处理，这导致批量大小不均匀，资源利用率低下</strong>。下文中的 <a href=\"https://baoyu.io/translations/llm/mixture-of-experts-explained#making-moes-go-brrr\">优化 MoE 性能</a> 一节将讨论更多挑战及其解决方案。</p>\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><p>那我们该如何解决这些问题呢？通过一个学习型的门控网络 (G)，决定将输入的哪些部分分配给哪些专家 (E)：</p>\n<p>在这种设置中，所有专家都参与处理所有输入——这是一种加权乘法过程。但如果 G 的值为 0 呢？这种情况下，就无需计算相应专家的操作，从而节约了计算资源。那么，典型的门控函数是什么样的呢？在传统设置中，我们通常使用一个简单的网络配合 softmax 函数。这个网络会学习如何选择最合适的专家处理输入。</p>\n<p>为了让门控学习如何路由到不同的专家，需要路由到一个以上的专家，因此至少需要选择两个专家。<a href=\"https://baoyu.io/translations/llm/mixture-of-experts-explained#switch-transformers\">Switch Transformers</a> 章节将重新审视这一决策。</p>\n<p>我们为什么要加入噪声？这是为了实现负载均衡！</p>\n<h2 id=\"为多专家系统-MoEs-负载均衡-tokens\"><a href=\"#为多专家系统-MoEs-负载均衡-tokens\" class=\"headerlink\" title=\"为多专家系统 MoEs 负载均衡 tokens\"></a>为多专家系统 MoEs 负载均衡 tokens</h2><p>如果所有的 tokens 都被发送到少数几个受欢迎的专家，这将导致训练效率低下。在标准的多专家系统训练中，门控网络倾向于主要激活相同的几位专家。这会形成自我加强的循环，因为得到优先训练的专家会被更频繁地选择。为了减轻这种情况，引入了一种<strong>辅助损失</strong>来鼓励平等对待所有专家。这种损失确保所有专家获得大致相同数量的训练样本。后续章节还将探讨“专家容量”的概念，这涉及到一个专家能处理的 tokens 数量上限。在 <code>transformers</code> 中，这种辅助损失可以通过 <code>aux_loss</code> 参数来调节。</p>\n<h2 id=\"MoEs-和-Transformers\"><a href=\"#MoEs-和-Transformers\" class=\"headerlink\" title=\"MoEs 和 Transformers\"></a>MoEs 和 Transformers</h2><p>Transformers 模型展示了一个明显的趋势：增加参数的数量可以显著提高性能。Google 的 <a href=\"https://arxiv.org/abs/2006.16668\">GShard</a> 项目正是在这方面进行了深入探索，试图将 Transformers 模型扩展到超过 6000 亿个参数。</p>\n<h2 id=\"专家在学习中角色和专长\"><a href=\"#专家在学习中角色和专长\" class=\"headerlink\" title=\"专家在学习中角色和专长\"></a>专家在学习中角色和专长</h2><p>解码器的专家倾向于特定的 Token 组或基础概念。例如可能形成专门处理标点符号或转悠名词的专家，而解码器的专家则在专业化方面表现的较为平均。</p>\n<h2 id=\"增加专家数量对预训练的影响\"><a href=\"#增加专家数量对预训练的影响\" class=\"headerlink\" title=\"增加专家数量对预训练的影响\"></a>增加专家数量对预训练的影响</h2><p>增加更多的专家可以提高样本效率和加速训练过程，但增益逐渐减少（特别是在达到 256 或 512 个专家后），并且在推理过程中需要更多的 VRAM。在大规模应用中研究的 Switch Transformers 的特性，在小规模应用中也得到了验证，即便是每层只有 2、4 或 8 个专家</p>\n<h2 id=\"微调-MoE-技术\"><a href=\"#微调-MoE-技术\" class=\"headerlink\" title=\"微调 MoE 技术\"></a>微调 MoE 技术</h2><p>Mixtral 软件已经在 transformers 4.36.0 版本中得到支持，您可以通过运行 <code>pip install &quot;transformers==4.36.0 --upgrade&quot;</code> 命令进行安装。<br>密集型模型和稀疏型模型在过拟合上表现出明显不同的特点。稀疏型模型更易于过拟合，因此我们可以尝试在专家系统内部应用更强的正则化手段，例如不同层次的 dropout 率——对密集层和稀疏层分别设置不同的 dropout 率。</p>\n<p>在微调过程中，一个关键的决策是是否采用辅助损失。ST-MoE 的研究人员尝试关闭辅助损失，并发现即使高达 11% 的 Token 被丢弃，模型的质量也几乎不受影响。这表明 Token 丢弃可能是一种有效的防止过拟合的正则化策略。</p>\n<p>另一个尝试是冻结所有非专家层的权重，结果如预期那样导致了性能大幅下降，因为 MoE 层占据了网络的大部分。相反，仅冻结 MoE 层的参数几乎能达到更新所有参数的效果。这种方法可以加速微调过程，同时减少内存使用。<br>通过仅冻结 MoE 层，我们不仅能加快训练速度，还能保持模型的质量。这些发现同样源于 ST-MoE 的研究论文。 </p>\n<h2 id=\"何时选择稀疏-MoEs-和稠密模型？\"><a href=\"#何时选择稀疏-MoEs-和稠密模型？\" class=\"headerlink\" title=\"何时选择稀疏 MoEs 和稠密模型？\"></a>何时选择稀疏 MoEs 和稠密模型？</h2><p>在多机器、高吞吐量的场景中，专家系统是非常有效的。如果预训练的计算预算有限，那么稀疏模型将是更佳的选择。对于 VRAM 较少、吞吐量低的情况，稠密模型则更为合适。</p>\n<p><strong>注意：</strong> 我们不能直接比较稀疏和稠密模型之间的参数数量，因为这两种模型代表的是完全不同的概念。</p>\n<ol>\n<li>稀疏模型：<ul>\n<li>定义：稀疏模型是一种模型设计策略，其中模型结构被设计为具有少量的参数或专家（Experts），每个专家对应于模型中的一个子模型。</li>\n<li>特点：<ul>\n<li>模型结构简单，仅包含少量的专家。s</li>\n<li>每个专家专注于处理特定的输入模式或任务。</li>\n<li>专家之间在参数空间上是相互独立的。</li>\n<li>在推理阶段，只有少量的专家被激活并参与预测，以提高计算效率。</li>\n</ul>\n</li>\n<li>优点：<ul>\n<li>可以处理复杂的输入模式，并对不同的任务进行专门化处理。</li>\n<li>可以节省模型的参数量和计算资源。</li>\n</ul>\n</li>\n<li>缺点：<ul>\n<li>需要设计合适的选择机制和激活策略，以确保在不同输入情况下激活合适的专家。</li>\n<li>对于一些特定的输入模式，可能需要较大的专家数量才能达到较好的性能。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>稠密模型：<ul>\n<li>定义：稠密模型是一种模型设计策略，其中模型结构被设计为具有更多的参数和层级，以便能够更全面地学习输入数据的特征和表示。</li>\n<li>特点：<ul>\n<li>模型结构相对更复杂，包含多个参数较多的层。</li>\n<li>在训练过程中，模型可以通过反向传播算法端到端地学习输入数据的特征。</li>\n<li>通常用于处理输入模式和任务较为均衡的情况。</li>\n</ul>\n</li>\n<li>优点：<ul>\n<li>可以捕获输入数据中更丰富的特征，并具有更强的表达能力。</li>\n<li>可以适应不同的输入模式和任务，并在训练过程中自动学习特征的权重和表示。</li>\n</ul>\n</li>\n<li>缺点：<ul>\n<li>参数较多，需要更多的计算资源和内存空间。</li>\n<li>在处理特定输入模式和任务时，可能存在过拟合的风险。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p>![[Pasted image 20240311104630.png]]</p>\n<h1 id=\"最新进展\"><a href=\"#最新进展\" class=\"headerlink\" title=\"最新进展\"></a>最新进展</h1><ul>\n<li><a href=\"https://link.zhihu.com/?target=https://arxiv.org/abs/1701.06538\">The Sparsely-Gated Mixture-of-Experts Layer (2017)</a><br>  <a href=\"https://link.zhihu.com/?target=https://arxiv.org/abs/1701.06538\">稀疏门控专家混合层（2017）</a></li>\n<li><a href=\"https://link.zhihu.com/?target=https://arxiv.org/abs/2006.16668\">GShard: Scaling Giant Models with Conditional Computation and Automatic Sharding (2020)</a><br>  <a href=\"https://link.zhihu.com/?target=https://arxiv.org/abs/2006.16668\">GShard：通过条件计算和自动分片扩展巨型模型（2020）</a></li>\n<li><a href=\"https://link.zhihu.com/?target=https://arxiv.org/abs/2211.15841\">MegaBlocks: Efficient Sparse Training with Mixture-of-Experts (2022)</a><br>  <a href=\"https://link.zhihu.com/?target=https://arxiv.org/abs/2211.15841\">MegaBlocks：高效稀疏训练与专家混合（2022）</a></li>\n<li><a href=\"https://link.zhihu.com/?target=https://arxiv.org/abs/2305.14705\">Mixture-of-Experts Meets Instruction Tuning (2023)</a><br>  <a href=\"https://link.zhihu.com/?target=https://arxiv.org/abs/2305.14705\">混合专家遇见指令调整（2023）</a></li>\n</ul>\n<p><a href=\"https://zhuanlan.zhihu.com/p/674162664\">万字长文详解 MoE - 超越ChatGPT的开源混合专家模型 - 知乎 (zhihu.com)</a></p>\n<p><a href=\"https://www.semanticscholar.org/paper/a6cb366736791bcccc5c8639de5a8f9636bf87e8\">1. Diederik P. Kingma, Jimmy Ba. “Adam: A Method for Stochastic Optimization.” International Conference on Learning Representations(2014).</a> </p>\n<p><a href=\"https://www.semanticscholar.org/paper/204e3073870fae3d05bcbc2f6a8e263d9b72e776\">2. Ashish Vaswani, Noam M. Shazeer et al. “Attention is All you Need.” Neural Information Processing Systems(2017).</a> </p>\n<p><a href=\"https://www.semanticscholar.org/paper/97fb4e3d45bb098e27e0071448b6152217bd35a5\">3. Jimmy Ba, J. Kiros et al. “Layer Normalization.” arXiv.org(2016).</a> </p>\n<p><a href=\"https://doi.org/10.48550/arXiv.2308.14352\">4. Rongjie Yi, Liwei Guo et al. “EdgeMoE: Fast On-Device Inference of MoE-based Large Language Models.” arXiv.org (2023).</a> </p>\n<p><a href=\"https://www.semanticscholar.org/paper/23894a64bcd7db9007c90fd201264d113e67b6a7\">5. Alexander Hauptmann. “From Syntax to Meaning in Natural Language Processing.” AAAI Conference on Artificial Intelligence (1991).</a> </p>\n<p><a href=\"https://doi.org/10.1145/3539597.3572720\">6. Chenguang Zhu, Yichong Xu et al. “Knowledge-Augmented Methods for Natural Language Processing.” Annual Meeting of the Association for Computational Linguistics (2023).</a> </p>\n<p><a href=\"https://doi.org/10.48161/QAJ.V1N2A44\">7. Dastan Hussen Maulud, Subhi R. M. Zeebaree et al. “State of Art for Semantic Analysis of Natural Language Processing.” Qubahan Academic Journal (2021).</a> </p>\n<p><a href=\"https://www.semanticscholar.org/paper/a1730ffaf9701f9bc66962fe3823f4c4404bccdd\">8. Neha Yadav. “Applications Associated With Morphological Analysis And Generation In Natural Language Processing.” (2017). 284-286.</a></p>\n"},{"_content":"生物老师:\n我想让你扮演一名生物老师。我将提供一些问题或概念，你的工作是用易于理解的术语来解释它们。这可能包括提供解决问题的分步说明、用视觉演示各种技术或建议在线资源以供进一步研究。\n\n马屁精：\n现在请你扮演一位马屁精，不管我说的内容有多么荒谬，你都能恰如其分的拍我的马屁\n\n文学老师:\n我想让你扮演一名大学文学老师。我将提供一些问题或概念，你的工作是精准回答我的问题，用易于理解的专业术语来解释它们。这可能包括提供解决问题的依据、纠正我的错误以及给出示例的等。\n\n\n内容: 使用 GPT-4, 设计 Prompt 优化 **图说数据库系统** 的文本内容.\n    \n- **基本要求:**\n    \n    - 优化自己负责部分的一个小节, 丰富内容, 优化章节结构, 语言风格等.\n        \n    - 采用将大问题分解为多个小问题的方式进行优化, 使用多个 Prompt 对比生成的结果. 最后, 对比丰富后与丰富前的文本. (保留优化前的文本)\n\n提升文章的独特性：\nRewrite the existing document tomake it more imaginative, engaging, and unique.\n\n将文档转为引|人入胜的故事：\nTransform the existingdocument into a compelling story that highlights thechallenges faced and the solutions provided.\n\n提升文档说服力：\nRefine the existing document byincorporating persuasive language and techniques tomake it more convincing and impactful.\n\n提升文档的吸引力：\nAdd emotional language and sensorydetails to the existing document to make it morerelatable and engaging.\n\n使内容更加简洁：\nRefine the existing document byremoving unnecessaryinformation and making it moreconcise and to-the-point.\n\n强调急迫感：\nRefine the existing document by adding asense of urgency and emphasizing the need forimmediate action.\n\n突出重点：\nEmphasize important information using boldor italic text.\n\n让模型使用类比或比喻的方法解释复杂问题：\nExplain complexideas using analogies or comparisons.\n\n添加现实中的例子：\nInclude case studies or real-worldexamples to make concepts more relatable.\n\n\n\n\n```\nChatGPT，我正在编辑一本名为《图说数据库》的专业书籍。我希望你能帮助我优化这本书中部分文本的内容和结构。以下是一些我需要你考虑的方面：\n\n1. 内容丰富：我希望你能根据我提供文字，结合文字的中心内容，把握住数据库的深入主题，进一步丰富专业表述，能够为读者提供更深入的理解和实践经验。\n\n2. 章节结构：我希望你能帮助我设计一个清晰、连贯的章节结构，这个结构应该能够帮助读者更好地理解和学习数据库的各个方面。\n\n3. 语言风格：我希望你能改进语言风格的建议，使得其中的内容既能够清晰地传达技术信息，又能够吸引和保持读者的兴趣。\n\n请你根据以上的要求，修改我之后给你发送的章节部分。\n```\n\n我想让你担任心理健康顾问。我将为您提供一个寻求指导和建议的人，以管理他们的情绪、压力、焦虑和其他心理健康问题。您应该利用您的认知行为疗法、冥想技巧、正念练习和其他治疗方法的知识来制定个人可以实施的策略，以改善他们的整体健康状况。我的第一个请求是“我需要一个可以帮助我控制抑郁症状的人。","source":"_posts/人工智能/大语言模型/Prompt.md","raw":"生物老师:\n我想让你扮演一名生物老师。我将提供一些问题或概念，你的工作是用易于理解的术语来解释它们。这可能包括提供解决问题的分步说明、用视觉演示各种技术或建议在线资源以供进一步研究。\n\n马屁精：\n现在请你扮演一位马屁精，不管我说的内容有多么荒谬，你都能恰如其分的拍我的马屁\n\n文学老师:\n我想让你扮演一名大学文学老师。我将提供一些问题或概念，你的工作是精准回答我的问题，用易于理解的专业术语来解释它们。这可能包括提供解决问题的依据、纠正我的错误以及给出示例的等。\n\n\n内容: 使用 GPT-4, 设计 Prompt 优化 **图说数据库系统** 的文本内容.\n    \n- **基本要求:**\n    \n    - 优化自己负责部分的一个小节, 丰富内容, 优化章节结构, 语言风格等.\n        \n    - 采用将大问题分解为多个小问题的方式进行优化, 使用多个 Prompt 对比生成的结果. 最后, 对比丰富后与丰富前的文本. (保留优化前的文本)\n\n提升文章的独特性：\nRewrite the existing document tomake it more imaginative, engaging, and unique.\n\n将文档转为引|人入胜的故事：\nTransform the existingdocument into a compelling story that highlights thechallenges faced and the solutions provided.\n\n提升文档说服力：\nRefine the existing document byincorporating persuasive language and techniques tomake it more convincing and impactful.\n\n提升文档的吸引力：\nAdd emotional language and sensorydetails to the existing document to make it morerelatable and engaging.\n\n使内容更加简洁：\nRefine the existing document byremoving unnecessaryinformation and making it moreconcise and to-the-point.\n\n强调急迫感：\nRefine the existing document by adding asense of urgency and emphasizing the need forimmediate action.\n\n突出重点：\nEmphasize important information using boldor italic text.\n\n让模型使用类比或比喻的方法解释复杂问题：\nExplain complexideas using analogies or comparisons.\n\n添加现实中的例子：\nInclude case studies or real-worldexamples to make concepts more relatable.\n\n\n\n\n```\nChatGPT，我正在编辑一本名为《图说数据库》的专业书籍。我希望你能帮助我优化这本书中部分文本的内容和结构。以下是一些我需要你考虑的方面：\n\n1. 内容丰富：我希望你能根据我提供文字，结合文字的中心内容，把握住数据库的深入主题，进一步丰富专业表述，能够为读者提供更深入的理解和实践经验。\n\n2. 章节结构：我希望你能帮助我设计一个清晰、连贯的章节结构，这个结构应该能够帮助读者更好地理解和学习数据库的各个方面。\n\n3. 语言风格：我希望你能改进语言风格的建议，使得其中的内容既能够清晰地传达技术信息，又能够吸引和保持读者的兴趣。\n\n请你根据以上的要求，修改我之后给你发送的章节部分。\n```\n\n我想让你担任心理健康顾问。我将为您提供一个寻求指导和建议的人，以管理他们的情绪、压力、焦虑和其他心理健康问题。您应该利用您的认知行为疗法、冥想技巧、正念练习和其他治疗方法的知识来制定个人可以实施的策略，以改善他们的整体健康状况。我的第一个请求是“我需要一个可以帮助我控制抑郁症状的人。","slug":"人工智能/大语言模型/Prompt","published":1,"date":"2024-04-22T13:14:48.983Z","updated":"2024-03-12T12:37:56.080Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0o0025kgg43l7f9w1f","content":"<p>生物老师:<br>我想让你扮演一名生物老师。我将提供一些问题或概念，你的工作是用易于理解的术语来解释它们。这可能包括提供解决问题的分步说明、用视觉演示各种技术或建议在线资源以供进一步研究。</p>\n<p>马屁精：<br>现在请你扮演一位马屁精，不管我说的内容有多么荒谬，你都能恰如其分的拍我的马屁</p>\n<p>文学老师:<br>我想让你扮演一名大学文学老师。我将提供一些问题或概念，你的工作是精准回答我的问题，用易于理解的专业术语来解释它们。这可能包括提供解决问题的依据、纠正我的错误以及给出示例的等。</p>\n<p>内容: 使用 GPT-4, 设计 Prompt 优化 <strong>图说数据库系统</strong> 的文本内容.</p>\n<ul>\n<li><p><strong>基本要求:</strong></p>\n<ul>\n<li><p>优化自己负责部分的一个小节, 丰富内容, 优化章节结构, 语言风格等.</p>\n</li>\n<li><p>采用将大问题分解为多个小问题的方式进行优化, 使用多个 Prompt 对比生成的结果. 最后, 对比丰富后与丰富前的文本. (保留优化前的文本)</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>提升文章的独特性：<br>Rewrite the existing document tomake it more imaginative, engaging, and unique.</p>\n<p>将文档转为引|人入胜的故事：<br>Transform the existingdocument into a compelling story that highlights thechallenges faced and the solutions provided.</p>\n<p>提升文档说服力：<br>Refine the existing document byincorporating persuasive language and techniques tomake it more convincing and impactful.</p>\n<p>提升文档的吸引力：<br>Add emotional language and sensorydetails to the existing document to make it morerelatable and engaging.</p>\n<p>使内容更加简洁：<br>Refine the existing document byremoving unnecessaryinformation and making it moreconcise and to-the-point.</p>\n<p>强调急迫感：<br>Refine the existing document by adding asense of urgency and emphasizing the need forimmediate action.</p>\n<p>突出重点：<br>Emphasize important information using boldor italic text.</p>\n<p>让模型使用类比或比喻的方法解释复杂问题：<br>Explain complexideas using analogies or comparisons.</p>\n<p>添加现实中的例子：<br>Include case studies or real-worldexamples to make concepts more relatable.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ChatGPT，我正在编辑一本名为《图说数据库》的专业书籍。我希望你能帮助我优化这本书中部分文本的内容和结构。以下是一些我需要你考虑的方面：</span><br><span class=\"line\"></span><br><span class=\"line\">1. 内容丰富：我希望你能根据我提供文字，结合文字的中心内容，把握住数据库的深入主题，进一步丰富专业表述，能够为读者提供更深入的理解和实践经验。</span><br><span class=\"line\"></span><br><span class=\"line\">2. 章节结构：我希望你能帮助我设计一个清晰、连贯的章节结构，这个结构应该能够帮助读者更好地理解和学习数据库的各个方面。</span><br><span class=\"line\"></span><br><span class=\"line\">3. 语言风格：我希望你能改进语言风格的建议，使得其中的内容既能够清晰地传达技术信息，又能够吸引和保持读者的兴趣。</span><br><span class=\"line\"></span><br><span class=\"line\">请你根据以上的要求，修改我之后给你发送的章节部分。</span><br></pre></td></tr></table></figure>\n\n<p>我想让你担任心理健康顾问。我将为您提供一个寻求指导和建议的人，以管理他们的情绪、压力、焦虑和其他心理健康问题。您应该利用您的认知行为疗法、冥想技巧、正念练习和其他治疗方法的知识来制定个人可以实施的策略，以改善他们的整体健康状况。我的第一个请求是“我需要一个可以帮助我控制抑郁症状的人。</p>\n","excerpt":"","more":"<p>生物老师:<br>我想让你扮演一名生物老师。我将提供一些问题或概念，你的工作是用易于理解的术语来解释它们。这可能包括提供解决问题的分步说明、用视觉演示各种技术或建议在线资源以供进一步研究。</p>\n<p>马屁精：<br>现在请你扮演一位马屁精，不管我说的内容有多么荒谬，你都能恰如其分的拍我的马屁</p>\n<p>文学老师:<br>我想让你扮演一名大学文学老师。我将提供一些问题或概念，你的工作是精准回答我的问题，用易于理解的专业术语来解释它们。这可能包括提供解决问题的依据、纠正我的错误以及给出示例的等。</p>\n<p>内容: 使用 GPT-4, 设计 Prompt 优化 <strong>图说数据库系统</strong> 的文本内容.</p>\n<ul>\n<li><p><strong>基本要求:</strong></p>\n<ul>\n<li><p>优化自己负责部分的一个小节, 丰富内容, 优化章节结构, 语言风格等.</p>\n</li>\n<li><p>采用将大问题分解为多个小问题的方式进行优化, 使用多个 Prompt 对比生成的结果. 最后, 对比丰富后与丰富前的文本. (保留优化前的文本)</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>提升文章的独特性：<br>Rewrite the existing document tomake it more imaginative, engaging, and unique.</p>\n<p>将文档转为引|人入胜的故事：<br>Transform the existingdocument into a compelling story that highlights thechallenges faced and the solutions provided.</p>\n<p>提升文档说服力：<br>Refine the existing document byincorporating persuasive language and techniques tomake it more convincing and impactful.</p>\n<p>提升文档的吸引力：<br>Add emotional language and sensorydetails to the existing document to make it morerelatable and engaging.</p>\n<p>使内容更加简洁：<br>Refine the existing document byremoving unnecessaryinformation and making it moreconcise and to-the-point.</p>\n<p>强调急迫感：<br>Refine the existing document by adding asense of urgency and emphasizing the need forimmediate action.</p>\n<p>突出重点：<br>Emphasize important information using boldor italic text.</p>\n<p>让模型使用类比或比喻的方法解释复杂问题：<br>Explain complexideas using analogies or comparisons.</p>\n<p>添加现实中的例子：<br>Include case studies or real-worldexamples to make concepts more relatable.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ChatGPT，我正在编辑一本名为《图说数据库》的专业书籍。我希望你能帮助我优化这本书中部分文本的内容和结构。以下是一些我需要你考虑的方面：</span><br><span class=\"line\"></span><br><span class=\"line\">1. 内容丰富：我希望你能根据我提供文字，结合文字的中心内容，把握住数据库的深入主题，进一步丰富专业表述，能够为读者提供更深入的理解和实践经验。</span><br><span class=\"line\"></span><br><span class=\"line\">2. 章节结构：我希望你能帮助我设计一个清晰、连贯的章节结构，这个结构应该能够帮助读者更好地理解和学习数据库的各个方面。</span><br><span class=\"line\"></span><br><span class=\"line\">3. 语言风格：我希望你能改进语言风格的建议，使得其中的内容既能够清晰地传达技术信息，又能够吸引和保持读者的兴趣。</span><br><span class=\"line\"></span><br><span class=\"line\">请你根据以上的要求，修改我之后给你发送的章节部分。</span><br></pre></td></tr></table></figure>\n\n<p>我想让你担任心理健康顾问。我将为您提供一个寻求指导和建议的人，以管理他们的情绪、压力、焦虑和其他心理健康问题。您应该利用您的认知行为疗法、冥想技巧、正念练习和其他治疗方法的知识来制定个人可以实施的策略，以改善他们的整体健康状况。我的第一个请求是“我需要一个可以帮助我控制抑郁症状的人。</p>\n"},{"_content":"\n\n\n\n![[Pasted image 20240303155734.png]]\n\n\n\n\nChatGPT基于循环神经网络（RNN）和注意力机制的模型架构。它是一个生成式模型，可以根据之前的聊天信息生成响应。\n\n模型的原理如下：\n\n1. 输入编码：在每个对话轮次中，聊天历史被编码为一个输入向量序列。这些向量可以是词向量、字符向量或其他表示形式，根据具体的实现方式而定。\n    \n2. 上下文理解：模型使用编码后的输入向量序列，通过循环神经网络（如长短期记忆网络，LSTM）或变种（如GPT-3中的Transformer网络）来理解上下文。这些模型会捕捉到前面对话中的语义和语法结构，并对其进行建模。\n    \n3. 注意力机制：模型使用注意力机制来关注历史上下文中与当前生成响应相关的部分。通过对不同部分的注意力分配权重，模型可以更好地理解和应答对话。\n    \n4. 响应生成：模型将上下文理解与当前对话的目标进行合并，然后通过解码器生成响应。解码器会根据上下文和已生成内容预测下一个最有可能的词或子序列。\n    \n5. 迭代训练：模型通过最大似然估计（MLE）或其他适当的训练目标进行训练，以使生成的响应与训练数据中的目标响应尽可能一致。\n    \n6. 上下文维护：模型会维护一个有限的上下文窗口，以限制对话历史的长度。这有助于控制模型的记忆和计算需求，并防止信息过载。\n\n\n\n在每个对话轮次中，聊天历史被编码为一个输入向量序列。这些向量可以是词向量、字符向量或其他表示形式，根据具体的实现方式而定。模型使用编码后的输入向量序列，通过循环神经网络（如长短期记忆网络，LSTM）或变种（如GPT-3中的Transformer网络）来理解上下文，这些模型会捕捉到前面对话中的语义和语法结构，并对其进行建模。模型将上下文理解与当前对话的目标进行合并，然后通过解码器生成响应。模型会维护一个有限的上下文窗口，以限制对话历史的长度。这有助于控制模型的记忆和计算需求，并防止信息过载。\n\n这里 memory 模块 保持一个聊天记录的列表，作为历史记录的缓冲区，并且每次都将这些消息与问题一起传递给聊天机器人。\n\n在每个对话轮次中，ChatGPT通过将聊天历史编码为一个输入向量序列来处理上下文信息。这些向量可以采用词向量、字符向量或其他形式的表示，具体取决于实现的方式。\n\n然后，通过使用神经网络（如GPT-3中的Transformer网络），模型能够全面理解上下文，并捕捉前面对话中的语义和语法结构。这样，模型可以建立起对对话历史的深入理解。\n\n模型将上下文理解与当前对话目标相结合，然后通过解码器生成响应。解码器利用上下文信息和已经生成的内容来预测下一个最可能的词或子序列，从而生成连贯的回复。\n\n为了控制模型的记忆和计算需求，并避免信息过载，ChatGPT维护一个有限的上下文窗口，限制对话历史的长度。这种方式确保模型在适应多轮对话时能够保持高效性，并生成准确、有逻辑的回应。","source":"_posts/人工智能/大语言模型/RAG 项目.md","raw":"\n\n\n\n![[Pasted image 20240303155734.png]]\n\n\n\n\nChatGPT基于循环神经网络（RNN）和注意力机制的模型架构。它是一个生成式模型，可以根据之前的聊天信息生成响应。\n\n模型的原理如下：\n\n1. 输入编码：在每个对话轮次中，聊天历史被编码为一个输入向量序列。这些向量可以是词向量、字符向量或其他表示形式，根据具体的实现方式而定。\n    \n2. 上下文理解：模型使用编码后的输入向量序列，通过循环神经网络（如长短期记忆网络，LSTM）或变种（如GPT-3中的Transformer网络）来理解上下文。这些模型会捕捉到前面对话中的语义和语法结构，并对其进行建模。\n    \n3. 注意力机制：模型使用注意力机制来关注历史上下文中与当前生成响应相关的部分。通过对不同部分的注意力分配权重，模型可以更好地理解和应答对话。\n    \n4. 响应生成：模型将上下文理解与当前对话的目标进行合并，然后通过解码器生成响应。解码器会根据上下文和已生成内容预测下一个最有可能的词或子序列。\n    \n5. 迭代训练：模型通过最大似然估计（MLE）或其他适当的训练目标进行训练，以使生成的响应与训练数据中的目标响应尽可能一致。\n    \n6. 上下文维护：模型会维护一个有限的上下文窗口，以限制对话历史的长度。这有助于控制模型的记忆和计算需求，并防止信息过载。\n\n\n\n在每个对话轮次中，聊天历史被编码为一个输入向量序列。这些向量可以是词向量、字符向量或其他表示形式，根据具体的实现方式而定。模型使用编码后的输入向量序列，通过循环神经网络（如长短期记忆网络，LSTM）或变种（如GPT-3中的Transformer网络）来理解上下文，这些模型会捕捉到前面对话中的语义和语法结构，并对其进行建模。模型将上下文理解与当前对话的目标进行合并，然后通过解码器生成响应。模型会维护一个有限的上下文窗口，以限制对话历史的长度。这有助于控制模型的记忆和计算需求，并防止信息过载。\n\n这里 memory 模块 保持一个聊天记录的列表，作为历史记录的缓冲区，并且每次都将这些消息与问题一起传递给聊天机器人。\n\n在每个对话轮次中，ChatGPT通过将聊天历史编码为一个输入向量序列来处理上下文信息。这些向量可以采用词向量、字符向量或其他形式的表示，具体取决于实现的方式。\n\n然后，通过使用神经网络（如GPT-3中的Transformer网络），模型能够全面理解上下文，并捕捉前面对话中的语义和语法结构。这样，模型可以建立起对对话历史的深入理解。\n\n模型将上下文理解与当前对话目标相结合，然后通过解码器生成响应。解码器利用上下文信息和已经生成的内容来预测下一个最可能的词或子序列，从而生成连贯的回复。\n\n为了控制模型的记忆和计算需求，并避免信息过载，ChatGPT维护一个有限的上下文窗口，限制对话历史的长度。这种方式确保模型在适应多轮对话时能够保持高效性，并生成准确、有逻辑的回应。","slug":"人工智能/大语言模型/RAG 项目","published":1,"date":"2024-04-22T13:14:48.983Z","updated":"2024-03-04T02:37:26.601Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0o0026kgg48f4fcqyl","content":"<p>![[Pasted image 20240303155734.png]]</p>\n<p>ChatGPT基于循环神经网络（RNN）和注意力机制的模型架构。它是一个生成式模型，可以根据之前的聊天信息生成响应。</p>\n<p>模型的原理如下：</p>\n<ol>\n<li><p>输入编码：在每个对话轮次中，聊天历史被编码为一个输入向量序列。这些向量可以是词向量、字符向量或其他表示形式，根据具体的实现方式而定。</p>\n</li>\n<li><p>上下文理解：模型使用编码后的输入向量序列，通过循环神经网络（如长短期记忆网络，LSTM）或变种（如GPT-3中的Transformer网络）来理解上下文。这些模型会捕捉到前面对话中的语义和语法结构，并对其进行建模。</p>\n</li>\n<li><p>注意力机制：模型使用注意力机制来关注历史上下文中与当前生成响应相关的部分。通过对不同部分的注意力分配权重，模型可以更好地理解和应答对话。</p>\n</li>\n<li><p>响应生成：模型将上下文理解与当前对话的目标进行合并，然后通过解码器生成响应。解码器会根据上下文和已生成内容预测下一个最有可能的词或子序列。</p>\n</li>\n<li><p>迭代训练：模型通过最大似然估计（MLE）或其他适当的训练目标进行训练，以使生成的响应与训练数据中的目标响应尽可能一致。</p>\n</li>\n<li><p>上下文维护：模型会维护一个有限的上下文窗口，以限制对话历史的长度。这有助于控制模型的记忆和计算需求，并防止信息过载。</p>\n</li>\n</ol>\n<p>在每个对话轮次中，聊天历史被编码为一个输入向量序列。这些向量可以是词向量、字符向量或其他表示形式，根据具体的实现方式而定。模型使用编码后的输入向量序列，通过循环神经网络（如长短期记忆网络，LSTM）或变种（如GPT-3中的Transformer网络）来理解上下文，这些模型会捕捉到前面对话中的语义和语法结构，并对其进行建模。模型将上下文理解与当前对话的目标进行合并，然后通过解码器生成响应。模型会维护一个有限的上下文窗口，以限制对话历史的长度。这有助于控制模型的记忆和计算需求，并防止信息过载。</p>\n<p>这里 memory 模块 保持一个聊天记录的列表，作为历史记录的缓冲区，并且每次都将这些消息与问题一起传递给聊天机器人。</p>\n<p>在每个对话轮次中，ChatGPT通过将聊天历史编码为一个输入向量序列来处理上下文信息。这些向量可以采用词向量、字符向量或其他形式的表示，具体取决于实现的方式。</p>\n<p>然后，通过使用神经网络（如GPT-3中的Transformer网络），模型能够全面理解上下文，并捕捉前面对话中的语义和语法结构。这样，模型可以建立起对对话历史的深入理解。</p>\n<p>模型将上下文理解与当前对话目标相结合，然后通过解码器生成响应。解码器利用上下文信息和已经生成的内容来预测下一个最可能的词或子序列，从而生成连贯的回复。</p>\n<p>为了控制模型的记忆和计算需求，并避免信息过载，ChatGPT维护一个有限的上下文窗口，限制对话历史的长度。这种方式确保模型在适应多轮对话时能够保持高效性，并生成准确、有逻辑的回应。</p>\n","excerpt":"","more":"<p>![[Pasted image 20240303155734.png]]</p>\n<p>ChatGPT基于循环神经网络（RNN）和注意力机制的模型架构。它是一个生成式模型，可以根据之前的聊天信息生成响应。</p>\n<p>模型的原理如下：</p>\n<ol>\n<li><p>输入编码：在每个对话轮次中，聊天历史被编码为一个输入向量序列。这些向量可以是词向量、字符向量或其他表示形式，根据具体的实现方式而定。</p>\n</li>\n<li><p>上下文理解：模型使用编码后的输入向量序列，通过循环神经网络（如长短期记忆网络，LSTM）或变种（如GPT-3中的Transformer网络）来理解上下文。这些模型会捕捉到前面对话中的语义和语法结构，并对其进行建模。</p>\n</li>\n<li><p>注意力机制：模型使用注意力机制来关注历史上下文中与当前生成响应相关的部分。通过对不同部分的注意力分配权重，模型可以更好地理解和应答对话。</p>\n</li>\n<li><p>响应生成：模型将上下文理解与当前对话的目标进行合并，然后通过解码器生成响应。解码器会根据上下文和已生成内容预测下一个最有可能的词或子序列。</p>\n</li>\n<li><p>迭代训练：模型通过最大似然估计（MLE）或其他适当的训练目标进行训练，以使生成的响应与训练数据中的目标响应尽可能一致。</p>\n</li>\n<li><p>上下文维护：模型会维护一个有限的上下文窗口，以限制对话历史的长度。这有助于控制模型的记忆和计算需求，并防止信息过载。</p>\n</li>\n</ol>\n<p>在每个对话轮次中，聊天历史被编码为一个输入向量序列。这些向量可以是词向量、字符向量或其他表示形式，根据具体的实现方式而定。模型使用编码后的输入向量序列，通过循环神经网络（如长短期记忆网络，LSTM）或变种（如GPT-3中的Transformer网络）来理解上下文，这些模型会捕捉到前面对话中的语义和语法结构，并对其进行建模。模型将上下文理解与当前对话的目标进行合并，然后通过解码器生成响应。模型会维护一个有限的上下文窗口，以限制对话历史的长度。这有助于控制模型的记忆和计算需求，并防止信息过载。</p>\n<p>这里 memory 模块 保持一个聊天记录的列表，作为历史记录的缓冲区，并且每次都将这些消息与问题一起传递给聊天机器人。</p>\n<p>在每个对话轮次中，ChatGPT通过将聊天历史编码为一个输入向量序列来处理上下文信息。这些向量可以采用词向量、字符向量或其他形式的表示，具体取决于实现的方式。</p>\n<p>然后，通过使用神经网络（如GPT-3中的Transformer网络），模型能够全面理解上下文，并捕捉前面对话中的语义和语法结构。这样，模型可以建立起对对话历史的深入理解。</p>\n<p>模型将上下文理解与当前对话目标相结合，然后通过解码器生成响应。解码器利用上下文信息和已经生成的内容来预测下一个最可能的词或子序列，从而生成连贯的回复。</p>\n<p>为了控制模型的记忆和计算需求，并避免信息过载，ChatGPT维护一个有限的上下文窗口，限制对话历史的长度。这种方式确保模型在适应多轮对话时能够保持高效性，并生成准确、有逻辑的回应。</p>\n"},{"_content":"[[RAG 项目]]\n# 概念\n检索增强生成（RAG——Retrieval **Augmented** Generation）是指对大型语言模型输出进行优化，使其能够在生成响应之前引用训练数据来源之外的权威知识库。大型语言模型（LLM）用海量数据进行训练，使用数十亿个参数为回答问题、翻译语言和完成句子等任务生成原始输出。在 LLM 本就强大的功能基础上，RAG 将其扩展为能访问特定领域或组织的内部知识库，所有这些都无需重新训练模型。这是一种经济高效地改进 LLM 输出的方法，让它在各种情境下都能保持相关性、准确性和实用性。\n\n```\n会拿这个权威知识库进行训练嘛？\n\n```\n\n![[Pasted image 20240303130455.png]]\n数据提取——embedding（向量化）——创建索引——检索——自动排序（Rerank）——LLM归纳生成\n\nLLM 面临的已知挑战包括：\n- 在没有答案的情况下提供虚假信息。\n- 当用户需要特定的当前响应时，提供过时或通用的信息。\n- 从非权威来源创建响应。\n- 由于术语混淆，不同的培训来源使用相同的术语来谈论不同的事情，因此会产生不准确的响应。\n\n\n\n## Lang Chain 起源\n\n像 ChatGPT 这样的 大语言模型 或者 LLM 可以回答许多话题的问题，但是，一个孤立的 LLM 只知道它的训练内容，这并不包括某些个人信息数据，如果您可以和这些数据与 LLM 进行对话，就会非常有用\n\n\n## Lang Chain 介绍\n用于构建 LLM 应用的开源开发框架\n\n## Lang Chain 组件\n1. prompts 提示\n2. models 模型\n3. indexes 索引\n4. chains 链\n5. agents 代理\n## Lang Chain 使用——如何与数据对话\n\n![[Pasted image 20240303174734.png]]\n核心：\n1. 向量存储\n\t1. 加载数据\n\t2. 拆分为有意义的块\n2. 索引--检索文档\n\t1. 语义搜索：最简单的方式\n3. 使得 LLM 能回答 文档相关内容\n4. 记忆功能\n### 文档加载器\n从不同格式和来源的数据中访问和转换数据的具体细节，转换为标准化格式，即加载到一个标准的文档对象中，该对象由内容和相关元数据组成。\n> Lang Chain 中有 80 种 数据加载器\n```python\n# 例\nfrom langchain.document_loaders import PyPDFLoader\nloader = PyPDFLoader(\"docs/cs229_lectures/MachineLearning-Lecture01.pdf\")\npages = loader.load()\n\n# 例\nfrom langchain.document_loaders import WebBaseLoader\n\nloader = WebBaseLoader(\"https://github.com/basecamp/handbook/blob/master/37signals-is-you.md\")\ndocs = loader.load()\n```\n\n文档加载器之间可以组合为一个通用加载器\n```python\nfrom langchain.document_loaders.generic import GenericLoader\nfrom langchain.document_loaders.parsers import OpenAIWhisperParser\nfrom langchain.document_loaders.blob_loaders.youtube_audio import YoutubeAudioLoader\n# ! pip install yt_dlp\n# ! pip install pydub\nurl=\"https://www.youtube.com/watch?v=jGwO_UgTS7I\"\nsave_dir=\"docs/youtube/\"\nloader = GenericLoader(\n    YoutubeAudioLoader([url],save_dir),\n    OpenAIWhisperParser()\n)\ndocs = loader.load()\ndocs[0].page_content[0:500]\n```\n> 可以同时加载多个文件\n```python\nfrom langchain.document_loaders import PyPDFLoader\n\n# Load PDF\nloaders = [\n    # Duplicate documents on purpose - messy data\n    PyPDFLoader(\"docs/cs229_lectures/MachineLearning-Lecture01.pdf\"),\n    PyPDFLoader(\"docs/cs229_lectures/MachineLearning-Lecture01.pdf\"),\n    PyPDFLoader(\"docs/cs229_lectures/MachineLearning-Lecture02.pdf\"),\n    PyPDFLoader(\"docs/cs229_lectures/MachineLearning-Lecture03.pdf\")\n]\ndocs = []\nfor loader in loaders:\n    docs.extend(loader.load())\n```\n### 字符切割\n\n> 为什么需要字符切割\n\nRAG是一种基于检索的生成模型，它结合了检索和生成的能力。在RAG中，检索阶段用于从大型文本语料库中检索相关的上下文，然后再通过生成阶段生成响应或答案。\n\n切割文本可以帮助RAG模型更好地处理长文本，并提高生成的效率和质量。长文本可能包含大量冗余信息或无关信息，这可能会对模型的性能产生负面影响。通过将文本切割成较小的片段，RAG模型可以在生成阶段更好地处理和理解这些部分，并减少不必要的计算。\n\n另外，文本切割还可以帮助限制输入的长度，以满足模型的输入限制或资源限制。通过将文本切割成块，可以更好地管理模型的内存和计算需求。\n\n总的来说，在转换为向量存储之前，还要对原始数据分为有意义的块，作为后续索引的单位？？。\n\n![[Pasted image 20240303183026.png]]\n#### 导入包\n\n##### 第一类\n```python\n# 例，还有其他分割器，基于文本\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter, CharacterTextSplitter\n```\n\nRecursiveCharacterTextSplitter\"和\"CharacterTextSplitter\"都是用于文本分割的类，但它们有不同的实现方式和适用场景。\n\n1. RecursiveCharacterTextSplitter（递归字符文本分割器）：\n    \n    - 递归字符文本分割器是基于递归的分割方法，它将文本逐层地切割成更小的片段。\n    - 它使用递归算法，将文本分割成单个字符或字符的子序列。例如，将\"Hello\"分割为[\"H\", \"e\", \"l\", \"l\", \"o\"]。\n    - 递归字符文本分割器适用于一些需要对文本进行字符级别处理的任务，例如生成文本的字符级别表示或字符级别的语言建模。\n2. CharacterTextSplitter（字符文本分割器）：\n    \n    - 字符文本分割器是将文本按照固定长度切割成块的方法。\n    - 它将文本按照指定的块大小分割成连续的字符序列。例如，将\"Hello, world!\"以块大小为5分割为[\"Hello\", \", wor\", \"ld!\"]。\n    - 字符文本分割器适用于一些需要对文本进行块级别处理的任务，例如将文本输入模型进行批处理或限制输入长度。\n    - 默认的分隔符是‘\\n’，如果没有这个分隔符，即使到达 长度也不会分隔。\n    - 带有回溯的正则表示\n##### 第二类\n```python\n# 基于 token\nfrom langchain.text_splitter import TokenTextSplitter\ntext_splitter = TokenTextSplitter(chunk_size=1, chunk_overlap=0)\n\n```\n因为有许多基于 token 计数设计的 LLM 上下文窗口\n##### 第三类\n```python\n# 会为块，添加元数据信息\n# 例 \nfrom langchain.document_loaders import NotionDirectoryLoader\nfrom langchain.text_splitter import MarkdownHeaderTextSplitter\nmarkdown_document = \"\"\"# Title\\n\\n \\\n## Chapter 1\\n\\n \\\nHi this is Jim\\n\\n Hi this is Joe\\n\\n \\\n### Section \\n\\n \\\nHi this is Lance \\n\\n \n## Chapter 2\\n\\n \\\nHi this is Molly\"\"\"\nheaders_to_split_on = [\n    (\"#\", \"Header 1\"),\n    (\"##\", \"Header 2\"),\n    (\"###\", \"Header 3\"),\n]\n\nmarkdown_splitter = MarkdownHeaderTextSplitter(\n    headers_to_split_on=headers_to_split_on\n)\nmd_header_splits = markdown_splitter.split_text(markdown_document)\n\nmd_header_splits[0]\n\n# 切割的  Hi this is Jim\\n\\n Hi this is Joe\\n\\n \\ 的元数据中会有 head1 和 head2 \n```\n####  包的使用\n只有两个成员函数\n```python\ncreate_documents()\nsplit_documents()\n```\n\n```python\n# 回溯\nr_splitter = RecursiveCharacterTextSplitter(\n    chunk_size=150,\n    chunk_overlap=0,\n    separators=[\"\\n\\n\", \"\\n\", \"(?<=\\. )\", \" \", \"\"]\n)\nr_splitter.split_text(some_text)\n```\n### 嵌入\n将文本转为数字格式\n将块放入索引之中 \n#### 转换为向量\n```python\nfrom langchain.embeddings.openai import OpenAIEmbeddings\nembedding = OpenAIEmbeddings()\n\nsentence1 = \"i like dogs\"\nsentence2 = \"i like canines\"\nsentence3 = \"the weather is ugly outside\"\n\nembedding1 = embedding.embed_query(sentence1)\nembedding2 = embedding.embed_query(sentence2)\nembedding3 = embedding.embed_query(sentence3)\n\nimport numpy as np\n\nnp.dot(embedding1, embedding2)\nnp.dot(embedding1, embedding3)\nnp.dot(embedding2, embedding3)\n\n\n```\n#### 向量存储与使用\n```python \n# ! pip install chromadb\n\nfrom langchain.vectorstores import Chroma\npersist_directory = 'docs/chroma/'\n!rm -rf ./docs/chroma  # remove old database files if any\nvectordb = Chroma.from_documents(\n    documents=splits,\n    embedding=embedding,\n    persist_directory=persist_directory\n)\nprint(vectordb._collection.count())\n\n# 持久化存储\nvectordb.persist()\n\n# 使用，基本查询，寓意相似性查询\nquestion = \"is there an email i can ask for help\"\ndocs = vectordb.similarity_search(question,k=3) # 3个最佳结果\n\nlen(docs)\n  \ndocs[0].page_content\n\n\n\n```\n#### 边缘情况检索的失效问题\n\n原因：基于语义进行查找。\n1. 重复的查询结果\n2. 查询不能准确把握语义\n\n### 高级检索\n#### MMR 最大边际相关性\n如果选择与嵌入空间中查询最相似的文档，实际上可能会错过一些多样化的信息\n指定搜索源\n这样做的代价是需要对语言模型进行更多的调用，但密非常适合将最终答案集中在最重要的内容上\n\n#### 对话检索链\n在检索问答链的基础上添加了一个新的部分，不仅有记忆，它将历史记录和新问题压缩成一个独立的问题以便传递给向量存储以查找相关文档\n\n### 记忆功能\n保持一个聊天记录的列表，作为历史记录的缓冲区，并且每次都将这些消息与问题一起传递给聊天机器人。\n\nFeel free to copy this code and modify it to add your own features. You can try alternate memory and retriever models by changing the configuration in `load_db` function and the `convchain` method. [Panel](https://panel.holoviz.org/) and [Param](https://param.holoviz.org/) have many useful features and widgets you can use to extend the GUI.\n请随意复制此代码并对其进行修改以添加您自己的功能。 您可以通过更改“load_db”函数和“convchain”方法中的配置来尝试替代内存和检索器模型。 [Panel](https://panel.holoviz.org/) 和 [Param](https://param.holoviz.org/) 有许多有用的功能和小部件，可用于扩展 GUI。\n\n\n\n```python\n pip3  install -U docarray\n```\n\n```python\n\npip3  install pydantic==1.10.9\n```","source":"_posts/人工智能/大语言模型/RAG 检索增强.md","raw":"[[RAG 项目]]\n# 概念\n检索增强生成（RAG——Retrieval **Augmented** Generation）是指对大型语言模型输出进行优化，使其能够在生成响应之前引用训练数据来源之外的权威知识库。大型语言模型（LLM）用海量数据进行训练，使用数十亿个参数为回答问题、翻译语言和完成句子等任务生成原始输出。在 LLM 本就强大的功能基础上，RAG 将其扩展为能访问特定领域或组织的内部知识库，所有这些都无需重新训练模型。这是一种经济高效地改进 LLM 输出的方法，让它在各种情境下都能保持相关性、准确性和实用性。\n\n```\n会拿这个权威知识库进行训练嘛？\n\n```\n\n![[Pasted image 20240303130455.png]]\n数据提取——embedding（向量化）——创建索引——检索——自动排序（Rerank）——LLM归纳生成\n\nLLM 面临的已知挑战包括：\n- 在没有答案的情况下提供虚假信息。\n- 当用户需要特定的当前响应时，提供过时或通用的信息。\n- 从非权威来源创建响应。\n- 由于术语混淆，不同的培训来源使用相同的术语来谈论不同的事情，因此会产生不准确的响应。\n\n\n\n## Lang Chain 起源\n\n像 ChatGPT 这样的 大语言模型 或者 LLM 可以回答许多话题的问题，但是，一个孤立的 LLM 只知道它的训练内容，这并不包括某些个人信息数据，如果您可以和这些数据与 LLM 进行对话，就会非常有用\n\n\n## Lang Chain 介绍\n用于构建 LLM 应用的开源开发框架\n\n## Lang Chain 组件\n1. prompts 提示\n2. models 模型\n3. indexes 索引\n4. chains 链\n5. agents 代理\n## Lang Chain 使用——如何与数据对话\n\n![[Pasted image 20240303174734.png]]\n核心：\n1. 向量存储\n\t1. 加载数据\n\t2. 拆分为有意义的块\n2. 索引--检索文档\n\t1. 语义搜索：最简单的方式\n3. 使得 LLM 能回答 文档相关内容\n4. 记忆功能\n### 文档加载器\n从不同格式和来源的数据中访问和转换数据的具体细节，转换为标准化格式，即加载到一个标准的文档对象中，该对象由内容和相关元数据组成。\n> Lang Chain 中有 80 种 数据加载器\n```python\n# 例\nfrom langchain.document_loaders import PyPDFLoader\nloader = PyPDFLoader(\"docs/cs229_lectures/MachineLearning-Lecture01.pdf\")\npages = loader.load()\n\n# 例\nfrom langchain.document_loaders import WebBaseLoader\n\nloader = WebBaseLoader(\"https://github.com/basecamp/handbook/blob/master/37signals-is-you.md\")\ndocs = loader.load()\n```\n\n文档加载器之间可以组合为一个通用加载器\n```python\nfrom langchain.document_loaders.generic import GenericLoader\nfrom langchain.document_loaders.parsers import OpenAIWhisperParser\nfrom langchain.document_loaders.blob_loaders.youtube_audio import YoutubeAudioLoader\n# ! pip install yt_dlp\n# ! pip install pydub\nurl=\"https://www.youtube.com/watch?v=jGwO_UgTS7I\"\nsave_dir=\"docs/youtube/\"\nloader = GenericLoader(\n    YoutubeAudioLoader([url],save_dir),\n    OpenAIWhisperParser()\n)\ndocs = loader.load()\ndocs[0].page_content[0:500]\n```\n> 可以同时加载多个文件\n```python\nfrom langchain.document_loaders import PyPDFLoader\n\n# Load PDF\nloaders = [\n    # Duplicate documents on purpose - messy data\n    PyPDFLoader(\"docs/cs229_lectures/MachineLearning-Lecture01.pdf\"),\n    PyPDFLoader(\"docs/cs229_lectures/MachineLearning-Lecture01.pdf\"),\n    PyPDFLoader(\"docs/cs229_lectures/MachineLearning-Lecture02.pdf\"),\n    PyPDFLoader(\"docs/cs229_lectures/MachineLearning-Lecture03.pdf\")\n]\ndocs = []\nfor loader in loaders:\n    docs.extend(loader.load())\n```\n### 字符切割\n\n> 为什么需要字符切割\n\nRAG是一种基于检索的生成模型，它结合了检索和生成的能力。在RAG中，检索阶段用于从大型文本语料库中检索相关的上下文，然后再通过生成阶段生成响应或答案。\n\n切割文本可以帮助RAG模型更好地处理长文本，并提高生成的效率和质量。长文本可能包含大量冗余信息或无关信息，这可能会对模型的性能产生负面影响。通过将文本切割成较小的片段，RAG模型可以在生成阶段更好地处理和理解这些部分，并减少不必要的计算。\n\n另外，文本切割还可以帮助限制输入的长度，以满足模型的输入限制或资源限制。通过将文本切割成块，可以更好地管理模型的内存和计算需求。\n\n总的来说，在转换为向量存储之前，还要对原始数据分为有意义的块，作为后续索引的单位？？。\n\n![[Pasted image 20240303183026.png]]\n#### 导入包\n\n##### 第一类\n```python\n# 例，还有其他分割器，基于文本\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter, CharacterTextSplitter\n```\n\nRecursiveCharacterTextSplitter\"和\"CharacterTextSplitter\"都是用于文本分割的类，但它们有不同的实现方式和适用场景。\n\n1. RecursiveCharacterTextSplitter（递归字符文本分割器）：\n    \n    - 递归字符文本分割器是基于递归的分割方法，它将文本逐层地切割成更小的片段。\n    - 它使用递归算法，将文本分割成单个字符或字符的子序列。例如，将\"Hello\"分割为[\"H\", \"e\", \"l\", \"l\", \"o\"]。\n    - 递归字符文本分割器适用于一些需要对文本进行字符级别处理的任务，例如生成文本的字符级别表示或字符级别的语言建模。\n2. CharacterTextSplitter（字符文本分割器）：\n    \n    - 字符文本分割器是将文本按照固定长度切割成块的方法。\n    - 它将文本按照指定的块大小分割成连续的字符序列。例如，将\"Hello, world!\"以块大小为5分割为[\"Hello\", \", wor\", \"ld!\"]。\n    - 字符文本分割器适用于一些需要对文本进行块级别处理的任务，例如将文本输入模型进行批处理或限制输入长度。\n    - 默认的分隔符是‘\\n’，如果没有这个分隔符，即使到达 长度也不会分隔。\n    - 带有回溯的正则表示\n##### 第二类\n```python\n# 基于 token\nfrom langchain.text_splitter import TokenTextSplitter\ntext_splitter = TokenTextSplitter(chunk_size=1, chunk_overlap=0)\n\n```\n因为有许多基于 token 计数设计的 LLM 上下文窗口\n##### 第三类\n```python\n# 会为块，添加元数据信息\n# 例 \nfrom langchain.document_loaders import NotionDirectoryLoader\nfrom langchain.text_splitter import MarkdownHeaderTextSplitter\nmarkdown_document = \"\"\"# Title\\n\\n \\\n## Chapter 1\\n\\n \\\nHi this is Jim\\n\\n Hi this is Joe\\n\\n \\\n### Section \\n\\n \\\nHi this is Lance \\n\\n \n## Chapter 2\\n\\n \\\nHi this is Molly\"\"\"\nheaders_to_split_on = [\n    (\"#\", \"Header 1\"),\n    (\"##\", \"Header 2\"),\n    (\"###\", \"Header 3\"),\n]\n\nmarkdown_splitter = MarkdownHeaderTextSplitter(\n    headers_to_split_on=headers_to_split_on\n)\nmd_header_splits = markdown_splitter.split_text(markdown_document)\n\nmd_header_splits[0]\n\n# 切割的  Hi this is Jim\\n\\n Hi this is Joe\\n\\n \\ 的元数据中会有 head1 和 head2 \n```\n####  包的使用\n只有两个成员函数\n```python\ncreate_documents()\nsplit_documents()\n```\n\n```python\n# 回溯\nr_splitter = RecursiveCharacterTextSplitter(\n    chunk_size=150,\n    chunk_overlap=0,\n    separators=[\"\\n\\n\", \"\\n\", \"(?<=\\. )\", \" \", \"\"]\n)\nr_splitter.split_text(some_text)\n```\n### 嵌入\n将文本转为数字格式\n将块放入索引之中 \n#### 转换为向量\n```python\nfrom langchain.embeddings.openai import OpenAIEmbeddings\nembedding = OpenAIEmbeddings()\n\nsentence1 = \"i like dogs\"\nsentence2 = \"i like canines\"\nsentence3 = \"the weather is ugly outside\"\n\nembedding1 = embedding.embed_query(sentence1)\nembedding2 = embedding.embed_query(sentence2)\nembedding3 = embedding.embed_query(sentence3)\n\nimport numpy as np\n\nnp.dot(embedding1, embedding2)\nnp.dot(embedding1, embedding3)\nnp.dot(embedding2, embedding3)\n\n\n```\n#### 向量存储与使用\n```python \n# ! pip install chromadb\n\nfrom langchain.vectorstores import Chroma\npersist_directory = 'docs/chroma/'\n!rm -rf ./docs/chroma  # remove old database files if any\nvectordb = Chroma.from_documents(\n    documents=splits,\n    embedding=embedding,\n    persist_directory=persist_directory\n)\nprint(vectordb._collection.count())\n\n# 持久化存储\nvectordb.persist()\n\n# 使用，基本查询，寓意相似性查询\nquestion = \"is there an email i can ask for help\"\ndocs = vectordb.similarity_search(question,k=3) # 3个最佳结果\n\nlen(docs)\n  \ndocs[0].page_content\n\n\n\n```\n#### 边缘情况检索的失效问题\n\n原因：基于语义进行查找。\n1. 重复的查询结果\n2. 查询不能准确把握语义\n\n### 高级检索\n#### MMR 最大边际相关性\n如果选择与嵌入空间中查询最相似的文档，实际上可能会错过一些多样化的信息\n指定搜索源\n这样做的代价是需要对语言模型进行更多的调用，但密非常适合将最终答案集中在最重要的内容上\n\n#### 对话检索链\n在检索问答链的基础上添加了一个新的部分，不仅有记忆，它将历史记录和新问题压缩成一个独立的问题以便传递给向量存储以查找相关文档\n\n### 记忆功能\n保持一个聊天记录的列表，作为历史记录的缓冲区，并且每次都将这些消息与问题一起传递给聊天机器人。\n\nFeel free to copy this code and modify it to add your own features. You can try alternate memory and retriever models by changing the configuration in `load_db` function and the `convchain` method. [Panel](https://panel.holoviz.org/) and [Param](https://param.holoviz.org/) have many useful features and widgets you can use to extend the GUI.\n请随意复制此代码并对其进行修改以添加您自己的功能。 您可以通过更改“load_db”函数和“convchain”方法中的配置来尝试替代内存和检索器模型。 [Panel](https://panel.holoviz.org/) 和 [Param](https://param.holoviz.org/) 有许多有用的功能和小部件，可用于扩展 GUI。\n\n\n\n```python\n pip3  install -U docarray\n```\n\n```python\n\npip3  install pydantic==1.10.9\n```","slug":"人工智能/大语言模型/RAG 检索增强","published":1,"date":"2024-04-22T13:14:48.983Z","updated":"2024-03-19T02:44:10.260Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0o0027kgg47hdpc7k8","content":"<p>[[RAG 项目]]</p>\n<h1 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h1><p>检索增强生成（RAG——Retrieval <strong>Augmented</strong> Generation）是指对大型语言模型输出进行优化，使其能够在生成响应之前引用训练数据来源之外的权威知识库。大型语言模型（LLM）用海量数据进行训练，使用数十亿个参数为回答问题、翻译语言和完成句子等任务生成原始输出。在 LLM 本就强大的功能基础上，RAG 将其扩展为能访问特定领域或组织的内部知识库，所有这些都无需重新训练模型。这是一种经济高效地改进 LLM 输出的方法，让它在各种情境下都能保持相关性、准确性和实用性。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">会拿这个权威知识库进行训练嘛？</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>![[Pasted image 20240303130455.png]]<br>数据提取——embedding（向量化）——创建索引——检索——自动排序（Rerank）——LLM归纳生成</p>\n<p>LLM 面临的已知挑战包括：</p>\n<ul>\n<li>在没有答案的情况下提供虚假信息。</li>\n<li>当用户需要特定的当前响应时，提供过时或通用的信息。</li>\n<li>从非权威来源创建响应。</li>\n<li>由于术语混淆，不同的培训来源使用相同的术语来谈论不同的事情，因此会产生不准确的响应。</li>\n</ul>\n<h2 id=\"Lang-Chain-起源\"><a href=\"#Lang-Chain-起源\" class=\"headerlink\" title=\"Lang Chain 起源\"></a>Lang Chain 起源</h2><p>像 ChatGPT 这样的 大语言模型 或者 LLM 可以回答许多话题的问题，但是，一个孤立的 LLM 只知道它的训练内容，这并不包括某些个人信息数据，如果您可以和这些数据与 LLM 进行对话，就会非常有用</p>\n<h2 id=\"Lang-Chain-介绍\"><a href=\"#Lang-Chain-介绍\" class=\"headerlink\" title=\"Lang Chain 介绍\"></a>Lang Chain 介绍</h2><p>用于构建 LLM 应用的开源开发框架</p>\n<h2 id=\"Lang-Chain-组件\"><a href=\"#Lang-Chain-组件\" class=\"headerlink\" title=\"Lang Chain 组件\"></a>Lang Chain 组件</h2><ol>\n<li>prompts 提示</li>\n<li>models 模型</li>\n<li>indexes 索引</li>\n<li>chains 链</li>\n<li>agents 代理</li>\n</ol>\n<h2 id=\"Lang-Chain-使用——如何与数据对话\"><a href=\"#Lang-Chain-使用——如何与数据对话\" class=\"headerlink\" title=\"Lang Chain 使用——如何与数据对话\"></a>Lang Chain 使用——如何与数据对话</h2><p>![[Pasted image 20240303174734.png]]<br>核心：</p>\n<ol>\n<li>向量存储<ol>\n<li>加载数据</li>\n<li>拆分为有意义的块</li>\n</ol>\n</li>\n<li>索引–检索文档<ol>\n<li>语义搜索：最简单的方式</li>\n</ol>\n</li>\n<li>使得 LLM 能回答 文档相关内容</li>\n<li>记忆功能</li>\n</ol>\n<h3 id=\"文档加载器\"><a href=\"#文档加载器\" class=\"headerlink\" title=\"文档加载器\"></a>文档加载器</h3><p>从不同格式和来源的数据中访问和转换数据的具体细节，转换为标准化格式，即加载到一个标准的文档对象中，该对象由内容和相关元数据组成。</p>\n<blockquote>\n<p>Lang Chain 中有 80 种 数据加载器</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 例</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> langchain.document_loaders <span class=\"keyword\">import</span> PyPDFLoader</span><br><span class=\"line\">loader = PyPDFLoader(<span class=\"string\">&quot;docs/cs229_lectures/MachineLearning-Lecture01.pdf&quot;</span>)</span><br><span class=\"line\">pages = loader.load()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 例</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> langchain.document_loaders <span class=\"keyword\">import</span> WebBaseLoader</span><br><span class=\"line\"></span><br><span class=\"line\">loader = WebBaseLoader(<span class=\"string\">&quot;https://github.com/basecamp/handbook/blob/master/37signals-is-you.md&quot;</span>)</span><br><span class=\"line\">docs = loader.load()</span><br></pre></td></tr></table></figure>\n\n<p>文档加载器之间可以组合为一个通用加载器</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> langchain.document_loaders.generic <span class=\"keyword\">import</span> GenericLoader</span><br><span class=\"line\"><span class=\"keyword\">from</span> langchain.document_loaders.parsers <span class=\"keyword\">import</span> OpenAIWhisperParser</span><br><span class=\"line\"><span class=\"keyword\">from</span> langchain.document_loaders.blob_loaders.youtube_audio <span class=\"keyword\">import</span> YoutubeAudioLoader</span><br><span class=\"line\"><span class=\"comment\"># ! pip install yt_dlp</span></span><br><span class=\"line\"><span class=\"comment\"># ! pip install pydub</span></span><br><span class=\"line\">url=<span class=\"string\">&quot;https://www.youtube.com/watch?v=jGwO_UgTS7I&quot;</span></span><br><span class=\"line\">save_dir=<span class=\"string\">&quot;docs/youtube/&quot;</span></span><br><span class=\"line\">loader = GenericLoader(</span><br><span class=\"line\">    YoutubeAudioLoader([url],save_dir),</span><br><span class=\"line\">    OpenAIWhisperParser()</span><br><span class=\"line\">)</span><br><span class=\"line\">docs = loader.load()</span><br><span class=\"line\">docs[<span class=\"number\">0</span>].page_content[<span class=\"number\">0</span>:<span class=\"number\">500</span>]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>可以同时加载多个文件</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> langchain.document_loaders <span class=\"keyword\">import</span> PyPDFLoader</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Load PDF</span></span><br><span class=\"line\">loaders = [</span><br><span class=\"line\">    <span class=\"comment\"># Duplicate documents on purpose - messy data</span></span><br><span class=\"line\">    PyPDFLoader(<span class=\"string\">&quot;docs/cs229_lectures/MachineLearning-Lecture01.pdf&quot;</span>),</span><br><span class=\"line\">    PyPDFLoader(<span class=\"string\">&quot;docs/cs229_lectures/MachineLearning-Lecture01.pdf&quot;</span>),</span><br><span class=\"line\">    PyPDFLoader(<span class=\"string\">&quot;docs/cs229_lectures/MachineLearning-Lecture02.pdf&quot;</span>),</span><br><span class=\"line\">    PyPDFLoader(<span class=\"string\">&quot;docs/cs229_lectures/MachineLearning-Lecture03.pdf&quot;</span>)</span><br><span class=\"line\">]</span><br><span class=\"line\">docs = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> loader <span class=\"keyword\">in</span> loaders:</span><br><span class=\"line\">    docs.extend(loader.load())</span><br></pre></td></tr></table></figure>\n<h3 id=\"字符切割\"><a href=\"#字符切割\" class=\"headerlink\" title=\"字符切割\"></a>字符切割</h3><blockquote>\n<p>为什么需要字符切割</p>\n</blockquote>\n<p>RAG是一种基于检索的生成模型，它结合了检索和生成的能力。在RAG中，检索阶段用于从大型文本语料库中检索相关的上下文，然后再通过生成阶段生成响应或答案。</p>\n<p>切割文本可以帮助RAG模型更好地处理长文本，并提高生成的效率和质量。长文本可能包含大量冗余信息或无关信息，这可能会对模型的性能产生负面影响。通过将文本切割成较小的片段，RAG模型可以在生成阶段更好地处理和理解这些部分，并减少不必要的计算。</p>\n<p>另外，文本切割还可以帮助限制输入的长度，以满足模型的输入限制或资源限制。通过将文本切割成块，可以更好地管理模型的内存和计算需求。</p>\n<p>总的来说，在转换为向量存储之前，还要对原始数据分为有意义的块，作为后续索引的单位？？。</p>\n<p>![[Pasted image 20240303183026.png]]</p>\n<h4 id=\"导入包\"><a href=\"#导入包\" class=\"headerlink\" title=\"导入包\"></a>导入包</h4><h5 id=\"第一类\"><a href=\"#第一类\" class=\"headerlink\" title=\"第一类\"></a>第一类</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 例，还有其他分割器，基于文本</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> langchain.text_splitter <span class=\"keyword\">import</span> RecursiveCharacterTextSplitter, CharacterTextSplitter</span><br></pre></td></tr></table></figure>\n\n<p>RecursiveCharacterTextSplitter”和”CharacterTextSplitter”都是用于文本分割的类，但它们有不同的实现方式和适用场景。</p>\n<ol>\n<li><p>RecursiveCharacterTextSplitter（递归字符文本分割器）：</p>\n<ul>\n<li>递归字符文本分割器是基于递归的分割方法，它将文本逐层地切割成更小的片段。</li>\n<li>它使用递归算法，将文本分割成单个字符或字符的子序列。例如，将”Hello”分割为[“H”, “e”, “l”, “l”, “o”]。</li>\n<li>递归字符文本分割器适用于一些需要对文本进行字符级别处理的任务，例如生成文本的字符级别表示或字符级别的语言建模。</li>\n</ul>\n</li>\n<li><p>CharacterTextSplitter（字符文本分割器）：</p>\n<ul>\n<li>字符文本分割器是将文本按照固定长度切割成块的方法。</li>\n<li>它将文本按照指定的块大小分割成连续的字符序列。例如，将”Hello, world!”以块大小为5分割为[“Hello”, “, wor”, “ld!”]。</li>\n<li>字符文本分割器适用于一些需要对文本进行块级别处理的任务，例如将文本输入模型进行批处理或限制输入长度。</li>\n<li>默认的分隔符是‘\\n’，如果没有这个分隔符，即使到达 长度也不会分隔。</li>\n<li>带有回溯的正则表示</li>\n</ul>\n</li>\n</ol>\n<h5 id=\"第二类\"><a href=\"#第二类\" class=\"headerlink\" title=\"第二类\"></a>第二类</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 基于 token</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> langchain.text_splitter <span class=\"keyword\">import</span> TokenTextSplitter</span><br><span class=\"line\">text_splitter = TokenTextSplitter(chunk_size=<span class=\"number\">1</span>, chunk_overlap=<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>因为有许多基于 token 计数设计的 LLM 上下文窗口</p>\n<h5 id=\"第三类\"><a href=\"#第三类\" class=\"headerlink\" title=\"第三类\"></a>第三类</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 会为块，添加元数据信息</span></span><br><span class=\"line\"><span class=\"comment\"># 例 </span></span><br><span class=\"line\"><span class=\"keyword\">from</span> langchain.document_loaders <span class=\"keyword\">import</span> NotionDirectoryLoader</span><br><span class=\"line\"><span class=\"keyword\">from</span> langchain.text_splitter <span class=\"keyword\">import</span> MarkdownHeaderTextSplitter</span><br><span class=\"line\">markdown_document = <span class=\"string\">&quot;&quot;&quot;# Title\\n\\n \\</span></span><br><span class=\"line\"><span class=\"string\">## Chapter 1\\n\\n \\</span></span><br><span class=\"line\"><span class=\"string\">Hi this is Jim\\n\\n Hi this is Joe\\n\\n \\</span></span><br><span class=\"line\"><span class=\"string\">### Section \\n\\n \\</span></span><br><span class=\"line\"><span class=\"string\">Hi this is Lance \\n\\n </span></span><br><span class=\"line\"><span class=\"string\">## Chapter 2\\n\\n \\</span></span><br><span class=\"line\"><span class=\"string\">Hi this is Molly&quot;&quot;&quot;</span></span><br><span class=\"line\">headers_to_split_on = [</span><br><span class=\"line\">    (<span class=\"string\">&quot;#&quot;</span>, <span class=\"string\">&quot;Header 1&quot;</span>),</span><br><span class=\"line\">    (<span class=\"string\">&quot;##&quot;</span>, <span class=\"string\">&quot;Header 2&quot;</span>),</span><br><span class=\"line\">    (<span class=\"string\">&quot;###&quot;</span>, <span class=\"string\">&quot;Header 3&quot;</span>),</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">markdown_splitter = MarkdownHeaderTextSplitter(</span><br><span class=\"line\">    headers_to_split_on=headers_to_split_on</span><br><span class=\"line\">)</span><br><span class=\"line\">md_header_splits = markdown_splitter.split_text(markdown_document)</span><br><span class=\"line\"></span><br><span class=\"line\">md_header_splits[<span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 切割的  Hi this is Jim\\n\\n Hi this is Joe\\n\\n \\ 的元数据中会有 head1 和 head2 </span></span><br></pre></td></tr></table></figure>\n<h4 id=\"包的使用\"><a href=\"#包的使用\" class=\"headerlink\" title=\"包的使用\"></a>包的使用</h4><p>只有两个成员函数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create_documents()</span><br><span class=\"line\">split_documents()</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 回溯</span></span><br><span class=\"line\">r_splitter = RecursiveCharacterTextSplitter(</span><br><span class=\"line\">    chunk_size=<span class=\"number\">150</span>,</span><br><span class=\"line\">    chunk_overlap=<span class=\"number\">0</span>,</span><br><span class=\"line\">    separators=[<span class=\"string\">&quot;\\n\\n&quot;</span>, <span class=\"string\">&quot;\\n&quot;</span>, <span class=\"string\">&quot;(?&lt;=\\. )&quot;</span>, <span class=\"string\">&quot; &quot;</span>, <span class=\"string\">&quot;&quot;</span>]</span><br><span class=\"line\">)</span><br><span class=\"line\">r_splitter.split_text(some_text)</span><br></pre></td></tr></table></figure>\n<h3 id=\"嵌入\"><a href=\"#嵌入\" class=\"headerlink\" title=\"嵌入\"></a>嵌入</h3><p>将文本转为数字格式<br>将块放入索引之中 </p>\n<h4 id=\"转换为向量\"><a href=\"#转换为向量\" class=\"headerlink\" title=\"转换为向量\"></a>转换为向量</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> langchain.embeddings.openai <span class=\"keyword\">import</span> OpenAIEmbeddings</span><br><span class=\"line\">embedding = OpenAIEmbeddings()</span><br><span class=\"line\"></span><br><span class=\"line\">sentence1 = <span class=\"string\">&quot;i like dogs&quot;</span></span><br><span class=\"line\">sentence2 = <span class=\"string\">&quot;i like canines&quot;</span></span><br><span class=\"line\">sentence3 = <span class=\"string\">&quot;the weather is ugly outside&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">embedding1 = embedding.embed_query(sentence1)</span><br><span class=\"line\">embedding2 = embedding.embed_query(sentence2)</span><br><span class=\"line\">embedding3 = embedding.embed_query(sentence3)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\">np.dot(embedding1, embedding2)</span><br><span class=\"line\">np.dot(embedding1, embedding3)</span><br><span class=\"line\">np.dot(embedding2, embedding3)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"向量存储与使用\"><a href=\"#向量存储与使用\" class=\"headerlink\" title=\"向量存储与使用\"></a>向量存储与使用</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ! pip install chromadb</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> langchain.vectorstores <span class=\"keyword\">import</span> Chroma</span><br><span class=\"line\">persist_directory = <span class=\"string\">&#x27;docs/chroma/&#x27;</span></span><br><span class=\"line\">!rm -rf ./docs/chroma  <span class=\"comment\"># remove old database files if any</span></span><br><span class=\"line\">vectordb = Chroma.from_documents(</span><br><span class=\"line\">    documents=splits,</span><br><span class=\"line\">    embedding=embedding,</span><br><span class=\"line\">    persist_directory=persist_directory</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(vectordb._collection.count())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 持久化存储</span></span><br><span class=\"line\">vectordb.persist()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用，基本查询，寓意相似性查询</span></span><br><span class=\"line\">question = <span class=\"string\">&quot;is there an email i can ask for help&quot;</span></span><br><span class=\"line\">docs = vectordb.similarity_search(question,k=<span class=\"number\">3</span>) <span class=\"comment\"># 3个最佳结果</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">len</span>(docs)</span><br><span class=\"line\">  </span><br><span class=\"line\">docs[<span class=\"number\">0</span>].page_content</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"边缘情况检索的失效问题\"><a href=\"#边缘情况检索的失效问题\" class=\"headerlink\" title=\"边缘情况检索的失效问题\"></a>边缘情况检索的失效问题</h4><p>原因：基于语义进行查找。</p>\n<ol>\n<li>重复的查询结果</li>\n<li>查询不能准确把握语义</li>\n</ol>\n<h3 id=\"高级检索\"><a href=\"#高级检索\" class=\"headerlink\" title=\"高级检索\"></a>高级检索</h3><h4 id=\"MMR-最大边际相关性\"><a href=\"#MMR-最大边际相关性\" class=\"headerlink\" title=\"MMR 最大边际相关性\"></a>MMR 最大边际相关性</h4><p>如果选择与嵌入空间中查询最相似的文档，实际上可能会错过一些多样化的信息<br>指定搜索源<br>这样做的代价是需要对语言模型进行更多的调用，但密非常适合将最终答案集中在最重要的内容上</p>\n<h4 id=\"对话检索链\"><a href=\"#对话检索链\" class=\"headerlink\" title=\"对话检索链\"></a>对话检索链</h4><p>在检索问答链的基础上添加了一个新的部分，不仅有记忆，它将历史记录和新问题压缩成一个独立的问题以便传递给向量存储以查找相关文档</p>\n<h3 id=\"记忆功能\"><a href=\"#记忆功能\" class=\"headerlink\" title=\"记忆功能\"></a>记忆功能</h3><p>保持一个聊天记录的列表，作为历史记录的缓冲区，并且每次都将这些消息与问题一起传递给聊天机器人。</p>\n<p>Feel free to copy this code and modify it to add your own features. You can try alternate memory and retriever models by changing the configuration in <code>load_db</code> function and the <code>convchain</code> method. <a href=\"https://panel.holoviz.org/\">Panel</a> and <a href=\"https://param.holoviz.org/\">Param</a> have many useful features and widgets you can use to extend the GUI.<br>请随意复制此代码并对其进行修改以添加您自己的功能。 您可以通过更改“load_db”函数和“convchain”方法中的配置来尝试替代内存和检索器模型。 <a href=\"https://panel.holoviz.org/\">Panel</a> 和 <a href=\"https://param.holoviz.org/\">Param</a> 有许多有用的功能和小部件，可用于扩展 GUI。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip3  install -U docarray</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">pip3  install pydantic==<span class=\"number\">1.10</span><span class=\"number\">.9</span></span><br></pre></td></tr></table></figure>","excerpt":"","more":"<p>[[RAG 项目]]</p>\n<h1 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h1><p>检索增强生成（RAG——Retrieval <strong>Augmented</strong> Generation）是指对大型语言模型输出进行优化，使其能够在生成响应之前引用训练数据来源之外的权威知识库。大型语言模型（LLM）用海量数据进行训练，使用数十亿个参数为回答问题、翻译语言和完成句子等任务生成原始输出。在 LLM 本就强大的功能基础上，RAG 将其扩展为能访问特定领域或组织的内部知识库，所有这些都无需重新训练模型。这是一种经济高效地改进 LLM 输出的方法，让它在各种情境下都能保持相关性、准确性和实用性。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">会拿这个权威知识库进行训练嘛？</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>![[Pasted image 20240303130455.png]]<br>数据提取——embedding（向量化）——创建索引——检索——自动排序（Rerank）——LLM归纳生成</p>\n<p>LLM 面临的已知挑战包括：</p>\n<ul>\n<li>在没有答案的情况下提供虚假信息。</li>\n<li>当用户需要特定的当前响应时，提供过时或通用的信息。</li>\n<li>从非权威来源创建响应。</li>\n<li>由于术语混淆，不同的培训来源使用相同的术语来谈论不同的事情，因此会产生不准确的响应。</li>\n</ul>\n<h2 id=\"Lang-Chain-起源\"><a href=\"#Lang-Chain-起源\" class=\"headerlink\" title=\"Lang Chain 起源\"></a>Lang Chain 起源</h2><p>像 ChatGPT 这样的 大语言模型 或者 LLM 可以回答许多话题的问题，但是，一个孤立的 LLM 只知道它的训练内容，这并不包括某些个人信息数据，如果您可以和这些数据与 LLM 进行对话，就会非常有用</p>\n<h2 id=\"Lang-Chain-介绍\"><a href=\"#Lang-Chain-介绍\" class=\"headerlink\" title=\"Lang Chain 介绍\"></a>Lang Chain 介绍</h2><p>用于构建 LLM 应用的开源开发框架</p>\n<h2 id=\"Lang-Chain-组件\"><a href=\"#Lang-Chain-组件\" class=\"headerlink\" title=\"Lang Chain 组件\"></a>Lang Chain 组件</h2><ol>\n<li>prompts 提示</li>\n<li>models 模型</li>\n<li>indexes 索引</li>\n<li>chains 链</li>\n<li>agents 代理</li>\n</ol>\n<h2 id=\"Lang-Chain-使用——如何与数据对话\"><a href=\"#Lang-Chain-使用——如何与数据对话\" class=\"headerlink\" title=\"Lang Chain 使用——如何与数据对话\"></a>Lang Chain 使用——如何与数据对话</h2><p>![[Pasted image 20240303174734.png]]<br>核心：</p>\n<ol>\n<li>向量存储<ol>\n<li>加载数据</li>\n<li>拆分为有意义的块</li>\n</ol>\n</li>\n<li>索引–检索文档<ol>\n<li>语义搜索：最简单的方式</li>\n</ol>\n</li>\n<li>使得 LLM 能回答 文档相关内容</li>\n<li>记忆功能</li>\n</ol>\n<h3 id=\"文档加载器\"><a href=\"#文档加载器\" class=\"headerlink\" title=\"文档加载器\"></a>文档加载器</h3><p>从不同格式和来源的数据中访问和转换数据的具体细节，转换为标准化格式，即加载到一个标准的文档对象中，该对象由内容和相关元数据组成。</p>\n<blockquote>\n<p>Lang Chain 中有 80 种 数据加载器</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 例</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> langchain.document_loaders <span class=\"keyword\">import</span> PyPDFLoader</span><br><span class=\"line\">loader = PyPDFLoader(<span class=\"string\">&quot;docs/cs229_lectures/MachineLearning-Lecture01.pdf&quot;</span>)</span><br><span class=\"line\">pages = loader.load()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 例</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> langchain.document_loaders <span class=\"keyword\">import</span> WebBaseLoader</span><br><span class=\"line\"></span><br><span class=\"line\">loader = WebBaseLoader(<span class=\"string\">&quot;https://github.com/basecamp/handbook/blob/master/37signals-is-you.md&quot;</span>)</span><br><span class=\"line\">docs = loader.load()</span><br></pre></td></tr></table></figure>\n\n<p>文档加载器之间可以组合为一个通用加载器</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> langchain.document_loaders.generic <span class=\"keyword\">import</span> GenericLoader</span><br><span class=\"line\"><span class=\"keyword\">from</span> langchain.document_loaders.parsers <span class=\"keyword\">import</span> OpenAIWhisperParser</span><br><span class=\"line\"><span class=\"keyword\">from</span> langchain.document_loaders.blob_loaders.youtube_audio <span class=\"keyword\">import</span> YoutubeAudioLoader</span><br><span class=\"line\"><span class=\"comment\"># ! pip install yt_dlp</span></span><br><span class=\"line\"><span class=\"comment\"># ! pip install pydub</span></span><br><span class=\"line\">url=<span class=\"string\">&quot;https://www.youtube.com/watch?v=jGwO_UgTS7I&quot;</span></span><br><span class=\"line\">save_dir=<span class=\"string\">&quot;docs/youtube/&quot;</span></span><br><span class=\"line\">loader = GenericLoader(</span><br><span class=\"line\">    YoutubeAudioLoader([url],save_dir),</span><br><span class=\"line\">    OpenAIWhisperParser()</span><br><span class=\"line\">)</span><br><span class=\"line\">docs = loader.load()</span><br><span class=\"line\">docs[<span class=\"number\">0</span>].page_content[<span class=\"number\">0</span>:<span class=\"number\">500</span>]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>可以同时加载多个文件</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> langchain.document_loaders <span class=\"keyword\">import</span> PyPDFLoader</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Load PDF</span></span><br><span class=\"line\">loaders = [</span><br><span class=\"line\">    <span class=\"comment\"># Duplicate documents on purpose - messy data</span></span><br><span class=\"line\">    PyPDFLoader(<span class=\"string\">&quot;docs/cs229_lectures/MachineLearning-Lecture01.pdf&quot;</span>),</span><br><span class=\"line\">    PyPDFLoader(<span class=\"string\">&quot;docs/cs229_lectures/MachineLearning-Lecture01.pdf&quot;</span>),</span><br><span class=\"line\">    PyPDFLoader(<span class=\"string\">&quot;docs/cs229_lectures/MachineLearning-Lecture02.pdf&quot;</span>),</span><br><span class=\"line\">    PyPDFLoader(<span class=\"string\">&quot;docs/cs229_lectures/MachineLearning-Lecture03.pdf&quot;</span>)</span><br><span class=\"line\">]</span><br><span class=\"line\">docs = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> loader <span class=\"keyword\">in</span> loaders:</span><br><span class=\"line\">    docs.extend(loader.load())</span><br></pre></td></tr></table></figure>\n<h3 id=\"字符切割\"><a href=\"#字符切割\" class=\"headerlink\" title=\"字符切割\"></a>字符切割</h3><blockquote>\n<p>为什么需要字符切割</p>\n</blockquote>\n<p>RAG是一种基于检索的生成模型，它结合了检索和生成的能力。在RAG中，检索阶段用于从大型文本语料库中检索相关的上下文，然后再通过生成阶段生成响应或答案。</p>\n<p>切割文本可以帮助RAG模型更好地处理长文本，并提高生成的效率和质量。长文本可能包含大量冗余信息或无关信息，这可能会对模型的性能产生负面影响。通过将文本切割成较小的片段，RAG模型可以在生成阶段更好地处理和理解这些部分，并减少不必要的计算。</p>\n<p>另外，文本切割还可以帮助限制输入的长度，以满足模型的输入限制或资源限制。通过将文本切割成块，可以更好地管理模型的内存和计算需求。</p>\n<p>总的来说，在转换为向量存储之前，还要对原始数据分为有意义的块，作为后续索引的单位？？。</p>\n<p>![[Pasted image 20240303183026.png]]</p>\n<h4 id=\"导入包\"><a href=\"#导入包\" class=\"headerlink\" title=\"导入包\"></a>导入包</h4><h5 id=\"第一类\"><a href=\"#第一类\" class=\"headerlink\" title=\"第一类\"></a>第一类</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 例，还有其他分割器，基于文本</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> langchain.text_splitter <span class=\"keyword\">import</span> RecursiveCharacterTextSplitter, CharacterTextSplitter</span><br></pre></td></tr></table></figure>\n\n<p>RecursiveCharacterTextSplitter”和”CharacterTextSplitter”都是用于文本分割的类，但它们有不同的实现方式和适用场景。</p>\n<ol>\n<li><p>RecursiveCharacterTextSplitter（递归字符文本分割器）：</p>\n<ul>\n<li>递归字符文本分割器是基于递归的分割方法，它将文本逐层地切割成更小的片段。</li>\n<li>它使用递归算法，将文本分割成单个字符或字符的子序列。例如，将”Hello”分割为[“H”, “e”, “l”, “l”, “o”]。</li>\n<li>递归字符文本分割器适用于一些需要对文本进行字符级别处理的任务，例如生成文本的字符级别表示或字符级别的语言建模。</li>\n</ul>\n</li>\n<li><p>CharacterTextSplitter（字符文本分割器）：</p>\n<ul>\n<li>字符文本分割器是将文本按照固定长度切割成块的方法。</li>\n<li>它将文本按照指定的块大小分割成连续的字符序列。例如，将”Hello, world!”以块大小为5分割为[“Hello”, “, wor”, “ld!”]。</li>\n<li>字符文本分割器适用于一些需要对文本进行块级别处理的任务，例如将文本输入模型进行批处理或限制输入长度。</li>\n<li>默认的分隔符是‘\\n’，如果没有这个分隔符，即使到达 长度也不会分隔。</li>\n<li>带有回溯的正则表示</li>\n</ul>\n</li>\n</ol>\n<h5 id=\"第二类\"><a href=\"#第二类\" class=\"headerlink\" title=\"第二类\"></a>第二类</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 基于 token</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> langchain.text_splitter <span class=\"keyword\">import</span> TokenTextSplitter</span><br><span class=\"line\">text_splitter = TokenTextSplitter(chunk_size=<span class=\"number\">1</span>, chunk_overlap=<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>因为有许多基于 token 计数设计的 LLM 上下文窗口</p>\n<h5 id=\"第三类\"><a href=\"#第三类\" class=\"headerlink\" title=\"第三类\"></a>第三类</h5><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 会为块，添加元数据信息</span></span><br><span class=\"line\"><span class=\"comment\"># 例 </span></span><br><span class=\"line\"><span class=\"keyword\">from</span> langchain.document_loaders <span class=\"keyword\">import</span> NotionDirectoryLoader</span><br><span class=\"line\"><span class=\"keyword\">from</span> langchain.text_splitter <span class=\"keyword\">import</span> MarkdownHeaderTextSplitter</span><br><span class=\"line\">markdown_document = <span class=\"string\">&quot;&quot;&quot;# Title\\n\\n \\</span></span><br><span class=\"line\"><span class=\"string\">## Chapter 1\\n\\n \\</span></span><br><span class=\"line\"><span class=\"string\">Hi this is Jim\\n\\n Hi this is Joe\\n\\n \\</span></span><br><span class=\"line\"><span class=\"string\">### Section \\n\\n \\</span></span><br><span class=\"line\"><span class=\"string\">Hi this is Lance \\n\\n </span></span><br><span class=\"line\"><span class=\"string\">## Chapter 2\\n\\n \\</span></span><br><span class=\"line\"><span class=\"string\">Hi this is Molly&quot;&quot;&quot;</span></span><br><span class=\"line\">headers_to_split_on = [</span><br><span class=\"line\">    (<span class=\"string\">&quot;#&quot;</span>, <span class=\"string\">&quot;Header 1&quot;</span>),</span><br><span class=\"line\">    (<span class=\"string\">&quot;##&quot;</span>, <span class=\"string\">&quot;Header 2&quot;</span>),</span><br><span class=\"line\">    (<span class=\"string\">&quot;###&quot;</span>, <span class=\"string\">&quot;Header 3&quot;</span>),</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">markdown_splitter = MarkdownHeaderTextSplitter(</span><br><span class=\"line\">    headers_to_split_on=headers_to_split_on</span><br><span class=\"line\">)</span><br><span class=\"line\">md_header_splits = markdown_splitter.split_text(markdown_document)</span><br><span class=\"line\"></span><br><span class=\"line\">md_header_splits[<span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 切割的  Hi this is Jim\\n\\n Hi this is Joe\\n\\n \\ 的元数据中会有 head1 和 head2 </span></span><br></pre></td></tr></table></figure>\n<h4 id=\"包的使用\"><a href=\"#包的使用\" class=\"headerlink\" title=\"包的使用\"></a>包的使用</h4><p>只有两个成员函数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create_documents()</span><br><span class=\"line\">split_documents()</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 回溯</span></span><br><span class=\"line\">r_splitter = RecursiveCharacterTextSplitter(</span><br><span class=\"line\">    chunk_size=<span class=\"number\">150</span>,</span><br><span class=\"line\">    chunk_overlap=<span class=\"number\">0</span>,</span><br><span class=\"line\">    separators=[<span class=\"string\">&quot;\\n\\n&quot;</span>, <span class=\"string\">&quot;\\n&quot;</span>, <span class=\"string\">&quot;(?&lt;=\\. )&quot;</span>, <span class=\"string\">&quot; &quot;</span>, <span class=\"string\">&quot;&quot;</span>]</span><br><span class=\"line\">)</span><br><span class=\"line\">r_splitter.split_text(some_text)</span><br></pre></td></tr></table></figure>\n<h3 id=\"嵌入\"><a href=\"#嵌入\" class=\"headerlink\" title=\"嵌入\"></a>嵌入</h3><p>将文本转为数字格式<br>将块放入索引之中 </p>\n<h4 id=\"转换为向量\"><a href=\"#转换为向量\" class=\"headerlink\" title=\"转换为向量\"></a>转换为向量</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> langchain.embeddings.openai <span class=\"keyword\">import</span> OpenAIEmbeddings</span><br><span class=\"line\">embedding = OpenAIEmbeddings()</span><br><span class=\"line\"></span><br><span class=\"line\">sentence1 = <span class=\"string\">&quot;i like dogs&quot;</span></span><br><span class=\"line\">sentence2 = <span class=\"string\">&quot;i like canines&quot;</span></span><br><span class=\"line\">sentence3 = <span class=\"string\">&quot;the weather is ugly outside&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">embedding1 = embedding.embed_query(sentence1)</span><br><span class=\"line\">embedding2 = embedding.embed_query(sentence2)</span><br><span class=\"line\">embedding3 = embedding.embed_query(sentence3)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\">np.dot(embedding1, embedding2)</span><br><span class=\"line\">np.dot(embedding1, embedding3)</span><br><span class=\"line\">np.dot(embedding2, embedding3)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"向量存储与使用\"><a href=\"#向量存储与使用\" class=\"headerlink\" title=\"向量存储与使用\"></a>向量存储与使用</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ! pip install chromadb</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> langchain.vectorstores <span class=\"keyword\">import</span> Chroma</span><br><span class=\"line\">persist_directory = <span class=\"string\">&#x27;docs/chroma/&#x27;</span></span><br><span class=\"line\">!rm -rf ./docs/chroma  <span class=\"comment\"># remove old database files if any</span></span><br><span class=\"line\">vectordb = Chroma.from_documents(</span><br><span class=\"line\">    documents=splits,</span><br><span class=\"line\">    embedding=embedding,</span><br><span class=\"line\">    persist_directory=persist_directory</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(vectordb._collection.count())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 持久化存储</span></span><br><span class=\"line\">vectordb.persist()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用，基本查询，寓意相似性查询</span></span><br><span class=\"line\">question = <span class=\"string\">&quot;is there an email i can ask for help&quot;</span></span><br><span class=\"line\">docs = vectordb.similarity_search(question,k=<span class=\"number\">3</span>) <span class=\"comment\"># 3个最佳结果</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">len</span>(docs)</span><br><span class=\"line\">  </span><br><span class=\"line\">docs[<span class=\"number\">0</span>].page_content</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"边缘情况检索的失效问题\"><a href=\"#边缘情况检索的失效问题\" class=\"headerlink\" title=\"边缘情况检索的失效问题\"></a>边缘情况检索的失效问题</h4><p>原因：基于语义进行查找。</p>\n<ol>\n<li>重复的查询结果</li>\n<li>查询不能准确把握语义</li>\n</ol>\n<h3 id=\"高级检索\"><a href=\"#高级检索\" class=\"headerlink\" title=\"高级检索\"></a>高级检索</h3><h4 id=\"MMR-最大边际相关性\"><a href=\"#MMR-最大边际相关性\" class=\"headerlink\" title=\"MMR 最大边际相关性\"></a>MMR 最大边际相关性</h4><p>如果选择与嵌入空间中查询最相似的文档，实际上可能会错过一些多样化的信息<br>指定搜索源<br>这样做的代价是需要对语言模型进行更多的调用，但密非常适合将最终答案集中在最重要的内容上</p>\n<h4 id=\"对话检索链\"><a href=\"#对话检索链\" class=\"headerlink\" title=\"对话检索链\"></a>对话检索链</h4><p>在检索问答链的基础上添加了一个新的部分，不仅有记忆，它将历史记录和新问题压缩成一个独立的问题以便传递给向量存储以查找相关文档</p>\n<h3 id=\"记忆功能\"><a href=\"#记忆功能\" class=\"headerlink\" title=\"记忆功能\"></a>记忆功能</h3><p>保持一个聊天记录的列表，作为历史记录的缓冲区，并且每次都将这些消息与问题一起传递给聊天机器人。</p>\n<p>Feel free to copy this code and modify it to add your own features. You can try alternate memory and retriever models by changing the configuration in <code>load_db</code> function and the <code>convchain</code> method. <a href=\"https://panel.holoviz.org/\">Panel</a> and <a href=\"https://param.holoviz.org/\">Param</a> have many useful features and widgets you can use to extend the GUI.<br>请随意复制此代码并对其进行修改以添加您自己的功能。 您可以通过更改“load_db”函数和“convchain”方法中的配置来尝试替代内存和检索器模型。 <a href=\"https://panel.holoviz.org/\">Panel</a> 和 <a href=\"https://param.holoviz.org/\">Param</a> 有许多有用的功能和小部件，可用于扩展 GUI。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip3  install -U docarray</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">pip3  install pydantic==<span class=\"number\">1.10</span><span class=\"number\">.9</span></span><br></pre></td></tr></table></figure>"},{"_content":"\n# 地址\n\nhttps://github.com/zhayujie/chatgpt-on-wechat\n\n[ChatGPT微信开发，轻松拿捏_keyerror: 'wxsid-CSDN博客](https://blog.csdn.net/qq_37215621/article/details/130517060)\n\nhttps://space.bilibili.com/4401694/dynamic\n\n\n\n# 运行\nnohup python3 app.py & tail -f nohup.out\nnohup ./clash-linux-amd64 > /dev/null 2>&1 &\nnohup docker compose up > /dev/null 2>&1 &\n# 问题\n\n[WARNING][2024-02-27 04:41:40][chat_gpt_bot.py:150] - [CHATGPT] APIConnectionError: Error communicating with OpenAI: HTTPSConnectionPool(host='api.openai.com', port=443): Max retries exceeded with url: /v1/chat/completions (Caused by ProxyError('Cannot connect to proxy.', NewConnectionError('<urllib3.connection.HTTPSConnection object at 0x7f75d9c45e50>: Failed to establish a new connection: [Errno 111] Connection refused')))\n[WARNING][2024-02-27 04:41:40][chat_gpt_bot.py:150] - [CHATGPT] APIConnectionError: Error communicating with OpenAI: HTTPSConnectionPool(host='api.openai.com', port=443): Max retries exceeded with url: /v1/chat/completions (Caused by ProxyError('Cannot connect to proxy.', NewConnectionError('<urllib3.connection.HTTPSConnection object at 0x7f75d9c45fa0>: Failed to establish a new connection: [Errno 111] Connection refused')))\n[INFO][2024-02-27 04:41:40][wechat_channel.py:218] - [WX] sendMsg=Reply(type=ERROR, content=[ERROR]\n我连接不到你的网络), receiver=@dade582ddc06e63c6ec1175c680f90ff82f77df7c20d9450bfb147cb5a925968\n\n\n## 解决\n[【完美解决：openai.error.APIConnectionError: Error communicating with OpenAI:】_openai.openaierror: the api_key client option must-CSDN博客](https://blog.csdn.net/T752462536/article/details/134164508)\n\n`pip3 show openai`查看安装目录\n`cd /opt/conda/envs/fyn_python3_8/lib/python3.8/site-packages/openai`\n\n\n# 问题\n\n## 1 \n\n[INFO][2024-02-27 05:34:07][chat_gpt_bot.py:49] - [CHATGPT] query=哈哈哈\n[ERROR][2024-02-27 05:34:07][chat_gpt_bot.py:155] - [CHATGPT] Exception: local variable 'proxy' referenced before assignment\nTraceback (most recent call last):\n  File \"/root/test/GptWchat/chatgpt-on-wechat/bot/chatgpt/chat_gpt_bot.py\", line 123, in reply_text\n    response = openai.ChatCompletion.create(api_key=api_key, messages=session.messages, **args)\n  File \"/opt/conda/envs/fyn_python3_8/lib/python3.8/site-packages/openai/api_resources/chat_completion.py\", line 25, in create\n    return super().create(*args, **kwargs)\n  File \"/opt/conda/envs/fyn_python3_8/lib/python3.8/site-packages/openai/api_resources/abstract/engine_api_resource.py\", line 153, in create\n    response, _, api_key = requestor.request(\n  File \"/opt/conda/envs/fyn_python3_8/lib/python3.8/site-packages/openai/api_requestor.py\", line 288, in request\n    result = self.request_raw(\n  File \"/opt/conda/envs/fyn_python3_8/lib/python3.8/site-packages/openai/api_requestor.py\", line 609, in request_raw\n    proxies=proxy,\nUnboundLocalError: local variable 'proxy' referenced before assignment\n[INFO][2024-02-27 05:34:08][wechat_channel.py:218] - [WX] sendMsg=Reply(type=ERROR, content=[ERROR]\n我现在有点累了，等会再来吧), receiver=@5dc3bf914f7a577d4798603da08adc85720678732d3a0413329ceebb3041f0b7\n\n\n\n[bot] 这段代码是在Python中定义一个特殊的 `__setitem__` 方法，它是一个魔法方法或者叫做运算符重载。这个方法在我们试图给一个对象的实例分配值时被调用。这里看起来像是在实现一个优先级队列或者是一个以某种方式排序的字典。\n\n下面是代码行的详细解释：\n\n1. `def __setitem__(self, key, value):`: 定义一个名为 `__setitem__` 的方法，它接收三个参数：`self`（表示实例自身，类似于 Java 或 C++ 中的 `this`），`key`（字典中要设置的键），`value`（该键所对应的值）。\n\n2. `if key in self:`: 如果提供的键已经在字典中存在。\n\n3. `super().__setitem__(key, value)`: 使用超类（可能是 `dict` 或其它字典类型）的 `__setitem__` 方法来设置键值对。\n\n4. `for i, (priority, k) in enumerate(self.heap):`: 遍历 `heap` 列表中的每一项，`i` 是索引，`priority` 和 `k` 分别是元组中的两个项目，其中 `priority` 是优先级（或排序函数的结果），`k` 是键。\n\n5. `if k == key:`: 如果当前键等于要设置的键。\n\n6. `self.heap[i] = (self.sort_func(key, value), key)`: 使用 `sort_func` 函数计算新的优先级，并更新 `heap` 列表中对应的项。\n\n7. `heapq.heapify(self.heap)`: 重新调整 `heap` 列表以保持堆的特性（堆是完全二叉树，且任一节点的值都大于或等于其子节点的值）。\n\n8. `break`: 找到了正确的键，所以退出循环。\n\n9. `self.sorted_keys = None`: 重置 `sorted_keys`。\n\n10. `else:`: 如果字典中不存在这个键。\n\n11. `super().__setitem__(key, value)`: 使用超类的 `__setitem__` 方法来设置新的键值对。\n\n12. `heapq.heappush(self.heap, (self.sort_func(key, value), key))`: 在 `heap` 列表中添加新的元素，元素是一个元组，包含 `sort_func` 函数计算出的优先级和键。\n\n13. `self.sorted_keys = None`: 重置 `sorted_keys`。\n\n这段代码的主要目的是实现一个可以自我排序的字典或者类似结构，键值对的排序取决于 `sort_func` 函数的返回结果。\n## 2\nimport ntwork\nimport pilk\n\n","source":"_posts/人工智能/大语言模型/微信项目.md","raw":"\n# 地址\n\nhttps://github.com/zhayujie/chatgpt-on-wechat\n\n[ChatGPT微信开发，轻松拿捏_keyerror: 'wxsid-CSDN博客](https://blog.csdn.net/qq_37215621/article/details/130517060)\n\nhttps://space.bilibili.com/4401694/dynamic\n\n\n\n# 运行\nnohup python3 app.py & tail -f nohup.out\nnohup ./clash-linux-amd64 > /dev/null 2>&1 &\nnohup docker compose up > /dev/null 2>&1 &\n# 问题\n\n[WARNING][2024-02-27 04:41:40][chat_gpt_bot.py:150] - [CHATGPT] APIConnectionError: Error communicating with OpenAI: HTTPSConnectionPool(host='api.openai.com', port=443): Max retries exceeded with url: /v1/chat/completions (Caused by ProxyError('Cannot connect to proxy.', NewConnectionError('<urllib3.connection.HTTPSConnection object at 0x7f75d9c45e50>: Failed to establish a new connection: [Errno 111] Connection refused')))\n[WARNING][2024-02-27 04:41:40][chat_gpt_bot.py:150] - [CHATGPT] APIConnectionError: Error communicating with OpenAI: HTTPSConnectionPool(host='api.openai.com', port=443): Max retries exceeded with url: /v1/chat/completions (Caused by ProxyError('Cannot connect to proxy.', NewConnectionError('<urllib3.connection.HTTPSConnection object at 0x7f75d9c45fa0>: Failed to establish a new connection: [Errno 111] Connection refused')))\n[INFO][2024-02-27 04:41:40][wechat_channel.py:218] - [WX] sendMsg=Reply(type=ERROR, content=[ERROR]\n我连接不到你的网络), receiver=@dade582ddc06e63c6ec1175c680f90ff82f77df7c20d9450bfb147cb5a925968\n\n\n## 解决\n[【完美解决：openai.error.APIConnectionError: Error communicating with OpenAI:】_openai.openaierror: the api_key client option must-CSDN博客](https://blog.csdn.net/T752462536/article/details/134164508)\n\n`pip3 show openai`查看安装目录\n`cd /opt/conda/envs/fyn_python3_8/lib/python3.8/site-packages/openai`\n\n\n# 问题\n\n## 1 \n\n[INFO][2024-02-27 05:34:07][chat_gpt_bot.py:49] - [CHATGPT] query=哈哈哈\n[ERROR][2024-02-27 05:34:07][chat_gpt_bot.py:155] - [CHATGPT] Exception: local variable 'proxy' referenced before assignment\nTraceback (most recent call last):\n  File \"/root/test/GptWchat/chatgpt-on-wechat/bot/chatgpt/chat_gpt_bot.py\", line 123, in reply_text\n    response = openai.ChatCompletion.create(api_key=api_key, messages=session.messages, **args)\n  File \"/opt/conda/envs/fyn_python3_8/lib/python3.8/site-packages/openai/api_resources/chat_completion.py\", line 25, in create\n    return super().create(*args, **kwargs)\n  File \"/opt/conda/envs/fyn_python3_8/lib/python3.8/site-packages/openai/api_resources/abstract/engine_api_resource.py\", line 153, in create\n    response, _, api_key = requestor.request(\n  File \"/opt/conda/envs/fyn_python3_8/lib/python3.8/site-packages/openai/api_requestor.py\", line 288, in request\n    result = self.request_raw(\n  File \"/opt/conda/envs/fyn_python3_8/lib/python3.8/site-packages/openai/api_requestor.py\", line 609, in request_raw\n    proxies=proxy,\nUnboundLocalError: local variable 'proxy' referenced before assignment\n[INFO][2024-02-27 05:34:08][wechat_channel.py:218] - [WX] sendMsg=Reply(type=ERROR, content=[ERROR]\n我现在有点累了，等会再来吧), receiver=@5dc3bf914f7a577d4798603da08adc85720678732d3a0413329ceebb3041f0b7\n\n\n\n[bot] 这段代码是在Python中定义一个特殊的 `__setitem__` 方法，它是一个魔法方法或者叫做运算符重载。这个方法在我们试图给一个对象的实例分配值时被调用。这里看起来像是在实现一个优先级队列或者是一个以某种方式排序的字典。\n\n下面是代码行的详细解释：\n\n1. `def __setitem__(self, key, value):`: 定义一个名为 `__setitem__` 的方法，它接收三个参数：`self`（表示实例自身，类似于 Java 或 C++ 中的 `this`），`key`（字典中要设置的键），`value`（该键所对应的值）。\n\n2. `if key in self:`: 如果提供的键已经在字典中存在。\n\n3. `super().__setitem__(key, value)`: 使用超类（可能是 `dict` 或其它字典类型）的 `__setitem__` 方法来设置键值对。\n\n4. `for i, (priority, k) in enumerate(self.heap):`: 遍历 `heap` 列表中的每一项，`i` 是索引，`priority` 和 `k` 分别是元组中的两个项目，其中 `priority` 是优先级（或排序函数的结果），`k` 是键。\n\n5. `if k == key:`: 如果当前键等于要设置的键。\n\n6. `self.heap[i] = (self.sort_func(key, value), key)`: 使用 `sort_func` 函数计算新的优先级，并更新 `heap` 列表中对应的项。\n\n7. `heapq.heapify(self.heap)`: 重新调整 `heap` 列表以保持堆的特性（堆是完全二叉树，且任一节点的值都大于或等于其子节点的值）。\n\n8. `break`: 找到了正确的键，所以退出循环。\n\n9. `self.sorted_keys = None`: 重置 `sorted_keys`。\n\n10. `else:`: 如果字典中不存在这个键。\n\n11. `super().__setitem__(key, value)`: 使用超类的 `__setitem__` 方法来设置新的键值对。\n\n12. `heapq.heappush(self.heap, (self.sort_func(key, value), key))`: 在 `heap` 列表中添加新的元素，元素是一个元组，包含 `sort_func` 函数计算出的优先级和键。\n\n13. `self.sorted_keys = None`: 重置 `sorted_keys`。\n\n这段代码的主要目的是实现一个可以自我排序的字典或者类似结构，键值对的排序取决于 `sort_func` 函数的返回结果。\n## 2\nimport ntwork\nimport pilk\n\n","slug":"人工智能/大语言模型/微信项目","published":1,"date":"2024-04-22T13:14:48.991Z","updated":"2024-03-19T14:00:49.793Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0o0028kgg48pbj3efe","content":"<h1 id=\"地址\"><a href=\"#地址\" class=\"headerlink\" title=\"地址\"></a>地址</h1><p><a href=\"https://github.com/zhayujie/chatgpt-on-wechat\">https://github.com/zhayujie/chatgpt-on-wechat</a></p>\n<p><a href=\"https://blog.csdn.net/qq_37215621/article/details/130517060\">ChatGPT微信开发，轻松拿捏_keyerror: ‘wxsid-CSDN博客</a></p>\n<p><a href=\"https://space.bilibili.com/4401694/dynamic\">https://space.bilibili.com/4401694/dynamic</a></p>\n<h1 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h1><p>nohup python3 app.py &amp; tail -f nohup.out<br>nohup .&#x2F;clash-linux-amd64 &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;<br>nohup docker compose up &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;</p>\n<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><p>[WARNING][2024-02-27 04:41:40][chat_gpt_bot.py:150] - [CHATGPT] APIConnectionError: Error communicating with OpenAI: HTTPSConnectionPool(host&#x3D;’api.openai.com’, port&#x3D;443): Max retries exceeded with url: &#x2F;v1&#x2F;chat&#x2F;completions (Caused by ProxyError(‘Cannot connect to proxy.’, NewConnectionError(‘&lt;urllib3.connection.HTTPSConnection object at 0x7f75d9c45e50&gt;: Failed to establish a new connection: [Errno 111] Connection refused’)))<br>[WARNING][2024-02-27 04:41:40][chat_gpt_bot.py:150] - [CHATGPT] APIConnectionError: Error communicating with OpenAI: HTTPSConnectionPool(host&#x3D;’api.openai.com’, port&#x3D;443): Max retries exceeded with url: &#x2F;v1&#x2F;chat&#x2F;completions (Caused by ProxyError(‘Cannot connect to proxy.’, NewConnectionError(‘&lt;urllib3.connection.HTTPSConnection object at 0x7f75d9c45fa0&gt;: Failed to establish a new connection: [Errno 111] Connection refused’)))<br>[INFO][2024-02-27 04:41:40][wechat_channel.py:218] - [WX] sendMsg&#x3D;Reply(type&#x3D;ERROR, content&#x3D;[ERROR]<br>我连接不到你的网络), receiver&#x3D;@dade582ddc06e63c6ec1175c680f90ff82f77df7c20d9450bfb147cb5a925968</p>\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><p><a href=\"https://blog.csdn.net/T752462536/article/details/134164508\">【完美解决：openai.error.APIConnectionError: Error communicating with OpenAI:】_openai.openaierror: the api_key client option must-CSDN博客</a></p>\n<p><code>pip3 show openai</code>查看安装目录<br><code>cd /opt/conda/envs/fyn_python3_8/lib/python3.8/site-packages/openai</code></p>\n<h1 id=\"问题-1\"><a href=\"#问题-1\" class=\"headerlink\" title=\"问题\"></a>问题</h1><h2 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1\"></a>1</h2><p>[INFO][2024-02-27 05:34:07][chat_gpt_bot.py:49] - [CHATGPT] query&#x3D;哈哈哈<br>[ERROR][2024-02-27 05:34:07][chat_gpt_bot.py:155] - [CHATGPT] Exception: local variable ‘proxy’ referenced before assignment<br>Traceback (most recent call last):<br>  File “&#x2F;root&#x2F;test&#x2F;GptWchat&#x2F;chatgpt-on-wechat&#x2F;bot&#x2F;chatgpt&#x2F;chat_gpt_bot.py”, line 123, in reply_text<br>    response &#x3D; openai.ChatCompletion.create(api_key&#x3D;api_key, messages&#x3D;session.messages, **args)<br>  File “&#x2F;opt&#x2F;conda&#x2F;envs&#x2F;fyn_python3_8&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;openai&#x2F;api_resources&#x2F;chat_completion.py”, line 25, in create<br>    return super().create(*args, **kwargs)<br>  File “&#x2F;opt&#x2F;conda&#x2F;envs&#x2F;fyn_python3_8&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;openai&#x2F;api_resources&#x2F;abstract&#x2F;engine_api_resource.py”, line 153, in create<br>    response, _, api_key &#x3D; requestor.request(<br>  File “&#x2F;opt&#x2F;conda&#x2F;envs&#x2F;fyn_python3_8&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;openai&#x2F;api_requestor.py”, line 288, in request<br>    result &#x3D; self.request_raw(<br>  File “&#x2F;opt&#x2F;conda&#x2F;envs&#x2F;fyn_python3_8&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;openai&#x2F;api_requestor.py”, line 609, in request_raw<br>    proxies&#x3D;proxy,<br>UnboundLocalError: local variable ‘proxy’ referenced before assignment<br>[INFO][2024-02-27 05:34:08][wechat_channel.py:218] - [WX] sendMsg&#x3D;Reply(type&#x3D;ERROR, content&#x3D;[ERROR]<br>我现在有点累了，等会再来吧), receiver&#x3D;@5dc3bf914f7a577d4798603da08adc85720678732d3a0413329ceebb3041f0b7</p>\n<p>[bot] 这段代码是在Python中定义一个特殊的 <code>__setitem__</code> 方法，它是一个魔法方法或者叫做运算符重载。这个方法在我们试图给一个对象的实例分配值时被调用。这里看起来像是在实现一个优先级队列或者是一个以某种方式排序的字典。</p>\n<p>下面是代码行的详细解释：</p>\n<ol>\n<li><p><code>def __setitem__(self, key, value):</code>: 定义一个名为 <code>__setitem__</code> 的方法，它接收三个参数：<code>self</code>（表示实例自身，类似于 Java 或 C++ 中的 <code>this</code>），<code>key</code>（字典中要设置的键），<code>value</code>（该键所对应的值）。</p>\n</li>\n<li><p><code>if key in self:</code>: 如果提供的键已经在字典中存在。</p>\n</li>\n<li><p><code>super().__setitem__(key, value)</code>: 使用超类（可能是 <code>dict</code> 或其它字典类型）的 <code>__setitem__</code> 方法来设置键值对。</p>\n</li>\n<li><p><code>for i, (priority, k) in enumerate(self.heap):</code>: 遍历 <code>heap</code> 列表中的每一项，<code>i</code> 是索引，<code>priority</code> 和 <code>k</code> 分别是元组中的两个项目，其中 <code>priority</code> 是优先级（或排序函数的结果），<code>k</code> 是键。</p>\n</li>\n<li><p><code>if k == key:</code>: 如果当前键等于要设置的键。</p>\n</li>\n<li><p><code>self.heap[i] = (self.sort_func(key, value), key)</code>: 使用 <code>sort_func</code> 函数计算新的优先级，并更新 <code>heap</code> 列表中对应的项。</p>\n</li>\n<li><p><code>heapq.heapify(self.heap)</code>: 重新调整 <code>heap</code> 列表以保持堆的特性（堆是完全二叉树，且任一节点的值都大于或等于其子节点的值）。</p>\n</li>\n<li><p><code>break</code>: 找到了正确的键，所以退出循环。</p>\n</li>\n<li><p><code>self.sorted_keys = None</code>: 重置 <code>sorted_keys</code>。</p>\n</li>\n<li><p><code>else:</code>: 如果字典中不存在这个键。</p>\n</li>\n<li><p><code>super().__setitem__(key, value)</code>: 使用超类的 <code>__setitem__</code> 方法来设置新的键值对。</p>\n</li>\n<li><p><code>heapq.heappush(self.heap, (self.sort_func(key, value), key))</code>: 在 <code>heap</code> 列表中添加新的元素，元素是一个元组，包含 <code>sort_func</code> 函数计算出的优先级和键。</p>\n</li>\n<li><p><code>self.sorted_keys = None</code>: 重置 <code>sorted_keys</code>。</p>\n</li>\n</ol>\n<p>这段代码的主要目的是实现一个可以自我排序的字典或者类似结构，键值对的排序取决于 <code>sort_func</code> 函数的返回结果。</p>\n<h2 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2\"></a>2</h2><p>import ntwork<br>import pilk</p>\n","excerpt":"","more":"<h1 id=\"地址\"><a href=\"#地址\" class=\"headerlink\" title=\"地址\"></a>地址</h1><p><a href=\"https://github.com/zhayujie/chatgpt-on-wechat\">https://github.com/zhayujie/chatgpt-on-wechat</a></p>\n<p><a href=\"https://blog.csdn.net/qq_37215621/article/details/130517060\">ChatGPT微信开发，轻松拿捏_keyerror: ‘wxsid-CSDN博客</a></p>\n<p><a href=\"https://space.bilibili.com/4401694/dynamic\">https://space.bilibili.com/4401694/dynamic</a></p>\n<h1 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h1><p>nohup python3 app.py &amp; tail -f nohup.out<br>nohup .&#x2F;clash-linux-amd64 &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;<br>nohup docker compose up &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;</p>\n<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><p>[WARNING][2024-02-27 04:41:40][chat_gpt_bot.py:150] - [CHATGPT] APIConnectionError: Error communicating with OpenAI: HTTPSConnectionPool(host&#x3D;’api.openai.com’, port&#x3D;443): Max retries exceeded with url: &#x2F;v1&#x2F;chat&#x2F;completions (Caused by ProxyError(‘Cannot connect to proxy.’, NewConnectionError(‘&lt;urllib3.connection.HTTPSConnection object at 0x7f75d9c45e50&gt;: Failed to establish a new connection: [Errno 111] Connection refused’)))<br>[WARNING][2024-02-27 04:41:40][chat_gpt_bot.py:150] - [CHATGPT] APIConnectionError: Error communicating with OpenAI: HTTPSConnectionPool(host&#x3D;’api.openai.com’, port&#x3D;443): Max retries exceeded with url: &#x2F;v1&#x2F;chat&#x2F;completions (Caused by ProxyError(‘Cannot connect to proxy.’, NewConnectionError(‘&lt;urllib3.connection.HTTPSConnection object at 0x7f75d9c45fa0&gt;: Failed to establish a new connection: [Errno 111] Connection refused’)))<br>[INFO][2024-02-27 04:41:40][wechat_channel.py:218] - [WX] sendMsg&#x3D;Reply(type&#x3D;ERROR, content&#x3D;[ERROR]<br>我连接不到你的网络), receiver&#x3D;@dade582ddc06e63c6ec1175c680f90ff82f77df7c20d9450bfb147cb5a925968</p>\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><p><a href=\"https://blog.csdn.net/T752462536/article/details/134164508\">【完美解决：openai.error.APIConnectionError: Error communicating with OpenAI:】_openai.openaierror: the api_key client option must-CSDN博客</a></p>\n<p><code>pip3 show openai</code>查看安装目录<br><code>cd /opt/conda/envs/fyn_python3_8/lib/python3.8/site-packages/openai</code></p>\n<h1 id=\"问题-1\"><a href=\"#问题-1\" class=\"headerlink\" title=\"问题\"></a>问题</h1><h2 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1\"></a>1</h2><p>[INFO][2024-02-27 05:34:07][chat_gpt_bot.py:49] - [CHATGPT] query&#x3D;哈哈哈<br>[ERROR][2024-02-27 05:34:07][chat_gpt_bot.py:155] - [CHATGPT] Exception: local variable ‘proxy’ referenced before assignment<br>Traceback (most recent call last):<br>  File “&#x2F;root&#x2F;test&#x2F;GptWchat&#x2F;chatgpt-on-wechat&#x2F;bot&#x2F;chatgpt&#x2F;chat_gpt_bot.py”, line 123, in reply_text<br>    response &#x3D; openai.ChatCompletion.create(api_key&#x3D;api_key, messages&#x3D;session.messages, **args)<br>  File “&#x2F;opt&#x2F;conda&#x2F;envs&#x2F;fyn_python3_8&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;openai&#x2F;api_resources&#x2F;chat_completion.py”, line 25, in create<br>    return super().create(*args, **kwargs)<br>  File “&#x2F;opt&#x2F;conda&#x2F;envs&#x2F;fyn_python3_8&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;openai&#x2F;api_resources&#x2F;abstract&#x2F;engine_api_resource.py”, line 153, in create<br>    response, _, api_key &#x3D; requestor.request(<br>  File “&#x2F;opt&#x2F;conda&#x2F;envs&#x2F;fyn_python3_8&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;openai&#x2F;api_requestor.py”, line 288, in request<br>    result &#x3D; self.request_raw(<br>  File “&#x2F;opt&#x2F;conda&#x2F;envs&#x2F;fyn_python3_8&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;openai&#x2F;api_requestor.py”, line 609, in request_raw<br>    proxies&#x3D;proxy,<br>UnboundLocalError: local variable ‘proxy’ referenced before assignment<br>[INFO][2024-02-27 05:34:08][wechat_channel.py:218] - [WX] sendMsg&#x3D;Reply(type&#x3D;ERROR, content&#x3D;[ERROR]<br>我现在有点累了，等会再来吧), receiver&#x3D;@5dc3bf914f7a577d4798603da08adc85720678732d3a0413329ceebb3041f0b7</p>\n<p>[bot] 这段代码是在Python中定义一个特殊的 <code>__setitem__</code> 方法，它是一个魔法方法或者叫做运算符重载。这个方法在我们试图给一个对象的实例分配值时被调用。这里看起来像是在实现一个优先级队列或者是一个以某种方式排序的字典。</p>\n<p>下面是代码行的详细解释：</p>\n<ol>\n<li><p><code>def __setitem__(self, key, value):</code>: 定义一个名为 <code>__setitem__</code> 的方法，它接收三个参数：<code>self</code>（表示实例自身，类似于 Java 或 C++ 中的 <code>this</code>），<code>key</code>（字典中要设置的键），<code>value</code>（该键所对应的值）。</p>\n</li>\n<li><p><code>if key in self:</code>: 如果提供的键已经在字典中存在。</p>\n</li>\n<li><p><code>super().__setitem__(key, value)</code>: 使用超类（可能是 <code>dict</code> 或其它字典类型）的 <code>__setitem__</code> 方法来设置键值对。</p>\n</li>\n<li><p><code>for i, (priority, k) in enumerate(self.heap):</code>: 遍历 <code>heap</code> 列表中的每一项，<code>i</code> 是索引，<code>priority</code> 和 <code>k</code> 分别是元组中的两个项目，其中 <code>priority</code> 是优先级（或排序函数的结果），<code>k</code> 是键。</p>\n</li>\n<li><p><code>if k == key:</code>: 如果当前键等于要设置的键。</p>\n</li>\n<li><p><code>self.heap[i] = (self.sort_func(key, value), key)</code>: 使用 <code>sort_func</code> 函数计算新的优先级，并更新 <code>heap</code> 列表中对应的项。</p>\n</li>\n<li><p><code>heapq.heapify(self.heap)</code>: 重新调整 <code>heap</code> 列表以保持堆的特性（堆是完全二叉树，且任一节点的值都大于或等于其子节点的值）。</p>\n</li>\n<li><p><code>break</code>: 找到了正确的键，所以退出循环。</p>\n</li>\n<li><p><code>self.sorted_keys = None</code>: 重置 <code>sorted_keys</code>。</p>\n</li>\n<li><p><code>else:</code>: 如果字典中不存在这个键。</p>\n</li>\n<li><p><code>super().__setitem__(key, value)</code>: 使用超类的 <code>__setitem__</code> 方法来设置新的键值对。</p>\n</li>\n<li><p><code>heapq.heappush(self.heap, (self.sort_func(key, value), key))</code>: 在 <code>heap</code> 列表中添加新的元素，元素是一个元组，包含 <code>sort_func</code> 函数计算出的优先级和键。</p>\n</li>\n<li><p><code>self.sorted_keys = None</code>: 重置 <code>sorted_keys</code>。</p>\n</li>\n</ol>\n<p>这段代码的主要目的是实现一个可以自我排序的字典或者类似结构，键值对的排序取决于 <code>sort_func</code> 函数的返回结果。</p>\n<h2 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2\"></a>2</h2><p>import ntwork<br>import pilk</p>\n"},{"_content":"\n\n# 大模型基础\n\n- **[Generative AI 的工作原理](https://www.bilibili.com/video/BV11G411X7nZ?p=2&vd_source=31f1c950b5b95af0c48f188f0bc047c7)**\n    \n- **[LLM 可以做什么, 不能做什么](https://www.bilibili.com/video/BV11G411X7nZ?p=8&vd_source=31f1c950b5b95af0c48f188f0bc047c7)**\n\n    \n- [LLM 技术精要](https://zhuanlan.zhihu.com/p/597586623)\n    \n- [经典开源 LLM](https://github.com/kebijuelun/Awesome-LLM-Learning/blob/main/3.%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/3.%E7%BB%8F%E5%85%B8%E5%BC%80%E6%BA%90LLM%E4%BB%8B%E7%BB%8D.md)\n\n## GAI\n[[GAI 的应用]]\n[[GAI 的工作原理]]\n\n\n# 一些资料\n\nhttps://www.bilibili.com/video/BV18G411q78w/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=59461060c1867e9bf731e467ae6f00b\n\nchatgptwchat\nhttps://github.com/a13120854557/Chatgptwchat/blob/main/README_ZH.md\n\n","source":"_posts/人工智能/大语言模型/大模型入门.md","raw":"\n\n# 大模型基础\n\n- **[Generative AI 的工作原理](https://www.bilibili.com/video/BV11G411X7nZ?p=2&vd_source=31f1c950b5b95af0c48f188f0bc047c7)**\n    \n- **[LLM 可以做什么, 不能做什么](https://www.bilibili.com/video/BV11G411X7nZ?p=8&vd_source=31f1c950b5b95af0c48f188f0bc047c7)**\n\n    \n- [LLM 技术精要](https://zhuanlan.zhihu.com/p/597586623)\n    \n- [经典开源 LLM](https://github.com/kebijuelun/Awesome-LLM-Learning/blob/main/3.%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/3.%E7%BB%8F%E5%85%B8%E5%BC%80%E6%BA%90LLM%E4%BB%8B%E7%BB%8D.md)\n\n## GAI\n[[GAI 的应用]]\n[[GAI 的工作原理]]\n\n\n# 一些资料\n\nhttps://www.bilibili.com/video/BV18G411q78w/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=59461060c1867e9bf731e467ae6f00b\n\nchatgptwchat\nhttps://github.com/a13120854557/Chatgptwchat/blob/main/README_ZH.md\n\n","slug":"人工智能/大语言模型/大模型入门","published":1,"date":"2024-04-22T13:14:48.991Z","updated":"2024-03-19T02:45:53.307Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0o0029kgg417t6azhm","content":"<h1 id=\"大模型基础\"><a href=\"#大模型基础\" class=\"headerlink\" title=\"大模型基础\"></a>大模型基础</h1><ul>\n<li><p><strong><a href=\"https://www.bilibili.com/video/BV11G411X7nZ?p=2&vd_source=31f1c950b5b95af0c48f188f0bc047c7\">Generative AI 的工作原理</a></strong></p>\n</li>\n<li><p><strong><a href=\"https://www.bilibili.com/video/BV11G411X7nZ?p=8&vd_source=31f1c950b5b95af0c48f188f0bc047c7\">LLM 可以做什么, 不能做什么</a></strong></p>\n</li>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/597586623\">LLM 技术精要</a></p>\n</li>\n<li><p><a href=\"https://github.com/kebijuelun/Awesome-LLM-Learning/blob/main/3.%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/3.%E7%BB%8F%E5%85%B8%E5%BC%80%E6%BA%90LLM%E4%BB%8B%E7%BB%8D.md\">经典开源 LLM</a></p>\n</li>\n</ul>\n<h2 id=\"GAI\"><a href=\"#GAI\" class=\"headerlink\" title=\"GAI\"></a>GAI</h2><p>[[GAI 的应用]]<br>[[GAI 的工作原理]]</p>\n<h1 id=\"一些资料\"><a href=\"#一些资料\" class=\"headerlink\" title=\"一些资料\"></a>一些资料</h1><p><a href=\"https://www.bilibili.com/video/BV18G411q78w/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=59461060c1867e9bf731e467ae6f00b\">https://www.bilibili.com/video/BV18G411q78w/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=59461060c1867e9bf731e467ae6f00b</a></p>\n<p>chatgptwchat<br><a href=\"https://github.com/a13120854557/Chatgptwchat/blob/main/README_ZH.md\">https://github.com/a13120854557/Chatgptwchat/blob/main/README_ZH.md</a></p>\n","excerpt":"","more":"<h1 id=\"大模型基础\"><a href=\"#大模型基础\" class=\"headerlink\" title=\"大模型基础\"></a>大模型基础</h1><ul>\n<li><p><strong><a href=\"https://www.bilibili.com/video/BV11G411X7nZ?p=2&vd_source=31f1c950b5b95af0c48f188f0bc047c7\">Generative AI 的工作原理</a></strong></p>\n</li>\n<li><p><strong><a href=\"https://www.bilibili.com/video/BV11G411X7nZ?p=8&vd_source=31f1c950b5b95af0c48f188f0bc047c7\">LLM 可以做什么, 不能做什么</a></strong></p>\n</li>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/597586623\">LLM 技术精要</a></p>\n</li>\n<li><p><a href=\"https://github.com/kebijuelun/Awesome-LLM-Learning/blob/main/3.%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/3.%E7%BB%8F%E5%85%B8%E5%BC%80%E6%BA%90LLM%E4%BB%8B%E7%BB%8D.md\">经典开源 LLM</a></p>\n</li>\n</ul>\n<h2 id=\"GAI\"><a href=\"#GAI\" class=\"headerlink\" title=\"GAI\"></a>GAI</h2><p>[[GAI 的应用]]<br>[[GAI 的工作原理]]</p>\n<h1 id=\"一些资料\"><a href=\"#一些资料\" class=\"headerlink\" title=\"一些资料\"></a>一些资料</h1><p><a href=\"https://www.bilibili.com/video/BV18G411q78w/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=59461060c1867e9bf731e467ae6f00b\">https://www.bilibili.com/video/BV18G411q78w/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=59461060c1867e9bf731e467ae6f00b</a></p>\n<p>chatgptwchat<br><a href=\"https://github.com/a13120854557/Chatgptwchat/blob/main/README_ZH.md\">https://github.com/a13120854557/Chatgptwchat/blob/main/README_ZH.md</a></p>\n"},{"_content":"https://jalammar.github.io/visualizing-neural-machine-translation-mechanics-of-seq2seq-models-with-attention/\n\nhttps://jalammar.github.io/illustrated-transformer/\nhttps://blog.csdn.net/yujianmin1990/article/details/85221271\n\n\n扩展 Attention 来加速训练，并且在特定任务上Transformer 表现比 Google NMT 模型还要好，最大好处是可并行 \n\n# 提出\n[Attention is All You Need](https://arxiv.org/abs/1706.03762)\n其中的 TF 应用是 Tensor2Tensor 的子模块。\n\n# 粗略概述\n1. 编码组件\n\t1. 六层编码器首尾相连：完全结构相同，但是不共享参数。\n\t2. 对于每一个编码器\n\t\t1. self-attention 层：帮助模型在编码某一个此时能看到别的单词\n\t\t2. 前向网络：每个self-attention的输出流向一个前向网络，每个输入位置对应的前向网络是独立互不干扰的。\n\t\t```text\n\t\t\n\t\t这里的每个输入位置：其实是一个序列中的不同位置\n\t\t\n\t\t```\n2. 连接层\n3. 解码组件\n\t1. 六层解码器首尾相连。每个输入位置对应的前向网络是独立互不干扰的。\n\t2. 对于每一个解码器：\n\t\t1. self-attention 层：\n\t\t2. attention 层：该层有助于解码器能够关注到输入句子的相关部分，以便更好的生成与输入有关的输出。（生成每个输出时，根据输入序列的不同部分动态地分配注意力权重。）\n\t\t3. 前向网络：\n# 待继续，有点累了。\nhttps://blog.csdn.net/yujianmin1990/article/details/85221271\n\n\n# Transformer有两个版本：\nTransformer base和Transformer Big。两者结构其实是一样的，主要区别是包含的Transformer Block数量不同，Transformer base包含12个Block叠加，而Transformer Big则扩张一倍，包含24个Block。无疑Transformer Big在网络深度，参数量以及计算量相对Transformer base翻倍，所以是相对重的一个模型，但是效果也最好。","source":"_posts/人工智能/常见模型/Transformer.md","raw":"https://jalammar.github.io/visualizing-neural-machine-translation-mechanics-of-seq2seq-models-with-attention/\n\nhttps://jalammar.github.io/illustrated-transformer/\nhttps://blog.csdn.net/yujianmin1990/article/details/85221271\n\n\n扩展 Attention 来加速训练，并且在特定任务上Transformer 表现比 Google NMT 模型还要好，最大好处是可并行 \n\n# 提出\n[Attention is All You Need](https://arxiv.org/abs/1706.03762)\n其中的 TF 应用是 Tensor2Tensor 的子模块。\n\n# 粗略概述\n1. 编码组件\n\t1. 六层编码器首尾相连：完全结构相同，但是不共享参数。\n\t2. 对于每一个编码器\n\t\t1. self-attention 层：帮助模型在编码某一个此时能看到别的单词\n\t\t2. 前向网络：每个self-attention的输出流向一个前向网络，每个输入位置对应的前向网络是独立互不干扰的。\n\t\t```text\n\t\t\n\t\t这里的每个输入位置：其实是一个序列中的不同位置\n\t\t\n\t\t```\n2. 连接层\n3. 解码组件\n\t1. 六层解码器首尾相连。每个输入位置对应的前向网络是独立互不干扰的。\n\t2. 对于每一个解码器：\n\t\t1. self-attention 层：\n\t\t2. attention 层：该层有助于解码器能够关注到输入句子的相关部分，以便更好的生成与输入有关的输出。（生成每个输出时，根据输入序列的不同部分动态地分配注意力权重。）\n\t\t3. 前向网络：\n# 待继续，有点累了。\nhttps://blog.csdn.net/yujianmin1990/article/details/85221271\n\n\n# Transformer有两个版本：\nTransformer base和Transformer Big。两者结构其实是一样的，主要区别是包含的Transformer Block数量不同，Transformer base包含12个Block叠加，而Transformer Big则扩张一倍，包含24个Block。无疑Transformer Big在网络深度，参数量以及计算量相对Transformer base翻倍，所以是相对重的一个模型，但是效果也最好。","slug":"人工智能/常见模型/Transformer","published":1,"date":"2024-04-22T13:14:49.007Z","updated":"2024-03-02T06:31:21.631Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0o002akgg4eyq27bg1","content":"<p><a href=\"https://jalammar.github.io/visualizing-neural-machine-translation-mechanics-of-seq2seq-models-with-attention/\">https://jalammar.github.io/visualizing-neural-machine-translation-mechanics-of-seq2seq-models-with-attention/</a></p>\n<p><a href=\"https://jalammar.github.io/illustrated-transformer/\">https://jalammar.github.io/illustrated-transformer/</a><br><a href=\"https://blog.csdn.net/yujianmin1990/article/details/85221271\">https://blog.csdn.net/yujianmin1990/article/details/85221271</a></p>\n<p>扩展 Attention 来加速训练，并且在特定任务上Transformer 表现比 Google NMT 模型还要好，最大好处是可并行 </p>\n<h1 id=\"提出\"><a href=\"#提出\" class=\"headerlink\" title=\"提出\"></a>提出</h1><p><a href=\"https://arxiv.org/abs/1706.03762\">Attention is All You Need</a><br>其中的 TF 应用是 Tensor2Tensor 的子模块。</p>\n<h1 id=\"粗略概述\"><a href=\"#粗略概述\" class=\"headerlink\" title=\"粗略概述\"></a>粗略概述</h1><ol>\n<li>编码组件<ol>\n<li>六层编码器首尾相连：完全结构相同，但是不共享参数。</li>\n<li>对于每一个编码器<ol>\n<li>self-attention 层：帮助模型在编码某一个此时能看到别的单词</li>\n<li>前向网络：每个self-attention的输出流向一个前向网络，每个输入位置对应的前向网络是独立互不干扰的。 <figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">这里的每个输入位置：其实是一个序列中的不同位置</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n</li>\n<li>连接层</li>\n<li>解码组件<ol>\n<li>六层解码器首尾相连。每个输入位置对应的前向网络是独立互不干扰的。</li>\n<li>对于每一个解码器：<ol>\n<li>self-attention 层：</li>\n<li>attention 层：该层有助于解码器能够关注到输入句子的相关部分，以便更好的生成与输入有关的输出。（生成每个输出时，根据输入序列的不同部分动态地分配注意力权重。）</li>\n<li>前向网络：</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"待继续，有点累了。\"><a href=\"#待继续，有点累了。\" class=\"headerlink\" title=\"待继续，有点累了。\"></a>待继续，有点累了。</h1><p><a href=\"https://blog.csdn.net/yujianmin1990/article/details/85221271\">https://blog.csdn.net/yujianmin1990/article/details/85221271</a></p>\n<h1 id=\"Transformer有两个版本：\"><a href=\"#Transformer有两个版本：\" class=\"headerlink\" title=\"Transformer有两个版本：\"></a>Transformer有两个版本：</h1><p>Transformer base和Transformer Big。两者结构其实是一样的，主要区别是包含的Transformer Block数量不同，Transformer base包含12个Block叠加，而Transformer Big则扩张一倍，包含24个Block。无疑Transformer Big在网络深度，参数量以及计算量相对Transformer base翻倍，所以是相对重的一个模型，但是效果也最好。</p>\n","excerpt":"","more":"<p><a href=\"https://jalammar.github.io/visualizing-neural-machine-translation-mechanics-of-seq2seq-models-with-attention/\">https://jalammar.github.io/visualizing-neural-machine-translation-mechanics-of-seq2seq-models-with-attention/</a></p>\n<p><a href=\"https://jalammar.github.io/illustrated-transformer/\">https://jalammar.github.io/illustrated-transformer/</a><br><a href=\"https://blog.csdn.net/yujianmin1990/article/details/85221271\">https://blog.csdn.net/yujianmin1990/article/details/85221271</a></p>\n<p>扩展 Attention 来加速训练，并且在特定任务上Transformer 表现比 Google NMT 模型还要好，最大好处是可并行 </p>\n<h1 id=\"提出\"><a href=\"#提出\" class=\"headerlink\" title=\"提出\"></a>提出</h1><p><a href=\"https://arxiv.org/abs/1706.03762\">Attention is All You Need</a><br>其中的 TF 应用是 Tensor2Tensor 的子模块。</p>\n<h1 id=\"粗略概述\"><a href=\"#粗略概述\" class=\"headerlink\" title=\"粗略概述\"></a>粗略概述</h1><ol>\n<li>编码组件<ol>\n<li>六层编码器首尾相连：完全结构相同，但是不共享参数。</li>\n<li>对于每一个编码器<ol>\n<li>self-attention 层：帮助模型在编码某一个此时能看到别的单词</li>\n<li>前向网络：每个self-attention的输出流向一个前向网络，每个输入位置对应的前向网络是独立互不干扰的。 <figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">这里的每个输入位置：其实是一个序列中的不同位置</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n</li>\n<li>连接层</li>\n<li>解码组件<ol>\n<li>六层解码器首尾相连。每个输入位置对应的前向网络是独立互不干扰的。</li>\n<li>对于每一个解码器：<ol>\n<li>self-attention 层：</li>\n<li>attention 层：该层有助于解码器能够关注到输入句子的相关部分，以便更好的生成与输入有关的输出。（生成每个输出时，根据输入序列的不同部分动态地分配注意力权重。）</li>\n<li>前向网络：</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"待继续，有点累了。\"><a href=\"#待继续，有点累了。\" class=\"headerlink\" title=\"待继续，有点累了。\"></a>待继续，有点累了。</h1><p><a href=\"https://blog.csdn.net/yujianmin1990/article/details/85221271\">https://blog.csdn.net/yujianmin1990/article/details/85221271</a></p>\n<h1 id=\"Transformer有两个版本：\"><a href=\"#Transformer有两个版本：\" class=\"headerlink\" title=\"Transformer有两个版本：\"></a>Transformer有两个版本：</h1><p>Transformer base和Transformer Big。两者结构其实是一样的，主要区别是包含的Transformer Block数量不同，Transformer base包含12个Block叠加，而Transformer Big则扩张一倍，包含24个Block。无疑Transformer Big在网络深度，参数量以及计算量相对Transformer base翻倍，所以是相对重的一个模型，但是效果也最好。</p>\n"},{"_content":"# GAN\n## 关键\n1. 生成对抗网络（GANs）将当前用于判别机器学习的深度神经网络的进步转化为（隐式）生成建模。\n2. GAN 训练一个生成式深度学习网络 G，将多维随机样本 z （来自高斯分布或者均匀分布）作为输入，从所需分布中生成一个样本。\n3. GANs 将密度估计问题转换为 二元分类问题，其中对 G 参数的学习是通过能耐区分真假数据的判别深度神经网络 D 来实现的。\n4. 更正式地说，GAN 解决的优化问题可以概括如下：\n\t![[Pasted image 20240415162616.png]]\n\t  HashCat Per position Markov Chains. \n\n## 分类\n1. 基于积分概率指标：IPM-based GAN\n\t为 GAN 训练 提供稳定性，学习过程中相对稳定，\n2. 基于非积分概率指标：non-IPM-based GAN\n## 缺点\n在学习阶段不稳定，模型优化困难。\n\n# WGAN\n## 概述\nArjovsky 等人 2017 提出的 WGAN 通过采用 Wasserstein 距离作为损失来提高标准 GAN 的训练稳定性。 这种方法的好处包括减少模式崩溃和有意义的学习曲线，这有助于确定最佳超参数。 WGAN 纳入了新的成本函数； 然而，WGAN 的实验重点是生成逼真的图像。 古尔拉贾尼等人。\n## 优化\n与传统的GAN相比，WGAN通过引入Wasserstein距离取代了传统GAN中使用的JS散度或KL散度，从而在训练过程中提供了更稳定的梯度信号。\n\n## 策略\n为了实现Wasserstein距离的近似，WGAN引入了一个判别器的参数范数约束，即Lipschitz限制。这通过对判别器的权重进行剪裁或权重正则化来实现。然而，这种限制方法可能难以实施并且效果不稳定。\n\n\n# IWGAN \n可以更有效地找到全局最优值。 他们引入了梯度惩罚的概念来代替 WGAN 的梯度裁剪。 古尔拉贾尼等人。 提出使用IWGAN来解决文本生成问题。 在 Gulrajani 等人的 IWGAN 中，G 和 D 都由简单的残差 CNN 组成。 残差架构使得 GAN 的训练快速且稳定[30,31]。 G 将潜在噪声向量作为输入，通过将其转发到其卷积层来对其进行转换，并输出 32 个 one-hot 字符向量的序列。 G的输出层采用softmax非线性函数，并将其转发给D。假样本的每个输出特征由argmax函数的结果决定，argmax函数将G生成的每个输出向量作为输入。 \n\n## Relativistic Average GAN\n\n相对论平均生成对抗网络（Relativistic Average GAN）是生成对抗网络（GAN）的一种变体，旨在改善生成对抗网络的训练和生成效果。\n\n## 背景\n传统的GAN中，生成器试图生成逼真的样本，而判别器则根据样本的真实性进行分类。然而，这种方式可能导致生成器和判别器陷入不稳定的训练过程，因为生成器的更新依赖于判别器的反馈，而判别器的反馈又依赖于生成器生成的样本。\n## 特点\n相对论平均GAN通过引入相对论平均策略来解决这个问题。在这种策略下，生成器和判别器之间的对抗性比较被重新定义，以便更准确地反映出生成样本的真实性。具体而言，相对论平均GAN引入了两个新的损失函数：相对论平均生成器损失和相对论平均判别器损失。\n\n1. 相对论平均生成器损失（Relativistic Average Generator Loss）是通过对真实样本和生成样本进行比较来度量生成器的性能。它通过计算生成样本在判别器给出真实样本的概率上的平均值来评估生成器的生成能力。\n\n2. 相对论平均判别器损失（Relativistic Average Discriminator Loss）用于度量判别器的性能。它通过比较真实样本和生成样本之间的相对概率来评估判别器的辨别能力。\n\n## 训练过程\n\n1. 从真实样本中随机采样。\n2. 使用生成器生成一批样本。\n3. 计算相对论平均生成器损失和相对论平均判别器损失。\n4. 更新生成器的参数以减小相对论平均生成器损失。\n5. 更新判别器的参数以减小相对论平均判别器损失。\n6. 重复步骤1-5，直到达到预定的训练轮数或生成样本达到所需的质量。\n## 优点\n改善了生成样本的质量和训练的稳定性。通过引入相对论平均策略，生成器和判别器能够更准确地估计样本的真实性，并促使它们相互逼近，提高生成样本的质量。这种模型在图像生成、文本生成和其他生成任务中都有应用。\n\n\n# WGAN-GP\nWGAN-GP通过引入梯度惩罚解决了WGAN中的限制问题。梯度惩罚是通过在判别器的输出和真实样本之间的采样点上计算梯度范数的平均值，并将其与预定义的惩罚因子相乘来实现的。这个惩罚项鼓励判别器在整个输入空间上保持平滑的梯度，从而使判别器满足Lipschitz连续性的要求。\n\n具体来说，在WGAN-GP中，生成器和判别器的训练过程如下：\n\n1. 从真实数据和生成器生成的样本中采样。\n2. 在采样点上计算判别器的输出。\n3. 计算判别器的梯度惩罚，并将其添加到判别器的损失函数中。\n4. 更新判别器的参数以最小化损失函数。\n5. 对生成器进行更新，最大化判别器对生成样本的输出。\n\nWGAN-GP相对于传统的GAN具有几个优点。首先，它提供了更稳定的训练过程，减少了训练中的模式崩溃和模式衍生问题。其次，通过梯度惩罚，WGAN-GP避免了对判别器权重的剪裁或正则化，使得模型的训练更简单和可靠。最后，WGAN-GP在生成器和判别器之间提供了更准确的梯度信号，从而改善了生成样本的质量和多样性。","source":"_posts/人工智能/常见模型/GAN.md","raw":"# GAN\n## 关键\n1. 生成对抗网络（GANs）将当前用于判别机器学习的深度神经网络的进步转化为（隐式）生成建模。\n2. GAN 训练一个生成式深度学习网络 G，将多维随机样本 z （来自高斯分布或者均匀分布）作为输入，从所需分布中生成一个样本。\n3. GANs 将密度估计问题转换为 二元分类问题，其中对 G 参数的学习是通过能耐区分真假数据的判别深度神经网络 D 来实现的。\n4. 更正式地说，GAN 解决的优化问题可以概括如下：\n\t![[Pasted image 20240415162616.png]]\n\t  HashCat Per position Markov Chains. \n\n## 分类\n1. 基于积分概率指标：IPM-based GAN\n\t为 GAN 训练 提供稳定性，学习过程中相对稳定，\n2. 基于非积分概率指标：non-IPM-based GAN\n## 缺点\n在学习阶段不稳定，模型优化困难。\n\n# WGAN\n## 概述\nArjovsky 等人 2017 提出的 WGAN 通过采用 Wasserstein 距离作为损失来提高标准 GAN 的训练稳定性。 这种方法的好处包括减少模式崩溃和有意义的学习曲线，这有助于确定最佳超参数。 WGAN 纳入了新的成本函数； 然而，WGAN 的实验重点是生成逼真的图像。 古尔拉贾尼等人。\n## 优化\n与传统的GAN相比，WGAN通过引入Wasserstein距离取代了传统GAN中使用的JS散度或KL散度，从而在训练过程中提供了更稳定的梯度信号。\n\n## 策略\n为了实现Wasserstein距离的近似，WGAN引入了一个判别器的参数范数约束，即Lipschitz限制。这通过对判别器的权重进行剪裁或权重正则化来实现。然而，这种限制方法可能难以实施并且效果不稳定。\n\n\n# IWGAN \n可以更有效地找到全局最优值。 他们引入了梯度惩罚的概念来代替 WGAN 的梯度裁剪。 古尔拉贾尼等人。 提出使用IWGAN来解决文本生成问题。 在 Gulrajani 等人的 IWGAN 中，G 和 D 都由简单的残差 CNN 组成。 残差架构使得 GAN 的训练快速且稳定[30,31]。 G 将潜在噪声向量作为输入，通过将其转发到其卷积层来对其进行转换，并输出 32 个 one-hot 字符向量的序列。 G的输出层采用softmax非线性函数，并将其转发给D。假样本的每个输出特征由argmax函数的结果决定，argmax函数将G生成的每个输出向量作为输入。 \n\n## Relativistic Average GAN\n\n相对论平均生成对抗网络（Relativistic Average GAN）是生成对抗网络（GAN）的一种变体，旨在改善生成对抗网络的训练和生成效果。\n\n## 背景\n传统的GAN中，生成器试图生成逼真的样本，而判别器则根据样本的真实性进行分类。然而，这种方式可能导致生成器和判别器陷入不稳定的训练过程，因为生成器的更新依赖于判别器的反馈，而判别器的反馈又依赖于生成器生成的样本。\n## 特点\n相对论平均GAN通过引入相对论平均策略来解决这个问题。在这种策略下，生成器和判别器之间的对抗性比较被重新定义，以便更准确地反映出生成样本的真实性。具体而言，相对论平均GAN引入了两个新的损失函数：相对论平均生成器损失和相对论平均判别器损失。\n\n1. 相对论平均生成器损失（Relativistic Average Generator Loss）是通过对真实样本和生成样本进行比较来度量生成器的性能。它通过计算生成样本在判别器给出真实样本的概率上的平均值来评估生成器的生成能力。\n\n2. 相对论平均判别器损失（Relativistic Average Discriminator Loss）用于度量判别器的性能。它通过比较真实样本和生成样本之间的相对概率来评估判别器的辨别能力。\n\n## 训练过程\n\n1. 从真实样本中随机采样。\n2. 使用生成器生成一批样本。\n3. 计算相对论平均生成器损失和相对论平均判别器损失。\n4. 更新生成器的参数以减小相对论平均生成器损失。\n5. 更新判别器的参数以减小相对论平均判别器损失。\n6. 重复步骤1-5，直到达到预定的训练轮数或生成样本达到所需的质量。\n## 优点\n改善了生成样本的质量和训练的稳定性。通过引入相对论平均策略，生成器和判别器能够更准确地估计样本的真实性，并促使它们相互逼近，提高生成样本的质量。这种模型在图像生成、文本生成和其他生成任务中都有应用。\n\n\n# WGAN-GP\nWGAN-GP通过引入梯度惩罚解决了WGAN中的限制问题。梯度惩罚是通过在判别器的输出和真实样本之间的采样点上计算梯度范数的平均值，并将其与预定义的惩罚因子相乘来实现的。这个惩罚项鼓励判别器在整个输入空间上保持平滑的梯度，从而使判别器满足Lipschitz连续性的要求。\n\n具体来说，在WGAN-GP中，生成器和判别器的训练过程如下：\n\n1. 从真实数据和生成器生成的样本中采样。\n2. 在采样点上计算判别器的输出。\n3. 计算判别器的梯度惩罚，并将其添加到判别器的损失函数中。\n4. 更新判别器的参数以最小化损失函数。\n5. 对生成器进行更新，最大化判别器对生成样本的输出。\n\nWGAN-GP相对于传统的GAN具有几个优点。首先，它提供了更稳定的训练过程，减少了训练中的模式崩溃和模式衍生问题。其次，通过梯度惩罚，WGAN-GP避免了对判别器权重的剪裁或正则化，使得模型的训练更简单和可靠。最后，WGAN-GP在生成器和判别器之间提供了更准确的梯度信号，从而改善了生成样本的质量和多样性。","slug":"人工智能/常见模型/GAN","published":1,"date":"2024-04-22T13:14:49.007Z","updated":"2024-04-16T12:03:14.386Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0p002bkgg4fvv2hufz","content":"<h1 id=\"GAN\"><a href=\"#GAN\" class=\"headerlink\" title=\"GAN\"></a>GAN</h1><h2 id=\"关键\"><a href=\"#关键\" class=\"headerlink\" title=\"关键\"></a>关键</h2><ol>\n<li>生成对抗网络（GANs）将当前用于判别机器学习的深度神经网络的进步转化为（隐式）生成建模。</li>\n<li>GAN 训练一个生成式深度学习网络 G，将多维随机样本 z （来自高斯分布或者均匀分布）作为输入，从所需分布中生成一个样本。</li>\n<li>GANs 将密度估计问题转换为 二元分类问题，其中对 G 参数的学习是通过能耐区分真假数据的判别深度神经网络 D 来实现的。</li>\n<li>更正式地说，GAN 解决的优化问题可以概括如下：<br> ![[Pasted image 20240415162616.png]]<br>   HashCat Per position Markov Chains.</li>\n</ol>\n<h2 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h2><ol>\n<li>基于积分概率指标：IPM-based GAN<br> 为 GAN 训练 提供稳定性，学习过程中相对稳定，</li>\n<li>基于非积分概率指标：non-IPM-based GAN</li>\n</ol>\n<h2 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h2><p>在学习阶段不稳定，模型优化困难。</p>\n<h1 id=\"WGAN\"><a href=\"#WGAN\" class=\"headerlink\" title=\"WGAN\"></a>WGAN</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>Arjovsky 等人 2017 提出的 WGAN 通过采用 Wasserstein 距离作为损失来提高标准 GAN 的训练稳定性。 这种方法的好处包括减少模式崩溃和有意义的学习曲线，这有助于确定最佳超参数。 WGAN 纳入了新的成本函数； 然而，WGAN 的实验重点是生成逼真的图像。 古尔拉贾尼等人。</p>\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><p>与传统的GAN相比，WGAN通过引入Wasserstein距离取代了传统GAN中使用的JS散度或KL散度，从而在训练过程中提供了更稳定的梯度信号。</p>\n<h2 id=\"策略\"><a href=\"#策略\" class=\"headerlink\" title=\"策略\"></a>策略</h2><p>为了实现Wasserstein距离的近似，WGAN引入了一个判别器的参数范数约束，即Lipschitz限制。这通过对判别器的权重进行剪裁或权重正则化来实现。然而，这种限制方法可能难以实施并且效果不稳定。</p>\n<h1 id=\"IWGAN\"><a href=\"#IWGAN\" class=\"headerlink\" title=\"IWGAN\"></a>IWGAN</h1><p>可以更有效地找到全局最优值。 他们引入了梯度惩罚的概念来代替 WGAN 的梯度裁剪。 古尔拉贾尼等人。 提出使用IWGAN来解决文本生成问题。 在 Gulrajani 等人的 IWGAN 中，G 和 D 都由简单的残差 CNN 组成。 残差架构使得 GAN 的训练快速且稳定[30,31]。 G 将潜在噪声向量作为输入，通过将其转发到其卷积层来对其进行转换，并输出 32 个 one-hot 字符向量的序列。 G的输出层采用softmax非线性函数，并将其转发给D。假样本的每个输出特征由argmax函数的结果决定，argmax函数将G生成的每个输出向量作为输入。 </p>\n<h2 id=\"Relativistic-Average-GAN\"><a href=\"#Relativistic-Average-GAN\" class=\"headerlink\" title=\"Relativistic Average GAN\"></a>Relativistic Average GAN</h2><p>相对论平均生成对抗网络（Relativistic Average GAN）是生成对抗网络（GAN）的一种变体，旨在改善生成对抗网络的训练和生成效果。</p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>传统的GAN中，生成器试图生成逼真的样本，而判别器则根据样本的真实性进行分类。然而，这种方式可能导致生成器和判别器陷入不稳定的训练过程，因为生成器的更新依赖于判别器的反馈，而判别器的反馈又依赖于生成器生成的样本。</p>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><p>相对论平均GAN通过引入相对论平均策略来解决这个问题。在这种策略下，生成器和判别器之间的对抗性比较被重新定义，以便更准确地反映出生成样本的真实性。具体而言，相对论平均GAN引入了两个新的损失函数：相对论平均生成器损失和相对论平均判别器损失。</p>\n<ol>\n<li><p>相对论平均生成器损失（Relativistic Average Generator Loss）是通过对真实样本和生成样本进行比较来度量生成器的性能。它通过计算生成样本在判别器给出真实样本的概率上的平均值来评估生成器的生成能力。</p>\n</li>\n<li><p>相对论平均判别器损失（Relativistic Average Discriminator Loss）用于度量判别器的性能。它通过比较真实样本和生成样本之间的相对概率来评估判别器的辨别能力。</p>\n</li>\n</ol>\n<h2 id=\"训练过程\"><a href=\"#训练过程\" class=\"headerlink\" title=\"训练过程\"></a>训练过程</h2><ol>\n<li>从真实样本中随机采样。</li>\n<li>使用生成器生成一批样本。</li>\n<li>计算相对论平均生成器损失和相对论平均判别器损失。</li>\n<li>更新生成器的参数以减小相对论平均生成器损失。</li>\n<li>更新判别器的参数以减小相对论平均判别器损失。</li>\n<li>重复步骤1-5，直到达到预定的训练轮数或生成样本达到所需的质量。</li>\n</ol>\n<h2 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h2><p>改善了生成样本的质量和训练的稳定性。通过引入相对论平均策略，生成器和判别器能够更准确地估计样本的真实性，并促使它们相互逼近，提高生成样本的质量。这种模型在图像生成、文本生成和其他生成任务中都有应用。</p>\n<h1 id=\"WGAN-GP\"><a href=\"#WGAN-GP\" class=\"headerlink\" title=\"WGAN-GP\"></a>WGAN-GP</h1><p>WGAN-GP通过引入梯度惩罚解决了WGAN中的限制问题。梯度惩罚是通过在判别器的输出和真实样本之间的采样点上计算梯度范数的平均值，并将其与预定义的惩罚因子相乘来实现的。这个惩罚项鼓励判别器在整个输入空间上保持平滑的梯度，从而使判别器满足Lipschitz连续性的要求。</p>\n<p>具体来说，在WGAN-GP中，生成器和判别器的训练过程如下：</p>\n<ol>\n<li>从真实数据和生成器生成的样本中采样。</li>\n<li>在采样点上计算判别器的输出。</li>\n<li>计算判别器的梯度惩罚，并将其添加到判别器的损失函数中。</li>\n<li>更新判别器的参数以最小化损失函数。</li>\n<li>对生成器进行更新，最大化判别器对生成样本的输出。</li>\n</ol>\n<p>WGAN-GP相对于传统的GAN具有几个优点。首先，它提供了更稳定的训练过程，减少了训练中的模式崩溃和模式衍生问题。其次，通过梯度惩罚，WGAN-GP避免了对判别器权重的剪裁或正则化，使得模型的训练更简单和可靠。最后，WGAN-GP在生成器和判别器之间提供了更准确的梯度信号，从而改善了生成样本的质量和多样性。</p>\n","excerpt":"","more":"<h1 id=\"GAN\"><a href=\"#GAN\" class=\"headerlink\" title=\"GAN\"></a>GAN</h1><h2 id=\"关键\"><a href=\"#关键\" class=\"headerlink\" title=\"关键\"></a>关键</h2><ol>\n<li>生成对抗网络（GANs）将当前用于判别机器学习的深度神经网络的进步转化为（隐式）生成建模。</li>\n<li>GAN 训练一个生成式深度学习网络 G，将多维随机样本 z （来自高斯分布或者均匀分布）作为输入，从所需分布中生成一个样本。</li>\n<li>GANs 将密度估计问题转换为 二元分类问题，其中对 G 参数的学习是通过能耐区分真假数据的判别深度神经网络 D 来实现的。</li>\n<li>更正式地说，GAN 解决的优化问题可以概括如下：<br> ![[Pasted image 20240415162616.png]]<br>   HashCat Per position Markov Chains.</li>\n</ol>\n<h2 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h2><ol>\n<li>基于积分概率指标：IPM-based GAN<br> 为 GAN 训练 提供稳定性，学习过程中相对稳定，</li>\n<li>基于非积分概率指标：non-IPM-based GAN</li>\n</ol>\n<h2 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h2><p>在学习阶段不稳定，模型优化困难。</p>\n<h1 id=\"WGAN\"><a href=\"#WGAN\" class=\"headerlink\" title=\"WGAN\"></a>WGAN</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>Arjovsky 等人 2017 提出的 WGAN 通过采用 Wasserstein 距离作为损失来提高标准 GAN 的训练稳定性。 这种方法的好处包括减少模式崩溃和有意义的学习曲线，这有助于确定最佳超参数。 WGAN 纳入了新的成本函数； 然而，WGAN 的实验重点是生成逼真的图像。 古尔拉贾尼等人。</p>\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><p>与传统的GAN相比，WGAN通过引入Wasserstein距离取代了传统GAN中使用的JS散度或KL散度，从而在训练过程中提供了更稳定的梯度信号。</p>\n<h2 id=\"策略\"><a href=\"#策略\" class=\"headerlink\" title=\"策略\"></a>策略</h2><p>为了实现Wasserstein距离的近似，WGAN引入了一个判别器的参数范数约束，即Lipschitz限制。这通过对判别器的权重进行剪裁或权重正则化来实现。然而，这种限制方法可能难以实施并且效果不稳定。</p>\n<h1 id=\"IWGAN\"><a href=\"#IWGAN\" class=\"headerlink\" title=\"IWGAN\"></a>IWGAN</h1><p>可以更有效地找到全局最优值。 他们引入了梯度惩罚的概念来代替 WGAN 的梯度裁剪。 古尔拉贾尼等人。 提出使用IWGAN来解决文本生成问题。 在 Gulrajani 等人的 IWGAN 中，G 和 D 都由简单的残差 CNN 组成。 残差架构使得 GAN 的训练快速且稳定[30,31]。 G 将潜在噪声向量作为输入，通过将其转发到其卷积层来对其进行转换，并输出 32 个 one-hot 字符向量的序列。 G的输出层采用softmax非线性函数，并将其转发给D。假样本的每个输出特征由argmax函数的结果决定，argmax函数将G生成的每个输出向量作为输入。 </p>\n<h2 id=\"Relativistic-Average-GAN\"><a href=\"#Relativistic-Average-GAN\" class=\"headerlink\" title=\"Relativistic Average GAN\"></a>Relativistic Average GAN</h2><p>相对论平均生成对抗网络（Relativistic Average GAN）是生成对抗网络（GAN）的一种变体，旨在改善生成对抗网络的训练和生成效果。</p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>传统的GAN中，生成器试图生成逼真的样本，而判别器则根据样本的真实性进行分类。然而，这种方式可能导致生成器和判别器陷入不稳定的训练过程，因为生成器的更新依赖于判别器的反馈，而判别器的反馈又依赖于生成器生成的样本。</p>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><p>相对论平均GAN通过引入相对论平均策略来解决这个问题。在这种策略下，生成器和判别器之间的对抗性比较被重新定义，以便更准确地反映出生成样本的真实性。具体而言，相对论平均GAN引入了两个新的损失函数：相对论平均生成器损失和相对论平均判别器损失。</p>\n<ol>\n<li><p>相对论平均生成器损失（Relativistic Average Generator Loss）是通过对真实样本和生成样本进行比较来度量生成器的性能。它通过计算生成样本在判别器给出真实样本的概率上的平均值来评估生成器的生成能力。</p>\n</li>\n<li><p>相对论平均判别器损失（Relativistic Average Discriminator Loss）用于度量判别器的性能。它通过比较真实样本和生成样本之间的相对概率来评估判别器的辨别能力。</p>\n</li>\n</ol>\n<h2 id=\"训练过程\"><a href=\"#训练过程\" class=\"headerlink\" title=\"训练过程\"></a>训练过程</h2><ol>\n<li>从真实样本中随机采样。</li>\n<li>使用生成器生成一批样本。</li>\n<li>计算相对论平均生成器损失和相对论平均判别器损失。</li>\n<li>更新生成器的参数以减小相对论平均生成器损失。</li>\n<li>更新判别器的参数以减小相对论平均判别器损失。</li>\n<li>重复步骤1-5，直到达到预定的训练轮数或生成样本达到所需的质量。</li>\n</ol>\n<h2 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h2><p>改善了生成样本的质量和训练的稳定性。通过引入相对论平均策略，生成器和判别器能够更准确地估计样本的真实性，并促使它们相互逼近，提高生成样本的质量。这种模型在图像生成、文本生成和其他生成任务中都有应用。</p>\n<h1 id=\"WGAN-GP\"><a href=\"#WGAN-GP\" class=\"headerlink\" title=\"WGAN-GP\"></a>WGAN-GP</h1><p>WGAN-GP通过引入梯度惩罚解决了WGAN中的限制问题。梯度惩罚是通过在判别器的输出和真实样本之间的采样点上计算梯度范数的平均值，并将其与预定义的惩罚因子相乘来实现的。这个惩罚项鼓励判别器在整个输入空间上保持平滑的梯度，从而使判别器满足Lipschitz连续性的要求。</p>\n<p>具体来说，在WGAN-GP中，生成器和判别器的训练过程如下：</p>\n<ol>\n<li>从真实数据和生成器生成的样本中采样。</li>\n<li>在采样点上计算判别器的输出。</li>\n<li>计算判别器的梯度惩罚，并将其添加到判别器的损失函数中。</li>\n<li>更新判别器的参数以最小化损失函数。</li>\n<li>对生成器进行更新，最大化判别器对生成样本的输出。</li>\n</ol>\n<p>WGAN-GP相对于传统的GAN具有几个优点。首先，它提供了更稳定的训练过程，减少了训练中的模式崩溃和模式衍生问题。其次，通过梯度惩罚，WGAN-GP避免了对判别器权重的剪裁或正则化，使得模型的训练更简单和可靠。最后，WGAN-GP在生成器和判别器之间提供了更准确的梯度信号，从而改善了生成样本的质量和多样性。</p>\n"},{"_content":"Variational Auto-Encoders (VAEs) \n# 概念\n变分自编码器（Variational Autoencoders，VAEs）是一种生成模型，结合了自编码器和概率推断的思想。它被用于学习数据的潜在表示，并可以生成与原始数据相似的新样本。\n# 构成\nVAEs的基本结构由两部分组成：编码器（Encoder）和解码器（Decoder）。编码器将输入数据映射到一个潜在空间中的潜在变量（也称为编码），而解码器则将潜在变量映射回重构的输入数据。\n\n与传统的自编码器不同，VAEs引入了概率推断的概念，其中潜在变量被建模为潜在空间中的概率分布。具体来说，VAEs假设潜在变量服从一个先验分布（通常是高斯分布），并通过编码器将输入数据映射到潜在空间的均值和方差参数上。然后，从该潜在分布中采样一个潜在变量，并通过解码器将其映射回重构的输入数据空间。\n\n训练VAEs的过程涉及最大化观测数据的对数似然性，并最小化潜在变量与先验分布之间的差异，即最小化重构误差和潜在变量的KL散度。\n# 优点 \nVAEs的一个关键优点是它们提供了对潜在空间的连续、平滑的控制，这使得可以在潜在空间中进行插值和操作，生成具有多样性和连续变化的新样本。\n# 应用\nVAEs在生成模型、数据压缩、数据降维和生成样本等任务中得到广泛应用，并成为深度学习领域中重要的模型之一。\n# 总结\n总结起来，变分自编码器（VAEs）是一种结合了自编码器和概率推断的生成模型。它通过学习潜在变量的概率分布来表示数据，并可以生成与原始数据相似的新样本。VAEs提供了对潜在空间的平滑控制，具有广泛的应用潜力。","source":"_posts/人工智能/常见模型/变分编码器.md","raw":"Variational Auto-Encoders (VAEs) \n# 概念\n变分自编码器（Variational Autoencoders，VAEs）是一种生成模型，结合了自编码器和概率推断的思想。它被用于学习数据的潜在表示，并可以生成与原始数据相似的新样本。\n# 构成\nVAEs的基本结构由两部分组成：编码器（Encoder）和解码器（Decoder）。编码器将输入数据映射到一个潜在空间中的潜在变量（也称为编码），而解码器则将潜在变量映射回重构的输入数据。\n\n与传统的自编码器不同，VAEs引入了概率推断的概念，其中潜在变量被建模为潜在空间中的概率分布。具体来说，VAEs假设潜在变量服从一个先验分布（通常是高斯分布），并通过编码器将输入数据映射到潜在空间的均值和方差参数上。然后，从该潜在分布中采样一个潜在变量，并通过解码器将其映射回重构的输入数据空间。\n\n训练VAEs的过程涉及最大化观测数据的对数似然性，并最小化潜在变量与先验分布之间的差异，即最小化重构误差和潜在变量的KL散度。\n# 优点 \nVAEs的一个关键优点是它们提供了对潜在空间的连续、平滑的控制，这使得可以在潜在空间中进行插值和操作，生成具有多样性和连续变化的新样本。\n# 应用\nVAEs在生成模型、数据压缩、数据降维和生成样本等任务中得到广泛应用，并成为深度学习领域中重要的模型之一。\n# 总结\n总结起来，变分自编码器（VAEs）是一种结合了自编码器和概率推断的生成模型。它通过学习潜在变量的概率分布来表示数据，并可以生成与原始数据相似的新样本。VAEs提供了对潜在空间的平滑控制，具有广泛的应用潜力。","slug":"人工智能/常见模型/变分编码器","published":1,"date":"2024-04-22T13:14:49.007Z","updated":"2024-02-25T05:30:39.653Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0p002ckgg42cbh32i5","content":"<p>Variational Auto-Encoders (VAEs) </p>\n<h1 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h1><p>变分自编码器（Variational Autoencoders，VAEs）是一种生成模型，结合了自编码器和概率推断的思想。它被用于学习数据的潜在表示，并可以生成与原始数据相似的新样本。</p>\n<h1 id=\"构成\"><a href=\"#构成\" class=\"headerlink\" title=\"构成\"></a>构成</h1><p>VAEs的基本结构由两部分组成：编码器（Encoder）和解码器（Decoder）。编码器将输入数据映射到一个潜在空间中的潜在变量（也称为编码），而解码器则将潜在变量映射回重构的输入数据。</p>\n<p>与传统的自编码器不同，VAEs引入了概率推断的概念，其中潜在变量被建模为潜在空间中的概率分布。具体来说，VAEs假设潜在变量服从一个先验分布（通常是高斯分布），并通过编码器将输入数据映射到潜在空间的均值和方差参数上。然后，从该潜在分布中采样一个潜在变量，并通过解码器将其映射回重构的输入数据空间。</p>\n<p>训练VAEs的过程涉及最大化观测数据的对数似然性，并最小化潜在变量与先验分布之间的差异，即最小化重构误差和潜在变量的KL散度。</p>\n<h1 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h1><p>VAEs的一个关键优点是它们提供了对潜在空间的连续、平滑的控制，这使得可以在潜在空间中进行插值和操作，生成具有多样性和连续变化的新样本。</p>\n<h1 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h1><p>VAEs在生成模型、数据压缩、数据降维和生成样本等任务中得到广泛应用，并成为深度学习领域中重要的模型之一。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>总结起来，变分自编码器（VAEs）是一种结合了自编码器和概率推断的生成模型。它通过学习潜在变量的概率分布来表示数据，并可以生成与原始数据相似的新样本。VAEs提供了对潜在空间的平滑控制，具有广泛的应用潜力。</p>\n","excerpt":"","more":"<p>Variational Auto-Encoders (VAEs) </p>\n<h1 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h1><p>变分自编码器（Variational Autoencoders，VAEs）是一种生成模型，结合了自编码器和概率推断的思想。它被用于学习数据的潜在表示，并可以生成与原始数据相似的新样本。</p>\n<h1 id=\"构成\"><a href=\"#构成\" class=\"headerlink\" title=\"构成\"></a>构成</h1><p>VAEs的基本结构由两部分组成：编码器（Encoder）和解码器（Decoder）。编码器将输入数据映射到一个潜在空间中的潜在变量（也称为编码），而解码器则将潜在变量映射回重构的输入数据。</p>\n<p>与传统的自编码器不同，VAEs引入了概率推断的概念，其中潜在变量被建模为潜在空间中的概率分布。具体来说，VAEs假设潜在变量服从一个先验分布（通常是高斯分布），并通过编码器将输入数据映射到潜在空间的均值和方差参数上。然后，从该潜在分布中采样一个潜在变量，并通过解码器将其映射回重构的输入数据空间。</p>\n<p>训练VAEs的过程涉及最大化观测数据的对数似然性，并最小化潜在变量与先验分布之间的差异，即最小化重构误差和潜在变量的KL散度。</p>\n<h1 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h1><p>VAEs的一个关键优点是它们提供了对潜在空间的连续、平滑的控制，这使得可以在潜在空间中进行插值和操作，生成具有多样性和连续变化的新样本。</p>\n<h1 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h1><p>VAEs在生成模型、数据压缩、数据降维和生成样本等任务中得到广泛应用，并成为深度学习领域中重要的模型之一。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>总结起来，变分自编码器（VAEs）是一种结合了自编码器和概率推断的生成模型。它通过学习潜在变量的概率分布来表示数据，并可以生成与原始数据相似的新样本。VAEs提供了对潜在空间的平滑控制，具有广泛的应用潜力。</p>\n"},{"_content":"DDPMs DDIMs DiTs\n\nhttps://en.wikipedia.org/wiki/Diffusion_model\n扩散模型，在机器学习领域，也被称为扩散概率模型，或者基于得分的生成模型，是一类潜变量生成模型。\n\n扩散模型由三个主要部分组成：正向过程，反向过程和采样过程\n扩散模型的目标是学习生成给定数据集概率分布的扩散过程。\n她们通过对数据点在潜在空间中扩散的方式来进行建模并学习数据集的潜在结构。\n就计算机视觉而言，扩散模型可以应用于各种任务，包括图像去噪、修复、超分辨率和图像生成。这通常涉及训练神经网络以顺序对高斯噪声模糊的图像进行去噪。 2(https://en.wikipedia.org/wiki/Diffusion_model#cite_note-song-2) 3(https://en.wikipedia.org/wiki/Diffusion_model#cite_note-gu-3) 该模型经过训练可以逆转向图像添加噪声的过程。训练收敛后，它可以用于图像生成，从由随机噪声组成的图像开始，让网络迭代去噪。 OpenAI 于 2022 年 4 月 13 日发布的文本到图像模型 DALL-E 2 是一个示例，该示例将扩散模型用于模型的先验（在给定文本标题的情况下生成图像嵌入）和生成最终图像的解码器。 4(https://en.wikipedia.org/wiki/Diffusion_model#cite_note-dalle2-4) 扩散模型最近在自然语言处理 (NLP) 中得到应用， 5(https://en.wikipedia.org/wiki/Diffusion_model#cite_note-5) 特别是在文本生成 6(https://en.wikipedia.org/wiki/Diffusion_model#cite_note-6) 7(https://en.wikipedia.org/wiki/Diffusion_model#cite_note-7) 和摘要等领域。 8(https://en.wikipedia.org/wiki/Diffusion_model#cite_note-8)\n\n\n扩散模型通常被表述为马尔可夫链并使用变分推理进行训练。 9(https://en.wikipedia.org/wiki/Diffusion_model#cite_note-ho-9) 计算机视觉中使用的通用扩散建模框架的示例包括去噪扩散概率模型、噪声条件评分网络和随机微分方程。 10(https://en.wikipedia.org/wiki/Diffusion_model#cite_note-10)\n\n\n# 类型\n属于无监督生成模型\n# 原理\n扩散模型由三个主要部分组成：正向过程（扩散过程），反向过程和采样过程，生成过程（逆向过程、推断过程）\n为了避免混淆，本文以 $x_1,x_2,...,x_T$ 表示不同的时间步中的样本，以 $X_1,X_2,...,X_T$ 表示不同时间步对应的随机变量， 以 $p(X_T)$ 表示随机变量的概率分布，以 $N(x_T,\\mu,\\sum)$ ，表示在分布 $N(\\mu, \\sum)$ 中 $X=x_T$ 时的概率样本概率值。\n## 正向过程（扩散过程）\n通过对任意的初始样本 $x_0$ 连续的添加 $T$ 次高斯噪声，可获得一条样本的轨迹 $x_1,x_2,...,x_T$ ，并且当 $T$ 趋于无穷时，原始样本 $x_0$ 的特征完全消失，成为标准高斯噪声。从概率分布的角度而言，如果定义初始样本（训练样本）的概率分布为 $q(X_0)$ 则通过无限次地扩散动作，时宪历从初始样本分布到高斯分布的映射，即 $q(X_T) = N(0,I)$\n。\n当然扩散过程连续添加高斯噪声不是任意的，其具体的限定规则为 \n$q(X_t|x_t-1) = N(\\sqrt {1-\\beta_t}x_{t-1},\\beta_tI)$ ,其中 $\\beta_1 <\\beta_2 <...< \\beta_T$\n由上式可知，在给定 $t-1$ 时刻的样本 $x_{t-1}$ 的情况下，t时刻样本的分布为高斯分布。\n由此式可以看出，该调见高斯分布的均值参数只与 $x_{t-1}$ 有关， 与前面时间的样本无关，因而随机过程 $\\{X_t\\}$ 是一个马尔科夫过程。 \nTODO ：https://zhuanlan.zhihu.com/p/532402983\n## 反向过程\n\n## 采样过程\n\n\n","source":"_posts/人工智能/常见模型/扩散模型.md","raw":"DDPMs DDIMs DiTs\n\nhttps://en.wikipedia.org/wiki/Diffusion_model\n扩散模型，在机器学习领域，也被称为扩散概率模型，或者基于得分的生成模型，是一类潜变量生成模型。\n\n扩散模型由三个主要部分组成：正向过程，反向过程和采样过程\n扩散模型的目标是学习生成给定数据集概率分布的扩散过程。\n她们通过对数据点在潜在空间中扩散的方式来进行建模并学习数据集的潜在结构。\n就计算机视觉而言，扩散模型可以应用于各种任务，包括图像去噪、修复、超分辨率和图像生成。这通常涉及训练神经网络以顺序对高斯噪声模糊的图像进行去噪。 2(https://en.wikipedia.org/wiki/Diffusion_model#cite_note-song-2) 3(https://en.wikipedia.org/wiki/Diffusion_model#cite_note-gu-3) 该模型经过训练可以逆转向图像添加噪声的过程。训练收敛后，它可以用于图像生成，从由随机噪声组成的图像开始，让网络迭代去噪。 OpenAI 于 2022 年 4 月 13 日发布的文本到图像模型 DALL-E 2 是一个示例，该示例将扩散模型用于模型的先验（在给定文本标题的情况下生成图像嵌入）和生成最终图像的解码器。 4(https://en.wikipedia.org/wiki/Diffusion_model#cite_note-dalle2-4) 扩散模型最近在自然语言处理 (NLP) 中得到应用， 5(https://en.wikipedia.org/wiki/Diffusion_model#cite_note-5) 特别是在文本生成 6(https://en.wikipedia.org/wiki/Diffusion_model#cite_note-6) 7(https://en.wikipedia.org/wiki/Diffusion_model#cite_note-7) 和摘要等领域。 8(https://en.wikipedia.org/wiki/Diffusion_model#cite_note-8)\n\n\n扩散模型通常被表述为马尔可夫链并使用变分推理进行训练。 9(https://en.wikipedia.org/wiki/Diffusion_model#cite_note-ho-9) 计算机视觉中使用的通用扩散建模框架的示例包括去噪扩散概率模型、噪声条件评分网络和随机微分方程。 10(https://en.wikipedia.org/wiki/Diffusion_model#cite_note-10)\n\n\n# 类型\n属于无监督生成模型\n# 原理\n扩散模型由三个主要部分组成：正向过程（扩散过程），反向过程和采样过程，生成过程（逆向过程、推断过程）\n为了避免混淆，本文以 $x_1,x_2,...,x_T$ 表示不同的时间步中的样本，以 $X_1,X_2,...,X_T$ 表示不同时间步对应的随机变量， 以 $p(X_T)$ 表示随机变量的概率分布，以 $N(x_T,\\mu,\\sum)$ ，表示在分布 $N(\\mu, \\sum)$ 中 $X=x_T$ 时的概率样本概率值。\n## 正向过程（扩散过程）\n通过对任意的初始样本 $x_0$ 连续的添加 $T$ 次高斯噪声，可获得一条样本的轨迹 $x_1,x_2,...,x_T$ ，并且当 $T$ 趋于无穷时，原始样本 $x_0$ 的特征完全消失，成为标准高斯噪声。从概率分布的角度而言，如果定义初始样本（训练样本）的概率分布为 $q(X_0)$ 则通过无限次地扩散动作，时宪历从初始样本分布到高斯分布的映射，即 $q(X_T) = N(0,I)$\n。\n当然扩散过程连续添加高斯噪声不是任意的，其具体的限定规则为 \n$q(X_t|x_t-1) = N(\\sqrt {1-\\beta_t}x_{t-1},\\beta_tI)$ ,其中 $\\beta_1 <\\beta_2 <...< \\beta_T$\n由上式可知，在给定 $t-1$ 时刻的样本 $x_{t-1}$ 的情况下，t时刻样本的分布为高斯分布。\n由此式可以看出，该调见高斯分布的均值参数只与 $x_{t-1}$ 有关， 与前面时间的样本无关，因而随机过程 $\\{X_t\\}$ 是一个马尔科夫过程。 \nTODO ：https://zhuanlan.zhihu.com/p/532402983\n## 反向过程\n\n## 采样过程\n\n\n","slug":"人工智能/常见模型/扩散模型","published":1,"date":"2024-04-22T13:14:49.007Z","updated":"2024-04-13T05:20:42.477Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0p002dkgg4bxfr3nze","content":"<p>DDPMs DDIMs DiTs</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Diffusion_model\">https://en.wikipedia.org/wiki/Diffusion_model</a><br>扩散模型，在机器学习领域，也被称为扩散概率模型，或者基于得分的生成模型，是一类潜变量生成模型。</p>\n<p>扩散模型由三个主要部分组成：正向过程，反向过程和采样过程<br>扩散模型的目标是学习生成给定数据集概率分布的扩散过程。<br>她们通过对数据点在潜在空间中扩散的方式来进行建模并学习数据集的潜在结构。<br>就计算机视觉而言，扩散模型可以应用于各种任务，包括图像去噪、修复、超分辨率和图像生成。这通常涉及训练神经网络以顺序对高斯噪声模糊的图像进行去噪。 2(<a href=\"https://en.wikipedia.org/wiki/Diffusion_model#cite_note-song-2\">https://en.wikipedia.org/wiki/Diffusion_model#cite_note-song-2</a>) 3(<a href=\"https://en.wikipedia.org/wiki/Diffusion_model#cite_note-gu-3\">https://en.wikipedia.org/wiki/Diffusion_model#cite_note-gu-3</a>) 该模型经过训练可以逆转向图像添加噪声的过程。训练收敛后，它可以用于图像生成，从由随机噪声组成的图像开始，让网络迭代去噪。 OpenAI 于 2022 年 4 月 13 日发布的文本到图像模型 DALL-E 2 是一个示例，该示例将扩散模型用于模型的先验（在给定文本标题的情况下生成图像嵌入）和生成最终图像的解码器。 4(<a href=\"https://en.wikipedia.org/wiki/Diffusion_model#cite_note-dalle2-4\">https://en.wikipedia.org/wiki/Diffusion_model#cite_note-dalle2-4</a>) 扩散模型最近在自然语言处理 (NLP) 中得到应用， 5(<a href=\"https://en.wikipedia.org/wiki/Diffusion_model#cite_note-5\">https://en.wikipedia.org/wiki/Diffusion_model#cite_note-5</a>) 特别是在文本生成 6(<a href=\"https://en.wikipedia.org/wiki/Diffusion_model#cite_note-6\">https://en.wikipedia.org/wiki/Diffusion_model#cite_note-6</a>) 7(<a href=\"https://en.wikipedia.org/wiki/Diffusion_model#cite_note-7\">https://en.wikipedia.org/wiki/Diffusion_model#cite_note-7</a>) 和摘要等领域。 8(<a href=\"https://en.wikipedia.org/wiki/Diffusion_model#cite_note-8\">https://en.wikipedia.org/wiki/Diffusion_model#cite_note-8</a>)</p>\n<p>扩散模型通常被表述为马尔可夫链并使用变分推理进行训练。 9(<a href=\"https://en.wikipedia.org/wiki/Diffusion_model#cite_note-ho-9\">https://en.wikipedia.org/wiki/Diffusion_model#cite_note-ho-9</a>) 计算机视觉中使用的通用扩散建模框架的示例包括去噪扩散概率模型、噪声条件评分网络和随机微分方程。 10(<a href=\"https://en.wikipedia.org/wiki/Diffusion_model#cite_note-10\">https://en.wikipedia.org/wiki/Diffusion_model#cite_note-10</a>)</p>\n<h1 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h1><p>属于无监督生成模型</p>\n<h1 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h1><p>扩散模型由三个主要部分组成：正向过程（扩散过程），反向过程和采样过程，生成过程（逆向过程、推断过程）<br>为了避免混淆，本文以 $x_1,x_2,…,x_T$ 表示不同的时间步中的样本，以 $X_1,X_2,…,X_T$ 表示不同时间步对应的随机变量， 以 $p(X_T)$ 表示随机变量的概率分布，以 $N(x_T,\\mu,\\sum)$ ，表示在分布 $N(\\mu, \\sum)$ 中 $X&#x3D;x_T$ 时的概率样本概率值。</p>\n<h2 id=\"正向过程（扩散过程）\"><a href=\"#正向过程（扩散过程）\" class=\"headerlink\" title=\"正向过程（扩散过程）\"></a>正向过程（扩散过程）</h2><p>通过对任意的初始样本 $x_0$ 连续的添加 $T$ 次高斯噪声，可获得一条样本的轨迹 $x_1,x_2,…,x_T$ ，并且当 $T$ 趋于无穷时，原始样本 $x_0$ 的特征完全消失，成为标准高斯噪声。从概率分布的角度而言，如果定义初始样本（训练样本）的概率分布为 $q(X_0)$ 则通过无限次地扩散动作，时宪历从初始样本分布到高斯分布的映射，即 $q(X_T) &#x3D; N(0,I)$<br>。<br>当然扩散过程连续添加高斯噪声不是任意的，其具体的限定规则为<br>$q(X_t|x_t-1) &#x3D; N(\\sqrt {1-\\beta_t}x_{t-1},\\beta_tI)$ ,其中 $\\beta_1 &lt;\\beta_2 &lt;…&lt; \\beta_T$<br>由上式可知，在给定 $t-1$ 时刻的样本 $x_{t-1}$ 的情况下，t时刻样本的分布为高斯分布。<br>由此式可以看出，该调见高斯分布的均值参数只与 $x_{t-1}$ 有关， 与前面时间的样本无关，因而随机过程 ${X_t}$ 是一个马尔科夫过程。<br>TODO ：<a href=\"https://zhuanlan.zhihu.com/p/532402983\">https://zhuanlan.zhihu.com/p/532402983</a></p>\n<h2 id=\"反向过程\"><a href=\"#反向过程\" class=\"headerlink\" title=\"反向过程\"></a>反向过程</h2><h2 id=\"采样过程\"><a href=\"#采样过程\" class=\"headerlink\" title=\"采样过程\"></a>采样过程</h2>","excerpt":"","more":"<p>DDPMs DDIMs DiTs</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Diffusion_model\">https://en.wikipedia.org/wiki/Diffusion_model</a><br>扩散模型，在机器学习领域，也被称为扩散概率模型，或者基于得分的生成模型，是一类潜变量生成模型。</p>\n<p>扩散模型由三个主要部分组成：正向过程，反向过程和采样过程<br>扩散模型的目标是学习生成给定数据集概率分布的扩散过程。<br>她们通过对数据点在潜在空间中扩散的方式来进行建模并学习数据集的潜在结构。<br>就计算机视觉而言，扩散模型可以应用于各种任务，包括图像去噪、修复、超分辨率和图像生成。这通常涉及训练神经网络以顺序对高斯噪声模糊的图像进行去噪。 2(<a href=\"https://en.wikipedia.org/wiki/Diffusion_model#cite_note-song-2\">https://en.wikipedia.org/wiki/Diffusion_model#cite_note-song-2</a>) 3(<a href=\"https://en.wikipedia.org/wiki/Diffusion_model#cite_note-gu-3\">https://en.wikipedia.org/wiki/Diffusion_model#cite_note-gu-3</a>) 该模型经过训练可以逆转向图像添加噪声的过程。训练收敛后，它可以用于图像生成，从由随机噪声组成的图像开始，让网络迭代去噪。 OpenAI 于 2022 年 4 月 13 日发布的文本到图像模型 DALL-E 2 是一个示例，该示例将扩散模型用于模型的先验（在给定文本标题的情况下生成图像嵌入）和生成最终图像的解码器。 4(<a href=\"https://en.wikipedia.org/wiki/Diffusion_model#cite_note-dalle2-4\">https://en.wikipedia.org/wiki/Diffusion_model#cite_note-dalle2-4</a>) 扩散模型最近在自然语言处理 (NLP) 中得到应用， 5(<a href=\"https://en.wikipedia.org/wiki/Diffusion_model#cite_note-5\">https://en.wikipedia.org/wiki/Diffusion_model#cite_note-5</a>) 特别是在文本生成 6(<a href=\"https://en.wikipedia.org/wiki/Diffusion_model#cite_note-6\">https://en.wikipedia.org/wiki/Diffusion_model#cite_note-6</a>) 7(<a href=\"https://en.wikipedia.org/wiki/Diffusion_model#cite_note-7\">https://en.wikipedia.org/wiki/Diffusion_model#cite_note-7</a>) 和摘要等领域。 8(<a href=\"https://en.wikipedia.org/wiki/Diffusion_model#cite_note-8\">https://en.wikipedia.org/wiki/Diffusion_model#cite_note-8</a>)</p>\n<p>扩散模型通常被表述为马尔可夫链并使用变分推理进行训练。 9(<a href=\"https://en.wikipedia.org/wiki/Diffusion_model#cite_note-ho-9\">https://en.wikipedia.org/wiki/Diffusion_model#cite_note-ho-9</a>) 计算机视觉中使用的通用扩散建模框架的示例包括去噪扩散概率模型、噪声条件评分网络和随机微分方程。 10(<a href=\"https://en.wikipedia.org/wiki/Diffusion_model#cite_note-10\">https://en.wikipedia.org/wiki/Diffusion_model#cite_note-10</a>)</p>\n<h1 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h1><p>属于无监督生成模型</p>\n<h1 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h1><p>扩散模型由三个主要部分组成：正向过程（扩散过程），反向过程和采样过程，生成过程（逆向过程、推断过程）<br>为了避免混淆，本文以 $x_1,x_2,…,x_T$ 表示不同的时间步中的样本，以 $X_1,X_2,…,X_T$ 表示不同时间步对应的随机变量， 以 $p(X_T)$ 表示随机变量的概率分布，以 $N(x_T,\\mu,\\sum)$ ，表示在分布 $N(\\mu, \\sum)$ 中 $X&#x3D;x_T$ 时的概率样本概率值。</p>\n<h2 id=\"正向过程（扩散过程）\"><a href=\"#正向过程（扩散过程）\" class=\"headerlink\" title=\"正向过程（扩散过程）\"></a>正向过程（扩散过程）</h2><p>通过对任意的初始样本 $x_0$ 连续的添加 $T$ 次高斯噪声，可获得一条样本的轨迹 $x_1,x_2,…,x_T$ ，并且当 $T$ 趋于无穷时，原始样本 $x_0$ 的特征完全消失，成为标准高斯噪声。从概率分布的角度而言，如果定义初始样本（训练样本）的概率分布为 $q(X_0)$ 则通过无限次地扩散动作，时宪历从初始样本分布到高斯分布的映射，即 $q(X_T) &#x3D; N(0,I)$<br>。<br>当然扩散过程连续添加高斯噪声不是任意的，其具体的限定规则为<br>$q(X_t|x_t-1) &#x3D; N(\\sqrt {1-\\beta_t}x_{t-1},\\beta_tI)$ ,其中 $\\beta_1 &lt;\\beta_2 &lt;…&lt; \\beta_T$<br>由上式可知，在给定 $t-1$ 时刻的样本 $x_{t-1}$ 的情况下，t时刻样本的分布为高斯分布。<br>由此式可以看出，该调见高斯分布的均值参数只与 $x_{t-1}$ 有关， 与前面时间的样本无关，因而随机过程 ${X_t}$ 是一个马尔科夫过程。<br>TODO ：<a href=\"https://zhuanlan.zhihu.com/p/532402983\">https://zhuanlan.zhihu.com/p/532402983</a></p>\n<h2 id=\"反向过程\"><a href=\"#反向过程\" class=\"headerlink\" title=\"反向过程\"></a>反向过程</h2><h2 id=\"采样过程\"><a href=\"#采样过程\" class=\"headerlink\" title=\"采样过程\"></a>采样过程</h2>"},{"_content":"go个人笔记\n\nhttps://blog.csdn.net/weiguang102/article/details/128501539\n\ngo 基础\n\nhttps://www.runoob.com/go/go-tutorial.html\n\ngo 环境安装\n\nhttps://blog.51cto.com/fish/5734211\n\n## 零、配置\n\n### 环境变量\n\n1.临时添加环境变量 PATH\n\nexport PATH=$PATH:/usr/local/go/bin\n\n2.所有用户永久添加环境变量\n\nvim /etc/profile\n\n末尾添加：export PATH:$PATH:/usr/local/go/bin\n\n刷新：sourse /etc/profile\n\n3.golang 工作目录\n\nGOPATH 是一个环境变量，用于指定Go项目的工作目录，默认情况下，GOPATH是 $HOME是当前用户的主目录。(/root 或者 /home/user1)\n\n获取：\n\ngo env GOPATH\n\n更改：\n\n编辑 .bashrc 或者 .zshrc\n\n找到 GOPATH 这行，将其修改为 /path/to/your/gopath\n\n  \n\n4.go.sum 与 go.mod\n\n`go.sum` 和 `go.mod` 是 Go 语言中用于管理模块依赖的文件。\n\n- `go.mod` 文件：`go.mod` 文件用于定义和管理项目的模块依赖关系。它位于项目的根目录下。当你使用 `go get` 命令来安装或更新依赖包时，`go.mod` 文件会被更新。它记录了项目所依赖的模块及其版本。你可以手动编辑 `go.mod` 文件来添加、移除或升级依赖包。在构建项目时，Go 会根据 `go.mod` 文件获取所需的依赖包。\n    \n- `go.sum` 文件：`go.sum` 文件用于记录项目所使用模块的校验和信息。每个模块都有一个唯一的校验和，用于确保下载的模块的完整性和安全性。`go.sum` 文件会自动生成并更新，其中包含了所有依赖模块的校验和。当你构建项目时，Go 会根据 `go.sum` 文件验证模块的完整性，以确保下载的模块与之前的校验和匹配。\n    \n\n使用 `go.mod` 和 `go.sum` 文件的基本操作如下：\n\n1. 初始化模块：在项目的根目录下执行 `go mod init` 命令，它会根据项目的路径和名称创建一个新的 `go.mod` 文件。\n    \n2. 添加依赖包：执行 `go get` 命令来添加所需的依赖包。例如，`go get` `github.com/example/package`。这会自动更新 `go.mod` 文件并下载依赖包。\n    \n3. 移除依赖包：执行 `go mod tidy` 命令来移除不再使用的依赖包。它会自动更新 `go.mod` 文件并删除不需要的依赖。\n    \n4. 升级依赖包：执行 `go get -u` 命令来升级依赖包到最新版本。这会自动更新 `go.mod` 文件。\n    \n5. 构建项目：使用 `go build` 或 `go run` 命令来构建或运行项目。Go 会根据 `go.mod` 文件下载依赖包并构建项目。\n    \n\n需要注意的是，`go.mod` 和 `go.sum` 文件对于保证项目的可复现性和依赖包的一致性非常重要。当你与他人共享项目时，确保将 `go.mod` 和 `go.sum` 文件一同共享，以便其他人可以获取相同的依赖包版本。\n\n管理和安装 `go.mod` 和 `go.sum` 中列出的依赖项：\n\n1. **下载依赖项**\n    \n\n当你首次克隆一个 Go 项目或者在已有项目中更新了依赖项时，可以使用以下命令来下载 `go.mod` 文件中指定的所有依赖项：\n\n```Bash\ngo mod download\n```\n\n这个命令会将依赖项下载到本地的 Go 模块缓存中，但不会在项目目录中创建任何文件。\n\n2. **同步依赖项**\n    \n\n如果你想确保项目目录下的依赖项与 `go.mod` 文件中定义的依赖项完全同步（即添加缺失的模块，删除不需要的模块，并更新 `go.sum`），可以使用：\n\n```Bash\ngo mod tidy\n```\n\n`go mod tidy` 命令会添加缺少的模块，移除未使用的模块，并生成一个新的 `go.sum` 文件。这是确保 `go.mod` 和 `go.sum` 文件准确反映项目依赖项的好方法。\n\n3. **查看依赖项**\n    \n\n如果你想查看当前项目的依赖树，可以使用：\n\n```Bash\ngo mod graph\n```\n\n这个命令会打印项目的所有依赖项及其版本，帮助你理解项目依赖的结构。\n\n4. **更新依赖项**\n    \n\n要更新项目中的某个依赖项到最新版本，可以使用：\n\n```Bash\ngo get -u package@version\n```\n\n其中 `package` 是依赖项的路径，`version` 是你想要更新到的版本。如果你想更新所有依赖项到最新版本，可以使用：\n\n```Bash\ngo get -u\n```\n\n但请注意，这可能会引入重大更改，因此建议仔细测试更新后的依赖项。\n\n  \n\n修改 proto 文件并运行 `make proto` 来更新 `proto/pkg/xxx/xxx.pb.go` 中相关生成的 go 代码\n\n  \n\n## 一、变量\n### 一般变量\n1. 变量声明\n    \n    1. 标准格式\n        \n    ```C++\n    var name type // 注意：声明变量时将变量的类型放在变量的名称之后\n    var a,b *int // 将 a b 同时声明为指针类型\n    \n    // 初始化\n    var hp int = 100 // 指定类型\n    var hp = 100 // 省略类型，编译器会尝试为变量推到类型\n    ```\n    \n    3. 简短格式\n        \n\n```C++\n// 名字 := 表达式\n/*\n1. 定义变量，同时显式初始化。\n2. 不能提供数据类型\n3. 只能用在函数内部。\n*/\n\n// 同时声明+初始化\ni, j := 0, 1\nfunc main() {\n   x:=100\n   a,s:=1, \"abc\"\n}\n// 注意  :=  左面必须是新变量\nvar hp int // 声明 hp 变量\nhp := 10  // 再次声明并赋值  报错！ 左面没有新变量出现\n\n// 错误！！！！其实 只要有新变量就行！\nvar conn net.Conn\nvar err error\nconn, err = net.Dial(\"tcp\", \"127.0.0.1:8080\")  // 不会报错\n```\n\n注意：变量的命名规则遵循骆驼命名法，即首个单词小写，每个新单词的首字母大写，例如：numShips 和 startDate 。\n\n2. 变量类型\n    \n    1. bool\n        \n    2. string\n        \n        1. 反引号可以实现多行\n            \n            ```C++\n            const str = `第一行\n            第二行\n            第三行\n            ` \n            fmt.Println(str);  // 输出上面的内容\n            \n            // 注意 ！！！！！！\n            // 此时所有的 转义都会失效，即 `` 内部的全部都视为 字符串一部分\n            ```\n            \n        2. 字符串长度\n            \n            1. len(), 判断的是 ASCII 长度 或者是 字节长度\n                \n                1. 在 go 语言中， 所有字符串都是以 utf-8 的格式保存，因此 汉字 3 字节，字符 1 字节\n                    \n                2. 若要将汉字作为一个整体统计， 可以使用下面的函数\n                    \n            2. RuneCountInString() , 判断的是字符的个数，或者说是 Unicode 字符串长度\n                \n                ```C++\n                package main\n                \n                import (\n                        \"fmt\"\n                        \"strings\"\n                )\n                \n                // 遍历字符串\n                // 按ASCII 字符\n                theme := \"狙击 start\"\n                for i := 0; i < len(theme); i++ {//使用 for 的数值循环进行遍历--\n                    fmt.Printf(\"ascii: %c  %d\\n\", theme[i], theme[i])\n                }// 这里 汉字为乱码\n                \n                // 按 Unicode  字符\n                theme := \"狙击 start\"\n                for _, s := range theme {\n                    fmt.Printf(\"Unicode: %c  %d\\n\", s, s)\n                }// 这里汉字正常显示\n                \n                \n                // 字符串截取\n                newtr := theme[i:]  // 截取部分包括 i\n                \n                // 字符串搜索\n                strings.Index(strings ,substring); // 返回 下标\n                strings.LastIndex(strings, substrings); // 反向搜索\n                \n                // 字符串修改\n                        s1 := \"abc\"\n                //     注意：字符串无法修改，只能在复制的基础上进行修改\n                //  方法一  转为 []byte()\n                        s2 := []byte(s1)\n                        s2[1] = 'B'\n                        fmt.Println(string(s2)) //aBc\n                // 方法二  转为 []runej() \n                        s3 := []rune(s1)\n                        s3[1] = 'B'\n                        fmt.Println(string(s3)) //aBc\n                 // 方法三 字符串替换\n                        new_str := \"ABC\"\n                        old_str := \"abc\"\n                        s4 := strings.Replace(s1, old_str , new_str , 2)\n                        fmt.Println(s4) //ABC\n                \n                // 字符串拼接\n                    str1 := \"hello\"\n                    str2 := \"world\"\n                 // 方法一 使用 + 直接拼接\n                     str3 := str1 + str2\n                 // 方法二 使用 bytes.Buffer\n                     var stringBuilder bytes.Buffer\n                     stringBuilder.WriteString(str1)\n                     stringBuilder.WriteString(str2)\n                     str4 := stringBuilder.String()\n                     \n                ```\n                \n    3. int、int8、int16、int32、int64\n        \n    4. uint、uint8、uint16、uint32、uint64、uintptr\n        \n    5. byte // uint8 的别名\n        \n    6. rune // int32 的别名 代表一个 Unicode 码 不对 是 UTF-8\n        \n    7. float32、float64\n        \n    8. complex64、complex128 内建函数\n    9. interface 接口类型\n\t    https://learnku.com/go/t/38843\n\t\t```go\n\t\t\ttype Animal interface {\n\t\t\t    Speak() string\n\t\t\t}\n\t\t```\n    10. map\\[string\\] \\*sync.WaitGroup  键值对类型\n3. 变量赋值\n    \n    ```C++\n    b, a = a, b  // 这里 可以实现交换操作\n    a, _ := a, _ := GetData()  // 这里 匿名变量\n    ```\n    \n      注意：**当一个变量被声明之后，系统自动赋予它该类型的零值：****`int 为 0，float 为 0.0，bool 为 false，string 为空字符串，指针为 nil 等`**\n    \n      所有的内存在 Go 中都是经过初始化的。\n    \n4. 匿名变量不占用内存空间，不分配内存\n    \n5. 作用域\n    1. 全局变量声明必须以 `var` 关键字开头，如果想要在外部包中使用全局变量的首字母必须大写。\n    2. 特殊变量定义位置\n\t    ```go\n\t    if firstIdx, err := Func(); err != nil {\n\t        log.Fatal(err)\n\t        return nil\n\t    }\n\t    // 这里的 firstIdx 只能在 if 里面的大括号用，一旦出去就使用不了\n\t\t```\n    \n6. 比较\n    \n      只有同类型的变量才能进行比较\n    \n      包括 0 1 到 true false 的转换\n    \n7. 类型转换\n    \n    1. bool 不能强转为 int\n        \n        ```C++\n        var n bool\n        n := (int)n\n        //会报错\n        ```\n        \n    2. 不能获取数组某个位置的的地址\n        \n\n### 结构体变量\n1. 结构体声明\n\t```go\n\t// 结构体成员变量\n\ttype MyStruct struct{\n\t\tage int     // 注意没有 逗号\n\t\tname string\n\t}\n\t// 结构体函数\n\tfunc (ms *MyStruct) grow(int a) bool{\n\t\tms.age += a\n\t\treturn true\n\t}\n\t\n\t// 结构体的指针继承\n\ttype MyStruct2 struct{\n\t\t*MyStruct  // 通过指针的方式，父亲结构体作为一个无名成员变量，\n\t\t\t\t   // 赋值时使用 父亲对象 赋值； \n\t\t\t\t   // 使用时使用 孩子对象 直接使用（不需要先点出来父亲）\n\t\tage int     // 注意没有 逗号\n\t\tname string\n\t}\n\t```\n2. 结构体实例化\n\t``` go\n\t// 方法一：var 声明\n\tvar fan MyStruct   // 为 fan 分配内存并且零化值\n\tfan.age = 26\n\tfan.name = \"fan\"\n\t\n\t// 方法二：new 关键字\n\t// 11\n\tfan := &MyStruct{   // 返回一个结构体指针，带有初始值\n\t\t26,\n\t\t\"fan\",\n\t}\n\t// 22 \n\tfan := new(MyStruct) // 返回一个结构体指针，零值\n\tfan.name = \"fan\"\n\tfan.age = 26\n\t\n\t// 方法三：赋值初始化\n\t// 11\n\tfan := MyStruct{\n\t\tname: \"fan\",\n\t\tage: 26,\n\t}\n\t// 22：必须要对应结构体定义顺序，并且每一个都必须进行初始化。\n\tfan := MyStruct{\n\t\t26,\n\t\t\"fan\",\n\t}\n\t```\n3. 匿名结构体\n\t```go\n\tprofile := &struct {\n            name string\n            age   int\n    }{\n            name: \"rat\",\n            age:   150,\n    }\n    // 打印值\n    fmt.Printf(\"使用'%%+v' %+v\\n\", profile)\n    fmt.Printf(\"使用'%%#v' %#v\\n\", profile)\n    fmt.Printf(\"使用'%%T' %T\\n\", profile)\n\t```\n4. 结构体返回值\n\t```go\n\tfunc newStruct() * MyStruct{\n\t\t// 此处替换为三种不同方式\n\t    var fan MyStruct   // 为 fan 分配内存并且零化值\n\t\tfan.age = 26\n\t\tfan.name = \"fan\"\n\t\tfmt.Printf(\"函数内变量 fan 的地址为：%p\\n\", &fan)\n\t\treturn &fan\n\t}\n\t\n\t// 测试\n\tfunc main() {\n\t    fan := newStruct()\n\t    fmt.Printf(\"函数外变量 fan 的地址为：%p\\n\", fan)\n\t\tfmt.Printf(\"fan使用'%%+v' %+v\\n\", fan)\n\t\tfan.age = 18\n\t\tfmt.Printf(\"fan使用'%%+v' %+v\\n\", fan)\n\t\t// 方法一：地址相同，可更改 \n\t\t// 方法二11：地址相同，可更改\n\t\t// 方法二22：地址相同，可更改\n\t\t// 方法三11：地址相同，可更改\n\t\t// 方法三22：地址相同，可更改\n\t}\n\t```\n### 键值对类型\nmap\\[string\\] \\*sync.WaitGroup  键值对类型\n1. 键值对变量\n```go\npackage main\n\nimport (\n        \"fmt\"\n)\n\ntype MyStruct struct {\n    a, b uint64\n}\n\t\nfunc main() {\n\t// !! 定义与使用 \n    //  初始 正常运行\n    stru := make(map[uint64]*MyStruct)\n    stru[2] = &MyStruct{\n        1,1,\n    }\n    stru[2].a = 1\n    stru[2].b  = 1\n    fmt.Printf(\"值为：%+v\",stru[2])\n    \n    //  这样也可以\n    var stru map[uint64]*MyStruct \n    stru = make(map[uint64]*MyStruct) // 没有这行运行不通\n    stru[2] = &MyStruct{   // 去掉这行也不行\n        1,1,\n    }  \n    stru[2].a = 1\n    stru[2].b  = 1\n    fmt.Printf(\"值为：%+v\",stru[2])\n    \n    // 结论： map 必须通过 make 且 键值对必须 初始化。才能修改\n\t\n\t// 判断键值是否存在\n\tif _, ok := stru[2]; !ok {\n\t\treturn\n\t}\n\t\n}\n\t\n```\n2. 键值对作为结构体成员变量\n```go\npackage main\n\nimport (\n        \"fmt\"\n)\n\ntype MyStruct struct {\n    a, b uint64\n}\n\t\ntype MS struct{\n    stu  map[uint64]*MyStruct\n}\nfunc main() {\n    var stru MS\n    stru.stu = make(map[uint64]*MyStruct) // 1 \n       stru.stu[2]  = & MyStruct{ // 2 , 1 2 这两步都是必须的，且可以多次执行不会冲突\n           1,1,\n       }\n    stru.stu[2].a =1\n    stru.stu[2].b =1\n\n    fmt.Printf(\"值为：%+v\",stru.stu[2])\n    \n}\n```\n\n### 数组\n1. 定义 \n\t```go\n\t// 构造特定大小的数组，初始会有 size 的大小，每一个元素会有一个初始值，默认0\n\tids := make([]uint64, size)\n\t// 构造大小为 0 的数组\n\tvar   ids  []uint64\n\t//! 注意两种 定义方式 都可以用下面的方法增加元素 \n\t// 增加元素\n\tids = append(ids,1)\n\t```\n## 二、输入、输出\n\n1. fmt.Sprintf(格式化样式 ， 参数列表)\n    \n    1. 和 C 语言类似 printf\n        \n2. fmt.Println(str)\n    \n\n```C++\npackage main\n\nimport (\n        \"fmt\"\n)\n\nfunc main() {\n        var progress = 2\n        var target = 8\n        // 两参数格式化\n        title := fmt.Sprintf(\"已采集%d个药草, 还需要%d个完成任务\", progress, target)\n        fmt.Println(title)\n        pi := 3.14159\n        // 按数值本身的格式输出\n        variant := fmt.Sprintf(\"%v %v %v\", \"月球基地\", pi, true) //月球基地 3.14159 true\n        fmt.Println(variant)\n        // 匿名结构体声明, 并赋予初值\n        profile := &struct {\n                Name string\n                HP   int\n        }{\n                Name: \"rat\",\n                HP:   150,\n        }\n        // 双百分号表示转义\n        fmt.Printf(\"使用'%%+v' %+v\\n\", profile)  // 使用'%+v' &{Name:rat HP:150}\n        fmt.Printf(\"使用'%%#v' %#v\\n\", profile)  // 使用'%#v' &struct { Name string; HP int }{Name:\"rat\", HP:150}\n        fmt.Printf(\"使用'%%T' %T\\n\", profile)  // 使用'%T' *struct { Name string; HP int }\n}\n```\n\n3. 动 词 功 能\n    \n      %v 按值的本来值输出\n    \n      %+v 在 %v 基础上，对结构体字段名和值进行展开\n    \n      %#v 输出 Go 语言语法格式的值\n    \n      %T 输出 Go 语言语法格式的类型和值\n\t\n      \\%% 输出 % 本体\n    \n      %b 整型以二进制方式显示\n    \n      %o 整型以八进制方式显示\n    \n      %d 整型以十进制方式显示\n    \n      %x 整型以十六进制方式显示\n    \n      %X 整型以十六进制、字母大写方式显示\n    \n      %U Unicode 字符\n    \n      %f 浮点数\n    \n      %p 指针，十六进制方式显示\n    \n\n\n## 四、 库\n\n#### flag\n\n功能：Go 语言标准库中的一个包，用于解析命令行参数\n\n关键函数：\n\nflag.type(arg_name,arg_default_value,arg_discription) -> value\n\nflag.Parse() ：解析命令获得各个参数的值\n\n实例：\n\n```Bash\nfunc main() {\n        // 定义命令行参数\n        num1 := flag.Int(\"num1\", 0, \"第一个整数\")\n        num2 := flag.Int(\"num2\", 0, \"第二个整数\")\n\n        // 解析命令行参数\n        flag.Parse()\n        \n        // 计算和\n        sum := *num1 + *num2\n\n        // 输出结果\n        fmt.Println(\"和:\", sum)\n}\n```\n\n  \n\n## 三、常见技巧\n### 常见调用\n1. 获取变量类型 \n\tvarb.(type)\n2. 获取数组长度\n\tlen(arr)\n### 键值对KV\n\ngo语言中可以使用`map[string]interface{}`类型来实现，键的索引和值的多种类型\n\n```Bash\npackage main\nimport (\n        \"fmt\"\n)\n\nfunc main() {\n        // 定义\n        data := map[string]interface{}{\n                \"myname\": \"电子科技大学@2023\",\n                \"tasks\":  []string{\"task 1\", \"task 2\", \"task 3\"},\n                \"age\":    25,\n                \"isStudent\": true,\n        }\n        // 增加\n        data[\"newKey\"] = \"New Value\"\n        \n        // 删除\n        delete(data, \"age\") // 删除 data 中键为 “age” 的键值对\n        // 查找\n        key := \"tasks\"\n        value, found := data[key]\n        if found {\n                fmt.Printf(\"Value of key '%s': %v\\n\", key, value)\n        } else {\n                fmt.Printf(\"Key '%s' not found\\n\", key)\n        }\n        \n        // json 解析为键值对 KV 形式\n        str := `{\"name\": \"@2023\"}`\n        var data map[string]interface{}\n        errr := json.Unmarshal([]byte(str), &data)\n        if errr != nil {\n            // 处理解析错误\n        }\n        fmt.Println(data[\"name\"])\n        \n        // 多个键值对支持\n            // 局部\n            data := make(map[string]interface{})\n            // 全局\n            var data map[string]interface{} = make(map[string]interface{})\n            \n        // 获取键值对的 K V\n        for k, v := range data {\n             existingData[k] = v\n        }\n        \n        // 将 KV对 处理为 json格式\n        jsonData, err := json.Marshal(data)\n        if err != nil {\n                // 处理编码错误\n        }\n        \n        // 将 K V 处理为 json格式\n            // 方法 一：\n            // fmt.Fprintf(w, \"{'%s':'%v'}\", param, value)\n            \n            // 方法 二：\n            jsonData, err := json.Marshal(map[string]interface{}{\n                param: value,\n            })\n            if err != nil {\n                // 处理编码错误\n            }\n       \n        \n        //\n}\n```\n\n### 数据排序\n对数据集合（包括自定义数据类型的集合）排序需要实现 sort.Interface 接口的三个方法，以下为该接口的定义：\n\n```go\ntype Interface interface {\n        // 获取数据集合元素个数\n        Len() int\n        // 如果 i 索引的数据小于 j 索引的数据，返回 true 且不会调用下面的 Swap()，即数据升序排序。\n        Less(i, j int) bool\n        // 交换 i 和 j 索引的两个元素的位置\n        Swap(i, j int)\n}\n```\n数据集合实现了这三个方法后，即可调用该包的 Sort() 方法进行排序。 Sort() 方法定义如下：\n```go\nfunc Sort(data Interface)\n```\n\n例子：\n```go\n// 定义\ntype messageSlice []pb.Message\n\nfunc (s messageSlice) Len() int           { return len(s) }\nfunc (s messageSlice) Less(i, j int) bool { return fmt.Sprint(s[i]) < fmt.Sprint(s[j]) }\nfunc (s messageSlice) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }\n\n// 使用\nsort.Sort(messageSlice(msgs)) // msgs 为 []pb.Message 类型， 先强转再使用\n\n```\n\n\n### 数据比较\n\nreflect包中的DeepEqual函数完美的解决了比较问题。\n\n函数签名：\n\nfunc DeepEqual(a1, a2 interface{}) bool\n\n文档中对该函数的说明：\nDeepEqual函数用来判断两个值是否深度一致：除了类型相同；在可以时（主要是基本类型）会使用==；但还会比较array、slice的成员，map的键值对，结构体字段进行深入比对。map的键值对，对键只使用==，但值会继续往深层比对。DeepEqual 函数可以正确处理循环的类型。函数类型只有都会nil时才相等；空切片不等于nil切片；还会考虑array、slice的长度、map键值对数。\n示例：\n\nfunc main() {\n\tm1 := map[int]interface{}{1: []int{1, 2, 3}, 2: 3, 3: \"a\"}\n\tm2 := map[int]interface{}{1: []int{1, 2, 3}, 2: 3, 3: \"a\"}\n\tif reflect.DeepEqual(m1, m2) {\n\t\tfmt.Println(\"相等\")\n\t}\n}\n\nuestc.leemen.org","source":"_posts/编程语言/GO_lang/go 基础.md","raw":"go个人笔记\n\nhttps://blog.csdn.net/weiguang102/article/details/128501539\n\ngo 基础\n\nhttps://www.runoob.com/go/go-tutorial.html\n\ngo 环境安装\n\nhttps://blog.51cto.com/fish/5734211\n\n## 零、配置\n\n### 环境变量\n\n1.临时添加环境变量 PATH\n\nexport PATH=$PATH:/usr/local/go/bin\n\n2.所有用户永久添加环境变量\n\nvim /etc/profile\n\n末尾添加：export PATH:$PATH:/usr/local/go/bin\n\n刷新：sourse /etc/profile\n\n3.golang 工作目录\n\nGOPATH 是一个环境变量，用于指定Go项目的工作目录，默认情况下，GOPATH是 $HOME是当前用户的主目录。(/root 或者 /home/user1)\n\n获取：\n\ngo env GOPATH\n\n更改：\n\n编辑 .bashrc 或者 .zshrc\n\n找到 GOPATH 这行，将其修改为 /path/to/your/gopath\n\n  \n\n4.go.sum 与 go.mod\n\n`go.sum` 和 `go.mod` 是 Go 语言中用于管理模块依赖的文件。\n\n- `go.mod` 文件：`go.mod` 文件用于定义和管理项目的模块依赖关系。它位于项目的根目录下。当你使用 `go get` 命令来安装或更新依赖包时，`go.mod` 文件会被更新。它记录了项目所依赖的模块及其版本。你可以手动编辑 `go.mod` 文件来添加、移除或升级依赖包。在构建项目时，Go 会根据 `go.mod` 文件获取所需的依赖包。\n    \n- `go.sum` 文件：`go.sum` 文件用于记录项目所使用模块的校验和信息。每个模块都有一个唯一的校验和，用于确保下载的模块的完整性和安全性。`go.sum` 文件会自动生成并更新，其中包含了所有依赖模块的校验和。当你构建项目时，Go 会根据 `go.sum` 文件验证模块的完整性，以确保下载的模块与之前的校验和匹配。\n    \n\n使用 `go.mod` 和 `go.sum` 文件的基本操作如下：\n\n1. 初始化模块：在项目的根目录下执行 `go mod init` 命令，它会根据项目的路径和名称创建一个新的 `go.mod` 文件。\n    \n2. 添加依赖包：执行 `go get` 命令来添加所需的依赖包。例如，`go get` `github.com/example/package`。这会自动更新 `go.mod` 文件并下载依赖包。\n    \n3. 移除依赖包：执行 `go mod tidy` 命令来移除不再使用的依赖包。它会自动更新 `go.mod` 文件并删除不需要的依赖。\n    \n4. 升级依赖包：执行 `go get -u` 命令来升级依赖包到最新版本。这会自动更新 `go.mod` 文件。\n    \n5. 构建项目：使用 `go build` 或 `go run` 命令来构建或运行项目。Go 会根据 `go.mod` 文件下载依赖包并构建项目。\n    \n\n需要注意的是，`go.mod` 和 `go.sum` 文件对于保证项目的可复现性和依赖包的一致性非常重要。当你与他人共享项目时，确保将 `go.mod` 和 `go.sum` 文件一同共享，以便其他人可以获取相同的依赖包版本。\n\n管理和安装 `go.mod` 和 `go.sum` 中列出的依赖项：\n\n1. **下载依赖项**\n    \n\n当你首次克隆一个 Go 项目或者在已有项目中更新了依赖项时，可以使用以下命令来下载 `go.mod` 文件中指定的所有依赖项：\n\n```Bash\ngo mod download\n```\n\n这个命令会将依赖项下载到本地的 Go 模块缓存中，但不会在项目目录中创建任何文件。\n\n2. **同步依赖项**\n    \n\n如果你想确保项目目录下的依赖项与 `go.mod` 文件中定义的依赖项完全同步（即添加缺失的模块，删除不需要的模块，并更新 `go.sum`），可以使用：\n\n```Bash\ngo mod tidy\n```\n\n`go mod tidy` 命令会添加缺少的模块，移除未使用的模块，并生成一个新的 `go.sum` 文件。这是确保 `go.mod` 和 `go.sum` 文件准确反映项目依赖项的好方法。\n\n3. **查看依赖项**\n    \n\n如果你想查看当前项目的依赖树，可以使用：\n\n```Bash\ngo mod graph\n```\n\n这个命令会打印项目的所有依赖项及其版本，帮助你理解项目依赖的结构。\n\n4. **更新依赖项**\n    \n\n要更新项目中的某个依赖项到最新版本，可以使用：\n\n```Bash\ngo get -u package@version\n```\n\n其中 `package` 是依赖项的路径，`version` 是你想要更新到的版本。如果你想更新所有依赖项到最新版本，可以使用：\n\n```Bash\ngo get -u\n```\n\n但请注意，这可能会引入重大更改，因此建议仔细测试更新后的依赖项。\n\n  \n\n修改 proto 文件并运行 `make proto` 来更新 `proto/pkg/xxx/xxx.pb.go` 中相关生成的 go 代码\n\n  \n\n## 一、变量\n### 一般变量\n1. 变量声明\n    \n    1. 标准格式\n        \n    ```C++\n    var name type // 注意：声明变量时将变量的类型放在变量的名称之后\n    var a,b *int // 将 a b 同时声明为指针类型\n    \n    // 初始化\n    var hp int = 100 // 指定类型\n    var hp = 100 // 省略类型，编译器会尝试为变量推到类型\n    ```\n    \n    3. 简短格式\n        \n\n```C++\n// 名字 := 表达式\n/*\n1. 定义变量，同时显式初始化。\n2. 不能提供数据类型\n3. 只能用在函数内部。\n*/\n\n// 同时声明+初始化\ni, j := 0, 1\nfunc main() {\n   x:=100\n   a,s:=1, \"abc\"\n}\n// 注意  :=  左面必须是新变量\nvar hp int // 声明 hp 变量\nhp := 10  // 再次声明并赋值  报错！ 左面没有新变量出现\n\n// 错误！！！！其实 只要有新变量就行！\nvar conn net.Conn\nvar err error\nconn, err = net.Dial(\"tcp\", \"127.0.0.1:8080\")  // 不会报错\n```\n\n注意：变量的命名规则遵循骆驼命名法，即首个单词小写，每个新单词的首字母大写，例如：numShips 和 startDate 。\n\n2. 变量类型\n    \n    1. bool\n        \n    2. string\n        \n        1. 反引号可以实现多行\n            \n            ```C++\n            const str = `第一行\n            第二行\n            第三行\n            ` \n            fmt.Println(str);  // 输出上面的内容\n            \n            // 注意 ！！！！！！\n            // 此时所有的 转义都会失效，即 `` 内部的全部都视为 字符串一部分\n            ```\n            \n        2. 字符串长度\n            \n            1. len(), 判断的是 ASCII 长度 或者是 字节长度\n                \n                1. 在 go 语言中， 所有字符串都是以 utf-8 的格式保存，因此 汉字 3 字节，字符 1 字节\n                    \n                2. 若要将汉字作为一个整体统计， 可以使用下面的函数\n                    \n            2. RuneCountInString() , 判断的是字符的个数，或者说是 Unicode 字符串长度\n                \n                ```C++\n                package main\n                \n                import (\n                        \"fmt\"\n                        \"strings\"\n                )\n                \n                // 遍历字符串\n                // 按ASCII 字符\n                theme := \"狙击 start\"\n                for i := 0; i < len(theme); i++ {//使用 for 的数值循环进行遍历--\n                    fmt.Printf(\"ascii: %c  %d\\n\", theme[i], theme[i])\n                }// 这里 汉字为乱码\n                \n                // 按 Unicode  字符\n                theme := \"狙击 start\"\n                for _, s := range theme {\n                    fmt.Printf(\"Unicode: %c  %d\\n\", s, s)\n                }// 这里汉字正常显示\n                \n                \n                // 字符串截取\n                newtr := theme[i:]  // 截取部分包括 i\n                \n                // 字符串搜索\n                strings.Index(strings ,substring); // 返回 下标\n                strings.LastIndex(strings, substrings); // 反向搜索\n                \n                // 字符串修改\n                        s1 := \"abc\"\n                //     注意：字符串无法修改，只能在复制的基础上进行修改\n                //  方法一  转为 []byte()\n                        s2 := []byte(s1)\n                        s2[1] = 'B'\n                        fmt.Println(string(s2)) //aBc\n                // 方法二  转为 []runej() \n                        s3 := []rune(s1)\n                        s3[1] = 'B'\n                        fmt.Println(string(s3)) //aBc\n                 // 方法三 字符串替换\n                        new_str := \"ABC\"\n                        old_str := \"abc\"\n                        s4 := strings.Replace(s1, old_str , new_str , 2)\n                        fmt.Println(s4) //ABC\n                \n                // 字符串拼接\n                    str1 := \"hello\"\n                    str2 := \"world\"\n                 // 方法一 使用 + 直接拼接\n                     str3 := str1 + str2\n                 // 方法二 使用 bytes.Buffer\n                     var stringBuilder bytes.Buffer\n                     stringBuilder.WriteString(str1)\n                     stringBuilder.WriteString(str2)\n                     str4 := stringBuilder.String()\n                     \n                ```\n                \n    3. int、int8、int16、int32、int64\n        \n    4. uint、uint8、uint16、uint32、uint64、uintptr\n        \n    5. byte // uint8 的别名\n        \n    6. rune // int32 的别名 代表一个 Unicode 码 不对 是 UTF-8\n        \n    7. float32、float64\n        \n    8. complex64、complex128 内建函数\n    9. interface 接口类型\n\t    https://learnku.com/go/t/38843\n\t\t```go\n\t\t\ttype Animal interface {\n\t\t\t    Speak() string\n\t\t\t}\n\t\t```\n    10. map\\[string\\] \\*sync.WaitGroup  键值对类型\n3. 变量赋值\n    \n    ```C++\n    b, a = a, b  // 这里 可以实现交换操作\n    a, _ := a, _ := GetData()  // 这里 匿名变量\n    ```\n    \n      注意：**当一个变量被声明之后，系统自动赋予它该类型的零值：****`int 为 0，float 为 0.0，bool 为 false，string 为空字符串，指针为 nil 等`**\n    \n      所有的内存在 Go 中都是经过初始化的。\n    \n4. 匿名变量不占用内存空间，不分配内存\n    \n5. 作用域\n    1. 全局变量声明必须以 `var` 关键字开头，如果想要在外部包中使用全局变量的首字母必须大写。\n    2. 特殊变量定义位置\n\t    ```go\n\t    if firstIdx, err := Func(); err != nil {\n\t        log.Fatal(err)\n\t        return nil\n\t    }\n\t    // 这里的 firstIdx 只能在 if 里面的大括号用，一旦出去就使用不了\n\t\t```\n    \n6. 比较\n    \n      只有同类型的变量才能进行比较\n    \n      包括 0 1 到 true false 的转换\n    \n7. 类型转换\n    \n    1. bool 不能强转为 int\n        \n        ```C++\n        var n bool\n        n := (int)n\n        //会报错\n        ```\n        \n    2. 不能获取数组某个位置的的地址\n        \n\n### 结构体变量\n1. 结构体声明\n\t```go\n\t// 结构体成员变量\n\ttype MyStruct struct{\n\t\tage int     // 注意没有 逗号\n\t\tname string\n\t}\n\t// 结构体函数\n\tfunc (ms *MyStruct) grow(int a) bool{\n\t\tms.age += a\n\t\treturn true\n\t}\n\t\n\t// 结构体的指针继承\n\ttype MyStruct2 struct{\n\t\t*MyStruct  // 通过指针的方式，父亲结构体作为一个无名成员变量，\n\t\t\t\t   // 赋值时使用 父亲对象 赋值； \n\t\t\t\t   // 使用时使用 孩子对象 直接使用（不需要先点出来父亲）\n\t\tage int     // 注意没有 逗号\n\t\tname string\n\t}\n\t```\n2. 结构体实例化\n\t``` go\n\t// 方法一：var 声明\n\tvar fan MyStruct   // 为 fan 分配内存并且零化值\n\tfan.age = 26\n\tfan.name = \"fan\"\n\t\n\t// 方法二：new 关键字\n\t// 11\n\tfan := &MyStruct{   // 返回一个结构体指针，带有初始值\n\t\t26,\n\t\t\"fan\",\n\t}\n\t// 22 \n\tfan := new(MyStruct) // 返回一个结构体指针，零值\n\tfan.name = \"fan\"\n\tfan.age = 26\n\t\n\t// 方法三：赋值初始化\n\t// 11\n\tfan := MyStruct{\n\t\tname: \"fan\",\n\t\tage: 26,\n\t}\n\t// 22：必须要对应结构体定义顺序，并且每一个都必须进行初始化。\n\tfan := MyStruct{\n\t\t26,\n\t\t\"fan\",\n\t}\n\t```\n3. 匿名结构体\n\t```go\n\tprofile := &struct {\n            name string\n            age   int\n    }{\n            name: \"rat\",\n            age:   150,\n    }\n    // 打印值\n    fmt.Printf(\"使用'%%+v' %+v\\n\", profile)\n    fmt.Printf(\"使用'%%#v' %#v\\n\", profile)\n    fmt.Printf(\"使用'%%T' %T\\n\", profile)\n\t```\n4. 结构体返回值\n\t```go\n\tfunc newStruct() * MyStruct{\n\t\t// 此处替换为三种不同方式\n\t    var fan MyStruct   // 为 fan 分配内存并且零化值\n\t\tfan.age = 26\n\t\tfan.name = \"fan\"\n\t\tfmt.Printf(\"函数内变量 fan 的地址为：%p\\n\", &fan)\n\t\treturn &fan\n\t}\n\t\n\t// 测试\n\tfunc main() {\n\t    fan := newStruct()\n\t    fmt.Printf(\"函数外变量 fan 的地址为：%p\\n\", fan)\n\t\tfmt.Printf(\"fan使用'%%+v' %+v\\n\", fan)\n\t\tfan.age = 18\n\t\tfmt.Printf(\"fan使用'%%+v' %+v\\n\", fan)\n\t\t// 方法一：地址相同，可更改 \n\t\t// 方法二11：地址相同，可更改\n\t\t// 方法二22：地址相同，可更改\n\t\t// 方法三11：地址相同，可更改\n\t\t// 方法三22：地址相同，可更改\n\t}\n\t```\n### 键值对类型\nmap\\[string\\] \\*sync.WaitGroup  键值对类型\n1. 键值对变量\n```go\npackage main\n\nimport (\n        \"fmt\"\n)\n\ntype MyStruct struct {\n    a, b uint64\n}\n\t\nfunc main() {\n\t// !! 定义与使用 \n    //  初始 正常运行\n    stru := make(map[uint64]*MyStruct)\n    stru[2] = &MyStruct{\n        1,1,\n    }\n    stru[2].a = 1\n    stru[2].b  = 1\n    fmt.Printf(\"值为：%+v\",stru[2])\n    \n    //  这样也可以\n    var stru map[uint64]*MyStruct \n    stru = make(map[uint64]*MyStruct) // 没有这行运行不通\n    stru[2] = &MyStruct{   // 去掉这行也不行\n        1,1,\n    }  \n    stru[2].a = 1\n    stru[2].b  = 1\n    fmt.Printf(\"值为：%+v\",stru[2])\n    \n    // 结论： map 必须通过 make 且 键值对必须 初始化。才能修改\n\t\n\t// 判断键值是否存在\n\tif _, ok := stru[2]; !ok {\n\t\treturn\n\t}\n\t\n}\n\t\n```\n2. 键值对作为结构体成员变量\n```go\npackage main\n\nimport (\n        \"fmt\"\n)\n\ntype MyStruct struct {\n    a, b uint64\n}\n\t\ntype MS struct{\n    stu  map[uint64]*MyStruct\n}\nfunc main() {\n    var stru MS\n    stru.stu = make(map[uint64]*MyStruct) // 1 \n       stru.stu[2]  = & MyStruct{ // 2 , 1 2 这两步都是必须的，且可以多次执行不会冲突\n           1,1,\n       }\n    stru.stu[2].a =1\n    stru.stu[2].b =1\n\n    fmt.Printf(\"值为：%+v\",stru.stu[2])\n    \n}\n```\n\n### 数组\n1. 定义 \n\t```go\n\t// 构造特定大小的数组，初始会有 size 的大小，每一个元素会有一个初始值，默认0\n\tids := make([]uint64, size)\n\t// 构造大小为 0 的数组\n\tvar   ids  []uint64\n\t//! 注意两种 定义方式 都可以用下面的方法增加元素 \n\t// 增加元素\n\tids = append(ids,1)\n\t```\n## 二、输入、输出\n\n1. fmt.Sprintf(格式化样式 ， 参数列表)\n    \n    1. 和 C 语言类似 printf\n        \n2. fmt.Println(str)\n    \n\n```C++\npackage main\n\nimport (\n        \"fmt\"\n)\n\nfunc main() {\n        var progress = 2\n        var target = 8\n        // 两参数格式化\n        title := fmt.Sprintf(\"已采集%d个药草, 还需要%d个完成任务\", progress, target)\n        fmt.Println(title)\n        pi := 3.14159\n        // 按数值本身的格式输出\n        variant := fmt.Sprintf(\"%v %v %v\", \"月球基地\", pi, true) //月球基地 3.14159 true\n        fmt.Println(variant)\n        // 匿名结构体声明, 并赋予初值\n        profile := &struct {\n                Name string\n                HP   int\n        }{\n                Name: \"rat\",\n                HP:   150,\n        }\n        // 双百分号表示转义\n        fmt.Printf(\"使用'%%+v' %+v\\n\", profile)  // 使用'%+v' &{Name:rat HP:150}\n        fmt.Printf(\"使用'%%#v' %#v\\n\", profile)  // 使用'%#v' &struct { Name string; HP int }{Name:\"rat\", HP:150}\n        fmt.Printf(\"使用'%%T' %T\\n\", profile)  // 使用'%T' *struct { Name string; HP int }\n}\n```\n\n3. 动 词 功 能\n    \n      %v 按值的本来值输出\n    \n      %+v 在 %v 基础上，对结构体字段名和值进行展开\n    \n      %#v 输出 Go 语言语法格式的值\n    \n      %T 输出 Go 语言语法格式的类型和值\n\t\n      \\%% 输出 % 本体\n    \n      %b 整型以二进制方式显示\n    \n      %o 整型以八进制方式显示\n    \n      %d 整型以十进制方式显示\n    \n      %x 整型以十六进制方式显示\n    \n      %X 整型以十六进制、字母大写方式显示\n    \n      %U Unicode 字符\n    \n      %f 浮点数\n    \n      %p 指针，十六进制方式显示\n    \n\n\n## 四、 库\n\n#### flag\n\n功能：Go 语言标准库中的一个包，用于解析命令行参数\n\n关键函数：\n\nflag.type(arg_name,arg_default_value,arg_discription) -> value\n\nflag.Parse() ：解析命令获得各个参数的值\n\n实例：\n\n```Bash\nfunc main() {\n        // 定义命令行参数\n        num1 := flag.Int(\"num1\", 0, \"第一个整数\")\n        num2 := flag.Int(\"num2\", 0, \"第二个整数\")\n\n        // 解析命令行参数\n        flag.Parse()\n        \n        // 计算和\n        sum := *num1 + *num2\n\n        // 输出结果\n        fmt.Println(\"和:\", sum)\n}\n```\n\n  \n\n## 三、常见技巧\n### 常见调用\n1. 获取变量类型 \n\tvarb.(type)\n2. 获取数组长度\n\tlen(arr)\n### 键值对KV\n\ngo语言中可以使用`map[string]interface{}`类型来实现，键的索引和值的多种类型\n\n```Bash\npackage main\nimport (\n        \"fmt\"\n)\n\nfunc main() {\n        // 定义\n        data := map[string]interface{}{\n                \"myname\": \"电子科技大学@2023\",\n                \"tasks\":  []string{\"task 1\", \"task 2\", \"task 3\"},\n                \"age\":    25,\n                \"isStudent\": true,\n        }\n        // 增加\n        data[\"newKey\"] = \"New Value\"\n        \n        // 删除\n        delete(data, \"age\") // 删除 data 中键为 “age” 的键值对\n        // 查找\n        key := \"tasks\"\n        value, found := data[key]\n        if found {\n                fmt.Printf(\"Value of key '%s': %v\\n\", key, value)\n        } else {\n                fmt.Printf(\"Key '%s' not found\\n\", key)\n        }\n        \n        // json 解析为键值对 KV 形式\n        str := `{\"name\": \"@2023\"}`\n        var data map[string]interface{}\n        errr := json.Unmarshal([]byte(str), &data)\n        if errr != nil {\n            // 处理解析错误\n        }\n        fmt.Println(data[\"name\"])\n        \n        // 多个键值对支持\n            // 局部\n            data := make(map[string]interface{})\n            // 全局\n            var data map[string]interface{} = make(map[string]interface{})\n            \n        // 获取键值对的 K V\n        for k, v := range data {\n             existingData[k] = v\n        }\n        \n        // 将 KV对 处理为 json格式\n        jsonData, err := json.Marshal(data)\n        if err != nil {\n                // 处理编码错误\n        }\n        \n        // 将 K V 处理为 json格式\n            // 方法 一：\n            // fmt.Fprintf(w, \"{'%s':'%v'}\", param, value)\n            \n            // 方法 二：\n            jsonData, err := json.Marshal(map[string]interface{}{\n                param: value,\n            })\n            if err != nil {\n                // 处理编码错误\n            }\n       \n        \n        //\n}\n```\n\n### 数据排序\n对数据集合（包括自定义数据类型的集合）排序需要实现 sort.Interface 接口的三个方法，以下为该接口的定义：\n\n```go\ntype Interface interface {\n        // 获取数据集合元素个数\n        Len() int\n        // 如果 i 索引的数据小于 j 索引的数据，返回 true 且不会调用下面的 Swap()，即数据升序排序。\n        Less(i, j int) bool\n        // 交换 i 和 j 索引的两个元素的位置\n        Swap(i, j int)\n}\n```\n数据集合实现了这三个方法后，即可调用该包的 Sort() 方法进行排序。 Sort() 方法定义如下：\n```go\nfunc Sort(data Interface)\n```\n\n例子：\n```go\n// 定义\ntype messageSlice []pb.Message\n\nfunc (s messageSlice) Len() int           { return len(s) }\nfunc (s messageSlice) Less(i, j int) bool { return fmt.Sprint(s[i]) < fmt.Sprint(s[j]) }\nfunc (s messageSlice) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }\n\n// 使用\nsort.Sort(messageSlice(msgs)) // msgs 为 []pb.Message 类型， 先强转再使用\n\n```\n\n\n### 数据比较\n\nreflect包中的DeepEqual函数完美的解决了比较问题。\n\n函数签名：\n\nfunc DeepEqual(a1, a2 interface{}) bool\n\n文档中对该函数的说明：\nDeepEqual函数用来判断两个值是否深度一致：除了类型相同；在可以时（主要是基本类型）会使用==；但还会比较array、slice的成员，map的键值对，结构体字段进行深入比对。map的键值对，对键只使用==，但值会继续往深层比对。DeepEqual 函数可以正确处理循环的类型。函数类型只有都会nil时才相等；空切片不等于nil切片；还会考虑array、slice的长度、map键值对数。\n示例：\n\nfunc main() {\n\tm1 := map[int]interface{}{1: []int{1, 2, 3}, 2: 3, 3: \"a\"}\n\tm2 := map[int]interface{}{1: []int{1, 2, 3}, 2: 3, 3: \"a\"}\n\tif reflect.DeepEqual(m1, m2) {\n\t\tfmt.Println(\"相等\")\n\t}\n}\n\nuestc.leemen.org","slug":"编程语言/GO_lang/go 基础","published":1,"date":"2024-04-22T13:14:48.676Z","updated":"2024-04-08T08:45:19.752Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0p002ekgg480zt1m3o","content":"<p>go个人笔记</p>\n<p><a href=\"https://blog.csdn.net/weiguang102/article/details/128501539\">https://blog.csdn.net/weiguang102/article/details/128501539</a></p>\n<p>go 基础</p>\n<p><a href=\"https://www.runoob.com/go/go-tutorial.html\">https://www.runoob.com/go/go-tutorial.html</a></p>\n<p>go 环境安装</p>\n<p><a href=\"https://blog.51cto.com/fish/5734211\">https://blog.51cto.com/fish/5734211</a></p>\n<h2 id=\"零、配置\"><a href=\"#零、配置\" class=\"headerlink\" title=\"零、配置\"></a>零、配置</h2><h3 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h3><p>1.临时添加环境变量 PATH</p>\n<p>export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;go&#x2F;bin</p>\n<p>2.所有用户永久添加环境变量</p>\n<p>vim &#x2F;etc&#x2F;profile</p>\n<p>末尾添加：export PATH:$PATH:&#x2F;usr&#x2F;local&#x2F;go&#x2F;bin</p>\n<p>刷新：sourse &#x2F;etc&#x2F;profile</p>\n<p>3.golang 工作目录</p>\n<p>GOPATH 是一个环境变量，用于指定Go项目的工作目录，默认情况下，GOPATH是 $HOME是当前用户的主目录。(&#x2F;root 或者 &#x2F;home&#x2F;user1)</p>\n<p>获取：</p>\n<p>go env GOPATH</p>\n<p>更改：</p>\n<p>编辑 .bashrc 或者 .zshrc</p>\n<p>找到 GOPATH 这行，将其修改为 &#x2F;path&#x2F;to&#x2F;your&#x2F;gopath</p>\n<p>4.go.sum 与 go.mod</p>\n<p><code>go.sum</code> 和 <code>go.mod</code> 是 Go 语言中用于管理模块依赖的文件。</p>\n<ul>\n<li><p><code>go.mod</code> 文件：<code>go.mod</code> 文件用于定义和管理项目的模块依赖关系。它位于项目的根目录下。当你使用 <code>go get</code> 命令来安装或更新依赖包时，<code>go.mod</code> 文件会被更新。它记录了项目所依赖的模块及其版本。你可以手动编辑 <code>go.mod</code> 文件来添加、移除或升级依赖包。在构建项目时，Go 会根据 <code>go.mod</code> 文件获取所需的依赖包。</p>\n</li>\n<li><p><code>go.sum</code> 文件：<code>go.sum</code> 文件用于记录项目所使用模块的校验和信息。每个模块都有一个唯一的校验和，用于确保下载的模块的完整性和安全性。<code>go.sum</code> 文件会自动生成并更新，其中包含了所有依赖模块的校验和。当你构建项目时，Go 会根据 <code>go.sum</code> 文件验证模块的完整性，以确保下载的模块与之前的校验和匹配。</p>\n</li>\n</ul>\n<p>使用 <code>go.mod</code> 和 <code>go.sum</code> 文件的基本操作如下：</p>\n<ol>\n<li><p>初始化模块：在项目的根目录下执行 <code>go mod init</code> 命令，它会根据项目的路径和名称创建一个新的 <code>go.mod</code> 文件。</p>\n</li>\n<li><p>添加依赖包：执行 <code>go get</code> 命令来添加所需的依赖包。例如，<code>go get</code> <code>github.com/example/package</code>。这会自动更新 <code>go.mod</code> 文件并下载依赖包。</p>\n</li>\n<li><p>移除依赖包：执行 <code>go mod tidy</code> 命令来移除不再使用的依赖包。它会自动更新 <code>go.mod</code> 文件并删除不需要的依赖。</p>\n</li>\n<li><p>升级依赖包：执行 <code>go get -u</code> 命令来升级依赖包到最新版本。这会自动更新 <code>go.mod</code> 文件。</p>\n</li>\n<li><p>构建项目：使用 <code>go build</code> 或 <code>go run</code> 命令来构建或运行项目。Go 会根据 <code>go.mod</code> 文件下载依赖包并构建项目。</p>\n</li>\n</ol>\n<p>需要注意的是，<code>go.mod</code> 和 <code>go.sum</code> 文件对于保证项目的可复现性和依赖包的一致性非常重要。当你与他人共享项目时，确保将 <code>go.mod</code> 和 <code>go.sum</code> 文件一同共享，以便其他人可以获取相同的依赖包版本。</p>\n<p>管理和安装 <code>go.mod</code> 和 <code>go.sum</code> 中列出的依赖项：</p>\n<ol>\n<li><strong>下载依赖项</strong></li>\n</ol>\n<p>当你首次克隆一个 Go 项目或者在已有项目中更新了依赖项时，可以使用以下命令来下载 <code>go.mod</code> 文件中指定的所有依赖项：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go mod download</span><br></pre></td></tr></table></figure>\n\n<p>这个命令会将依赖项下载到本地的 Go 模块缓存中，但不会在项目目录中创建任何文件。</p>\n<ol start=\"2\">\n<li><strong>同步依赖项</strong></li>\n</ol>\n<p>如果你想确保项目目录下的依赖项与 <code>go.mod</code> 文件中定义的依赖项完全同步（即添加缺失的模块，删除不需要的模块，并更新 <code>go.sum</code>），可以使用：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go mod tidy</span><br></pre></td></tr></table></figure>\n\n<p><code>go mod tidy</code> 命令会添加缺少的模块，移除未使用的模块，并生成一个新的 <code>go.sum</code> 文件。这是确保 <code>go.mod</code> 和 <code>go.sum</code> 文件准确反映项目依赖项的好方法。</p>\n<ol start=\"3\">\n<li><strong>查看依赖项</strong></li>\n</ol>\n<p>如果你想查看当前项目的依赖树，可以使用：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go mod graph</span><br></pre></td></tr></table></figure>\n\n<p>这个命令会打印项目的所有依赖项及其版本，帮助你理解项目依赖的结构。</p>\n<ol start=\"4\">\n<li><strong>更新依赖项</strong></li>\n</ol>\n<p>要更新项目中的某个依赖项到最新版本，可以使用：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go get -u package@version</span><br></pre></td></tr></table></figure>\n\n<p>其中 <code>package</code> 是依赖项的路径，<code>version</code> 是你想要更新到的版本。如果你想更新所有依赖项到最新版本，可以使用：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go get -u</span><br></pre></td></tr></table></figure>\n\n<p>但请注意，这可能会引入重大更改，因此建议仔细测试更新后的依赖项。</p>\n<p>修改 proto 文件并运行 <code>make proto</code> 来更新 <code>proto/pkg/xxx/xxx.pb.go</code> 中相关生成的 go 代码</p>\n<h2 id=\"一、变量\"><a href=\"#一、变量\" class=\"headerlink\" title=\"一、变量\"></a>一、变量</h2><h3 id=\"一般变量\"><a href=\"#一般变量\" class=\"headerlink\" title=\"一般变量\"></a>一般变量</h3><ol>\n<li><p>变量声明</p>\n<ol>\n<li>标准格式</li>\n</ol>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name type <span class=\"comment\">// 注意：声明变量时将变量的类型放在变量的名称之后</span></span><br><span class=\"line\">var a,b *<span class=\"type\">int</span> <span class=\"comment\">// 将 a b 同时声明为指针类型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化</span></span><br><span class=\"line\">var hp <span class=\"type\">int</span> = <span class=\"number\">100</span> <span class=\"comment\">// 指定类型</span></span><br><span class=\"line\">var hp = <span class=\"number\">100</span> <span class=\"comment\">// 省略类型，编译器会尝试为变量推到类型</span></span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>简短格式</li>\n</ol>\n</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 名字 := 表达式</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">1. 定义变量，同时显式初始化。</span></span><br><span class=\"line\"><span class=\"comment\">2. 不能提供数据类型</span></span><br><span class=\"line\"><span class=\"comment\">3. 只能用在函数内部。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 同时声明+初始化</span></span><br><span class=\"line\">i, j := <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">func <span class=\"built_in\">main</span>() &#123;</span><br><span class=\"line\">   x:=<span class=\"number\">100</span></span><br><span class=\"line\">   a,s:=<span class=\"number\">1</span>, <span class=\"string\">&quot;abc&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 注意  :=  左面必须是新变量</span></span><br><span class=\"line\">var hp <span class=\"type\">int</span> <span class=\"comment\">// 声明 hp 变量</span></span><br><span class=\"line\">hp := <span class=\"number\">10</span>  <span class=\"comment\">// 再次声明并赋值  报错！ 左面没有新变量出现</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 错误！！！！其实 只要有新变量就行！</span></span><br><span class=\"line\">var conn net.Conn</span><br><span class=\"line\">var err error</span><br><span class=\"line\">conn, err = net.<span class=\"built_in\">Dial</span>(<span class=\"string\">&quot;tcp&quot;</span>, <span class=\"string\">&quot;127.0.0.1:8080&quot;</span>)  <span class=\"comment\">// 不会报错</span></span><br></pre></td></tr></table></figure>\n\n<p>注意：变量的命名规则遵循骆驼命名法，即首个单词小写，每个新单词的首字母大写，例如：numShips 和 startDate 。</p>\n<ol start=\"2\">\n<li><p>变量类型</p>\n<ol>\n<li><p>bool</p>\n</li>\n<li><p>string</p>\n<ol>\n<li><p>反引号可以实现多行</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> str = `第一行</span><br><span class=\"line\">第二行</span><br><span class=\"line\">第三行</span><br><span class=\"line\">` </span><br><span class=\"line\">fmt.<span class=\"built_in\">Println</span>(str);  <span class=\"comment\">// 输出上面的内容</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注意 ！！！！！！</span></span><br><span class=\"line\"><span class=\"comment\">// 此时所有的 转义都会失效，即 `` 内部的全部都视为 字符串一部分</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>字符串长度</p>\n<ol>\n<li><p>len(), 判断的是 ASCII 长度 或者是 字节长度</p>\n<ol>\n<li><p>在 go 语言中， 所有字符串都是以 utf-8 的格式保存，因此 汉字 3 字节，字符 1 字节</p>\n</li>\n<li><p>若要将汉字作为一个整体统计， 可以使用下面的函数</p>\n</li>\n</ol>\n</li>\n<li><p>RuneCountInString() , 判断的是字符的个数，或者说是 Unicode 字符串长度</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">package main</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">import</span> <span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        <span class=\"string\">&quot;fmt&quot;</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        <span class=\"string\">&quot;strings&quot;</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 遍历字符串</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 按ASCII 字符</span></span></span><br><span class=\"line\"><span class=\"function\">theme :=</span> <span class=\"string\">&quot;狙击 start&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(theme); i++ &#123;<span class=\"comment\">//使用 for 的数值循环进行遍历--</span></span><br><span class=\"line\">    fmt.<span class=\"built_in\">Printf</span>(<span class=\"string\">&quot;ascii: %c  %d\\n&quot;</span>, theme[i], theme[i])</span><br><span class=\"line\">&#125;<span class=\"comment\">// 这里 汉字为乱码</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 按 Unicode  字符</span></span><br><span class=\"line\">theme := <span class=\"string\">&quot;狙击 start&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> _, s := range theme &#123;</span><br><span class=\"line\">    fmt.<span class=\"built_in\">Printf</span>(<span class=\"string\">&quot;Unicode: %c  %d\\n&quot;</span>, s, s)</span><br><span class=\"line\">&#125;<span class=\"comment\">// 这里汉字正常显示</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 字符串截取</span></span><br><span class=\"line\">newtr := theme[i:]  <span class=\"comment\">// 截取部分包括 i</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 字符串搜索</span></span><br><span class=\"line\">strings.<span class=\"built_in\">Index</span>(strings ,substring); <span class=\"comment\">// 返回 下标</span></span><br><span class=\"line\">strings.<span class=\"built_in\">LastIndex</span>(strings, substrings); <span class=\"comment\">// 反向搜索</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 字符串修改</span></span><br><span class=\"line\">        s1 := <span class=\"string\">&quot;abc&quot;</span></span><br><span class=\"line\"><span class=\"comment\">//     注意：字符串无法修改，只能在复制的基础上进行修改</span></span><br><span class=\"line\"><span class=\"comment\">//  方法一  转为 []byte()</span></span><br><span class=\"line\">        s2 := []<span class=\"built_in\">byte</span>(s1)</span><br><span class=\"line\">        s2[<span class=\"number\">1</span>] = <span class=\"string\">&#x27;B&#x27;</span></span><br><span class=\"line\">        fmt.<span class=\"built_in\">Println</span>(<span class=\"built_in\">string</span>(s2)) <span class=\"comment\">//aBc</span></span><br><span class=\"line\"><span class=\"comment\">// 方法二  转为 []runej() </span></span><br><span class=\"line\">        s3 := []<span class=\"built_in\">rune</span>(s1)</span><br><span class=\"line\">        s3[<span class=\"number\">1</span>] = <span class=\"string\">&#x27;B&#x27;</span></span><br><span class=\"line\">        fmt.<span class=\"built_in\">Println</span>(<span class=\"built_in\">string</span>(s3)) <span class=\"comment\">//aBc</span></span><br><span class=\"line\"> <span class=\"comment\">// 方法三 字符串替换</span></span><br><span class=\"line\">        new_str := <span class=\"string\">&quot;ABC&quot;</span></span><br><span class=\"line\">        old_str := <span class=\"string\">&quot;abc&quot;</span></span><br><span class=\"line\">        s4 := strings.<span class=\"built_in\">Replace</span>(s1, old_str , new_str , <span class=\"number\">2</span>)</span><br><span class=\"line\">        fmt.<span class=\"built_in\">Println</span>(s4) <span class=\"comment\">//ABC</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 字符串拼接</span></span><br><span class=\"line\">    str1 := <span class=\"string\">&quot;hello&quot;</span></span><br><span class=\"line\">    str2 := <span class=\"string\">&quot;world&quot;</span></span><br><span class=\"line\"> <span class=\"comment\">// 方法一 使用 + 直接拼接</span></span><br><span class=\"line\">     str3 := str1 + str2</span><br><span class=\"line\"> <span class=\"comment\">// 方法二 使用 bytes.Buffer</span></span><br><span class=\"line\">     var stringBuilder bytes.Buffer</span><br><span class=\"line\">     stringBuilder.<span class=\"built_in\">WriteString</span>(str1)</span><br><span class=\"line\">     stringBuilder.<span class=\"built_in\">WriteString</span>(str2)</span><br><span class=\"line\">     str4 := stringBuilder.<span class=\"built_in\">String</span>()</span><br><span class=\"line\">     </span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>int、int8、int16、int32、int64</p>\n</li>\n<li><p>uint、uint8、uint16、uint32、uint64、uintptr</p>\n</li>\n<li><p>byte &#x2F;&#x2F; uint8 的别名</p>\n</li>\n<li><p>rune &#x2F;&#x2F; int32 的别名 代表一个 Unicode 码 不对 是 UTF-8</p>\n</li>\n<li><p>float32、float64</p>\n</li>\n<li><p>complex64、complex128 内建函数</p>\n</li>\n<li><p>interface 接口类型<br> <a href=\"https://learnku.com/go/t/38843\">https://learnku.com/go/t/38843</a></p>\n <figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Animal <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Speak() <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>map[string] *sync.WaitGroup  键值对类型</p>\n</li>\n</ol>\n</li>\n<li><p>变量赋值</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b, a = a, b  <span class=\"comment\">// 这里 可以实现交换操作</span></span><br><span class=\"line\">a, _ := a, _ := <span class=\"built_in\">GetData</span>()  <span class=\"comment\">// 这里 匿名变量</span></span><br></pre></td></tr></table></figure>\n<p>   注意：<strong>当一个变量被声明之后，系统自动赋予它该类型的零值：</strong><strong><code>int 为 0，float 为 0.0，bool 为 false，string 为空字符串，指针为 nil 等</code></strong></p>\n<p>   所有的内存在 Go 中都是经过初始化的。</p>\n</li>\n<li><p>匿名变量不占用内存空间，不分配内存</p>\n</li>\n<li><p>作用域</p>\n<ol>\n<li>全局变量声明必须以 <code>var</code> 关键字开头，如果想要在外部包中使用全局变量的首字母必须大写。</li>\n<li>特殊变量定义位置 <figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> firstIdx, err := Func(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t        log.Fatal(err)</span><br><span class=\"line\">\t        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t    <span class=\"comment\">// 这里的 firstIdx 只能在 if 里面的大括号用，一旦出去就使用不了</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n<li><p>比较</p>\n<p>   只有同类型的变量才能进行比较</p>\n<p>   包括 0 1 到 true false 的转换</p>\n</li>\n<li><p>类型转换</p>\n<ol>\n<li><p>bool 不能强转为 int</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var n <span class=\"type\">bool</span></span><br><span class=\"line\">n := (<span class=\"type\">int</span>)n</span><br><span class=\"line\"><span class=\"comment\">//会报错</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>不能获取数组某个位置的的地址</p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"结构体变量\"><a href=\"#结构体变量\" class=\"headerlink\" title=\"结构体变量\"></a>结构体变量</h3><ol>\n<li>结构体声明 <figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 结构体成员变量</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> MyStruct <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">\tage <span class=\"type\">int</span>     <span class=\"comment\">// 注意没有 逗号</span></span><br><span class=\"line\">\tname <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 结构体函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(ms *MyStruct)</span></span> grow(<span class=\"type\">int</span> a) <span class=\"type\">bool</span>&#123;</span><br><span class=\"line\">\tms.age += a</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 结构体的指针继承</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> MyStruct2 <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">\t*MyStruct  <span class=\"comment\">// 通过指针的方式，父亲结构体作为一个无名成员变量，</span></span><br><span class=\"line\">\t\t\t   <span class=\"comment\">// 赋值时使用 父亲对象 赋值； </span></span><br><span class=\"line\">\t\t\t   <span class=\"comment\">// 使用时使用 孩子对象 直接使用（不需要先点出来父亲）</span></span><br><span class=\"line\">\tage <span class=\"type\">int</span>     <span class=\"comment\">// 注意没有 逗号</span></span><br><span class=\"line\">\tname <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>结构体实例化 <figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法一：var 声明</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fan MyStruct   <span class=\"comment\">// 为 fan 分配内存并且零化值</span></span><br><span class=\"line\">fan.age = <span class=\"number\">26</span></span><br><span class=\"line\">fan.name = <span class=\"string\">&quot;fan&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法二：new 关键字</span></span><br><span class=\"line\"><span class=\"comment\">// 11</span></span><br><span class=\"line\">fan := &amp;MyStruct&#123;   <span class=\"comment\">// 返回一个结构体指针，带有初始值</span></span><br><span class=\"line\">\t<span class=\"number\">26</span>,</span><br><span class=\"line\">\t<span class=\"string\">&quot;fan&quot;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 22 </span></span><br><span class=\"line\">fan := <span class=\"built_in\">new</span>(MyStruct) <span class=\"comment\">// 返回一个结构体指针，零值</span></span><br><span class=\"line\">fan.name = <span class=\"string\">&quot;fan&quot;</span></span><br><span class=\"line\">fan.age = <span class=\"number\">26</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法三：赋值初始化</span></span><br><span class=\"line\"><span class=\"comment\">// 11</span></span><br><span class=\"line\">fan := MyStruct&#123;</span><br><span class=\"line\">\tname: <span class=\"string\">&quot;fan&quot;</span>,</span><br><span class=\"line\">\tage: <span class=\"number\">26</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 22：必须要对应结构体定义顺序，并且每一个都必须进行初始化。</span></span><br><span class=\"line\">fan := MyStruct&#123;</span><br><span class=\"line\">\t<span class=\"number\">26</span>,</span><br><span class=\"line\">\t<span class=\"string\">&quot;fan&quot;</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>匿名结构体 <figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">profile := &amp;<span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">           name <span class=\"type\">string</span></span><br><span class=\"line\">           age   <span class=\"type\">int</span></span><br><span class=\"line\">   &#125;&#123;</span><br><span class=\"line\">           name: <span class=\"string\">&quot;rat&quot;</span>,</span><br><span class=\"line\">           age:   <span class=\"number\">150</span>,</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 打印值</span></span><br><span class=\"line\">   fmt.Printf(<span class=\"string\">&quot;使用&#x27;%%+v&#x27; %+v\\n&quot;</span>, profile)</span><br><span class=\"line\">   fmt.Printf(<span class=\"string\">&quot;使用&#x27;%%#v&#x27; %#v\\n&quot;</span>, profile)</span><br><span class=\"line\">   fmt.Printf(<span class=\"string\">&quot;使用&#x27;%%T&#x27; %T\\n&quot;</span>, profile)</span><br></pre></td></tr></table></figure></li>\n<li>结构体返回值 <figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newStruct</span><span class=\"params\">()</span></span> * MyStruct&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 此处替换为三种不同方式</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> fan MyStruct   <span class=\"comment\">// 为 fan 分配内存并且零化值</span></span><br><span class=\"line\">\tfan.age = <span class=\"number\">26</span></span><br><span class=\"line\">\tfan.name = <span class=\"string\">&quot;fan&quot;</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;函数内变量 fan 的地址为：%p\\n&quot;</span>, &amp;fan)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;fan</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    fan := newStruct()</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;函数外变量 fan 的地址为：%p\\n&quot;</span>, fan)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;fan使用&#x27;%%+v&#x27; %+v\\n&quot;</span>, fan)</span><br><span class=\"line\">\tfan.age = <span class=\"number\">18</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;fan使用&#x27;%%+v&#x27; %+v\\n&quot;</span>, fan)</span><br><span class=\"line\">\t<span class=\"comment\">// 方法一：地址相同，可更改 </span></span><br><span class=\"line\">\t<span class=\"comment\">// 方法二11：地址相同，可更改</span></span><br><span class=\"line\">\t<span class=\"comment\">// 方法二22：地址相同，可更改</span></span><br><span class=\"line\">\t<span class=\"comment\">// 方法三11：地址相同，可更改</span></span><br><span class=\"line\">\t<span class=\"comment\">// 方法三22：地址相同，可更改</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"键值对类型\"><a href=\"#键值对类型\" class=\"headerlink\" title=\"键值对类型\"></a>键值对类型</h3><p>map[string] *sync.WaitGroup  键值对类型</p>\n<ol>\n<li>键值对变量<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">        <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> MyStruct <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    a, b <span class=\"type\">uint64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// !! 定义与使用 </span></span><br><span class=\"line\">    <span class=\"comment\">//  初始 正常运行</span></span><br><span class=\"line\">    stru := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">uint64</span>]*MyStruct)</span><br><span class=\"line\">    stru[<span class=\"number\">2</span>] = &amp;MyStruct&#123;</span><br><span class=\"line\">        <span class=\"number\">1</span>,<span class=\"number\">1</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    stru[<span class=\"number\">2</span>].a = <span class=\"number\">1</span></span><br><span class=\"line\">    stru[<span class=\"number\">2</span>].b  = <span class=\"number\">1</span></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;值为：%+v&quot;</span>,stru[<span class=\"number\">2</span>])</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//  这样也可以</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> stru <span class=\"keyword\">map</span>[<span class=\"type\">uint64</span>]*MyStruct </span><br><span class=\"line\">    stru = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">uint64</span>]*MyStruct) <span class=\"comment\">// 没有这行运行不通</span></span><br><span class=\"line\">    stru[<span class=\"number\">2</span>] = &amp;MyStruct&#123;   <span class=\"comment\">// 去掉这行也不行</span></span><br><span class=\"line\">        <span class=\"number\">1</span>,<span class=\"number\">1</span>,</span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    stru[<span class=\"number\">2</span>].a = <span class=\"number\">1</span></span><br><span class=\"line\">    stru[<span class=\"number\">2</span>].b  = <span class=\"number\">1</span></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;值为：%+v&quot;</span>,stru[<span class=\"number\">2</span>])</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 结论： map 必须通过 make 且 键值对必须 初始化。才能修改</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 判断键值是否存在</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _, ok := stru[<span class=\"number\">2</span>]; !ok &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br></pre></td></tr></table></figure></li>\n<li>键值对作为结构体成员变量<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">        <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> MyStruct <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    a, b <span class=\"type\">uint64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"keyword\">type</span> MS <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    stu  <span class=\"keyword\">map</span>[<span class=\"type\">uint64</span>]*MyStruct</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> stru MS</span><br><span class=\"line\">    stru.stu = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">uint64</span>]*MyStruct) <span class=\"comment\">// 1 </span></span><br><span class=\"line\">       stru.stu[<span class=\"number\">2</span>]  = &amp; MyStruct&#123; <span class=\"comment\">// 2 , 1 2 这两步都是必须的，且可以多次执行不会冲突</span></span><br><span class=\"line\">           <span class=\"number\">1</span>,<span class=\"number\">1</span>,</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    stru.stu[<span class=\"number\">2</span>].a =<span class=\"number\">1</span></span><br><span class=\"line\">    stru.stu[<span class=\"number\">2</span>].b =<span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;值为：%+v&quot;</span>,stru.stu[<span class=\"number\">2</span>])</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><ol>\n<li>定义  <figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 构造特定大小的数组，初始会有 size 的大小，每一个元素会有一个初始值，默认0</span></span><br><span class=\"line\">ids := <span class=\"built_in\">make</span>([]<span class=\"type\">uint64</span>, size)</span><br><span class=\"line\"><span class=\"comment\">// 构造大小为 0 的数组</span></span><br><span class=\"line\"><span class=\"keyword\">var</span>   ids  []<span class=\"type\">uint64</span></span><br><span class=\"line\"><span class=\"comment\">//! 注意两种 定义方式 都可以用下面的方法增加元素 </span></span><br><span class=\"line\"><span class=\"comment\">// 增加元素</span></span><br><span class=\"line\">ids = <span class=\"built_in\">append</span>(ids,<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"二、输入、输出\"><a href=\"#二、输入、输出\" class=\"headerlink\" title=\"二、输入、输出\"></a>二、输入、输出</h2><ol>\n<li><p>fmt.Sprintf(格式化样式 ， 参数列表)</p>\n<ol>\n<li>和 C 语言类似 printf</li>\n</ol>\n</li>\n<li><p>fmt.Println(str)</p>\n</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">package main</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">import</span> <span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        <span class=\"string\">&quot;fmt&quot;</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">func <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        var progress = <span class=\"number\">2</span></span><br><span class=\"line\">        var target = <span class=\"number\">8</span></span><br><span class=\"line\">        <span class=\"comment\">// 两参数格式化</span></span><br><span class=\"line\">        title := fmt.<span class=\"built_in\">Sprintf</span>(<span class=\"string\">&quot;已采集%d个药草, 还需要%d个完成任务&quot;</span>, progress, target)</span><br><span class=\"line\">        fmt.<span class=\"built_in\">Println</span>(title)</span><br><span class=\"line\">        pi := <span class=\"number\">3.14159</span></span><br><span class=\"line\">        <span class=\"comment\">// 按数值本身的格式输出</span></span><br><span class=\"line\">        variant := fmt.<span class=\"built_in\">Sprintf</span>(<span class=\"string\">&quot;%v %v %v&quot;</span>, <span class=\"string\">&quot;月球基地&quot;</span>, pi, <span class=\"literal\">true</span>) <span class=\"comment\">//月球基地 3.14159 true</span></span><br><span class=\"line\">        fmt.<span class=\"built_in\">Println</span>(variant)</span><br><span class=\"line\">        <span class=\"comment\">// 匿名结构体声明, 并赋予初值</span></span><br><span class=\"line\">        profile := &amp;<span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">                Name string</span><br><span class=\"line\">                HP   <span class=\"type\">int</span></span><br><span class=\"line\">        &#125;&#123;</span><br><span class=\"line\">                Name: <span class=\"string\">&quot;rat&quot;</span>,</span><br><span class=\"line\">                HP:   <span class=\"number\">150</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 双百分号表示转义</span></span><br><span class=\"line\">        fmt.<span class=\"built_in\">Printf</span>(<span class=\"string\">&quot;使用&#x27;%%+v&#x27; %+v\\n&quot;</span>, profile)  <span class=\"comment\">// 使用&#x27;%+v&#x27; &amp;&#123;Name:rat HP:150&#125;</span></span><br><span class=\"line\">        fmt.<span class=\"built_in\">Printf</span>(<span class=\"string\">&quot;使用&#x27;%%#v&#x27; %#v\\n&quot;</span>, profile)  <span class=\"comment\">// 使用&#x27;%#v&#x27; &amp;struct &#123; Name string; HP int &#125;&#123;Name:&quot;rat&quot;, HP:150&#125;</span></span><br><span class=\"line\">        fmt.<span class=\"built_in\">Printf</span>(<span class=\"string\">&quot;使用&#x27;%%T&#x27; %T\\n&quot;</span>, profile)  <span class=\"comment\">// 使用&#x27;%T&#x27; *struct &#123; Name string; HP int &#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><p>动 词 功 能</p>\n<p>   %v 按值的本来值输出</p>\n<p>   %+v 在 %v 基础上，对结构体字段名和值进行展开</p>\n<p>   %#v 输出 Go 语言语法格式的值</p>\n<p>   %T 输出 Go 语言语法格式的类型和值</p>\n<p>   %% 输出 % 本体</p>\n<p>   %b 整型以二进制方式显示</p>\n<p>   %o 整型以八进制方式显示</p>\n<p>   %d 整型以十进制方式显示</p>\n<p>   %x 整型以十六进制方式显示</p>\n<p>   %X 整型以十六进制、字母大写方式显示</p>\n<p>   %U Unicode 字符</p>\n<p>   %f 浮点数</p>\n<p>   %p 指针，十六进制方式显示</p>\n</li>\n</ol>\n<h2 id=\"四、-库\"><a href=\"#四、-库\" class=\"headerlink\" title=\"四、 库\"></a>四、 库</h2><h4 id=\"flag\"><a href=\"#flag\" class=\"headerlink\" title=\"flag\"></a>flag</h4><p>功能：Go 语言标准库中的一个包，用于解析命令行参数</p>\n<p>关键函数：</p>\n<p>flag.type(arg_name,arg_default_value,arg_discription) -&gt; value</p>\n<p>flag.Parse() ：解析命令获得各个参数的值</p>\n<p>实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func <span class=\"function\"><span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">        // 定义命令行参数</span><br><span class=\"line\">        num1 := flag.Int(<span class=\"string\">&quot;num1&quot;</span>, 0, <span class=\"string\">&quot;第一个整数&quot;</span>)</span><br><span class=\"line\">        num2 := flag.Int(<span class=\"string\">&quot;num2&quot;</span>, 0, <span class=\"string\">&quot;第二个整数&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        // 解析命令行参数</span><br><span class=\"line\">        flag.Parse()</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 计算和</span><br><span class=\"line\">        <span class=\"built_in\">sum</span> := *num1 + *num2</span><br><span class=\"line\"></span><br><span class=\"line\">        // 输出结果</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;和:&quot;</span>, <span class=\"built_in\">sum</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、常见技巧\"><a href=\"#三、常见技巧\" class=\"headerlink\" title=\"三、常见技巧\"></a>三、常见技巧</h2><h3 id=\"常见调用\"><a href=\"#常见调用\" class=\"headerlink\" title=\"常见调用\"></a>常见调用</h3><ol>\n<li>获取变量类型<br> varb.(type)</li>\n<li>获取数组长度<br> len(arr)</li>\n</ol>\n<h3 id=\"键值对KV\"><a href=\"#键值对KV\" class=\"headerlink\" title=\"键值对KV\"></a>键值对KV</h3><p>go语言中可以使用<code>map[string]interface&#123;&#125;</code>类型来实现，键的索引和值的多种类型</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\">import (</span><br><span class=\"line\">        <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func <span class=\"function\"><span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">        // 定义</span><br><span class=\"line\">        data := map[string]interface&#123;&#125;&#123;</span><br><span class=\"line\">                <span class=\"string\">&quot;myname&quot;</span>: <span class=\"string\">&quot;电子科技大学@2023&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;tasks&quot;</span>:  []string&#123;<span class=\"string\">&quot;task 1&quot;</span>, <span class=\"string\">&quot;task 2&quot;</span>, <span class=\"string\">&quot;task 3&quot;</span>&#125;,</span><br><span class=\"line\">                <span class=\"string\">&quot;age&quot;</span>:    25,</span><br><span class=\"line\">                <span class=\"string\">&quot;isStudent&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 增加</span><br><span class=\"line\">        data[<span class=\"string\">&quot;newKey&quot;</span>] = <span class=\"string\">&quot;New Value&quot;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        // 删除</span><br><span class=\"line\">        delete(data, <span class=\"string\">&quot;age&quot;</span>) // 删除 data 中键为 “age” 的键值对</span><br><span class=\"line\">        // 查找</span><br><span class=\"line\">        key := <span class=\"string\">&quot;tasks&quot;</span></span><br><span class=\"line\">        value, found := data[key]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> found &#123;</span><br><span class=\"line\">                fmt.Printf(<span class=\"string\">&quot;Value of key &#x27;%s&#x27;: %v\\n&quot;</span>, key, value)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                fmt.Printf(<span class=\"string\">&quot;Key &#x27;%s&#x27; not found\\n&quot;</span>, key)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // json 解析为键值对 KV 形式</span><br><span class=\"line\">        str := `&#123;<span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;@2023&quot;</span>&#125;`</span><br><span class=\"line\">        var data map[string]interface&#123;&#125;</span><br><span class=\"line\">        errr := json.Unmarshal([]byte(str), &amp;data)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> errr != nil &#123;</span><br><span class=\"line\">            // 处理解析错误</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fmt.Println(data[<span class=\"string\">&quot;name&quot;</span>])</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 多个键值对支持</span><br><span class=\"line\">            // 局部</span><br><span class=\"line\">            data := make(map[string]interface&#123;&#125;)</span><br><span class=\"line\">            // 全局</span><br><span class=\"line\">            var data map[string]interface&#123;&#125; = make(map[string]interface&#123;&#125;)</span><br><span class=\"line\">            </span><br><span class=\"line\">        // 获取键值对的 K V</span><br><span class=\"line\">        <span class=\"keyword\">for</span> k, v := range data &#123;</span><br><span class=\"line\">             existingData[k] = v</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 将 KV对 处理为 json格式</span><br><span class=\"line\">        jsonData, err := json.Marshal(data)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != nil &#123;</span><br><span class=\"line\">                // 处理编码错误</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 将 K V 处理为 json格式</span><br><span class=\"line\">            // 方法 一：</span><br><span class=\"line\">            // fmt.Fprintf(w, <span class=\"string\">&quot;&#123;&#x27;%s&#x27;:&#x27;%v&#x27;&#125;&quot;</span>, param, value)</span><br><span class=\"line\">            </span><br><span class=\"line\">            // 方法 二：</span><br><span class=\"line\">            jsonData, err := json.Marshal(map[string]interface&#123;&#125;&#123;</span><br><span class=\"line\">                param: value,</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> err != nil &#123;</span><br><span class=\"line\">                // 处理编码错误</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">       </span><br><span class=\"line\">        </span><br><span class=\"line\">        //</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数据排序\"><a href=\"#数据排序\" class=\"headerlink\" title=\"数据排序\"></a>数据排序</h3><p>对数据集合（包括自定义数据类型的集合）排序需要实现 sort.Interface 接口的三个方法，以下为该接口的定义：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Interface <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取数据集合元素个数</span></span><br><span class=\"line\">        Len() <span class=\"type\">int</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果 i 索引的数据小于 j 索引的数据，返回 true 且不会调用下面的 Swap()，即数据升序排序。</span></span><br><span class=\"line\">        Less(i, j <span class=\"type\">int</span>) <span class=\"type\">bool</span></span><br><span class=\"line\">        <span class=\"comment\">// 交换 i 和 j 索引的两个元素的位置</span></span><br><span class=\"line\">        Swap(i, j <span class=\"type\">int</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>数据集合实现了这三个方法后，即可调用该包的 Sort() 方法进行排序。 Sort() 方法定义如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Sort</span><span class=\"params\">(data Interface)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>例子：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> messageSlice []pb.Message</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s messageSlice)</span></span> Len() <span class=\"type\">int</span>           &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(s) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s messageSlice)</span></span> Less(i, j <span class=\"type\">int</span>) <span class=\"type\">bool</span> &#123; <span class=\"keyword\">return</span> fmt.Sprint(s[i]) &lt; fmt.Sprint(s[j]) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s messageSlice)</span></span> Swap(i, j <span class=\"type\">int</span>)      &#123; s[i], s[j] = s[j], s[i] &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用</span></span><br><span class=\"line\">sort.Sort(messageSlice(msgs)) <span class=\"comment\">// msgs 为 []pb.Message 类型， 先强转再使用</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"数据比较\"><a href=\"#数据比较\" class=\"headerlink\" title=\"数据比较\"></a>数据比较</h3><p>reflect包中的DeepEqual函数完美的解决了比较问题。</p>\n<p>函数签名：</p>\n<p>func DeepEqual(a1, a2 interface{}) bool</p>\n<p>文档中对该函数的说明：<br>DeepEqual函数用来判断两个值是否深度一致：除了类型相同；在可以时（主要是基本类型）会使用&#x3D;&#x3D;；但还会比较array、slice的成员，map的键值对，结构体字段进行深入比对。map的键值对，对键只使用&#x3D;&#x3D;，但值会继续往深层比对。DeepEqual 函数可以正确处理循环的类型。函数类型只有都会nil时才相等；空切片不等于nil切片；还会考虑array、slice的长度、map键值对数。<br>示例：</p>\n<p>func main() {<br>    m1 :&#x3D; map[int]interface{}{1: []int{1, 2, 3}, 2: 3, 3: “a”}<br>    m2 :&#x3D; map[int]interface{}{1: []int{1, 2, 3}, 2: 3, 3: “a”}<br>    if reflect.DeepEqual(m1, m2) {<br>        fmt.Println(“相等”)<br>    }<br>}</p>\n<p>uestc.leemen.org</p>\n","excerpt":"","more":"<p>go个人笔记</p>\n<p><a href=\"https://blog.csdn.net/weiguang102/article/details/128501539\">https://blog.csdn.net/weiguang102/article/details/128501539</a></p>\n<p>go 基础</p>\n<p><a href=\"https://www.runoob.com/go/go-tutorial.html\">https://www.runoob.com/go/go-tutorial.html</a></p>\n<p>go 环境安装</p>\n<p><a href=\"https://blog.51cto.com/fish/5734211\">https://blog.51cto.com/fish/5734211</a></p>\n<h2 id=\"零、配置\"><a href=\"#零、配置\" class=\"headerlink\" title=\"零、配置\"></a>零、配置</h2><h3 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h3><p>1.临时添加环境变量 PATH</p>\n<p>export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;go&#x2F;bin</p>\n<p>2.所有用户永久添加环境变量</p>\n<p>vim &#x2F;etc&#x2F;profile</p>\n<p>末尾添加：export PATH:$PATH:&#x2F;usr&#x2F;local&#x2F;go&#x2F;bin</p>\n<p>刷新：sourse &#x2F;etc&#x2F;profile</p>\n<p>3.golang 工作目录</p>\n<p>GOPATH 是一个环境变量，用于指定Go项目的工作目录，默认情况下，GOPATH是 $HOME是当前用户的主目录。(&#x2F;root 或者 &#x2F;home&#x2F;user1)</p>\n<p>获取：</p>\n<p>go env GOPATH</p>\n<p>更改：</p>\n<p>编辑 .bashrc 或者 .zshrc</p>\n<p>找到 GOPATH 这行，将其修改为 &#x2F;path&#x2F;to&#x2F;your&#x2F;gopath</p>\n<p>4.go.sum 与 go.mod</p>\n<p><code>go.sum</code> 和 <code>go.mod</code> 是 Go 语言中用于管理模块依赖的文件。</p>\n<ul>\n<li><p><code>go.mod</code> 文件：<code>go.mod</code> 文件用于定义和管理项目的模块依赖关系。它位于项目的根目录下。当你使用 <code>go get</code> 命令来安装或更新依赖包时，<code>go.mod</code> 文件会被更新。它记录了项目所依赖的模块及其版本。你可以手动编辑 <code>go.mod</code> 文件来添加、移除或升级依赖包。在构建项目时，Go 会根据 <code>go.mod</code> 文件获取所需的依赖包。</p>\n</li>\n<li><p><code>go.sum</code> 文件：<code>go.sum</code> 文件用于记录项目所使用模块的校验和信息。每个模块都有一个唯一的校验和，用于确保下载的模块的完整性和安全性。<code>go.sum</code> 文件会自动生成并更新，其中包含了所有依赖模块的校验和。当你构建项目时，Go 会根据 <code>go.sum</code> 文件验证模块的完整性，以确保下载的模块与之前的校验和匹配。</p>\n</li>\n</ul>\n<p>使用 <code>go.mod</code> 和 <code>go.sum</code> 文件的基本操作如下：</p>\n<ol>\n<li><p>初始化模块：在项目的根目录下执行 <code>go mod init</code> 命令，它会根据项目的路径和名称创建一个新的 <code>go.mod</code> 文件。</p>\n</li>\n<li><p>添加依赖包：执行 <code>go get</code> 命令来添加所需的依赖包。例如，<code>go get</code> <code>github.com/example/package</code>。这会自动更新 <code>go.mod</code> 文件并下载依赖包。</p>\n</li>\n<li><p>移除依赖包：执行 <code>go mod tidy</code> 命令来移除不再使用的依赖包。它会自动更新 <code>go.mod</code> 文件并删除不需要的依赖。</p>\n</li>\n<li><p>升级依赖包：执行 <code>go get -u</code> 命令来升级依赖包到最新版本。这会自动更新 <code>go.mod</code> 文件。</p>\n</li>\n<li><p>构建项目：使用 <code>go build</code> 或 <code>go run</code> 命令来构建或运行项目。Go 会根据 <code>go.mod</code> 文件下载依赖包并构建项目。</p>\n</li>\n</ol>\n<p>需要注意的是，<code>go.mod</code> 和 <code>go.sum</code> 文件对于保证项目的可复现性和依赖包的一致性非常重要。当你与他人共享项目时，确保将 <code>go.mod</code> 和 <code>go.sum</code> 文件一同共享，以便其他人可以获取相同的依赖包版本。</p>\n<p>管理和安装 <code>go.mod</code> 和 <code>go.sum</code> 中列出的依赖项：</p>\n<ol>\n<li><strong>下载依赖项</strong></li>\n</ol>\n<p>当你首次克隆一个 Go 项目或者在已有项目中更新了依赖项时，可以使用以下命令来下载 <code>go.mod</code> 文件中指定的所有依赖项：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go mod download</span><br></pre></td></tr></table></figure>\n\n<p>这个命令会将依赖项下载到本地的 Go 模块缓存中，但不会在项目目录中创建任何文件。</p>\n<ol start=\"2\">\n<li><strong>同步依赖项</strong></li>\n</ol>\n<p>如果你想确保项目目录下的依赖项与 <code>go.mod</code> 文件中定义的依赖项完全同步（即添加缺失的模块，删除不需要的模块，并更新 <code>go.sum</code>），可以使用：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go mod tidy</span><br></pre></td></tr></table></figure>\n\n<p><code>go mod tidy</code> 命令会添加缺少的模块，移除未使用的模块，并生成一个新的 <code>go.sum</code> 文件。这是确保 <code>go.mod</code> 和 <code>go.sum</code> 文件准确反映项目依赖项的好方法。</p>\n<ol start=\"3\">\n<li><strong>查看依赖项</strong></li>\n</ol>\n<p>如果你想查看当前项目的依赖树，可以使用：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go mod graph</span><br></pre></td></tr></table></figure>\n\n<p>这个命令会打印项目的所有依赖项及其版本，帮助你理解项目依赖的结构。</p>\n<ol start=\"4\">\n<li><strong>更新依赖项</strong></li>\n</ol>\n<p>要更新项目中的某个依赖项到最新版本，可以使用：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go get -u package@version</span><br></pre></td></tr></table></figure>\n\n<p>其中 <code>package</code> 是依赖项的路径，<code>version</code> 是你想要更新到的版本。如果你想更新所有依赖项到最新版本，可以使用：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go get -u</span><br></pre></td></tr></table></figure>\n\n<p>但请注意，这可能会引入重大更改，因此建议仔细测试更新后的依赖项。</p>\n<p>修改 proto 文件并运行 <code>make proto</code> 来更新 <code>proto/pkg/xxx/xxx.pb.go</code> 中相关生成的 go 代码</p>\n<h2 id=\"一、变量\"><a href=\"#一、变量\" class=\"headerlink\" title=\"一、变量\"></a>一、变量</h2><h3 id=\"一般变量\"><a href=\"#一般变量\" class=\"headerlink\" title=\"一般变量\"></a>一般变量</h3><ol>\n<li><p>变量声明</p>\n<ol>\n<li>标准格式</li>\n</ol>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name type <span class=\"comment\">// 注意：声明变量时将变量的类型放在变量的名称之后</span></span><br><span class=\"line\">var a,b *<span class=\"type\">int</span> <span class=\"comment\">// 将 a b 同时声明为指针类型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化</span></span><br><span class=\"line\">var hp <span class=\"type\">int</span> = <span class=\"number\">100</span> <span class=\"comment\">// 指定类型</span></span><br><span class=\"line\">var hp = <span class=\"number\">100</span> <span class=\"comment\">// 省略类型，编译器会尝试为变量推到类型</span></span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>简短格式</li>\n</ol>\n</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 名字 := 表达式</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">1. 定义变量，同时显式初始化。</span></span><br><span class=\"line\"><span class=\"comment\">2. 不能提供数据类型</span></span><br><span class=\"line\"><span class=\"comment\">3. 只能用在函数内部。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 同时声明+初始化</span></span><br><span class=\"line\">i, j := <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">func <span class=\"built_in\">main</span>() &#123;</span><br><span class=\"line\">   x:=<span class=\"number\">100</span></span><br><span class=\"line\">   a,s:=<span class=\"number\">1</span>, <span class=\"string\">&quot;abc&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 注意  :=  左面必须是新变量</span></span><br><span class=\"line\">var hp <span class=\"type\">int</span> <span class=\"comment\">// 声明 hp 变量</span></span><br><span class=\"line\">hp := <span class=\"number\">10</span>  <span class=\"comment\">// 再次声明并赋值  报错！ 左面没有新变量出现</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 错误！！！！其实 只要有新变量就行！</span></span><br><span class=\"line\">var conn net.Conn</span><br><span class=\"line\">var err error</span><br><span class=\"line\">conn, err = net.<span class=\"built_in\">Dial</span>(<span class=\"string\">&quot;tcp&quot;</span>, <span class=\"string\">&quot;127.0.0.1:8080&quot;</span>)  <span class=\"comment\">// 不会报错</span></span><br></pre></td></tr></table></figure>\n\n<p>注意：变量的命名规则遵循骆驼命名法，即首个单词小写，每个新单词的首字母大写，例如：numShips 和 startDate 。</p>\n<ol start=\"2\">\n<li><p>变量类型</p>\n<ol>\n<li><p>bool</p>\n</li>\n<li><p>string</p>\n<ol>\n<li><p>反引号可以实现多行</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> str = `第一行</span><br><span class=\"line\">第二行</span><br><span class=\"line\">第三行</span><br><span class=\"line\">` </span><br><span class=\"line\">fmt.<span class=\"built_in\">Println</span>(str);  <span class=\"comment\">// 输出上面的内容</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注意 ！！！！！！</span></span><br><span class=\"line\"><span class=\"comment\">// 此时所有的 转义都会失效，即 `` 内部的全部都视为 字符串一部分</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>字符串长度</p>\n<ol>\n<li><p>len(), 判断的是 ASCII 长度 或者是 字节长度</p>\n<ol>\n<li><p>在 go 语言中， 所有字符串都是以 utf-8 的格式保存，因此 汉字 3 字节，字符 1 字节</p>\n</li>\n<li><p>若要将汉字作为一个整体统计， 可以使用下面的函数</p>\n</li>\n</ol>\n</li>\n<li><p>RuneCountInString() , 判断的是字符的个数，或者说是 Unicode 字符串长度</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">package main</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">import</span> <span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        <span class=\"string\">&quot;fmt&quot;</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        <span class=\"string\">&quot;strings&quot;</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 遍历字符串</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 按ASCII 字符</span></span></span><br><span class=\"line\"><span class=\"function\">theme :=</span> <span class=\"string\">&quot;狙击 start&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(theme); i++ &#123;<span class=\"comment\">//使用 for 的数值循环进行遍历--</span></span><br><span class=\"line\">    fmt.<span class=\"built_in\">Printf</span>(<span class=\"string\">&quot;ascii: %c  %d\\n&quot;</span>, theme[i], theme[i])</span><br><span class=\"line\">&#125;<span class=\"comment\">// 这里 汉字为乱码</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 按 Unicode  字符</span></span><br><span class=\"line\">theme := <span class=\"string\">&quot;狙击 start&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> _, s := range theme &#123;</span><br><span class=\"line\">    fmt.<span class=\"built_in\">Printf</span>(<span class=\"string\">&quot;Unicode: %c  %d\\n&quot;</span>, s, s)</span><br><span class=\"line\">&#125;<span class=\"comment\">// 这里汉字正常显示</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 字符串截取</span></span><br><span class=\"line\">newtr := theme[i:]  <span class=\"comment\">// 截取部分包括 i</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 字符串搜索</span></span><br><span class=\"line\">strings.<span class=\"built_in\">Index</span>(strings ,substring); <span class=\"comment\">// 返回 下标</span></span><br><span class=\"line\">strings.<span class=\"built_in\">LastIndex</span>(strings, substrings); <span class=\"comment\">// 反向搜索</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 字符串修改</span></span><br><span class=\"line\">        s1 := <span class=\"string\">&quot;abc&quot;</span></span><br><span class=\"line\"><span class=\"comment\">//     注意：字符串无法修改，只能在复制的基础上进行修改</span></span><br><span class=\"line\"><span class=\"comment\">//  方法一  转为 []byte()</span></span><br><span class=\"line\">        s2 := []<span class=\"built_in\">byte</span>(s1)</span><br><span class=\"line\">        s2[<span class=\"number\">1</span>] = <span class=\"string\">&#x27;B&#x27;</span></span><br><span class=\"line\">        fmt.<span class=\"built_in\">Println</span>(<span class=\"built_in\">string</span>(s2)) <span class=\"comment\">//aBc</span></span><br><span class=\"line\"><span class=\"comment\">// 方法二  转为 []runej() </span></span><br><span class=\"line\">        s3 := []<span class=\"built_in\">rune</span>(s1)</span><br><span class=\"line\">        s3[<span class=\"number\">1</span>] = <span class=\"string\">&#x27;B&#x27;</span></span><br><span class=\"line\">        fmt.<span class=\"built_in\">Println</span>(<span class=\"built_in\">string</span>(s3)) <span class=\"comment\">//aBc</span></span><br><span class=\"line\"> <span class=\"comment\">// 方法三 字符串替换</span></span><br><span class=\"line\">        new_str := <span class=\"string\">&quot;ABC&quot;</span></span><br><span class=\"line\">        old_str := <span class=\"string\">&quot;abc&quot;</span></span><br><span class=\"line\">        s4 := strings.<span class=\"built_in\">Replace</span>(s1, old_str , new_str , <span class=\"number\">2</span>)</span><br><span class=\"line\">        fmt.<span class=\"built_in\">Println</span>(s4) <span class=\"comment\">//ABC</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 字符串拼接</span></span><br><span class=\"line\">    str1 := <span class=\"string\">&quot;hello&quot;</span></span><br><span class=\"line\">    str2 := <span class=\"string\">&quot;world&quot;</span></span><br><span class=\"line\"> <span class=\"comment\">// 方法一 使用 + 直接拼接</span></span><br><span class=\"line\">     str3 := str1 + str2</span><br><span class=\"line\"> <span class=\"comment\">// 方法二 使用 bytes.Buffer</span></span><br><span class=\"line\">     var stringBuilder bytes.Buffer</span><br><span class=\"line\">     stringBuilder.<span class=\"built_in\">WriteString</span>(str1)</span><br><span class=\"line\">     stringBuilder.<span class=\"built_in\">WriteString</span>(str2)</span><br><span class=\"line\">     str4 := stringBuilder.<span class=\"built_in\">String</span>()</span><br><span class=\"line\">     </span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>int、int8、int16、int32、int64</p>\n</li>\n<li><p>uint、uint8、uint16、uint32、uint64、uintptr</p>\n</li>\n<li><p>byte &#x2F;&#x2F; uint8 的别名</p>\n</li>\n<li><p>rune &#x2F;&#x2F; int32 的别名 代表一个 Unicode 码 不对 是 UTF-8</p>\n</li>\n<li><p>float32、float64</p>\n</li>\n<li><p>complex64、complex128 内建函数</p>\n</li>\n<li><p>interface 接口类型<br> <a href=\"https://learnku.com/go/t/38843\">https://learnku.com/go/t/38843</a></p>\n <figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Animal <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Speak() <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>map[string] *sync.WaitGroup  键值对类型</p>\n</li>\n</ol>\n</li>\n<li><p>变量赋值</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b, a = a, b  <span class=\"comment\">// 这里 可以实现交换操作</span></span><br><span class=\"line\">a, _ := a, _ := <span class=\"built_in\">GetData</span>()  <span class=\"comment\">// 这里 匿名变量</span></span><br></pre></td></tr></table></figure>\n<p>   注意：<strong>当一个变量被声明之后，系统自动赋予它该类型的零值：</strong><strong><code>int 为 0，float 为 0.0，bool 为 false，string 为空字符串，指针为 nil 等</code></strong></p>\n<p>   所有的内存在 Go 中都是经过初始化的。</p>\n</li>\n<li><p>匿名变量不占用内存空间，不分配内存</p>\n</li>\n<li><p>作用域</p>\n<ol>\n<li>全局变量声明必须以 <code>var</code> 关键字开头，如果想要在外部包中使用全局变量的首字母必须大写。</li>\n<li>特殊变量定义位置 <figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> firstIdx, err := Func(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t        log.Fatal(err)</span><br><span class=\"line\">\t        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t    <span class=\"comment\">// 这里的 firstIdx 只能在 if 里面的大括号用，一旦出去就使用不了</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n<li><p>比较</p>\n<p>   只有同类型的变量才能进行比较</p>\n<p>   包括 0 1 到 true false 的转换</p>\n</li>\n<li><p>类型转换</p>\n<ol>\n<li><p>bool 不能强转为 int</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var n <span class=\"type\">bool</span></span><br><span class=\"line\">n := (<span class=\"type\">int</span>)n</span><br><span class=\"line\"><span class=\"comment\">//会报错</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>不能获取数组某个位置的的地址</p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"结构体变量\"><a href=\"#结构体变量\" class=\"headerlink\" title=\"结构体变量\"></a>结构体变量</h3><ol>\n<li>结构体声明 <figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 结构体成员变量</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> MyStruct <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">\tage <span class=\"type\">int</span>     <span class=\"comment\">// 注意没有 逗号</span></span><br><span class=\"line\">\tname <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 结构体函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(ms *MyStruct)</span></span> grow(<span class=\"type\">int</span> a) <span class=\"type\">bool</span>&#123;</span><br><span class=\"line\">\tms.age += a</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 结构体的指针继承</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> MyStruct2 <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">\t*MyStruct  <span class=\"comment\">// 通过指针的方式，父亲结构体作为一个无名成员变量，</span></span><br><span class=\"line\">\t\t\t   <span class=\"comment\">// 赋值时使用 父亲对象 赋值； </span></span><br><span class=\"line\">\t\t\t   <span class=\"comment\">// 使用时使用 孩子对象 直接使用（不需要先点出来父亲）</span></span><br><span class=\"line\">\tage <span class=\"type\">int</span>     <span class=\"comment\">// 注意没有 逗号</span></span><br><span class=\"line\">\tname <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>结构体实例化 <figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法一：var 声明</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fan MyStruct   <span class=\"comment\">// 为 fan 分配内存并且零化值</span></span><br><span class=\"line\">fan.age = <span class=\"number\">26</span></span><br><span class=\"line\">fan.name = <span class=\"string\">&quot;fan&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法二：new 关键字</span></span><br><span class=\"line\"><span class=\"comment\">// 11</span></span><br><span class=\"line\">fan := &amp;MyStruct&#123;   <span class=\"comment\">// 返回一个结构体指针，带有初始值</span></span><br><span class=\"line\">\t<span class=\"number\">26</span>,</span><br><span class=\"line\">\t<span class=\"string\">&quot;fan&quot;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 22 </span></span><br><span class=\"line\">fan := <span class=\"built_in\">new</span>(MyStruct) <span class=\"comment\">// 返回一个结构体指针，零值</span></span><br><span class=\"line\">fan.name = <span class=\"string\">&quot;fan&quot;</span></span><br><span class=\"line\">fan.age = <span class=\"number\">26</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法三：赋值初始化</span></span><br><span class=\"line\"><span class=\"comment\">// 11</span></span><br><span class=\"line\">fan := MyStruct&#123;</span><br><span class=\"line\">\tname: <span class=\"string\">&quot;fan&quot;</span>,</span><br><span class=\"line\">\tage: <span class=\"number\">26</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 22：必须要对应结构体定义顺序，并且每一个都必须进行初始化。</span></span><br><span class=\"line\">fan := MyStruct&#123;</span><br><span class=\"line\">\t<span class=\"number\">26</span>,</span><br><span class=\"line\">\t<span class=\"string\">&quot;fan&quot;</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>匿名结构体 <figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">profile := &amp;<span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">           name <span class=\"type\">string</span></span><br><span class=\"line\">           age   <span class=\"type\">int</span></span><br><span class=\"line\">   &#125;&#123;</span><br><span class=\"line\">           name: <span class=\"string\">&quot;rat&quot;</span>,</span><br><span class=\"line\">           age:   <span class=\"number\">150</span>,</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 打印值</span></span><br><span class=\"line\">   fmt.Printf(<span class=\"string\">&quot;使用&#x27;%%+v&#x27; %+v\\n&quot;</span>, profile)</span><br><span class=\"line\">   fmt.Printf(<span class=\"string\">&quot;使用&#x27;%%#v&#x27; %#v\\n&quot;</span>, profile)</span><br><span class=\"line\">   fmt.Printf(<span class=\"string\">&quot;使用&#x27;%%T&#x27; %T\\n&quot;</span>, profile)</span><br></pre></td></tr></table></figure></li>\n<li>结构体返回值 <figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newStruct</span><span class=\"params\">()</span></span> * MyStruct&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 此处替换为三种不同方式</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> fan MyStruct   <span class=\"comment\">// 为 fan 分配内存并且零化值</span></span><br><span class=\"line\">\tfan.age = <span class=\"number\">26</span></span><br><span class=\"line\">\tfan.name = <span class=\"string\">&quot;fan&quot;</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;函数内变量 fan 的地址为：%p\\n&quot;</span>, &amp;fan)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;fan</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    fan := newStruct()</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;函数外变量 fan 的地址为：%p\\n&quot;</span>, fan)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;fan使用&#x27;%%+v&#x27; %+v\\n&quot;</span>, fan)</span><br><span class=\"line\">\tfan.age = <span class=\"number\">18</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;fan使用&#x27;%%+v&#x27; %+v\\n&quot;</span>, fan)</span><br><span class=\"line\">\t<span class=\"comment\">// 方法一：地址相同，可更改 </span></span><br><span class=\"line\">\t<span class=\"comment\">// 方法二11：地址相同，可更改</span></span><br><span class=\"line\">\t<span class=\"comment\">// 方法二22：地址相同，可更改</span></span><br><span class=\"line\">\t<span class=\"comment\">// 方法三11：地址相同，可更改</span></span><br><span class=\"line\">\t<span class=\"comment\">// 方法三22：地址相同，可更改</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"键值对类型\"><a href=\"#键值对类型\" class=\"headerlink\" title=\"键值对类型\"></a>键值对类型</h3><p>map[string] *sync.WaitGroup  键值对类型</p>\n<ol>\n<li>键值对变量<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">        <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> MyStruct <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    a, b <span class=\"type\">uint64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// !! 定义与使用 </span></span><br><span class=\"line\">    <span class=\"comment\">//  初始 正常运行</span></span><br><span class=\"line\">    stru := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">uint64</span>]*MyStruct)</span><br><span class=\"line\">    stru[<span class=\"number\">2</span>] = &amp;MyStruct&#123;</span><br><span class=\"line\">        <span class=\"number\">1</span>,<span class=\"number\">1</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    stru[<span class=\"number\">2</span>].a = <span class=\"number\">1</span></span><br><span class=\"line\">    stru[<span class=\"number\">2</span>].b  = <span class=\"number\">1</span></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;值为：%+v&quot;</span>,stru[<span class=\"number\">2</span>])</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//  这样也可以</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> stru <span class=\"keyword\">map</span>[<span class=\"type\">uint64</span>]*MyStruct </span><br><span class=\"line\">    stru = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">uint64</span>]*MyStruct) <span class=\"comment\">// 没有这行运行不通</span></span><br><span class=\"line\">    stru[<span class=\"number\">2</span>] = &amp;MyStruct&#123;   <span class=\"comment\">// 去掉这行也不行</span></span><br><span class=\"line\">        <span class=\"number\">1</span>,<span class=\"number\">1</span>,</span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    stru[<span class=\"number\">2</span>].a = <span class=\"number\">1</span></span><br><span class=\"line\">    stru[<span class=\"number\">2</span>].b  = <span class=\"number\">1</span></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;值为：%+v&quot;</span>,stru[<span class=\"number\">2</span>])</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 结论： map 必须通过 make 且 键值对必须 初始化。才能修改</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 判断键值是否存在</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _, ok := stru[<span class=\"number\">2</span>]; !ok &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br></pre></td></tr></table></figure></li>\n<li>键值对作为结构体成员变量<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">        <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> MyStruct <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    a, b <span class=\"type\">uint64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"keyword\">type</span> MS <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    stu  <span class=\"keyword\">map</span>[<span class=\"type\">uint64</span>]*MyStruct</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> stru MS</span><br><span class=\"line\">    stru.stu = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">uint64</span>]*MyStruct) <span class=\"comment\">// 1 </span></span><br><span class=\"line\">       stru.stu[<span class=\"number\">2</span>]  = &amp; MyStruct&#123; <span class=\"comment\">// 2 , 1 2 这两步都是必须的，且可以多次执行不会冲突</span></span><br><span class=\"line\">           <span class=\"number\">1</span>,<span class=\"number\">1</span>,</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    stru.stu[<span class=\"number\">2</span>].a =<span class=\"number\">1</span></span><br><span class=\"line\">    stru.stu[<span class=\"number\">2</span>].b =<span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;值为：%+v&quot;</span>,stru.stu[<span class=\"number\">2</span>])</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><ol>\n<li>定义  <figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 构造特定大小的数组，初始会有 size 的大小，每一个元素会有一个初始值，默认0</span></span><br><span class=\"line\">ids := <span class=\"built_in\">make</span>([]<span class=\"type\">uint64</span>, size)</span><br><span class=\"line\"><span class=\"comment\">// 构造大小为 0 的数组</span></span><br><span class=\"line\"><span class=\"keyword\">var</span>   ids  []<span class=\"type\">uint64</span></span><br><span class=\"line\"><span class=\"comment\">//! 注意两种 定义方式 都可以用下面的方法增加元素 </span></span><br><span class=\"line\"><span class=\"comment\">// 增加元素</span></span><br><span class=\"line\">ids = <span class=\"built_in\">append</span>(ids,<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"二、输入、输出\"><a href=\"#二、输入、输出\" class=\"headerlink\" title=\"二、输入、输出\"></a>二、输入、输出</h2><ol>\n<li><p>fmt.Sprintf(格式化样式 ， 参数列表)</p>\n<ol>\n<li>和 C 语言类似 printf</li>\n</ol>\n</li>\n<li><p>fmt.Println(str)</p>\n</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">package main</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">import</span> <span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        <span class=\"string\">&quot;fmt&quot;</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">func <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        var progress = <span class=\"number\">2</span></span><br><span class=\"line\">        var target = <span class=\"number\">8</span></span><br><span class=\"line\">        <span class=\"comment\">// 两参数格式化</span></span><br><span class=\"line\">        title := fmt.<span class=\"built_in\">Sprintf</span>(<span class=\"string\">&quot;已采集%d个药草, 还需要%d个完成任务&quot;</span>, progress, target)</span><br><span class=\"line\">        fmt.<span class=\"built_in\">Println</span>(title)</span><br><span class=\"line\">        pi := <span class=\"number\">3.14159</span></span><br><span class=\"line\">        <span class=\"comment\">// 按数值本身的格式输出</span></span><br><span class=\"line\">        variant := fmt.<span class=\"built_in\">Sprintf</span>(<span class=\"string\">&quot;%v %v %v&quot;</span>, <span class=\"string\">&quot;月球基地&quot;</span>, pi, <span class=\"literal\">true</span>) <span class=\"comment\">//月球基地 3.14159 true</span></span><br><span class=\"line\">        fmt.<span class=\"built_in\">Println</span>(variant)</span><br><span class=\"line\">        <span class=\"comment\">// 匿名结构体声明, 并赋予初值</span></span><br><span class=\"line\">        profile := &amp;<span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">                Name string</span><br><span class=\"line\">                HP   <span class=\"type\">int</span></span><br><span class=\"line\">        &#125;&#123;</span><br><span class=\"line\">                Name: <span class=\"string\">&quot;rat&quot;</span>,</span><br><span class=\"line\">                HP:   <span class=\"number\">150</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 双百分号表示转义</span></span><br><span class=\"line\">        fmt.<span class=\"built_in\">Printf</span>(<span class=\"string\">&quot;使用&#x27;%%+v&#x27; %+v\\n&quot;</span>, profile)  <span class=\"comment\">// 使用&#x27;%+v&#x27; &amp;&#123;Name:rat HP:150&#125;</span></span><br><span class=\"line\">        fmt.<span class=\"built_in\">Printf</span>(<span class=\"string\">&quot;使用&#x27;%%#v&#x27; %#v\\n&quot;</span>, profile)  <span class=\"comment\">// 使用&#x27;%#v&#x27; &amp;struct &#123; Name string; HP int &#125;&#123;Name:&quot;rat&quot;, HP:150&#125;</span></span><br><span class=\"line\">        fmt.<span class=\"built_in\">Printf</span>(<span class=\"string\">&quot;使用&#x27;%%T&#x27; %T\\n&quot;</span>, profile)  <span class=\"comment\">// 使用&#x27;%T&#x27; *struct &#123; Name string; HP int &#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><p>动 词 功 能</p>\n<p>   %v 按值的本来值输出</p>\n<p>   %+v 在 %v 基础上，对结构体字段名和值进行展开</p>\n<p>   %#v 输出 Go 语言语法格式的值</p>\n<p>   %T 输出 Go 语言语法格式的类型和值</p>\n<p>   %% 输出 % 本体</p>\n<p>   %b 整型以二进制方式显示</p>\n<p>   %o 整型以八进制方式显示</p>\n<p>   %d 整型以十进制方式显示</p>\n<p>   %x 整型以十六进制方式显示</p>\n<p>   %X 整型以十六进制、字母大写方式显示</p>\n<p>   %U Unicode 字符</p>\n<p>   %f 浮点数</p>\n<p>   %p 指针，十六进制方式显示</p>\n</li>\n</ol>\n<h2 id=\"四、-库\"><a href=\"#四、-库\" class=\"headerlink\" title=\"四、 库\"></a>四、 库</h2><h4 id=\"flag\"><a href=\"#flag\" class=\"headerlink\" title=\"flag\"></a>flag</h4><p>功能：Go 语言标准库中的一个包，用于解析命令行参数</p>\n<p>关键函数：</p>\n<p>flag.type(arg_name,arg_default_value,arg_discription) -&gt; value</p>\n<p>flag.Parse() ：解析命令获得各个参数的值</p>\n<p>实例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func <span class=\"function\"><span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">        // 定义命令行参数</span><br><span class=\"line\">        num1 := flag.Int(<span class=\"string\">&quot;num1&quot;</span>, 0, <span class=\"string\">&quot;第一个整数&quot;</span>)</span><br><span class=\"line\">        num2 := flag.Int(<span class=\"string\">&quot;num2&quot;</span>, 0, <span class=\"string\">&quot;第二个整数&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        // 解析命令行参数</span><br><span class=\"line\">        flag.Parse()</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 计算和</span><br><span class=\"line\">        <span class=\"built_in\">sum</span> := *num1 + *num2</span><br><span class=\"line\"></span><br><span class=\"line\">        // 输出结果</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;和:&quot;</span>, <span class=\"built_in\">sum</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、常见技巧\"><a href=\"#三、常见技巧\" class=\"headerlink\" title=\"三、常见技巧\"></a>三、常见技巧</h2><h3 id=\"常见调用\"><a href=\"#常见调用\" class=\"headerlink\" title=\"常见调用\"></a>常见调用</h3><ol>\n<li>获取变量类型<br> varb.(type)</li>\n<li>获取数组长度<br> len(arr)</li>\n</ol>\n<h3 id=\"键值对KV\"><a href=\"#键值对KV\" class=\"headerlink\" title=\"键值对KV\"></a>键值对KV</h3><p>go语言中可以使用<code>map[string]interface&#123;&#125;</code>类型来实现，键的索引和值的多种类型</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\">import (</span><br><span class=\"line\">        <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func <span class=\"function\"><span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">        // 定义</span><br><span class=\"line\">        data := map[string]interface&#123;&#125;&#123;</span><br><span class=\"line\">                <span class=\"string\">&quot;myname&quot;</span>: <span class=\"string\">&quot;电子科技大学@2023&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;tasks&quot;</span>:  []string&#123;<span class=\"string\">&quot;task 1&quot;</span>, <span class=\"string\">&quot;task 2&quot;</span>, <span class=\"string\">&quot;task 3&quot;</span>&#125;,</span><br><span class=\"line\">                <span class=\"string\">&quot;age&quot;</span>:    25,</span><br><span class=\"line\">                <span class=\"string\">&quot;isStudent&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 增加</span><br><span class=\"line\">        data[<span class=\"string\">&quot;newKey&quot;</span>] = <span class=\"string\">&quot;New Value&quot;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        // 删除</span><br><span class=\"line\">        delete(data, <span class=\"string\">&quot;age&quot;</span>) // 删除 data 中键为 “age” 的键值对</span><br><span class=\"line\">        // 查找</span><br><span class=\"line\">        key := <span class=\"string\">&quot;tasks&quot;</span></span><br><span class=\"line\">        value, found := data[key]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> found &#123;</span><br><span class=\"line\">                fmt.Printf(<span class=\"string\">&quot;Value of key &#x27;%s&#x27;: %v\\n&quot;</span>, key, value)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                fmt.Printf(<span class=\"string\">&quot;Key &#x27;%s&#x27; not found\\n&quot;</span>, key)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // json 解析为键值对 KV 形式</span><br><span class=\"line\">        str := `&#123;<span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;@2023&quot;</span>&#125;`</span><br><span class=\"line\">        var data map[string]interface&#123;&#125;</span><br><span class=\"line\">        errr := json.Unmarshal([]byte(str), &amp;data)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> errr != nil &#123;</span><br><span class=\"line\">            // 处理解析错误</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fmt.Println(data[<span class=\"string\">&quot;name&quot;</span>])</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 多个键值对支持</span><br><span class=\"line\">            // 局部</span><br><span class=\"line\">            data := make(map[string]interface&#123;&#125;)</span><br><span class=\"line\">            // 全局</span><br><span class=\"line\">            var data map[string]interface&#123;&#125; = make(map[string]interface&#123;&#125;)</span><br><span class=\"line\">            </span><br><span class=\"line\">        // 获取键值对的 K V</span><br><span class=\"line\">        <span class=\"keyword\">for</span> k, v := range data &#123;</span><br><span class=\"line\">             existingData[k] = v</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 将 KV对 处理为 json格式</span><br><span class=\"line\">        jsonData, err := json.Marshal(data)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != nil &#123;</span><br><span class=\"line\">                // 处理编码错误</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 将 K V 处理为 json格式</span><br><span class=\"line\">            // 方法 一：</span><br><span class=\"line\">            // fmt.Fprintf(w, <span class=\"string\">&quot;&#123;&#x27;%s&#x27;:&#x27;%v&#x27;&#125;&quot;</span>, param, value)</span><br><span class=\"line\">            </span><br><span class=\"line\">            // 方法 二：</span><br><span class=\"line\">            jsonData, err := json.Marshal(map[string]interface&#123;&#125;&#123;</span><br><span class=\"line\">                param: value,</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> err != nil &#123;</span><br><span class=\"line\">                // 处理编码错误</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">       </span><br><span class=\"line\">        </span><br><span class=\"line\">        //</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数据排序\"><a href=\"#数据排序\" class=\"headerlink\" title=\"数据排序\"></a>数据排序</h3><p>对数据集合（包括自定义数据类型的集合）排序需要实现 sort.Interface 接口的三个方法，以下为该接口的定义：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Interface <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取数据集合元素个数</span></span><br><span class=\"line\">        Len() <span class=\"type\">int</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果 i 索引的数据小于 j 索引的数据，返回 true 且不会调用下面的 Swap()，即数据升序排序。</span></span><br><span class=\"line\">        Less(i, j <span class=\"type\">int</span>) <span class=\"type\">bool</span></span><br><span class=\"line\">        <span class=\"comment\">// 交换 i 和 j 索引的两个元素的位置</span></span><br><span class=\"line\">        Swap(i, j <span class=\"type\">int</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>数据集合实现了这三个方法后，即可调用该包的 Sort() 方法进行排序。 Sort() 方法定义如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Sort</span><span class=\"params\">(data Interface)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>例子：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> messageSlice []pb.Message</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s messageSlice)</span></span> Len() <span class=\"type\">int</span>           &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(s) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s messageSlice)</span></span> Less(i, j <span class=\"type\">int</span>) <span class=\"type\">bool</span> &#123; <span class=\"keyword\">return</span> fmt.Sprint(s[i]) &lt; fmt.Sprint(s[j]) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s messageSlice)</span></span> Swap(i, j <span class=\"type\">int</span>)      &#123; s[i], s[j] = s[j], s[i] &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用</span></span><br><span class=\"line\">sort.Sort(messageSlice(msgs)) <span class=\"comment\">// msgs 为 []pb.Message 类型， 先强转再使用</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"数据比较\"><a href=\"#数据比较\" class=\"headerlink\" title=\"数据比较\"></a>数据比较</h3><p>reflect包中的DeepEqual函数完美的解决了比较问题。</p>\n<p>函数签名：</p>\n<p>func DeepEqual(a1, a2 interface{}) bool</p>\n<p>文档中对该函数的说明：<br>DeepEqual函数用来判断两个值是否深度一致：除了类型相同；在可以时（主要是基本类型）会使用&#x3D;&#x3D;；但还会比较array、slice的成员，map的键值对，结构体字段进行深入比对。map的键值对，对键只使用&#x3D;&#x3D;，但值会继续往深层比对。DeepEqual 函数可以正确处理循环的类型。函数类型只有都会nil时才相等；空切片不等于nil切片；还会考虑array、slice的长度、map键值对数。<br>示例：</p>\n<p>func main() {<br>    m1 :&#x3D; map[int]interface{}{1: []int{1, 2, 3}, 2: 3, 3: “a”}<br>    m2 :&#x3D; map[int]interface{}{1: []int{1, 2, 3}, 2: 3, 3: “a”}<br>    if reflect.DeepEqual(m1, m2) {<br>        fmt.Println(“相等”)<br>    }<br>}</p>\n<p>uestc.leemen.org</p>\n"},{"_content":"# 参考\nhttps://zhuanlan.zhihu.com/p/532402983\n\n\n# 概念\n指一类机器学习模型，其目标是学习数据的概率分布，并通过该概率分布生成新的样本数据。生成模型可以根据已知数据的统计特征，学习数据的分布模式，然后使用这个模式生成新的数据样本。生成模型被广泛应用于数据生成、图像合成、文本生成等领域。\n\n# 分类\n## 按照概率密度函数的处理方式分类\n![[Pasted image 20240412152711.png]]\n## 按照是否有监督\n1. 有监督的生成模型。\n2. 无监督的生成模型。\n\t1. [[扩散模型]]\n\n# 基本任务\n1. 生成样本，例如生成逼真的人脸图片、生成高质量的语音等；\n2. 也可以通过改进生成模型从而实现样本之间的映射转换，例如图像风格迁移、语音增强等。\n\n## 原理：生成样本\n### 整体流程\n生成模型接受随机噪声 z 作为输入，然后产生输出样本 x\n### 训练和推理过程\n**分析**\n1. 由 N 个样本构成的集合，假设它们是彼此独立都采样来源于某个未知的概率分布 q(X)；\n2. 问题：如何在不知道 q(X) 的情况下产生一个模型使得，生成的样本在分布中。\n3. 解决：构建生成模型 p(X,θ)，通过 N 个样本来学习到最好的参数 θ，使得 p(X,θ)=q(X)\n**两个问题**\n1. 如何设计模型\n\t不同的模型有各自的考虑，比如 玻尔兹曼机 使用基于能量的模型，完全可见置信网络对模型进行的链式解析等等。\n2. 如何训练\n\t显式生成模型使用的训练准则为极大似然估计。这里有分两种情况：\n\t1. 对似然函数本身直接进行优化的精确推断方法。（例如流模型，自回归模型）\n\t2. 对似然函数近似值进行优化的近似推断方法。（例如VAE和玻尔兹曼机）\n\t隐式生成模型首先使用两类样本学习到了 p(X,θ) 和 q(X)  的距离，然后再以减少距离为目标训练生成模型。\n\n### 潜变量生成模型 \n潜变量生成模型（Latent Variable Generative Model）是一种统计模型，用于描述数据的生成过程。它假设存在一组潜在的变量（也称为隐藏变量或潜变量），这些变量无法直接观测到，但对生成数据起到重要作用。\n\n潜变量生成模型的基本思想是，通过学习数据中隐藏的潜在结构和变量，可以生成与观测数据相似的新样本。这种生成过程通常基于概率分布模型，如高斯混合模型（Gaussian Mixture Model，GMM）、隐马尔可夫模型（Hidden Markov Model，HMM）、变分自编码器（Variational Autoencoder，VAE）等。\n\n在潜变量生成模型中，潜变量表示了数据中的潜在特征或隐含结构，它们对生成数据的分布产生影响。通过对潜变量和观测变量之间的关系进行建模，生成模型可以通过给定潜变量的取值来生成对应的观测数据。\n\n潜变量生成模型的应用广泛，包括图像生成、文本生成、语音生成等。通过学习和探索数据中的潜在结构，潜变量生成模型可以生成具有多样性和创造性的新样本，进而用于数据增强、生成对抗网络（GAN）的训练、数据压缩和降维等任务。\n\n总而言之，潜变量生成模型是一种通过建模潜在变量与观测数据之间的关系来生成数据的统计模型。它利用隐藏的潜在结构和变量来模拟数据的生成过程，并可用于生成新样本和数据分析中的其他任务。","source":"_posts/人工智能/常见模型/生成模型.md","raw":"# 参考\nhttps://zhuanlan.zhihu.com/p/532402983\n\n\n# 概念\n指一类机器学习模型，其目标是学习数据的概率分布，并通过该概率分布生成新的样本数据。生成模型可以根据已知数据的统计特征，学习数据的分布模式，然后使用这个模式生成新的数据样本。生成模型被广泛应用于数据生成、图像合成、文本生成等领域。\n\n# 分类\n## 按照概率密度函数的处理方式分类\n![[Pasted image 20240412152711.png]]\n## 按照是否有监督\n1. 有监督的生成模型。\n2. 无监督的生成模型。\n\t1. [[扩散模型]]\n\n# 基本任务\n1. 生成样本，例如生成逼真的人脸图片、生成高质量的语音等；\n2. 也可以通过改进生成模型从而实现样本之间的映射转换，例如图像风格迁移、语音增强等。\n\n## 原理：生成样本\n### 整体流程\n生成模型接受随机噪声 z 作为输入，然后产生输出样本 x\n### 训练和推理过程\n**分析**\n1. 由 N 个样本构成的集合，假设它们是彼此独立都采样来源于某个未知的概率分布 q(X)；\n2. 问题：如何在不知道 q(X) 的情况下产生一个模型使得，生成的样本在分布中。\n3. 解决：构建生成模型 p(X,θ)，通过 N 个样本来学习到最好的参数 θ，使得 p(X,θ)=q(X)\n**两个问题**\n1. 如何设计模型\n\t不同的模型有各自的考虑，比如 玻尔兹曼机 使用基于能量的模型，完全可见置信网络对模型进行的链式解析等等。\n2. 如何训练\n\t显式生成模型使用的训练准则为极大似然估计。这里有分两种情况：\n\t1. 对似然函数本身直接进行优化的精确推断方法。（例如流模型，自回归模型）\n\t2. 对似然函数近似值进行优化的近似推断方法。（例如VAE和玻尔兹曼机）\n\t隐式生成模型首先使用两类样本学习到了 p(X,θ) 和 q(X)  的距离，然后再以减少距离为目标训练生成模型。\n\n### 潜变量生成模型 \n潜变量生成模型（Latent Variable Generative Model）是一种统计模型，用于描述数据的生成过程。它假设存在一组潜在的变量（也称为隐藏变量或潜变量），这些变量无法直接观测到，但对生成数据起到重要作用。\n\n潜变量生成模型的基本思想是，通过学习数据中隐藏的潜在结构和变量，可以生成与观测数据相似的新样本。这种生成过程通常基于概率分布模型，如高斯混合模型（Gaussian Mixture Model，GMM）、隐马尔可夫模型（Hidden Markov Model，HMM）、变分自编码器（Variational Autoencoder，VAE）等。\n\n在潜变量生成模型中，潜变量表示了数据中的潜在特征或隐含结构，它们对生成数据的分布产生影响。通过对潜变量和观测变量之间的关系进行建模，生成模型可以通过给定潜变量的取值来生成对应的观测数据。\n\n潜变量生成模型的应用广泛，包括图像生成、文本生成、语音生成等。通过学习和探索数据中的潜在结构，潜变量生成模型可以生成具有多样性和创造性的新样本，进而用于数据增强、生成对抗网络（GAN）的训练、数据压缩和降维等任务。\n\n总而言之，潜变量生成模型是一种通过建模潜在变量与观测数据之间的关系来生成数据的统计模型。它利用隐藏的潜在结构和变量来模拟数据的生成过程，并可用于生成新样本和数据分析中的其他任务。","slug":"人工智能/常见模型/生成模型","published":1,"date":"2024-04-22T13:14:49.007Z","updated":"2024-04-12T09:20:11.234Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0p002fkgg4ekuqap1l","content":"<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://zhuanlan.zhihu.com/p/532402983\">https://zhuanlan.zhihu.com/p/532402983</a></p>\n<h1 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h1><p>指一类机器学习模型，其目标是学习数据的概率分布，并通过该概率分布生成新的样本数据。生成模型可以根据已知数据的统计特征，学习数据的分布模式，然后使用这个模式生成新的数据样本。生成模型被广泛应用于数据生成、图像合成、文本生成等领域。</p>\n<h1 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h1><h2 id=\"按照概率密度函数的处理方式分类\"><a href=\"#按照概率密度函数的处理方式分类\" class=\"headerlink\" title=\"按照概率密度函数的处理方式分类\"></a>按照概率密度函数的处理方式分类</h2><p>![[Pasted image 20240412152711.png]]</p>\n<h2 id=\"按照是否有监督\"><a href=\"#按照是否有监督\" class=\"headerlink\" title=\"按照是否有监督\"></a>按照是否有监督</h2><ol>\n<li>有监督的生成模型。</li>\n<li>无监督的生成模型。<ol>\n<li>[[扩散模型]]</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"基本任务\"><a href=\"#基本任务\" class=\"headerlink\" title=\"基本任务\"></a>基本任务</h1><ol>\n<li>生成样本，例如生成逼真的人脸图片、生成高质量的语音等；</li>\n<li>也可以通过改进生成模型从而实现样本之间的映射转换，例如图像风格迁移、语音增强等。</li>\n</ol>\n<h2 id=\"原理：生成样本\"><a href=\"#原理：生成样本\" class=\"headerlink\" title=\"原理：生成样本\"></a>原理：生成样本</h2><h3 id=\"整体流程\"><a href=\"#整体流程\" class=\"headerlink\" title=\"整体流程\"></a>整体流程</h3><p>生成模型接受随机噪声 z 作为输入，然后产生输出样本 x</p>\n<h3 id=\"训练和推理过程\"><a href=\"#训练和推理过程\" class=\"headerlink\" title=\"训练和推理过程\"></a>训练和推理过程</h3><p><strong>分析</strong></p>\n<ol>\n<li>由 N 个样本构成的集合，假设它们是彼此独立都采样来源于某个未知的概率分布 q(X)；</li>\n<li>问题：如何在不知道 q(X) 的情况下产生一个模型使得，生成的样本在分布中。</li>\n<li>解决：构建生成模型 p(X,θ)，通过 N 个样本来学习到最好的参数 θ，使得 p(X,θ)&#x3D;q(X)<br><strong>两个问题</strong></li>\n<li>如何设计模型<br> 不同的模型有各自的考虑，比如 玻尔兹曼机 使用基于能量的模型，完全可见置信网络对模型进行的链式解析等等。</li>\n<li>如何训练<br> 显式生成模型使用的训练准则为极大似然估计。这里有分两种情况：<ol>\n<li>对似然函数本身直接进行优化的精确推断方法。（例如流模型，自回归模型）</li>\n<li>对似然函数近似值进行优化的近似推断方法。（例如VAE和玻尔兹曼机）<br> 隐式生成模型首先使用两类样本学习到了 p(X,θ) 和 q(X)  的距离，然后再以减少距离为目标训练生成模型。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"潜变量生成模型\"><a href=\"#潜变量生成模型\" class=\"headerlink\" title=\"潜变量生成模型\"></a>潜变量生成模型</h3><p>潜变量生成模型（Latent Variable Generative Model）是一种统计模型，用于描述数据的生成过程。它假设存在一组潜在的变量（也称为隐藏变量或潜变量），这些变量无法直接观测到，但对生成数据起到重要作用。</p>\n<p>潜变量生成模型的基本思想是，通过学习数据中隐藏的潜在结构和变量，可以生成与观测数据相似的新样本。这种生成过程通常基于概率分布模型，如高斯混合模型（Gaussian Mixture Model，GMM）、隐马尔可夫模型（Hidden Markov Model，HMM）、变分自编码器（Variational Autoencoder，VAE）等。</p>\n<p>在潜变量生成模型中，潜变量表示了数据中的潜在特征或隐含结构，它们对生成数据的分布产生影响。通过对潜变量和观测变量之间的关系进行建模，生成模型可以通过给定潜变量的取值来生成对应的观测数据。</p>\n<p>潜变量生成模型的应用广泛，包括图像生成、文本生成、语音生成等。通过学习和探索数据中的潜在结构，潜变量生成模型可以生成具有多样性和创造性的新样本，进而用于数据增强、生成对抗网络（GAN）的训练、数据压缩和降维等任务。</p>\n<p>总而言之，潜变量生成模型是一种通过建模潜在变量与观测数据之间的关系来生成数据的统计模型。它利用隐藏的潜在结构和变量来模拟数据的生成过程，并可用于生成新样本和数据分析中的其他任务。</p>\n","excerpt":"","more":"<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://zhuanlan.zhihu.com/p/532402983\">https://zhuanlan.zhihu.com/p/532402983</a></p>\n<h1 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h1><p>指一类机器学习模型，其目标是学习数据的概率分布，并通过该概率分布生成新的样本数据。生成模型可以根据已知数据的统计特征，学习数据的分布模式，然后使用这个模式生成新的数据样本。生成模型被广泛应用于数据生成、图像合成、文本生成等领域。</p>\n<h1 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h1><h2 id=\"按照概率密度函数的处理方式分类\"><a href=\"#按照概率密度函数的处理方式分类\" class=\"headerlink\" title=\"按照概率密度函数的处理方式分类\"></a>按照概率密度函数的处理方式分类</h2><p>![[Pasted image 20240412152711.png]]</p>\n<h2 id=\"按照是否有监督\"><a href=\"#按照是否有监督\" class=\"headerlink\" title=\"按照是否有监督\"></a>按照是否有监督</h2><ol>\n<li>有监督的生成模型。</li>\n<li>无监督的生成模型。<ol>\n<li>[[扩散模型]]</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"基本任务\"><a href=\"#基本任务\" class=\"headerlink\" title=\"基本任务\"></a>基本任务</h1><ol>\n<li>生成样本，例如生成逼真的人脸图片、生成高质量的语音等；</li>\n<li>也可以通过改进生成模型从而实现样本之间的映射转换，例如图像风格迁移、语音增强等。</li>\n</ol>\n<h2 id=\"原理：生成样本\"><a href=\"#原理：生成样本\" class=\"headerlink\" title=\"原理：生成样本\"></a>原理：生成样本</h2><h3 id=\"整体流程\"><a href=\"#整体流程\" class=\"headerlink\" title=\"整体流程\"></a>整体流程</h3><p>生成模型接受随机噪声 z 作为输入，然后产生输出样本 x</p>\n<h3 id=\"训练和推理过程\"><a href=\"#训练和推理过程\" class=\"headerlink\" title=\"训练和推理过程\"></a>训练和推理过程</h3><p><strong>分析</strong></p>\n<ol>\n<li>由 N 个样本构成的集合，假设它们是彼此独立都采样来源于某个未知的概率分布 q(X)；</li>\n<li>问题：如何在不知道 q(X) 的情况下产生一个模型使得，生成的样本在分布中。</li>\n<li>解决：构建生成模型 p(X,θ)，通过 N 个样本来学习到最好的参数 θ，使得 p(X,θ)&#x3D;q(X)<br><strong>两个问题</strong></li>\n<li>如何设计模型<br> 不同的模型有各自的考虑，比如 玻尔兹曼机 使用基于能量的模型，完全可见置信网络对模型进行的链式解析等等。</li>\n<li>如何训练<br> 显式生成模型使用的训练准则为极大似然估计。这里有分两种情况：<ol>\n<li>对似然函数本身直接进行优化的精确推断方法。（例如流模型，自回归模型）</li>\n<li>对似然函数近似值进行优化的近似推断方法。（例如VAE和玻尔兹曼机）<br> 隐式生成模型首先使用两类样本学习到了 p(X,θ) 和 q(X)  的距离，然后再以减少距离为目标训练生成模型。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"潜变量生成模型\"><a href=\"#潜变量生成模型\" class=\"headerlink\" title=\"潜变量生成模型\"></a>潜变量生成模型</h3><p>潜变量生成模型（Latent Variable Generative Model）是一种统计模型，用于描述数据的生成过程。它假设存在一组潜在的变量（也称为隐藏变量或潜变量），这些变量无法直接观测到，但对生成数据起到重要作用。</p>\n<p>潜变量生成模型的基本思想是，通过学习数据中隐藏的潜在结构和变量，可以生成与观测数据相似的新样本。这种生成过程通常基于概率分布模型，如高斯混合模型（Gaussian Mixture Model，GMM）、隐马尔可夫模型（Hidden Markov Model，HMM）、变分自编码器（Variational Autoencoder，VAE）等。</p>\n<p>在潜变量生成模型中，潜变量表示了数据中的潜在特征或隐含结构，它们对生成数据的分布产生影响。通过对潜变量和观测变量之间的关系进行建模，生成模型可以通过给定潜变量的取值来生成对应的观测数据。</p>\n<p>潜变量生成模型的应用广泛，包括图像生成、文本生成、语音生成等。通过学习和探索数据中的潜在结构，潜变量生成模型可以生成具有多样性和创造性的新样本，进而用于数据增强、生成对抗网络（GAN）的训练、数据压缩和降维等任务。</p>\n<p>总而言之，潜变量生成模型是一种通过建模潜在变量与观测数据之间的关系来生成数据的统计模型。它利用隐藏的潜在结构和变量来模拟数据的生成过程，并可用于生成新样本和数据分析中的其他任务。</p>\n"},{"_content":"# 使用python\n\n## 库\n\n```python\n# 导入数学计算\nimport numpy as np\n# 导入结构化数据处理\nimport pandas as pd\n# 导入绘图模块\nimport matplotlib.pyplot as plt\n# 导入基于 matplotlib 且数据结构与 pandas 统一的统计图制作库。\nimport seaborn as sns\n\n\n```\n\n### 魔术命令\n\n> 一组专门用于增强Jupyter Notebook交互性和功能的特殊命令。这些命令以`%`或`%%`开头，并且只能在Jupyter Notebook环境中使用。\n>\n> 注意：魔术命令不能在 python 命令行中执行。\n\n1. **行魔术命令（line magic commands）**：以`%`开头的命令，作用于单行代码。例如：\n   - `%run`：运行外部Python脚本。\n   - `%pwd`：显示当前工作目录。\n   - `%time`：测量代码的执行时间。\n2. **单元魔术命令（cell magic commands）**：以`%%`开头的命令，作用于整个代码单元格。例如：\n   - `%%time`：测量整个单元格的执行时间。\n   - `%%html`：将单元格内容解释为HTML。\n   - `%%bash`：在单元格中运行Bash命令。\n3. **帮助命令**：以`?`结尾的命令，用于获取相关对象或函数的帮助信息。例如：\n   - `len?`：获取`len`函数的帮助信息。\n   - `obj?`：获取对象`obj`的帮助信息。\n4. **魔术命令的参数和选项**：魔术命令可以接受参数和选项，以进一步定制其行为。例如：\n   - `%matplotlib inline`：将Matplotlib图形嵌入到Notebook中。\n   - `%run -i script.py`：以交互模式运行外部脚本。\n\n### 装饰函数\n[Python__](https://m.baidu.com/s?word=Python&sa=re_dqa_zy) 的装饰器是一种重要的编程概念，它们允许开发者在不改变被装饰函数源码的情况下，为函数添加额外的职责或者行为。装饰器通常由一个函数组成，它可以接收另一个函数作为输入，并返回一个新的函数对象。这些新的函数对象包含了原函数的功能和一些额外的逻辑。\n\n以下是关于 Python 装饰器的几个例子：\n\n1. `@lru_cache` 装饰器用于提高性能，特别是对于那些经常重复计算的函数。它会缓存函数的计算结果，以便在未来相同的参数调用下可以直接获取缓存中的结果，而无需重新计算。这种缓存机制特别适用于那些计算成本较高的场景。\n    \n2. `@total_ordering` 装饰器则是为了提供缺失的比较方法，特别是在没有实现这些方法的标准Python类中。通过使用这个装饰器，可以为预定义的Python类自动生成比较方法，确保不同实例之间能够进行正确的比较。\n    \n\n总结来说，Python 装饰器是设计用来简化代码、增强函数功能和提升程序效率的工具。它们使得开发者能够在保持函数接口不变的同时，灵活地扩展其功能。\n\n\n\n# 问题解决\n\n## 问题： 'utf-8' 解析出错\n\n```python\n    with open(args.train_path, \"r\", encoding=\"utf-8\") as f:\n\n    # with open(args.train_path, \"r\", encoding=\"utf-8\", errors='replace') as f:\n\n        lines = f.read().splitlines()\n```\n> UnicodeDecodeError: 'utf-8' codec can't decode byte 0xf1 in position 5079963: invalid continuation byte\n\n解决1：使用默认字符替换，默认是 “?”。\n`with open(args.train_path, \"r\", encoding=\"utf-8\", errors='replace') as f`\n\n解决2：定位到没有解析的字符行，重新输入\n\n## 问题：显存不足\n\n```\ntorch.cuda.OutOfMemoryError: CUDA out of memory. Tried to allocate 288.00 MiB. GPU 0 has a total capacity of 10.75 GiB of which 44.62 MiB is free. Process 1403323 has 10.69 GiB memory in use. Of the allocated memory 10.48 GiB is allocated by PyTorch, and 29.33 MiB is reserved by PyTorch but unallocated. If reserved but unallocated memory is large try setting PYTORCH_CUDA_ALLOC_CONF=expandable_segments:True to avoid fragmentation.  See documentation for Memory Management  (https://pytorch.org/docs/stable/notes/cuda.html#environment-variables)\n```\n\n使用 `watch -n 0.1 nvidia-smi `查看 显存情况，可以看到运行的一瞬间，显存爆掉了。","source":"_posts/编程语言/Python/python 高级.md","raw":"# 使用python\n\n## 库\n\n```python\n# 导入数学计算\nimport numpy as np\n# 导入结构化数据处理\nimport pandas as pd\n# 导入绘图模块\nimport matplotlib.pyplot as plt\n# 导入基于 matplotlib 且数据结构与 pandas 统一的统计图制作库。\nimport seaborn as sns\n\n\n```\n\n### 魔术命令\n\n> 一组专门用于增强Jupyter Notebook交互性和功能的特殊命令。这些命令以`%`或`%%`开头，并且只能在Jupyter Notebook环境中使用。\n>\n> 注意：魔术命令不能在 python 命令行中执行。\n\n1. **行魔术命令（line magic commands）**：以`%`开头的命令，作用于单行代码。例如：\n   - `%run`：运行外部Python脚本。\n   - `%pwd`：显示当前工作目录。\n   - `%time`：测量代码的执行时间。\n2. **单元魔术命令（cell magic commands）**：以`%%`开头的命令，作用于整个代码单元格。例如：\n   - `%%time`：测量整个单元格的执行时间。\n   - `%%html`：将单元格内容解释为HTML。\n   - `%%bash`：在单元格中运行Bash命令。\n3. **帮助命令**：以`?`结尾的命令，用于获取相关对象或函数的帮助信息。例如：\n   - `len?`：获取`len`函数的帮助信息。\n   - `obj?`：获取对象`obj`的帮助信息。\n4. **魔术命令的参数和选项**：魔术命令可以接受参数和选项，以进一步定制其行为。例如：\n   - `%matplotlib inline`：将Matplotlib图形嵌入到Notebook中。\n   - `%run -i script.py`：以交互模式运行外部脚本。\n\n### 装饰函数\n[Python__](https://m.baidu.com/s?word=Python&sa=re_dqa_zy) 的装饰器是一种重要的编程概念，它们允许开发者在不改变被装饰函数源码的情况下，为函数添加额外的职责或者行为。装饰器通常由一个函数组成，它可以接收另一个函数作为输入，并返回一个新的函数对象。这些新的函数对象包含了原函数的功能和一些额外的逻辑。\n\n以下是关于 Python 装饰器的几个例子：\n\n1. `@lru_cache` 装饰器用于提高性能，特别是对于那些经常重复计算的函数。它会缓存函数的计算结果，以便在未来相同的参数调用下可以直接获取缓存中的结果，而无需重新计算。这种缓存机制特别适用于那些计算成本较高的场景。\n    \n2. `@total_ordering` 装饰器则是为了提供缺失的比较方法，特别是在没有实现这些方法的标准Python类中。通过使用这个装饰器，可以为预定义的Python类自动生成比较方法，确保不同实例之间能够进行正确的比较。\n    \n\n总结来说，Python 装饰器是设计用来简化代码、增强函数功能和提升程序效率的工具。它们使得开发者能够在保持函数接口不变的同时，灵活地扩展其功能。\n\n\n\n# 问题解决\n\n## 问题： 'utf-8' 解析出错\n\n```python\n    with open(args.train_path, \"r\", encoding=\"utf-8\") as f:\n\n    # with open(args.train_path, \"r\", encoding=\"utf-8\", errors='replace') as f:\n\n        lines = f.read().splitlines()\n```\n> UnicodeDecodeError: 'utf-8' codec can't decode byte 0xf1 in position 5079963: invalid continuation byte\n\n解决1：使用默认字符替换，默认是 “?”。\n`with open(args.train_path, \"r\", encoding=\"utf-8\", errors='replace') as f`\n\n解决2：定位到没有解析的字符行，重新输入\n\n## 问题：显存不足\n\n```\ntorch.cuda.OutOfMemoryError: CUDA out of memory. Tried to allocate 288.00 MiB. GPU 0 has a total capacity of 10.75 GiB of which 44.62 MiB is free. Process 1403323 has 10.69 GiB memory in use. Of the allocated memory 10.48 GiB is allocated by PyTorch, and 29.33 MiB is reserved by PyTorch but unallocated. If reserved but unallocated memory is large try setting PYTORCH_CUDA_ALLOC_CONF=expandable_segments:True to avoid fragmentation.  See documentation for Memory Management  (https://pytorch.org/docs/stable/notes/cuda.html#environment-variables)\n```\n\n使用 `watch -n 0.1 nvidia-smi `查看 显存情况，可以看到运行的一瞬间，显存爆掉了。","slug":"编程语言/Python/python 高级","published":1,"date":"2024-04-22T13:14:48.685Z","updated":"2024-03-22T01:46:03.041Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0q002gkgg4g83p59u4","content":"<h1 id=\"使用python\"><a href=\"#使用python\" class=\"headerlink\" title=\"使用python\"></a>使用python</h1><h2 id=\"库\"><a href=\"#库\" class=\"headerlink\" title=\"库\"></a>库</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 导入数学计算</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"comment\"># 导入结构化数据处理</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"><span class=\"comment\"># 导入绘图模块</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"comment\"># 导入基于 matplotlib 且数据结构与 pandas 统一的统计图制作库。</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> seaborn <span class=\"keyword\">as</span> sns</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"魔术命令\"><a href=\"#魔术命令\" class=\"headerlink\" title=\"魔术命令\"></a>魔术命令</h3><blockquote>\n<p>一组专门用于增强Jupyter Notebook交互性和功能的特殊命令。这些命令以<code>%</code>或<code>%%</code>开头，并且只能在Jupyter Notebook环境中使用。</p>\n<p>注意：魔术命令不能在 python 命令行中执行。</p>\n</blockquote>\n<ol>\n<li><strong>行魔术命令（line magic commands）</strong>：以<code>%</code>开头的命令，作用于单行代码。例如：<ul>\n<li><code>%run</code>：运行外部Python脚本。</li>\n<li><code>%pwd</code>：显示当前工作目录。</li>\n<li><code>%time</code>：测量代码的执行时间。</li>\n</ul>\n</li>\n<li><strong>单元魔术命令（cell magic commands）</strong>：以<code>%%</code>开头的命令，作用于整个代码单元格。例如：<ul>\n<li><code>%%time</code>：测量整个单元格的执行时间。</li>\n<li><code>%%html</code>：将单元格内容解释为HTML。</li>\n<li><code>%%bash</code>：在单元格中运行Bash命令。</li>\n</ul>\n</li>\n<li><strong>帮助命令</strong>：以<code>?</code>结尾的命令，用于获取相关对象或函数的帮助信息。例如：<ul>\n<li><code>len?</code>：获取<code>len</code>函数的帮助信息。</li>\n<li><code>obj?</code>：获取对象<code>obj</code>的帮助信息。</li>\n</ul>\n</li>\n<li><strong>魔术命令的参数和选项</strong>：魔术命令可以接受参数和选项，以进一步定制其行为。例如：<ul>\n<li><code>%matplotlib inline</code>：将Matplotlib图形嵌入到Notebook中。</li>\n<li><code>%run -i script.py</code>：以交互模式运行外部脚本。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"装饰函数\"><a href=\"#装饰函数\" class=\"headerlink\" title=\"装饰函数\"></a>装饰函数</h3><p><a href=\"https://m.baidu.com/s?word=Python&sa=re_dqa_zy\">Python__</a> 的装饰器是一种重要的编程概念，它们允许开发者在不改变被装饰函数源码的情况下，为函数添加额外的职责或者行为。装饰器通常由一个函数组成，它可以接收另一个函数作为输入，并返回一个新的函数对象。这些新的函数对象包含了原函数的功能和一些额外的逻辑。</p>\n<p>以下是关于 Python 装饰器的几个例子：</p>\n<ol>\n<li><p><code>@lru_cache</code> 装饰器用于提高性能，特别是对于那些经常重复计算的函数。它会缓存函数的计算结果，以便在未来相同的参数调用下可以直接获取缓存中的结果，而无需重新计算。这种缓存机制特别适用于那些计算成本较高的场景。</p>\n</li>\n<li><p><code>@total_ordering</code> 装饰器则是为了提供缺失的比较方法，特别是在没有实现这些方法的标准Python类中。通过使用这个装饰器，可以为预定义的Python类自动生成比较方法，确保不同实例之间能够进行正确的比较。</p>\n</li>\n</ol>\n<p>总结来说，Python 装饰器是设计用来简化代码、增强函数功能和提升程序效率的工具。它们使得开发者能够在保持函数接口不变的同时，灵活地扩展其功能。</p>\n<h1 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h1><h2 id=\"问题：-‘utf-8’-解析出错\"><a href=\"#问题：-‘utf-8’-解析出错\" class=\"headerlink\" title=\"问题： ‘utf-8’ 解析出错\"></a>问题： ‘utf-8’ 解析出错</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(args.train_path, <span class=\"string\">&quot;r&quot;</span>, encoding=<span class=\"string\">&quot;utf-8&quot;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># with open(args.train_path, &quot;r&quot;, encoding=&quot;utf-8&quot;, errors=&#x27;replace&#x27;) as f:</span></span><br><span class=\"line\"></span><br><span class=\"line\">        lines = f.read().splitlines()</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>UnicodeDecodeError: ‘utf-8’ codec can’t decode byte 0xf1 in position 5079963: invalid continuation byte</p>\n</blockquote>\n<p>解决1：使用默认字符替换，默认是 “?”。<br><code>with open(args.train_path, &quot;r&quot;, encoding=&quot;utf-8&quot;, errors=&#39;replace&#39;) as f</code></p>\n<p>解决2：定位到没有解析的字符行，重新输入</p>\n<h2 id=\"问题：显存不足\"><a href=\"#问题：显存不足\" class=\"headerlink\" title=\"问题：显存不足\"></a>问题：显存不足</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">torch.cuda.OutOfMemoryError: CUDA out of memory. Tried to allocate 288.00 MiB. GPU 0 has a total capacity of 10.75 GiB of which 44.62 MiB is free. Process 1403323 has 10.69 GiB memory in use. Of the allocated memory 10.48 GiB is allocated by PyTorch, and 29.33 MiB is reserved by PyTorch but unallocated. If reserved but unallocated memory is large try setting PYTORCH_CUDA_ALLOC_CONF=expandable_segments:True to avoid fragmentation.  See documentation for Memory Management  (https://pytorch.org/docs/stable/notes/cuda.html#environment-variables)</span><br></pre></td></tr></table></figure>\n\n<p>使用 <code>watch -n 0.1 nvidia-smi </code>查看 显存情况，可以看到运行的一瞬间，显存爆掉了。</p>\n","excerpt":"","more":"<h1 id=\"使用python\"><a href=\"#使用python\" class=\"headerlink\" title=\"使用python\"></a>使用python</h1><h2 id=\"库\"><a href=\"#库\" class=\"headerlink\" title=\"库\"></a>库</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 导入数学计算</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"comment\"># 导入结构化数据处理</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"><span class=\"comment\"># 导入绘图模块</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"comment\"># 导入基于 matplotlib 且数据结构与 pandas 统一的统计图制作库。</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> seaborn <span class=\"keyword\">as</span> sns</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"魔术命令\"><a href=\"#魔术命令\" class=\"headerlink\" title=\"魔术命令\"></a>魔术命令</h3><blockquote>\n<p>一组专门用于增强Jupyter Notebook交互性和功能的特殊命令。这些命令以<code>%</code>或<code>%%</code>开头，并且只能在Jupyter Notebook环境中使用。</p>\n<p>注意：魔术命令不能在 python 命令行中执行。</p>\n</blockquote>\n<ol>\n<li><strong>行魔术命令（line magic commands）</strong>：以<code>%</code>开头的命令，作用于单行代码。例如：<ul>\n<li><code>%run</code>：运行外部Python脚本。</li>\n<li><code>%pwd</code>：显示当前工作目录。</li>\n<li><code>%time</code>：测量代码的执行时间。</li>\n</ul>\n</li>\n<li><strong>单元魔术命令（cell magic commands）</strong>：以<code>%%</code>开头的命令，作用于整个代码单元格。例如：<ul>\n<li><code>%%time</code>：测量整个单元格的执行时间。</li>\n<li><code>%%html</code>：将单元格内容解释为HTML。</li>\n<li><code>%%bash</code>：在单元格中运行Bash命令。</li>\n</ul>\n</li>\n<li><strong>帮助命令</strong>：以<code>?</code>结尾的命令，用于获取相关对象或函数的帮助信息。例如：<ul>\n<li><code>len?</code>：获取<code>len</code>函数的帮助信息。</li>\n<li><code>obj?</code>：获取对象<code>obj</code>的帮助信息。</li>\n</ul>\n</li>\n<li><strong>魔术命令的参数和选项</strong>：魔术命令可以接受参数和选项，以进一步定制其行为。例如：<ul>\n<li><code>%matplotlib inline</code>：将Matplotlib图形嵌入到Notebook中。</li>\n<li><code>%run -i script.py</code>：以交互模式运行外部脚本。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"装饰函数\"><a href=\"#装饰函数\" class=\"headerlink\" title=\"装饰函数\"></a>装饰函数</h3><p><a href=\"https://m.baidu.com/s?word=Python&sa=re_dqa_zy\">Python__</a> 的装饰器是一种重要的编程概念，它们允许开发者在不改变被装饰函数源码的情况下，为函数添加额外的职责或者行为。装饰器通常由一个函数组成，它可以接收另一个函数作为输入，并返回一个新的函数对象。这些新的函数对象包含了原函数的功能和一些额外的逻辑。</p>\n<p>以下是关于 Python 装饰器的几个例子：</p>\n<ol>\n<li><p><code>@lru_cache</code> 装饰器用于提高性能，特别是对于那些经常重复计算的函数。它会缓存函数的计算结果，以便在未来相同的参数调用下可以直接获取缓存中的结果，而无需重新计算。这种缓存机制特别适用于那些计算成本较高的场景。</p>\n</li>\n<li><p><code>@total_ordering</code> 装饰器则是为了提供缺失的比较方法，特别是在没有实现这些方法的标准Python类中。通过使用这个装饰器，可以为预定义的Python类自动生成比较方法，确保不同实例之间能够进行正确的比较。</p>\n</li>\n</ol>\n<p>总结来说，Python 装饰器是设计用来简化代码、增强函数功能和提升程序效率的工具。它们使得开发者能够在保持函数接口不变的同时，灵活地扩展其功能。</p>\n<h1 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h1><h2 id=\"问题：-‘utf-8’-解析出错\"><a href=\"#问题：-‘utf-8’-解析出错\" class=\"headerlink\" title=\"问题： ‘utf-8’ 解析出错\"></a>问题： ‘utf-8’ 解析出错</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(args.train_path, <span class=\"string\">&quot;r&quot;</span>, encoding=<span class=\"string\">&quot;utf-8&quot;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># with open(args.train_path, &quot;r&quot;, encoding=&quot;utf-8&quot;, errors=&#x27;replace&#x27;) as f:</span></span><br><span class=\"line\"></span><br><span class=\"line\">        lines = f.read().splitlines()</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>UnicodeDecodeError: ‘utf-8’ codec can’t decode byte 0xf1 in position 5079963: invalid continuation byte</p>\n</blockquote>\n<p>解决1：使用默认字符替换，默认是 “?”。<br><code>with open(args.train_path, &quot;r&quot;, encoding=&quot;utf-8&quot;, errors=&#39;replace&#39;) as f</code></p>\n<p>解决2：定位到没有解析的字符行，重新输入</p>\n<h2 id=\"问题：显存不足\"><a href=\"#问题：显存不足\" class=\"headerlink\" title=\"问题：显存不足\"></a>问题：显存不足</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">torch.cuda.OutOfMemoryError: CUDA out of memory. Tried to allocate 288.00 MiB. GPU 0 has a total capacity of 10.75 GiB of which 44.62 MiB is free. Process 1403323 has 10.69 GiB memory in use. Of the allocated memory 10.48 GiB is allocated by PyTorch, and 29.33 MiB is reserved by PyTorch but unallocated. If reserved but unallocated memory is large try setting PYTORCH_CUDA_ALLOC_CONF=expandable_segments:True to avoid fragmentation.  See documentation for Memory Management  (https://pytorch.org/docs/stable/notes/cuda.html#environment-variables)</span><br></pre></td></tr></table></figure>\n\n<p>使用 <code>watch -n 0.1 nvidia-smi </code>查看 显存情况，可以看到运行的一瞬间，显存爆掉了。</p>\n"},{"_content":"# 基本流程\n数据集：\n[RockYou password leak](https://wiki.skullsecurity.org/index.php/Passwords)\n\n使用论文预训练模型：\n1. 最多 10 个字符密码训练的 PassGPT [此处](https://huggingface.co/javirandor/passgpt-10characters/)。 \n2. 最多 16 个字符的密码训练的版本需要我们团队的研究批准，可以在[此处](https://huggingface.co/javirandor/passgpt-16characters/)找到。\n\n自己训练模型：\n1. 密码 tokenizer ：字符级（防止像 NLP 那样将 字符 串为分词），在模型下保留有意义的概率分布。\n```python\n\npython src/create_tokenizer.py --train_path {PATH_TO_TRAINING_DATA} --output_path {PATH_TO_TOKENIZERS_FOLDER}\n# Customization\npython src/create_tokenizer.py --train_path data/rockyou.txt --output_path output\n\n```\n2. 自定义一个配置文件： `CONFIG_PATH` ，可以使用默认的文件 [yaml 文件](https://github.com/javirandor/passbert/blob/main/configs/passgpt-16chars.yaml).\n3. 训练模型：\n```python\npython src/train_passgpt.py --config_path {CONFIG_PATH}\n# Customization\npython src/train_passgpt.py --config_path configs/passgpt-16chars.yaml\n```\n4. 模型使用\n```python\npython src/generate_passwords.py --model_path {MODEL_PATH} --out_path {PASSWORD_OUTPUT_FOLDER} --num_generate {NUM_PASSWORDS} --train_data_path {PATH_TO_TRAINING_DATA} --eval_data_path {PATH_TO_EVAL_DATA}\n# Customizeation\n python src/generate_passwords.py --model_path train_output/last/ --out_path ./train_output/last/ --num_generate 100000000 --train_data_path data/rockyou.txt --eval_data_path data/rockyou.txt --tokenizer_path output/byte_bpe_tokenizer_99/\n```\n\t进一步的生成参数，例如“--temper”、“--top_p”或“--top_k”\n\n# 环境\nconda + python3.11\nrequirements.txt\n```text\naccelerate==0.28.0\naiohttp==3.9.3\naiosignal==1.3.1\nappdirs==1.4.4\nasttokens==2.4.1\nattrs==23.2.0\nazure-core==1.30.1\nazure-storage-blob==12.19.1\ncertifi==2024.2.2\ncffi==1.16.0\ncharset-normalizer==3.3.2\nclick==8.1.7\ncomm==0.2.1\ncryptography==42.0.5\ndatasets==2.18.0\ndebugpy==1.6.7\ndecorator==5.1.1\ndill==0.3.8\ndocker-pycreds==0.4.0\nexceptiongroup==1.2.0\nexecuting==2.0.1\nfilelock==3.13.1\nfrozenlist==1.4.1\nfsspec==2024.2.0\ngitdb==4.0.11\nGitPython==3.1.42\nhuggingface-hub==0.21.4\nidna==3.6\nimportlib_metadata==7.0.2\nipykernel==6.29.3\nipython==8.22.2\nisodate==0.6.1\njedi==0.19.1\nJinja2==3.1.3\njoblib==1.3.2\njsonlines==4.0.0\njupyter_client==8.6.0\njupyter_core==5.7.1\nlamini==2.1.2\nlamini-configuration==0.8.3\nMarkupSafe==2.1.5\nmatplotlib-inline==0.1.6\nmpmath==1.3.0\nmultidict==6.0.5\nmultiprocess==0.70.16\nnest_asyncio==1.6.0\nnetworkx==3.2.1\nnumpy==1.26.4\npackaging==24.0\npandas==2.2.1\nparso==0.8.3\npexpect==4.9.0\npickleshare==0.7.5\npip==23.3.1\nplatformdirs==4.2.0\nprompt-toolkit==3.0.42\nprotobuf==4.25.3\npsutil==5.9.0\nptyprocess==0.7.0\npure-eval==0.2.2\npyarrow==15.0.1\npyarrow-hotfix==0.6\npycparser==2.21\nPygments==2.17.2\npython-dateutil==2.9.0\npytz==2024.1\nPyYAML==6.0.1\npyzmq==25.1.2\nregex==2023.12.25\nrequests==2.31.0\nsafetensors==0.4.2\nscikit-learn==1.4.1.post1\nscipy==1.12.0\nsentry-sdk==1.43.0\nsetproctitle==1.3.3\nsetuptools==68.2.2\nsix==1.16.0\nsmmap==5.0.1\nstack-data==0.6.2\nsympy==1.12\nthreadpoolctl==3.3.0\ntokenizers==0.15.2\ntorch==2.2.1\ntornado==6.3.3\ntqdm==4.66.2\ntraitlets==5.14.1\ntransformers==4.38.2\ntriton==2.2.0\ntyping_extensions==4.10.0\ntzdata==2024.1\nurllib3==2.2.1\nwandb==0.16.4\nwcwidth==0.2.13\nwheel==0.41.2\nxxhash==3.4.1\nyarl==1.9.4\nzipp==3.17.0\n```\n# 问题\n\n## 问题： 'utf-8' 解析出错\n\n```python\n    with open(args.train_path, \"r\", encoding=\"utf-8\") as f:\n\n    # with open(args.train_path, \"r\", encoding=\"utf-8\", errors='replace') as f:\n\n        lines = f.read().splitlines()\n```\n> UnicodeDecodeError: 'utf-8' codec can't decode byte 0xf1 in position 5079963: invalid continuation byte\n\n解决1：使用默认字符替换，默认是 “?”。\n`with open(args.train_path, \"r\", encoding=\"utf-8\", errors='replace') as f`\n\n解决2：定位到没有解析的字符行，重新输入\n\n\n## 问题： 包缺失\n```text\n  File \"/opt/conda/envs/py3_11/lib/python3.11/site-packages/transformers/training_args.py\", line 1905, in _setup_devices\n    raise ImportError(\nImportError: Using the `Trainer` with `PyTorch` requires `accelerate>=0.21.0`: Please run `pip install transformers[torch]` or `pip install accelerate -U`\n\n```\n\n```text\nTraceback (most recent call last):\n  File \"/root/PSG/passgpt-main/src/train_passgpt.py\", line 120, in <module>\n    trainer = Trainer(\n              ^^^^^^^^\n  File \"/opt/conda/envs/py3_11/lib/python3.11/site-packages/transformers/trainer.py\", line 533, in __init__\n    self.callback_handler = CallbackHandler(\n                            ^^^^^^^^^^^^^^^^\n  File \"/opt/conda/envs/py3_11/lib/python3.11/site-packages/transformers/trainer_callback.py\", line 313, in __init__\n    self.add_callback(cb)\n  File \"/opt/conda/envs/py3_11/lib/python3.11/site-packages/transformers/trainer_callback.py\", line 330, in add_callback\n    cb = callback() if isinstance(callback, type) else callback\n         ^^^^^^^^^^\n  File \"/opt/conda/envs/py3_11/lib/python3.11/site-packages/transformers/integrations/integration_utils.py\", line 673, in __init__\n    raise RuntimeError(\"WandbCallback requires wandb to be installed. Run `pip install wandb`.\")\n```\n\n## 问题：显存不够\n```text\ntorch.cuda.OutOfMemoryError: CUDA out of memory. Tried to allocate 288.00 MiB. GPU 0 has a total capacity of 10.75 GiB of which 44.62 MiB is free. Process 1338858 has 10.69 GiB memory in use.\n```\n1. 换服务器，当前服务器显卡资源不足：\n![[Pasted image 20240322093550.png]]\n\n2. 新服务器\n![[Pasted image 20240322093300.png]]\n\n## 问题： 显示 Driver Version 过低\n（导致训练时不能使用 GPU）\n\t此时不一定是 Driver Version 版本的问题，在实际中只要 显卡 显卡驱动兼容，那么就可以使用显卡跑程序。\n\t通过 降低 pytorch 的版本到 2.0.0 ，成功运行。\n\t\n\n\n\n![[Pasted image 20240322011742.png]]\n\n![[Pasted image 20240322091910.png]]\n\n\n\n# 当前的进度\n\n目前的进度： PassGPT 训练过程结束（最大字符 长度 设置为 10）\n\n![[Pasted image 20240322102651.png]]\n\n当前实验存在的问题：\n运行模型 需要 的配置较高。\n[模型显存需求估计](https://zhuanlan.zhihu.com/p/673125345)\n\n\n\n# 下一步计划\n之前是跑了模型的训练部分，下一步就是使用模型生成密码，并且分析数据。\n\n计划的实验目标是：\n\t1. 论文中没有提到只是说生成一定的数量的密码之后对测试数据集的覆盖率达到了多少，但是并没有提到那些 类型数据 是模型难以拟合的，我主要想看一下哪些没有匹配到的密码长什么样子。\n\t2. 对比以下 开源的预训练 10 字符 模型 和 此次训练的模型的效果，验证一下论文的效果。\n\n\n目前的一个小 idea，参考 [[MoEs]] ，但了解还比较粗浅。\n\n最后感觉论文读的还是太少了，需要接着调研论文 \n\n\n模型运行结果：https://wandb.ai/xinka/huggingface/runs/f4ta95w4?nw=nwuserfengdreamin\n","source":"_posts/论文笔记/复现/复现：PassGPT.md","raw":"# 基本流程\n数据集：\n[RockYou password leak](https://wiki.skullsecurity.org/index.php/Passwords)\n\n使用论文预训练模型：\n1. 最多 10 个字符密码训练的 PassGPT [此处](https://huggingface.co/javirandor/passgpt-10characters/)。 \n2. 最多 16 个字符的密码训练的版本需要我们团队的研究批准，可以在[此处](https://huggingface.co/javirandor/passgpt-16characters/)找到。\n\n自己训练模型：\n1. 密码 tokenizer ：字符级（防止像 NLP 那样将 字符 串为分词），在模型下保留有意义的概率分布。\n```python\n\npython src/create_tokenizer.py --train_path {PATH_TO_TRAINING_DATA} --output_path {PATH_TO_TOKENIZERS_FOLDER}\n# Customization\npython src/create_tokenizer.py --train_path data/rockyou.txt --output_path output\n\n```\n2. 自定义一个配置文件： `CONFIG_PATH` ，可以使用默认的文件 [yaml 文件](https://github.com/javirandor/passbert/blob/main/configs/passgpt-16chars.yaml).\n3. 训练模型：\n```python\npython src/train_passgpt.py --config_path {CONFIG_PATH}\n# Customization\npython src/train_passgpt.py --config_path configs/passgpt-16chars.yaml\n```\n4. 模型使用\n```python\npython src/generate_passwords.py --model_path {MODEL_PATH} --out_path {PASSWORD_OUTPUT_FOLDER} --num_generate {NUM_PASSWORDS} --train_data_path {PATH_TO_TRAINING_DATA} --eval_data_path {PATH_TO_EVAL_DATA}\n# Customizeation\n python src/generate_passwords.py --model_path train_output/last/ --out_path ./train_output/last/ --num_generate 100000000 --train_data_path data/rockyou.txt --eval_data_path data/rockyou.txt --tokenizer_path output/byte_bpe_tokenizer_99/\n```\n\t进一步的生成参数，例如“--temper”、“--top_p”或“--top_k”\n\n# 环境\nconda + python3.11\nrequirements.txt\n```text\naccelerate==0.28.0\naiohttp==3.9.3\naiosignal==1.3.1\nappdirs==1.4.4\nasttokens==2.4.1\nattrs==23.2.0\nazure-core==1.30.1\nazure-storage-blob==12.19.1\ncertifi==2024.2.2\ncffi==1.16.0\ncharset-normalizer==3.3.2\nclick==8.1.7\ncomm==0.2.1\ncryptography==42.0.5\ndatasets==2.18.0\ndebugpy==1.6.7\ndecorator==5.1.1\ndill==0.3.8\ndocker-pycreds==0.4.0\nexceptiongroup==1.2.0\nexecuting==2.0.1\nfilelock==3.13.1\nfrozenlist==1.4.1\nfsspec==2024.2.0\ngitdb==4.0.11\nGitPython==3.1.42\nhuggingface-hub==0.21.4\nidna==3.6\nimportlib_metadata==7.0.2\nipykernel==6.29.3\nipython==8.22.2\nisodate==0.6.1\njedi==0.19.1\nJinja2==3.1.3\njoblib==1.3.2\njsonlines==4.0.0\njupyter_client==8.6.0\njupyter_core==5.7.1\nlamini==2.1.2\nlamini-configuration==0.8.3\nMarkupSafe==2.1.5\nmatplotlib-inline==0.1.6\nmpmath==1.3.0\nmultidict==6.0.5\nmultiprocess==0.70.16\nnest_asyncio==1.6.0\nnetworkx==3.2.1\nnumpy==1.26.4\npackaging==24.0\npandas==2.2.1\nparso==0.8.3\npexpect==4.9.0\npickleshare==0.7.5\npip==23.3.1\nplatformdirs==4.2.0\nprompt-toolkit==3.0.42\nprotobuf==4.25.3\npsutil==5.9.0\nptyprocess==0.7.0\npure-eval==0.2.2\npyarrow==15.0.1\npyarrow-hotfix==0.6\npycparser==2.21\nPygments==2.17.2\npython-dateutil==2.9.0\npytz==2024.1\nPyYAML==6.0.1\npyzmq==25.1.2\nregex==2023.12.25\nrequests==2.31.0\nsafetensors==0.4.2\nscikit-learn==1.4.1.post1\nscipy==1.12.0\nsentry-sdk==1.43.0\nsetproctitle==1.3.3\nsetuptools==68.2.2\nsix==1.16.0\nsmmap==5.0.1\nstack-data==0.6.2\nsympy==1.12\nthreadpoolctl==3.3.0\ntokenizers==0.15.2\ntorch==2.2.1\ntornado==6.3.3\ntqdm==4.66.2\ntraitlets==5.14.1\ntransformers==4.38.2\ntriton==2.2.0\ntyping_extensions==4.10.0\ntzdata==2024.1\nurllib3==2.2.1\nwandb==0.16.4\nwcwidth==0.2.13\nwheel==0.41.2\nxxhash==3.4.1\nyarl==1.9.4\nzipp==3.17.0\n```\n# 问题\n\n## 问题： 'utf-8' 解析出错\n\n```python\n    with open(args.train_path, \"r\", encoding=\"utf-8\") as f:\n\n    # with open(args.train_path, \"r\", encoding=\"utf-8\", errors='replace') as f:\n\n        lines = f.read().splitlines()\n```\n> UnicodeDecodeError: 'utf-8' codec can't decode byte 0xf1 in position 5079963: invalid continuation byte\n\n解决1：使用默认字符替换，默认是 “?”。\n`with open(args.train_path, \"r\", encoding=\"utf-8\", errors='replace') as f`\n\n解决2：定位到没有解析的字符行，重新输入\n\n\n## 问题： 包缺失\n```text\n  File \"/opt/conda/envs/py3_11/lib/python3.11/site-packages/transformers/training_args.py\", line 1905, in _setup_devices\n    raise ImportError(\nImportError: Using the `Trainer` with `PyTorch` requires `accelerate>=0.21.0`: Please run `pip install transformers[torch]` or `pip install accelerate -U`\n\n```\n\n```text\nTraceback (most recent call last):\n  File \"/root/PSG/passgpt-main/src/train_passgpt.py\", line 120, in <module>\n    trainer = Trainer(\n              ^^^^^^^^\n  File \"/opt/conda/envs/py3_11/lib/python3.11/site-packages/transformers/trainer.py\", line 533, in __init__\n    self.callback_handler = CallbackHandler(\n                            ^^^^^^^^^^^^^^^^\n  File \"/opt/conda/envs/py3_11/lib/python3.11/site-packages/transformers/trainer_callback.py\", line 313, in __init__\n    self.add_callback(cb)\n  File \"/opt/conda/envs/py3_11/lib/python3.11/site-packages/transformers/trainer_callback.py\", line 330, in add_callback\n    cb = callback() if isinstance(callback, type) else callback\n         ^^^^^^^^^^\n  File \"/opt/conda/envs/py3_11/lib/python3.11/site-packages/transformers/integrations/integration_utils.py\", line 673, in __init__\n    raise RuntimeError(\"WandbCallback requires wandb to be installed. Run `pip install wandb`.\")\n```\n\n## 问题：显存不够\n```text\ntorch.cuda.OutOfMemoryError: CUDA out of memory. Tried to allocate 288.00 MiB. GPU 0 has a total capacity of 10.75 GiB of which 44.62 MiB is free. Process 1338858 has 10.69 GiB memory in use.\n```\n1. 换服务器，当前服务器显卡资源不足：\n![[Pasted image 20240322093550.png]]\n\n2. 新服务器\n![[Pasted image 20240322093300.png]]\n\n## 问题： 显示 Driver Version 过低\n（导致训练时不能使用 GPU）\n\t此时不一定是 Driver Version 版本的问题，在实际中只要 显卡 显卡驱动兼容，那么就可以使用显卡跑程序。\n\t通过 降低 pytorch 的版本到 2.0.0 ，成功运行。\n\t\n\n\n\n![[Pasted image 20240322011742.png]]\n\n![[Pasted image 20240322091910.png]]\n\n\n\n# 当前的进度\n\n目前的进度： PassGPT 训练过程结束（最大字符 长度 设置为 10）\n\n![[Pasted image 20240322102651.png]]\n\n当前实验存在的问题：\n运行模型 需要 的配置较高。\n[模型显存需求估计](https://zhuanlan.zhihu.com/p/673125345)\n\n\n\n# 下一步计划\n之前是跑了模型的训练部分，下一步就是使用模型生成密码，并且分析数据。\n\n计划的实验目标是：\n\t1. 论文中没有提到只是说生成一定的数量的密码之后对测试数据集的覆盖率达到了多少，但是并没有提到那些 类型数据 是模型难以拟合的，我主要想看一下哪些没有匹配到的密码长什么样子。\n\t2. 对比以下 开源的预训练 10 字符 模型 和 此次训练的模型的效果，验证一下论文的效果。\n\n\n目前的一个小 idea，参考 [[MoEs]] ，但了解还比较粗浅。\n\n最后感觉论文读的还是太少了，需要接着调研论文 \n\n\n模型运行结果：https://wandb.ai/xinka/huggingface/runs/f4ta95w4?nw=nwuserfengdreamin\n","slug":"论文笔记/复现/复现：PassGPT","published":1,"date":"2024-04-22T13:14:48.905Z","updated":"2024-04-02T11:41:15.622Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0q002hkgg44cqd6g3t","content":"<h1 id=\"基本流程\"><a href=\"#基本流程\" class=\"headerlink\" title=\"基本流程\"></a>基本流程</h1><p>数据集：<br><a href=\"https://wiki.skullsecurity.org/index.php/Passwords\">RockYou password leak</a></p>\n<p>使用论文预训练模型：</p>\n<ol>\n<li>最多 10 个字符密码训练的 PassGPT <a href=\"https://huggingface.co/javirandor/passgpt-10characters/\">此处</a>。 </li>\n<li>最多 16 个字符的密码训练的版本需要我们团队的研究批准，可以在<a href=\"https://huggingface.co/javirandor/passgpt-16characters/\">此处</a>找到。</li>\n</ol>\n<p>自己训练模型：</p>\n<ol>\n<li>密码 tokenizer ：字符级（防止像 NLP 那样将 字符 串为分词），在模型下保留有意义的概率分布。<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">python src/create_tokenizer.py --train_path &#123;PATH_TO_TRAINING_DATA&#125; --output_path &#123;PATH_TO_TOKENIZERS_FOLDER&#125;</span><br><span class=\"line\"><span class=\"comment\"># Customization</span></span><br><span class=\"line\">python src/create_tokenizer.py --train_path data/rockyou.txt --output_path output</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li>自定义一个配置文件： <code>CONFIG_PATH</code> ，可以使用默认的文件 <a href=\"https://github.com/javirandor/passbert/blob/main/configs/passgpt-16chars.yaml\">yaml 文件</a>.</li>\n<li>训练模型：<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python src/train_passgpt.py --config_path &#123;CONFIG_PATH&#125;</span><br><span class=\"line\"><span class=\"comment\"># Customization</span></span><br><span class=\"line\">python src/train_passgpt.py --config_path configs/passgpt-16chars.yaml</span><br></pre></td></tr></table></figure></li>\n<li>模型使用<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python src/generate_passwords.py --model_path &#123;MODEL_PATH&#125; --out_path &#123;PASSWORD_OUTPUT_FOLDER&#125; --num_generate &#123;NUM_PASSWORDS&#125; --train_data_path &#123;PATH_TO_TRAINING_DATA&#125; --eval_data_path &#123;PATH_TO_EVAL_DATA&#125;</span><br><span class=\"line\"><span class=\"comment\"># Customizeation</span></span><br><span class=\"line\"> python src/generate_passwords.py --model_path train_output/last/ --out_path ./train_output/last/ --num_generate <span class=\"number\">100000000</span> --train_data_path data/rockyou.txt --eval_data_path data/rockyou.txt --tokenizer_path output/byte_bpe_tokenizer_99/</span><br></pre></td></tr></table></figure>\n 进一步的生成参数，例如“–temper”、“–top_p”或“–top_k”</li>\n</ol>\n<h1 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h1><p>conda + python3.11<br>requirements.txt</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">accelerate==0.28.0</span><br><span class=\"line\">aiohttp==3.9.3</span><br><span class=\"line\">aiosignal==1.3.1</span><br><span class=\"line\">appdirs==1.4.4</span><br><span class=\"line\">asttokens==2.4.1</span><br><span class=\"line\">attrs==23.2.0</span><br><span class=\"line\">azure-core==1.30.1</span><br><span class=\"line\">azure-storage-blob==12.19.1</span><br><span class=\"line\">certifi==2024.2.2</span><br><span class=\"line\">cffi==1.16.0</span><br><span class=\"line\">charset-normalizer==3.3.2</span><br><span class=\"line\">click==8.1.7</span><br><span class=\"line\">comm==0.2.1</span><br><span class=\"line\">cryptography==42.0.5</span><br><span class=\"line\">datasets==2.18.0</span><br><span class=\"line\">debugpy==1.6.7</span><br><span class=\"line\">decorator==5.1.1</span><br><span class=\"line\">dill==0.3.8</span><br><span class=\"line\">docker-pycreds==0.4.0</span><br><span class=\"line\">exceptiongroup==1.2.0</span><br><span class=\"line\">executing==2.0.1</span><br><span class=\"line\">filelock==3.13.1</span><br><span class=\"line\">frozenlist==1.4.1</span><br><span class=\"line\">fsspec==2024.2.0</span><br><span class=\"line\">gitdb==4.0.11</span><br><span class=\"line\">GitPython==3.1.42</span><br><span class=\"line\">huggingface-hub==0.21.4</span><br><span class=\"line\">idna==3.6</span><br><span class=\"line\">importlib_metadata==7.0.2</span><br><span class=\"line\">ipykernel==6.29.3</span><br><span class=\"line\">ipython==8.22.2</span><br><span class=\"line\">isodate==0.6.1</span><br><span class=\"line\">jedi==0.19.1</span><br><span class=\"line\">Jinja2==3.1.3</span><br><span class=\"line\">joblib==1.3.2</span><br><span class=\"line\">jsonlines==4.0.0</span><br><span class=\"line\">jupyter_client==8.6.0</span><br><span class=\"line\">jupyter_core==5.7.1</span><br><span class=\"line\">lamini==2.1.2</span><br><span class=\"line\">lamini-configuration==0.8.3</span><br><span class=\"line\">MarkupSafe==2.1.5</span><br><span class=\"line\">matplotlib-inline==0.1.6</span><br><span class=\"line\">mpmath==1.3.0</span><br><span class=\"line\">multidict==6.0.5</span><br><span class=\"line\">multiprocess==0.70.16</span><br><span class=\"line\">nest_asyncio==1.6.0</span><br><span class=\"line\">networkx==3.2.1</span><br><span class=\"line\">numpy==1.26.4</span><br><span class=\"line\">packaging==24.0</span><br><span class=\"line\">pandas==2.2.1</span><br><span class=\"line\">parso==0.8.3</span><br><span class=\"line\">pexpect==4.9.0</span><br><span class=\"line\">pickleshare==0.7.5</span><br><span class=\"line\">pip==23.3.1</span><br><span class=\"line\">platformdirs==4.2.0</span><br><span class=\"line\">prompt-toolkit==3.0.42</span><br><span class=\"line\">protobuf==4.25.3</span><br><span class=\"line\">psutil==5.9.0</span><br><span class=\"line\">ptyprocess==0.7.0</span><br><span class=\"line\">pure-eval==0.2.2</span><br><span class=\"line\">pyarrow==15.0.1</span><br><span class=\"line\">pyarrow-hotfix==0.6</span><br><span class=\"line\">pycparser==2.21</span><br><span class=\"line\">Pygments==2.17.2</span><br><span class=\"line\">python-dateutil==2.9.0</span><br><span class=\"line\">pytz==2024.1</span><br><span class=\"line\">PyYAML==6.0.1</span><br><span class=\"line\">pyzmq==25.1.2</span><br><span class=\"line\">regex==2023.12.25</span><br><span class=\"line\">requests==2.31.0</span><br><span class=\"line\">safetensors==0.4.2</span><br><span class=\"line\">scikit-learn==1.4.1.post1</span><br><span class=\"line\">scipy==1.12.0</span><br><span class=\"line\">sentry-sdk==1.43.0</span><br><span class=\"line\">setproctitle==1.3.3</span><br><span class=\"line\">setuptools==68.2.2</span><br><span class=\"line\">six==1.16.0</span><br><span class=\"line\">smmap==5.0.1</span><br><span class=\"line\">stack-data==0.6.2</span><br><span class=\"line\">sympy==1.12</span><br><span class=\"line\">threadpoolctl==3.3.0</span><br><span class=\"line\">tokenizers==0.15.2</span><br><span class=\"line\">torch==2.2.1</span><br><span class=\"line\">tornado==6.3.3</span><br><span class=\"line\">tqdm==4.66.2</span><br><span class=\"line\">traitlets==5.14.1</span><br><span class=\"line\">transformers==4.38.2</span><br><span class=\"line\">triton==2.2.0</span><br><span class=\"line\">typing_extensions==4.10.0</span><br><span class=\"line\">tzdata==2024.1</span><br><span class=\"line\">urllib3==2.2.1</span><br><span class=\"line\">wandb==0.16.4</span><br><span class=\"line\">wcwidth==0.2.13</span><br><span class=\"line\">wheel==0.41.2</span><br><span class=\"line\">xxhash==3.4.1</span><br><span class=\"line\">yarl==1.9.4</span><br><span class=\"line\">zipp==3.17.0</span><br></pre></td></tr></table></figure>\n<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><h2 id=\"问题：-‘utf-8’-解析出错\"><a href=\"#问题：-‘utf-8’-解析出错\" class=\"headerlink\" title=\"问题： ‘utf-8’ 解析出错\"></a>问题： ‘utf-8’ 解析出错</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(args.train_path, <span class=\"string\">&quot;r&quot;</span>, encoding=<span class=\"string\">&quot;utf-8&quot;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># with open(args.train_path, &quot;r&quot;, encoding=&quot;utf-8&quot;, errors=&#x27;replace&#x27;) as f:</span></span><br><span class=\"line\"></span><br><span class=\"line\">        lines = f.read().splitlines()</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>UnicodeDecodeError: ‘utf-8’ codec can’t decode byte 0xf1 in position 5079963: invalid continuation byte</p>\n</blockquote>\n<p>解决1：使用默认字符替换，默认是 “?”。<br><code>with open(args.train_path, &quot;r&quot;, encoding=&quot;utf-8&quot;, errors=&#39;replace&#39;) as f</code></p>\n<p>解决2：定位到没有解析的字符行，重新输入</p>\n<h2 id=\"问题：-包缺失\"><a href=\"#问题：-包缺失\" class=\"headerlink\" title=\"问题： 包缺失\"></a>问题： 包缺失</h2><figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  File &quot;/opt/conda/envs/py3_11/lib/python3.11/site-packages/transformers/training_args.py&quot;, line 1905, in _setup_devices</span><br><span class=\"line\">    raise ImportError(</span><br><span class=\"line\">ImportError: Using the `Trainer` with `PyTorch` requires `accelerate&gt;=0.21.0`: Please run `pip install transformers[torch]` or `pip install accelerate -U`</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File &quot;/root/PSG/passgpt-main/src/train_passgpt.py&quot;, line 120, in &lt;module&gt;</span><br><span class=\"line\">    trainer = Trainer(</span><br><span class=\"line\">              ^^^^^^^^</span><br><span class=\"line\">  File &quot;/opt/conda/envs/py3_11/lib/python3.11/site-packages/transformers/trainer.py&quot;, line 533, in __init__</span><br><span class=\"line\">    self.callback_handler = CallbackHandler(</span><br><span class=\"line\">                            ^^^^^^^^^^^^^^^^</span><br><span class=\"line\">  File &quot;/opt/conda/envs/py3_11/lib/python3.11/site-packages/transformers/trainer_callback.py&quot;, line 313, in __init__</span><br><span class=\"line\">    self.add_callback(cb)</span><br><span class=\"line\">  File &quot;/opt/conda/envs/py3_11/lib/python3.11/site-packages/transformers/trainer_callback.py&quot;, line 330, in add_callback</span><br><span class=\"line\">    cb = callback() if isinstance(callback, type) else callback</span><br><span class=\"line\">         ^^^^^^^^^^</span><br><span class=\"line\">  File &quot;/opt/conda/envs/py3_11/lib/python3.11/site-packages/transformers/integrations/integration_utils.py&quot;, line 673, in __init__</span><br><span class=\"line\">    raise RuntimeError(&quot;WandbCallback requires wandb to be installed. Run `pip install wandb`.&quot;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"问题：显存不够\"><a href=\"#问题：显存不够\" class=\"headerlink\" title=\"问题：显存不够\"></a>问题：显存不够</h2><figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">torch.cuda.OutOfMemoryError: CUDA out of memory. Tried to allocate 288.00 MiB. GPU 0 has a total capacity of 10.75 GiB of which 44.62 MiB is free. Process 1338858 has 10.69 GiB memory in use.</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>换服务器，当前服务器显卡资源不足：<br>![[Pasted image 20240322093550.png]]</p>\n</li>\n<li><p>新服务器<br>![[Pasted image 20240322093300.png]]</p>\n</li>\n</ol>\n<h2 id=\"问题：-显示-Driver-Version-过低\"><a href=\"#问题：-显示-Driver-Version-过低\" class=\"headerlink\" title=\"问题： 显示 Driver Version 过低\"></a>问题： 显示 Driver Version 过低</h2><p>（导致训练时不能使用 GPU）<br>    此时不一定是 Driver Version 版本的问题，在实际中只要 显卡 显卡驱动兼容，那么就可以使用显卡跑程序。<br>    通过 降低 pytorch 的版本到 2.0.0 ，成功运行。</p>\n<p>![[Pasted image 20240322011742.png]]</p>\n<p>![[Pasted image 20240322091910.png]]</p>\n<h1 id=\"当前的进度\"><a href=\"#当前的进度\" class=\"headerlink\" title=\"当前的进度\"></a>当前的进度</h1><p>目前的进度： PassGPT 训练过程结束（最大字符 长度 设置为 10）</p>\n<p>![[Pasted image 20240322102651.png]]</p>\n<p>当前实验存在的问题：<br>运行模型 需要 的配置较高。<br><a href=\"https://zhuanlan.zhihu.com/p/673125345\">模型显存需求估计</a></p>\n<h1 id=\"下一步计划\"><a href=\"#下一步计划\" class=\"headerlink\" title=\"下一步计划\"></a>下一步计划</h1><p>之前是跑了模型的训练部分，下一步就是使用模型生成密码，并且分析数据。</p>\n<p>计划的实验目标是：<br>    1. 论文中没有提到只是说生成一定的数量的密码之后对测试数据集的覆盖率达到了多少，但是并没有提到那些 类型数据 是模型难以拟合的，我主要想看一下哪些没有匹配到的密码长什么样子。<br>    2. 对比以下 开源的预训练 10 字符 模型 和 此次训练的模型的效果，验证一下论文的效果。</p>\n<p>目前的一个小 idea，参考 [[MoEs]] ，但了解还比较粗浅。</p>\n<p>最后感觉论文读的还是太少了，需要接着调研论文 </p>\n<p>模型运行结果：<a href=\"https://wandb.ai/xinka/huggingface/runs/f4ta95w4?nw=nwuserfengdreamin\">https://wandb.ai/xinka/huggingface/runs/f4ta95w4?nw=nwuserfengdreamin</a></p>\n","excerpt":"","more":"<h1 id=\"基本流程\"><a href=\"#基本流程\" class=\"headerlink\" title=\"基本流程\"></a>基本流程</h1><p>数据集：<br><a href=\"https://wiki.skullsecurity.org/index.php/Passwords\">RockYou password leak</a></p>\n<p>使用论文预训练模型：</p>\n<ol>\n<li>最多 10 个字符密码训练的 PassGPT <a href=\"https://huggingface.co/javirandor/passgpt-10characters/\">此处</a>。 </li>\n<li>最多 16 个字符的密码训练的版本需要我们团队的研究批准，可以在<a href=\"https://huggingface.co/javirandor/passgpt-16characters/\">此处</a>找到。</li>\n</ol>\n<p>自己训练模型：</p>\n<ol>\n<li>密码 tokenizer ：字符级（防止像 NLP 那样将 字符 串为分词），在模型下保留有意义的概率分布。<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">python src/create_tokenizer.py --train_path &#123;PATH_TO_TRAINING_DATA&#125; --output_path &#123;PATH_TO_TOKENIZERS_FOLDER&#125;</span><br><span class=\"line\"><span class=\"comment\"># Customization</span></span><br><span class=\"line\">python src/create_tokenizer.py --train_path data/rockyou.txt --output_path output</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li>自定义一个配置文件： <code>CONFIG_PATH</code> ，可以使用默认的文件 <a href=\"https://github.com/javirandor/passbert/blob/main/configs/passgpt-16chars.yaml\">yaml 文件</a>.</li>\n<li>训练模型：<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python src/train_passgpt.py --config_path &#123;CONFIG_PATH&#125;</span><br><span class=\"line\"><span class=\"comment\"># Customization</span></span><br><span class=\"line\">python src/train_passgpt.py --config_path configs/passgpt-16chars.yaml</span><br></pre></td></tr></table></figure></li>\n<li>模型使用<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python src/generate_passwords.py --model_path &#123;MODEL_PATH&#125; --out_path &#123;PASSWORD_OUTPUT_FOLDER&#125; --num_generate &#123;NUM_PASSWORDS&#125; --train_data_path &#123;PATH_TO_TRAINING_DATA&#125; --eval_data_path &#123;PATH_TO_EVAL_DATA&#125;</span><br><span class=\"line\"><span class=\"comment\"># Customizeation</span></span><br><span class=\"line\"> python src/generate_passwords.py --model_path train_output/last/ --out_path ./train_output/last/ --num_generate <span class=\"number\">100000000</span> --train_data_path data/rockyou.txt --eval_data_path data/rockyou.txt --tokenizer_path output/byte_bpe_tokenizer_99/</span><br></pre></td></tr></table></figure>\n 进一步的生成参数，例如“–temper”、“–top_p”或“–top_k”</li>\n</ol>\n<h1 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h1><p>conda + python3.11<br>requirements.txt</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">accelerate==0.28.0</span><br><span class=\"line\">aiohttp==3.9.3</span><br><span class=\"line\">aiosignal==1.3.1</span><br><span class=\"line\">appdirs==1.4.4</span><br><span class=\"line\">asttokens==2.4.1</span><br><span class=\"line\">attrs==23.2.0</span><br><span class=\"line\">azure-core==1.30.1</span><br><span class=\"line\">azure-storage-blob==12.19.1</span><br><span class=\"line\">certifi==2024.2.2</span><br><span class=\"line\">cffi==1.16.0</span><br><span class=\"line\">charset-normalizer==3.3.2</span><br><span class=\"line\">click==8.1.7</span><br><span class=\"line\">comm==0.2.1</span><br><span class=\"line\">cryptography==42.0.5</span><br><span class=\"line\">datasets==2.18.0</span><br><span class=\"line\">debugpy==1.6.7</span><br><span class=\"line\">decorator==5.1.1</span><br><span class=\"line\">dill==0.3.8</span><br><span class=\"line\">docker-pycreds==0.4.0</span><br><span class=\"line\">exceptiongroup==1.2.0</span><br><span class=\"line\">executing==2.0.1</span><br><span class=\"line\">filelock==3.13.1</span><br><span class=\"line\">frozenlist==1.4.1</span><br><span class=\"line\">fsspec==2024.2.0</span><br><span class=\"line\">gitdb==4.0.11</span><br><span class=\"line\">GitPython==3.1.42</span><br><span class=\"line\">huggingface-hub==0.21.4</span><br><span class=\"line\">idna==3.6</span><br><span class=\"line\">importlib_metadata==7.0.2</span><br><span class=\"line\">ipykernel==6.29.3</span><br><span class=\"line\">ipython==8.22.2</span><br><span class=\"line\">isodate==0.6.1</span><br><span class=\"line\">jedi==0.19.1</span><br><span class=\"line\">Jinja2==3.1.3</span><br><span class=\"line\">joblib==1.3.2</span><br><span class=\"line\">jsonlines==4.0.0</span><br><span class=\"line\">jupyter_client==8.6.0</span><br><span class=\"line\">jupyter_core==5.7.1</span><br><span class=\"line\">lamini==2.1.2</span><br><span class=\"line\">lamini-configuration==0.8.3</span><br><span class=\"line\">MarkupSafe==2.1.5</span><br><span class=\"line\">matplotlib-inline==0.1.6</span><br><span class=\"line\">mpmath==1.3.0</span><br><span class=\"line\">multidict==6.0.5</span><br><span class=\"line\">multiprocess==0.70.16</span><br><span class=\"line\">nest_asyncio==1.6.0</span><br><span class=\"line\">networkx==3.2.1</span><br><span class=\"line\">numpy==1.26.4</span><br><span class=\"line\">packaging==24.0</span><br><span class=\"line\">pandas==2.2.1</span><br><span class=\"line\">parso==0.8.3</span><br><span class=\"line\">pexpect==4.9.0</span><br><span class=\"line\">pickleshare==0.7.5</span><br><span class=\"line\">pip==23.3.1</span><br><span class=\"line\">platformdirs==4.2.0</span><br><span class=\"line\">prompt-toolkit==3.0.42</span><br><span class=\"line\">protobuf==4.25.3</span><br><span class=\"line\">psutil==5.9.0</span><br><span class=\"line\">ptyprocess==0.7.0</span><br><span class=\"line\">pure-eval==0.2.2</span><br><span class=\"line\">pyarrow==15.0.1</span><br><span class=\"line\">pyarrow-hotfix==0.6</span><br><span class=\"line\">pycparser==2.21</span><br><span class=\"line\">Pygments==2.17.2</span><br><span class=\"line\">python-dateutil==2.9.0</span><br><span class=\"line\">pytz==2024.1</span><br><span class=\"line\">PyYAML==6.0.1</span><br><span class=\"line\">pyzmq==25.1.2</span><br><span class=\"line\">regex==2023.12.25</span><br><span class=\"line\">requests==2.31.0</span><br><span class=\"line\">safetensors==0.4.2</span><br><span class=\"line\">scikit-learn==1.4.1.post1</span><br><span class=\"line\">scipy==1.12.0</span><br><span class=\"line\">sentry-sdk==1.43.0</span><br><span class=\"line\">setproctitle==1.3.3</span><br><span class=\"line\">setuptools==68.2.2</span><br><span class=\"line\">six==1.16.0</span><br><span class=\"line\">smmap==5.0.1</span><br><span class=\"line\">stack-data==0.6.2</span><br><span class=\"line\">sympy==1.12</span><br><span class=\"line\">threadpoolctl==3.3.0</span><br><span class=\"line\">tokenizers==0.15.2</span><br><span class=\"line\">torch==2.2.1</span><br><span class=\"line\">tornado==6.3.3</span><br><span class=\"line\">tqdm==4.66.2</span><br><span class=\"line\">traitlets==5.14.1</span><br><span class=\"line\">transformers==4.38.2</span><br><span class=\"line\">triton==2.2.0</span><br><span class=\"line\">typing_extensions==4.10.0</span><br><span class=\"line\">tzdata==2024.1</span><br><span class=\"line\">urllib3==2.2.1</span><br><span class=\"line\">wandb==0.16.4</span><br><span class=\"line\">wcwidth==0.2.13</span><br><span class=\"line\">wheel==0.41.2</span><br><span class=\"line\">xxhash==3.4.1</span><br><span class=\"line\">yarl==1.9.4</span><br><span class=\"line\">zipp==3.17.0</span><br></pre></td></tr></table></figure>\n<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><h2 id=\"问题：-‘utf-8’-解析出错\"><a href=\"#问题：-‘utf-8’-解析出错\" class=\"headerlink\" title=\"问题： ‘utf-8’ 解析出错\"></a>问题： ‘utf-8’ 解析出错</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(args.train_path, <span class=\"string\">&quot;r&quot;</span>, encoding=<span class=\"string\">&quot;utf-8&quot;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># with open(args.train_path, &quot;r&quot;, encoding=&quot;utf-8&quot;, errors=&#x27;replace&#x27;) as f:</span></span><br><span class=\"line\"></span><br><span class=\"line\">        lines = f.read().splitlines()</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>UnicodeDecodeError: ‘utf-8’ codec can’t decode byte 0xf1 in position 5079963: invalid continuation byte</p>\n</blockquote>\n<p>解决1：使用默认字符替换，默认是 “?”。<br><code>with open(args.train_path, &quot;r&quot;, encoding=&quot;utf-8&quot;, errors=&#39;replace&#39;) as f</code></p>\n<p>解决2：定位到没有解析的字符行，重新输入</p>\n<h2 id=\"问题：-包缺失\"><a href=\"#问题：-包缺失\" class=\"headerlink\" title=\"问题： 包缺失\"></a>问题： 包缺失</h2><figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  File &quot;/opt/conda/envs/py3_11/lib/python3.11/site-packages/transformers/training_args.py&quot;, line 1905, in _setup_devices</span><br><span class=\"line\">    raise ImportError(</span><br><span class=\"line\">ImportError: Using the `Trainer` with `PyTorch` requires `accelerate&gt;=0.21.0`: Please run `pip install transformers[torch]` or `pip install accelerate -U`</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File &quot;/root/PSG/passgpt-main/src/train_passgpt.py&quot;, line 120, in &lt;module&gt;</span><br><span class=\"line\">    trainer = Trainer(</span><br><span class=\"line\">              ^^^^^^^^</span><br><span class=\"line\">  File &quot;/opt/conda/envs/py3_11/lib/python3.11/site-packages/transformers/trainer.py&quot;, line 533, in __init__</span><br><span class=\"line\">    self.callback_handler = CallbackHandler(</span><br><span class=\"line\">                            ^^^^^^^^^^^^^^^^</span><br><span class=\"line\">  File &quot;/opt/conda/envs/py3_11/lib/python3.11/site-packages/transformers/trainer_callback.py&quot;, line 313, in __init__</span><br><span class=\"line\">    self.add_callback(cb)</span><br><span class=\"line\">  File &quot;/opt/conda/envs/py3_11/lib/python3.11/site-packages/transformers/trainer_callback.py&quot;, line 330, in add_callback</span><br><span class=\"line\">    cb = callback() if isinstance(callback, type) else callback</span><br><span class=\"line\">         ^^^^^^^^^^</span><br><span class=\"line\">  File &quot;/opt/conda/envs/py3_11/lib/python3.11/site-packages/transformers/integrations/integration_utils.py&quot;, line 673, in __init__</span><br><span class=\"line\">    raise RuntimeError(&quot;WandbCallback requires wandb to be installed. Run `pip install wandb`.&quot;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"问题：显存不够\"><a href=\"#问题：显存不够\" class=\"headerlink\" title=\"问题：显存不够\"></a>问题：显存不够</h2><figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">torch.cuda.OutOfMemoryError: CUDA out of memory. Tried to allocate 288.00 MiB. GPU 0 has a total capacity of 10.75 GiB of which 44.62 MiB is free. Process 1338858 has 10.69 GiB memory in use.</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>换服务器，当前服务器显卡资源不足：<br>![[Pasted image 20240322093550.png]]</p>\n</li>\n<li><p>新服务器<br>![[Pasted image 20240322093300.png]]</p>\n</li>\n</ol>\n<h2 id=\"问题：-显示-Driver-Version-过低\"><a href=\"#问题：-显示-Driver-Version-过低\" class=\"headerlink\" title=\"问题： 显示 Driver Version 过低\"></a>问题： 显示 Driver Version 过低</h2><p>（导致训练时不能使用 GPU）<br>    此时不一定是 Driver Version 版本的问题，在实际中只要 显卡 显卡驱动兼容，那么就可以使用显卡跑程序。<br>    通过 降低 pytorch 的版本到 2.0.0 ，成功运行。</p>\n<p>![[Pasted image 20240322011742.png]]</p>\n<p>![[Pasted image 20240322091910.png]]</p>\n<h1 id=\"当前的进度\"><a href=\"#当前的进度\" class=\"headerlink\" title=\"当前的进度\"></a>当前的进度</h1><p>目前的进度： PassGPT 训练过程结束（最大字符 长度 设置为 10）</p>\n<p>![[Pasted image 20240322102651.png]]</p>\n<p>当前实验存在的问题：<br>运行模型 需要 的配置较高。<br><a href=\"https://zhuanlan.zhihu.com/p/673125345\">模型显存需求估计</a></p>\n<h1 id=\"下一步计划\"><a href=\"#下一步计划\" class=\"headerlink\" title=\"下一步计划\"></a>下一步计划</h1><p>之前是跑了模型的训练部分，下一步就是使用模型生成密码，并且分析数据。</p>\n<p>计划的实验目标是：<br>    1. 论文中没有提到只是说生成一定的数量的密码之后对测试数据集的覆盖率达到了多少，但是并没有提到那些 类型数据 是模型难以拟合的，我主要想看一下哪些没有匹配到的密码长什么样子。<br>    2. 对比以下 开源的预训练 10 字符 模型 和 此次训练的模型的效果，验证一下论文的效果。</p>\n<p>目前的一个小 idea，参考 [[MoEs]] ，但了解还比较粗浅。</p>\n<p>最后感觉论文读的还是太少了，需要接着调研论文 </p>\n<p>模型运行结果：<a href=\"https://wandb.ai/xinka/huggingface/runs/f4ta95w4?nw=nwuserfengdreamin\">https://wandb.ai/xinka/huggingface/runs/f4ta95w4?nw=nwuserfengdreamin</a></p>\n"},{"_content":"\n\t\n# 常见库\n## Flag 包\n### flag包基本使用\n[官方文档](https://studygolang.com/pkgdoc)]\n[参考文档](https://www.liwenzhou.com/posts/Go/flag/)\n\n\n#### 导入flag包\n\n```go\nimport flag\n```\n\n#### flag参数类型\n\nflag包支持的命令行参数类型有`bool`、`int`、`int64`、`uint`、`uint64`、`float` `float64`、`string`、`duration`。\n\n| flag参数     | 有效值                                                                          |\n| ---------- | ---------------------------------------------------------------------------- |\n| 字符串flag    | 合法字符串                                                                        |\n| 整数flag     | 1234、0664、0x1234等类型，也可以是负数。                                                  |\n| 浮点数flag    | 合法浮点数                                                                        |\n| bool类型flag | 1, 0, t, f, T, F, true, false, TRUE, FALSE, True, False。                     |\n| 时间段flag    | 任何合法的时间段字符串。如\"300ms\"、\"-1.5h\"、“2h45m”。合法的单位有\"ns\"、“us” /“µs”、“ms”、“s”、“m”、“h”。 |\n\n#### 定义命令行flag参数\n\n有以下两种常用的定义命令行`flag`参数的方法。\n\n### flag.Type()\n\n基本格式如下：\n\n`flag.Type(flag名, 默认值, 帮助信息)*Type` 例如我们要定义姓名、年龄、婚否三个命令行参数，我们可以按如下方式定义：\n\n```go\nname := flag.String(\"name\", \"张三\", \"姓名\")\nage := flag.Int(\"age\", 18, \"年龄\")\nmarried := flag.Bool(\"married\", false, \"婚否\")\ndelay := flag.Duration(\"d\", 0, \"时间间隔\")\n```\n\n需要注意的是，此时`name`、`age`、`married`、`delay`均为对应类型的指针。\n\n#### flag.TypeVar()\n\n基本格式如下： `flag.TypeVar(Type指针, flag名, 默认值, 帮助信息)` 例如我们要定义姓名、年龄、婚否三个命令行参数，我们可以按如下方式定义：\n\n```go\nvar name string\nvar age int\nvar married bool\nvar delay time.Duration\nflag.StringVar(&name, \"name\", \"张三\", \"姓名\")\nflag.IntVar(&age, \"age\", 18, \"年龄\")\nflag.BoolVar(&married, \"married\", false, \"婚否\")\nflag.DurationVar(&delay, \"d\", 0, \"时间间隔\")\n```\n\n#### flag.Parse()\n\n通过以上两种方法定义好命令行flag参数后，需要通过调用`flag.Parse()`来对命令行参数进行解析。\n\n支持的命令行参数格式有以下几种：\n\n- `-flag xxx` （使用空格，一个`-`符号）\n- `--flag xxx` （使用空格，两个`-`符号）\n- `-flag=xxx` （使用等号，一个`-`符号）\n- `--flag=xxx` （使用等号，两个`-`符号）\n\n其中，布尔类型的参数必须使用等号的方式指定。\n\nFlag解析在第一个非flag参数（单个\"-“不是flag参数）之前停止，或者在终止符”–“之后停止。\n\n#### flag其他函数\n\n```go\nflag.Args()  ////返回命令行参数后的其他参数，以[]string类型\nflag.NArg()  //返回命令行参数后的其他参数个数\nflag.NFlag() //返回使用的命令行参数个数\n```\n\n#### 完整示例\n\n##### 定义\n\n```go\nfunc main() {\n\t//定义命令行参数方式1\n\tvar name string\n\tvar age int\n\tvar married bool\n\tvar delay time.Duration\n\tflag.StringVar(&name, \"name\", \"张三\", \"姓名\")\n\tflag.IntVar(&age, \"age\", 18, \"年龄\")\n\tflag.BoolVar(&married, \"married\", false, \"婚否\")\n\tflag.DurationVar(&delay, \"d\", 0, \"延迟的时间间隔\")\n\n\t//解析命令行参数\n\tflag.Parse()\n\tfmt.Println(name, age, married, delay)\n\t//返回命令行参数后的其他参数\n\tfmt.Println(flag.Args())\n\t//返回命令行参数后的其他参数个数\n\tfmt.Println(flag.NArg())\n\t//返回使用的命令行参数个数\n\tfmt.Println(flag.NFlag())\n}\n```\n\n##### 使用\n\n命令行参数使用提示：\n\n```bash\n$ ./flag_demo -help\nUsage of ./flag_demo:\n  -age int\n        年龄 (default 18)\n  -d duration\n        时间间隔\n  -married\n        婚否\n  -name string\n        姓名 (default \"张三\")\n```\n\n正常使用命令行flag参数：\n\n```bash\n$ ./flag_demo -name 沙河娜扎 --age 28 -married=false -d=1h30m\n沙河娜扎 28 false 1h30m0s\n[]\n0\n4\n```\n\n使用非flag命令行参数：\n\n```bash\n$ ./flag_demo a b c\n张三 18 false 0s\n[a b c]\n3\n0\n```\n\n\n\n\n## Log 包\n日志相关，[参考](ttps://blog.csdn.net/cold___play/article/details/130744302)\n\n### 基本结构\n常量列表：\n\n- Ldate         日期 年/月/日\n- Ltime         时间 时:分:秒\n- Lmicroseconds 时间 .毫秒于Ltime之后\n- Llongfile     完整文件名:行号\n- Lshortfile    文件名，此标志位优先于 Llongfile\n- LstdFlags     = Ldate 并且 Ltime\n\n功能说明：标志位常量控制日志格式。\n\n示例：\n```go\nfunc main() {\n\tlog.SetFlags(log.Lshortfile | log.LstdFlags)\n\tlog.Println(\"log:\") //2023/05/18 12:09:57 constantsDemo.go:15: log:\n}\n```\n\n函数列表:\n```go\nfunc Fatal(v ...interface{})\nfunc Fatalf(format string, v ...interface{})\nfunc Fatalln(v ...interface{})\nfunc Flags() int\nfunc Panic(v ...interface{})\nfunc Panicf(format string, v ...interface{})\nfunc Panicln(v ...interface{})\nfunc Prefix() string\nfunc Print(v ...interface{})\nfunc Printf(format string, v ...interface{})\nfunc Println(v ...interface{})\nfunc SetFlags(flag int)\nfunc SetOutput(w io.Writer)\nfunc SetPrefix(prefix string)\nfunc New(out io.Writer, prefix string, flag int) *Logger\nfunc (l *Logger) Fatal(v ...interface{})\nfunc (l *Logger) Fatalf(format string, v ...interface{})\nfunc (l *Logger) Fatalln(v ...interface{})\nfunc (l *Logger) Flags() int\nfunc (l *Logger) Output(calldepth int, s string) error\nfunc (l *Logger) Panic(v ...interface{})\nfunc (l *Logger) Panicf(format string, v ...interface{})\nfunc (l *Logger) Panicln(v ...interface{})\nfunc (l *Logger) Prefix() string\nfunc (l *Logger) Print(v ...interface{})\nfunc (l *Logger) Printf(format string, v ...interface{})\nfunc (l *Logger) Println(v ...interface{})\nfunc (l *Logger) SetFlags(flag int)\nfunc (l *Logger) SetPrefix(prefix string)\n```\n### 自定义 logger:\n```go\nfunc New(out io.Writer, prefix string, flag int) *Logger\n```\n参数列表：\n\tout 输出目标\n\tprefix 输出前缀\n\tflag 格式配置标识值\n返回值：\n\t自定义的logger\n功能说明：\n\t这个方法用来自定义logger，指定输出目标、格式等\n示例：\n```go\nfunc main() {\n\tl := log.New(os.Stderr, \"logger\", log.Ldate)\n\tl.Println(\"log to stderr sample\")//logger2023/05/18 log to stderr sample\n}\n```\n\n###  Fatal系列函数\n#### 1.1 func Fatal(v …interface{})\n参数列表：\n\tv 待输出参数列表\n返回值：\n\t无\n功能说明：\n\t打印日志并退出。相当于调用Print()并os.Exit(1)\n#### 1.2 func Fatalf(format string, v …interface{})\n参数列表：\n\tformat 输出格式\n\tv 带输出参数列表\n返回值：\n\t无\n功能说明：\n\t按格式输出日志，并退出。相当于调用Printf()并调用os.Exit(1)\n#### 1.3 func Fatalln(v …interface{})\n参数列表：\n\tv\n返回值：\n\t无\n功能说明：\n\t打印一行日志并退出。相当于调用Println()并os.Exit(1)\n#### 1.4 func (l \\*Logger) Fatal(v …interface{})\n参数列表：\n\tv 待输出参数列表\n返回值：\n\t无\n功能说明：\n\t打印日志并退出。相当于调用l.Print()并os.Exit(1)\n#### 1.5 func Fatalf(format string, v …interface{})\n参数列表：\n\tformat 输出格式\n\tv 带输出参数列表\n返回值：\n\t无\n功能说明：\n\t按格式输出日志，并退出。相当于调用l.Printf()并调用os.Exit(1)\n#### 1.6 func (l \\*Logger) Fatalln(v …interface{})\n参数列表：\n\tv\n返回值：\n\t无\n功能说明：\n\t打印一行日志并退出。相当于调用l.Println()并os.Exit(1)\n#### 示例\n```go\n\n\nfunc main() {\n\tage := 25\n\tlog.Fatal(\"Hi & Bye ! Age = \", age) // this will print \"Hi & Bye ! Age = 25\"\n\tlog.Println(\"This will not be called.\")\n\n\tname := \"golang\"\n\tlog.Fatalf(\"%8d,%8s\", 23, name) //2013/03/10 16:08:49       23,  golang\n\n\tlog.Fatalln(\"bye!\") //2013/03/10 16:14:54 bye!\\n\n\n\tl := log.New(os.Stdout, \"\", log.LstdFlags)\n\tage = 25\n\tl.Fatal(\"Hi & Bye ! Age = \", age) // this will print \"Hi & Bye ! Age = 25\"\n\tl.Println(\"This will not be called.\")\n\n\tl = log.New(os.Stdout, \"\", log.LstdFlags)\n\t//l.Fatalf(\"%s\", \"hello\")\n\tname = \"golang\"\n\tl.Fatalf(\"%8d,%8s\", 23, name) //2013/03/10 16:08:49       23,  golang\n\n\tl = log.New(os.Stdout, \"\", log.LstdFlags)\n\tl.Fatalln(\"bye!\") //2013/03/10 16:14:54 bye!\\n\n}\n```\n### Flags系列函数\n#### 2.1 func Flags() int\n参数列表：\n\t无\n返回值：\n\t默认logger的配置值\n功能说明：\n\t返回默认logger配置值。\n#### 2.2 func (l \\*Logger) Flags() int\n参数列表：\n\t无\n返回值：\n\t当前logger的配置值\n功能说明：\n\t返回当前logger配置值。\n#### 2.3 func SetFlags(flag int)\n参数列表：\n\tflag logger配置值\n返回值：\n\t无\n功能说明：\n\t这个方法用来设置标准logger的配置，默认为3（logger.LstdFlags）\n#### 2.4 func (l \\*Logger) SetFlags(flag int)\n参数列表：\n\tflag logger配置值\n返回值：\n\t无\n功能说明：\n\t这个方法用来设置标准logger的配置，默认为3（logger.LstdFlags）\n#### 示例\n```go\nfunc main() {\n\tfmt.Println(\"standard flags :\", log.Flags()) //standard flags : 3\n\t//the flags constants\n\tfmt.Println(log.Ldate)         //1\n\tfmt.Println(log.Ltime)         //2\n\tfmt.Println(log.Lmicroseconds) //4\n\tfmt.Println(log.Llongfile)     //8\n\tfmt.Println(log.Lshortfile)    //16\n\tfmt.Println(log.LstdFlags)     //LstdFlags     = Ldate | Ltime   3\n\n\tl := log.New(os.Stdout, \"\", log.LstdFlags)\n\tfmt.Println(\"logger l's flags :\", l.Flags()) //logger l's flags : 3\n\n\tlog.Println(log.Flags()) //2013/03/10 17:46:53 3\n\tlog.SetFlags(log.Ldate)\n\tlog.Println(log.Flags()) //2013/03/10 1\n\tlog.SetFlags(log.LstdFlags | log.Lshortfile)\n\tlog.Println(log.Flags()) //2013/03/10 17:46:53 setflags.go:17: 19\n\n\tl = log.New(os.Stdout, \"\", log.LstdFlags)\n\tl.Println(l.Flags()) //2013/03/10 17:46:53 3\n\tl.SetFlags(log.Ldate)\n\tl.Println(l.Flags()) //2013/03/10 1\n\tl.SetFlags(log.LstdFlags | log.Lshortfile)\n\tl.Println(l.Flags()) //2013/03/10 17:46:53 setflags.go:17: 19\n}\n```\n\n### Panic系列函数\n#### 3.1 func (l \\*Logger) Panic(v …interface{})\n参数列表：\n\tv 待输出参数列表\n返回值：\n\t无\n功能说明：\n\t这个方法相当于调用l.Print()及panic()\n#### 3.2 func (l \\*Logger) Panicf(format string, v …interface{})\n参数列表：\n\tformat 输出格式\n\tv 待输出参数列表\n返回值：\n\t无\n功能说明：\n\t相当于调用l.Printf()，之后调用panic()\n#### 3.3 func (l \\*Logger) Panicln(v …interface{})\n参数列表：\n\tv 待输出参数列表\n返回值：\n\t无\n功能说明：\n\t相当于调用l.Println()并调用panic()\n#### 3.4 func Panic(v …interface{})\n参数列表：\n\tv 待输出参数列表\n返回值：\n\t无\n功能说明：\n\t这个方法相当于调用Print()及panic()\n#### 3.5 func Panicf(format string, v …interface{})\n参数列表：\n\tformat 输出格式\n\tv 待输出参数列表\n返回值：\n\t- 无\n功能说明：\n\t相当于调用Printf()，之后调用panic()\n#### 3.6 func Panicln(v …interface{})\n参数列表：\n\tv 待输出参数列表\n返回值：\n\t无\n功能说明：\n\t相当于调用Println()并调用panic()\n#### 示例\n```go\nfunc main() {\n\tl := log.New(os.Stdout, \"\", log.LstdFlags)\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tfmt.Println(err) //output : \"call panic and stop\"\n\t\t\thandleException()\n\t\t}\n\t}()\n\tl.Panic(\"call panic and stop\")\n\tlog.Println(\"this will not be called.\")\n\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tif err == \"3q\" {\n\t\t\t\tlog.Println(\"you are welcome\")\n\t\t\t}\n\t\t}\n\t}()\n\tl = log.New(os.Stdout, \"\", log.LstdFlags)\n\tl.Panicf(\"%d%s\", 3, \"q\")\n\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tif err == \"3q\\n\" {\n\t\t\t\tlog.Println(\"you are welcome\")\n\t\t\t}\n\t\t}\n\t}()\n\tl = log.New(os.Stdout, \"\", log.LstdFlags)\n\tl.Panicln(\"3q\")\n}\n\nfunc handleException() {\n\tlog.Println(\"recovering...\")\n}\n```\n\n### Print系列函数\n#### 4.1 func (l \\*Logger) Print(v …interface{})\n参数列表：\n\tv 待输出参数列表\n返回值：\n\t无\n功能说明：\n\t输出日志到logger。参数处理方式同fmt.Print\n#### 4.2 func (l \\*Logger) Printf(format string, v …interface{})\n参数列表：\n\tformat 输出格式\n\tv 待输出参数列表\n返回值：\n\t无\n功能说明：\n\t调用l.Output输出日志到logger l。参数处理方式同fmt.Printf\n#### 4.3 func (l \\*Logger) Println(v …interface{})\n参数列表：\n\tv 待输出参数列表\n返回值：\n\t无\n功能说明：\n\t调用Output打印日志到当前logger，参数处理方式同fmt.Println\n####  4.4 func Print(v …interface{})\n参数列表：\n\tv 待输出参数列表\n返回值：\n\t无\n功能说明：\n\t输出日志到标准logger。参数处理方式同fmt.Print\n#### 4.5 func Printf(format string, v …interface{})\n参数列表：\n\tformat 输出格式\n\tv 待输出参数列表\n返回值：\n\t无\n功能说明：\n\t调用Output输出日志到标准logger。参数处理方式同fmt.Printf\n#### 4.6 func Println(v …interface{})\n参数列表：\n\tv\n返回值：\n\t无\n功能说明：\n\t调用Output打印日志到标准logger，参数处理方式同fmt.Println\n#### 示例\n```go\nfunc main() {\n\tl := log.New(os.Stdout, \"\", log.LstdFlags)\n\tl.Print(\"string\", 1, 2.3) //2013/03/10 17:26:06 string1 2.3\n\n\tl = log.New(os.Stdout, \"\", log.LstdFlags)\n\tl.Printf(\"%s\", \"hello\") //hello\n\tname := \"golang\"\n\tl.Printf(\"%8d,%8s\", 23, name) //2013/03/10 16:08:49       23,  golang\n\n\tl = log.New(os.Stdout, \"\", log.LstdFlags)\n\tl.Println(\"hello\") //2013/03/10 17:35:28 hello\\n\n\n\tlog.Print(\"string\", 1, 2.3) //2013/03/10 17:26:06 string1 2.3\n\n\tlog.Printf(\"%s\", \"hello\") //hello\n\tname = \"golang\"\n\tlog.Printf(\"%8d,%8s\", 23, name) //2013/03/10 16:08:49       23,  golang\n\n\tlog.Println(\"hello\") //2013/03/10 17:35:28 hello\\n\n}\n```\n\n### 其它函数\n#### 5.1 func (l \\*Logger) Prefix() string\n参数列表：\n\t无\n返回值：\n\tlogger前缀，字符串类型\n功能说明：\n\t返回当前logger的输出前缀\n#### 5.2 func Prefix() string\n参数列表：\n\t无\n返回值：\n\t标准logger前缀，字符串类型\n功能说明：\n\t返回标准logger的输出前缀\n#### 5.3 func SetPrefix(prefix string)\n参数列表：\n\tprefix 前缀\n返回值：\n\t无\n功能说明：\n\t设置logger的输出前缀\n#### 5.4 func SetPrefix(prefix string)\n参数列表：\n\tprefix 前缀\n返回值：\n\t无\n功能说明：\n\t设置logger的输出前缀\n#### 5.5 func (l \\*Logger) Output(calldepth int, s string) error\n参数列表：\n\tcalldepth 深度\n\ts 字符串\n返回值：\n\terror 错误\n功能说明：\n\t输出日志事件。字符串s包含待打印内容，跟在预定义的prefix后面，并且根据flags设置会有区分。如果s末尾没有换行符，这个方法会默认加上一个。calldepth目前预定义均为2,以后会用来支持通用场景，支持其他值配置。（本人注：日志输出不建议直接使用该方法）\n#### 5.6 func SetOutput(w io.Writer)\n参数列表：\n\tw 目标流，io.Writer类型\n返回值：\n\t无\n功能说明：\n\t设置标准logger的输出目标\n#### 示例\n```go\nfunc main() {\n\tl := log.New(os.Stdout, \"\", log.LstdFlags)\n\tfmt.Print(l.Prefix()) //this will print nothing\n\tl.Println(1)          //2013/03/10 17:02:05 1\n\tl.SetPrefix(\"log:\")\n\tfmt.Println(l.Prefix()) //log:\n\tl.Println(2)            //log:2013/03/10 17:02:05 2\n\n\tfmt.Print(log.Prefix()) //this will print nothing\n\tlog.Println(1)          //2013/03/10 17:02:05 1\n\tlog.SetPrefix(\"log:\")\n\tfmt.Println(log.Prefix()) //log:\n\tlog.Println(2)            //log:2013/03/10 17:02:05 2\n\n\tl = log.New(os.Stdout, \"\", log.LstdFlags)\n\tfmt.Print(l.Prefix()) //this will print nothing\n\tl.Println(1)          //2013/03/10 17:02:05 1\n\tl.SetPrefix(\"log:\")\n\tfmt.Println(l.Prefix()) //log:\n\n\tl.Println(2) //log:2013/03/10 17:02:05 2\n\n\tfmt.Print(log.Prefix()) //this will print nothing\n\tlog.Println(1)          //2013/03/10 17:02:05 1\n\tlog.SetPrefix(\"log:\")\n\tfmt.Println(log.Prefix()) //log:\n\tlog.Println(2)            //log:2013/03/10 17:02:05 2\n\n\tl = log.New(os.Stdout, \"log->\", log.Ldate)\n\tl.Output(2, \"log output\")\n\n\tfile, err := os.OpenFile(\"sample.txt\", os.O_WRONLY, 0666)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer file.Close()\n\tlog.SetOutput(file)\n\tlog.Println(\"log to file\")\n}\n```\n\n\n## Badger 包\n[参考](https://juejin.cn/post/6844903814571491335)\n[官方文档](https://pkg.go.dev/github.com/dgraph-io/badger#Txn)\nbadger是一个纯Go实现的快速的嵌入式K/V数据库，针对LSM tree做了优化。\n### 安装\n\n`$ go get github.com/dgraph-io/badger/...`\n\n### 数据库\n\n打开一个数据库\n\n```go\nopts := badger.DefaultOptions\nopts.Dir = \"/tmp/badger\" \nopts.ValueDir = \"/tmp/badger\" \ndb, err := badger.Open(opts) \nif err != nil {\n\tlog.Fatal(err) \n} \ndefer db.Close()\n```\n### 存储\n\n#### 存储kv\n\n使用 Txn.Set()方法\n\n```go\nerr := db.Update(func(txn *badger.Txn) error {   \n\terr := txn.Set([]byte(\"answer\"), []byte(\"42\"))   \n\treturn err \n})\n```\n#### 批量设置\n```go\nwb := db.NewWriteBatch() \ndefer wb.Cancel() \nfor i := 0; i < N; i++ {\n\terr := wb.Set(key(i), value(i), 0) // Will create txns as needed. \n\thandle(err) \n} \nhandle(wb.Flush()) // Wait for all txns to finish.\n```\nWriteBatch不允许任何读取。对于读-修改-写，应该使用事务API。\n\n##### 设置生存时间 TTL\n\nBadger 允许在键上设置一个可选的生存时间 (TTL) 值。一旦 TTL 结束，KEY 将不再是可检索的，并且将进行垃圾收集。TTL 可以使用 Txn.SetWithTTL() 设置为一个`time.Duration`的值\n\n##### 设置元数据\n\n`Txn.SetWithMeta()` 设置用户元数据\n\n使用 `Txn.SetEntry()` 可以一次性设置 key, value, user metatadata 和 TTL\n\n##### 遍历 keys\n\n要遍历键，我们可以使用迭代器，可以使用 `Txn.NewIterator()`方法获得迭代器。迭代按字节字典排序顺序进行。\n```go\nerr := db.View(func(txn *badger.Txn) error { // badger 的 view 方法创建一个只读事务\n\topts := badger.DefaultIteratorOptions   \n\topts.PrefetchSize = 10   \n\tit := txn.NewIterator(opts)   \n\tdefer it.Close()   \n\tfor it.Rewind(); it.Valid(); it.Next() {\n\t    item := it.Item() \n\t    k := item.Key()     \n\t    err := item.Value(func(v []byte) error {\n\t        fmt.Printf(\"key=%s, value=%s\\n\", k, v)       \n\t        return nil     \n\t        })     \n\t    if err != nil {       \n\t\t    return err\n\t\t}   \n\t}   \n\treturn nil \n})\n```\n###### 前缀扫描\n\n要遍历键前缀，可以将 Seek() 和 ValidForPrefix() 组合使用：（这里的前缀是键值的）\n```go\ndb.View(func(txn *badger.Txn) error {\n\tit := txn.NewIterator(badger.DefaultIteratorOptions)\n\tdefer it.Close()   \n\tprefix := []byte(\"1234\")   \n\tfor it.Seek(prefix); it.ValidForPrefix(prefix); it.Next() {\n\t\titem := it.Item()    \n\t\tk := item.Key()     \n\t\terr := item.Value(func(v []byte) error {\n\t\t\tfmt.Printf(\"key=%s, value=%s\\n\", k, v)       \n\t\t\treturn nil     \n\t\t})     \n\t\tif err != nil {       \n\t\t\treturn err     \n\t\t}   \n\t}   \n\treturn nil \n})\n```\n###### 键的遍历\n\nBadger支持一种独特的迭代模式，称为只有键的迭代。它比常规迭代快几个数量级，因为它只涉及对 lsm 树的访问，而 lsm 树通常完全驻留在 RAM 中。要启用只有键的迭代，您需要设置 IteratorOptions 。PrefetchValues 字段为 false 。这还可以用于在迭代期间对选定的键执行稀疏读取，只在需要时调用 item.Value() 。(获取键，而不获取对应的值)\n```go\nerr := db.View(func(txn *badger.Txn) error {   \n\topts := badger.DefaultIteratorOptions   \n\topts.PrefetchValues = false   \n\tit := txn.NewIterator(opts)   \n\tdefer it.Close()   \n\tfor it.Rewind(); it.Valid(); it.Next() {\n\t\titem := it.Item()     \n\t\tk := item.Key()     \n\t\tfmt.Printf(\"key=%s\\n\", k)   \n\t}   \n\treturn nil \n})\n```\n\n### 数据流\n\nBadger 提供了一个流框架，它可以并发地遍历数据库的全部或部分，将数据转换为自定义键值，并连续地将数据流输出，以便通过网络发送、写入磁盘，甚至写入 Badger。这是比使用单个迭代器更快的遍历 Badger 的方法。Stream 在管理模式和正常模式下都支持Badger 。\n```go\nstream := db.NewStream() \n// db.NewStreamAt(readTs) for managed mode. \n// -- Optional settings \nstream.NumGo = 16          // Set number of goroutines to use for iteration.\nstream.Prefix = []byte(\"some-prefix\") // Leave nil for iteration over the whole DB. \nstream.LogPrefix = \"Badger.Streaming\" // For identifying stream logs. Outputs to Logger. \n// ChooseKey is called concurrently for every key. If left nil, assumes true by default. \nstream.ChooseKey = func(item *badger.Item) bool {   \n\treturn bytes.HasSuffix(item.Key(), []byte(\"er\")) \n\t// 这个例子中判断后缀 “er” \n} \n// KeyToList is called concurrently for chosen keys. This can be used to convert \n// Badger data into custom key-values. If nil, uses stream.ToList, a default \n// implementation, which picks all valid key-values. \nstream.KeyToList = nil \n// -- End of optional settings. \n// Send is called serially, while Stream.Orchestrate is running. 用于序列化并处理流操作的结果\nstream.Send = func(list *pb.KVList) error {   \n\treturn proto.MarshalText(w, list) // Write to w. \n\t} \n// Run the stream \nif err := stream.Orchestrate(context.Background()); err != nil {   \n\treturn err \n} // Done.\n```\n\n\n### 删除一个key\n\n使用`Txn.Delete()` 方法删除一个key\n\n### 获取 key value\n\n通过 txn.Get 获取 value\n```go\nerr := db.View(func(txn *badger.Txn) error {   \n\titem, err := txn.Get([]byte(\"answer\"))   \n\thandle(err)   \n\tvar valNot, valCopy []byte   \n\terr := item.Value(func(val []byte) error {     \n\t// This func with val would only be called if item.Value encounters no error.     \n\t// Accessing val here is valid.     \n\tfmt.Printf(\"The answer is: %s\\n\", val)     \n\t// Copying or parsing val is valid.     \n\tvalCopy = append([]byte{}, val...)     // 三个点（`...`）的语法，表示将切片 `val` 展开，将其中的元素逐个添加到新的切片 `valCopy` 中。\n\t// Assigning val slice to another variable is NOT OK.     \n\tvalNot = val // Do not do this.     \n\treturn nil   \n})   \nhandle(err)   // DO NOT access val here. It is the most common cause of bugs.\nfmt.Printf(\"NEVER do this. %s\\n\", valNot)   \n// You must copy it to use it outside item.Value(...).   \nfmt.Printf(\"The answer is: %s\\n\", valCopy)   \n// Alternatively, you could also use item.ValueCopy().   \nvalCopy, err = item.ValueCopy(nil)   \nhandle(err)   \nfmt.Printf(\"The answer is: %s\\n\", valCopy)   \nreturn nil \n})\n```\n\n如果不存在 `Txn.Get()` 将会返回一个 `ErrKeyNotFound` 错误\n\n请注意，Get()返回的值只在事务打开时有效。如果需要在事务外部使用值，则必须使用copy() 将其复制到另一个字节片。\n\n### 事务\n\n##### 只读事务\n\n只读事务使用 DB.View()方法\n```go\nerr := db.View(func(txn *badger.Txn) error {  \n\t// Your code here…   \n\treturn nil \n})\n```\n\n##### 读写事务锁\n\n读写事务可以使用 DB.Update()方法\n```go\nerr := db.Update(func(txn *badger.Txn) error {   \n\t// Your code here…   \n\treturn nil \n})\n```\n\n##### 手动管理事务\n\n直接使用`DB.NewTransaction()`函数，手动创建和提交事务。它接受一个布尔参数来指定是否需要读写事务。对于读写事务，需要调用`Txn.Commit()`来确保事务已提交。对于只读事务，调用 `txn.reject()`就可以了。`commit()`也在内部调用 `txn .reject()`来清除事务，因此只需调用Txn.Commit()就足以执行读写事务。\n\n但是，如果您的代码由于某种原因(出错)没有调用`Txn.Commit()`。就需要在defer中调用 `txn . reject()`\n```go\n// Start a writable transaction. \ntxn := db.NewTransaction(true) \ndefer txn.Discard() \n// Use the transaction... \nerr := txn.Set([]byte(\"answer\"), []byte(\"42\")) \nif err != nil {     return err } \n// Commit the transaction and check for error. \nif err := txn.Commit(); err != nil {     \n\treturn err \n}\n```\n\n\n\n## Error 包\n```go\n// 创建一个新 的 error 类型 数据\nerrors.New(\"dest id is not cur id\") \n```\n\n## Server 常用\n\n1. 获取 URL 的路径参数\n    \n      比如： 前端访问：http://127.0.0.1:8080/haha ， 如何获取 haha 这个字符串？ 看代码：\n    \n    ```Bash\n    package main\n    \n    import (\n            \"fmt\"\n            \"net/http\"\n    )\n    \n    func handler(w http.ResponseWriter, r *http.Request) {\n            // 从请求URL中获取路径参数\n            param := r.URL.Path[len(\"/\"):]\n    \n            // 输出获取到的字符串\n            fmt.Println(param)\n    \n            // 在响应中返回获取到的字符串\n            fmt.Fprintf(w, \"Received: %s\", param)\n    }\n    \n    func main() {\n            http.HandleFunc(\"/\", handler)\n            http.ListenAndServe(\":80\", nil)\n    }\n    ```\n    \n2. http 状态码返回\n    \n    ```Bash\n    package main\n    \n    import (\n            \"fmt\"\n            \"net/http\"\n    )\n    func handleRequest(w http.ResponseWriter, r *http.Request) {\n            // 模拟根据请求处理的逻辑\n            if r.URL.Path == \"/\" {\n                    // 处理成功，返回HTTP 200\n                    w.WriteHeader(http.StatusOK)\n                    fmt.Fprintf(w, \"Success\")\n            } else {\n                    // 处理失败，返回HTTP 404\n                    w.WriteHeader(http.StatusNotFound)\n                    fmt.Fprintf(w, \"Not Found\")\n            }\n    }\n    func main() {\n            http.HandleFunc(\"/\", handleRequest)\n            http.ListenAndServe(\":80\", nil)\n    }\n    ```\n    \n3. 闭包\n    \n    ```Bash\n    在Go语言中，http.HandleFunc()函数的第二个参数是一个函数类型，它必须是满足http.HandlerFunc函数签名的函数。该函数接收两个参数：http.ResponseWriter和*http.Request。\n    如果你想在handleRequest函数中传入其他参数，可以使用闭包（Closure）的方式。\n    以下是一个示例代码，展示如何在handleRequest函数中传入其他参数：\n    go\n    复制\n    package main\n    import (\n            \"fmt\"\n            \"net/http\"\n    )\n    \n    func handleRequest(customParam string) http.HandlerFunc {\n            return func(w http.ResponseWriter, r *http.Request) {\n                    // 在这里可以使用 customParam 和 w、r 来处理请求\n                    fmt.Println(\"Custom parameter:\", customParam)\n                    fmt.Fprintf(w, \"Hello, World!\")\n            }\n    }\n    \n    func main() {\n            param := \"custom value\"\n            http.HandleFunc(\"/\", handleRequest(param))\n            http.ListenAndServe(\":8080\", nil)\n    }\n    在上述代码中，我们定义了一个handleRequest函数，它接收一个类型为string的参数customParam。handleRequest函数返回一个函数，该函数满足http.HandlerFunc函数签名。\n    在返回的函数中，我们可以使用闭包的方式访问customParam以及http.ResponseWriter和*http.Request参数，并进行相应的处理。\n    在main函数中，我们定义了一个param变量作为自定义参数的值。然后，我们通过handleRequest(param)将param传递给handleRequest函数，并返回一个满足http.HandlerFunc函数签名的函数。\n    最后，我们使用http.HandleFunc()来将路径\"/\"与返回的处理函数进行绑定，并通过http.ListenAndServe()监听HTTP请求\n    ```\n    \n4. net 和 http同时使用\n    \n      Go 语言中，可以同时使用 `net` 和 `http` 包来监听同一个接口，但是需要小心处理并避免冲突。\n    \n      `net` 包提供了底层的网络功能，可以通过 `net.Listen` 函数来监听指定的网络地址和端口。而 `http` 包是建立在 `net` 包之上的，提供了更高级的 HTTP 服务器和客户端功能。\n    \n      以下是一个示例代码，同时使用 `net` 和 `http` 监听同一个接口：\n    \n      \n    \n    ```Plaintext\n    package main\n    import (\n            \"fmt\"\n            \"net\"\n            \"net/http\"\n    )\n    \n    func main() {\n            // 使用 net 包监听指定的网络地址和端口\n            listener, err := net.Listen(\"tcp\", \"localhost:8080\")\n            if err != nil {\n                    fmt.Println(\"Error listening:\", err)\n                    return\n            }\n            defer listener.Close()\n            // 启动 HTTP 服务器\n            go func() {\n                    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n                            fmt.Fprintf(w, \"Hello, HTTP!\")\n                    })\n                    err := http.Serve(listener, nil)\n                    if err != nil {\n                            fmt.Println(\"Error serving HTTP:\", err)\n                            return\n                    }\n            }()\n    \n            // 其他的网络处理逻辑...\n            // ...\n            // 等待程序退出\n            select {}\n    }\n    ```\n    \n      在上述示例中，我们使用 `net.Listen` 函数监听 `localhost:8080`，然后使用 `http` 包启动了一个 HTTP 服务器。通过 `http.HandleFunc` 函数，我们定义了一个简单的处理函数来响应 HTTP 请求。最后，通过 `http.Serve` 函数将监听器与 HTTP 服务器关联起来。\n    \n      你可以在 `// 其他的网络处理逻辑...` 的部分添加其他网络处理逻辑，如基于 `net` 包的 TCP 或 UDP 服务器。只需确保网络处理逻辑不会与 HTTP 服务器冲突，比如使用不同的端口或处理不同的网络协议。\n    \n      需要注意的是，当使用 `http.Serve` 函数时，它将阻塞当前的 goroutine，因此我们在示例中使用了 `select {}` 来阻止 `main` 函数退出。这样可以保持服务器的运行，直到显式地退出程序。\n    \n5. mymux\n    \n      `myMux := http.NewServeMux()` 这条语句用于创建一个新的 `ServeMux` 对象。\n    \n      在 Go 的 `http` 包中，`ServeMux` 是一个 HTTP 请求多路复用器（multiplexer），用于将收到的 HTTP 请求分发到相应的处理器。`ServeMux` 类型实现了 `http.Handler` 接口，因此它本身可以作为一个处理器来处理请求。\n    \n      通过调用 `http.NewServeMux()` 函数，我们可以创建一个新的 `ServeMux` 对象，它将用于注册和管理不同路径的处理器。\n    \n      例如，下面是一个简单示例，使用 `ServeMux` 对象来管理不同路径的处理器：\n    \n      \n    \n    ```Plaintext\n    package main\n    import (\n            \"fmt\"\n            \"net/http\"\n    )\n    \n    func main() {\n            myMux := http.NewServeMux()\n    \n            myMux.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n                    fmt.Fprintf(w, \"Hello, World!\")\n            })\n    \n            myMux.HandleFunc(\"/about\", func(w http.ResponseWriter, r *http.Request) {\n                    fmt.Fprintf(w, \"About page\")\n            })\n            server := &http.Server{\n                    Addr:    \":8080\",\n                    Handler: myMux,\n            }\n            server.ListenAndServe()\n    }\n    ```\n    \n      在上述示例中，我们首先使用 `http.NewServeMux()` 创建了一个新的 `ServeMux` 对象 `myMux`。然后，我们使用 `myMux.HandleFunc` 方法来注册处理器函数，每个函数对应一个特定的路径。\n    \n      最后，我们创建了一个 `http.Server` 对象，并将 `myMux` 对象作为处理器指定给该服务器。这样，当服务器收到请求时，就会使用 `myMux` 对象来根据请求的路径选择相应的处理器函数进行处理。\n    \n      总结起来，`myMux := http.NewServeMux()` 用于创建一个 `ServeMux` 对象，以便注册和管理不同路径的处理器，并根据路径选择相应的处理函数来处理请求。\n    \n6. go routine 实现并发执行\n    \n      Go 的 goroutine 来实现并发执行。以下是一个示例代码，演示了如何同时运行 HTTP 服务、gRPC 服务和连接其他 gRPC 服务器：\n    \n    \n    ```go\n    package main\n    import (\n            \"log\"\n            \"net\"\n            \"net/http\"\n            \"google.golang.org/grpc\"\n            \"google.golang.org/grpc/credentials\"\n    )\n    \n    func main() {\n            // 创建监听器\n            lis, err := net.Listen(\"tcp\", \":8080\")\n            if err != nil {\n                    log.Fatalf(\"Failed to listen: %v\", err)\n            }\n    \n            // 启动 HTTP 服务器\n            go func() {\n                    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n                            w.Write([]byte(\"Hello, HTTP!\"))\n                    })\n                    if err := http.Serve(lis, nil); err != nil {\n                            log.Fatalf(\"HTTP failed to serve: %v\", err)\n                    }\n            }()\n    \n            // 启动 gRPC 服务器\n            go func() {\n                    s := grpc.NewServer()\n                    // 注册 gRPC 服务\n                    // ...\n                    if err := s.Serve(lis); err != nil {\n                            log.Fatalf(\"gRPC failed to serve: %v\", err)\n                    }\n            }()\n    \n            // 连接其他 gRPC 服务器\n            conn, err := grpc.Dial(\"other_server_address\", grpc.WithTransportCredentials(credentials.NewInsecure()))\n            if err != nil {\n                    log.Fatalf(\"Failed to connect to other server: %v\", err)\n            }\n            defer conn.Close()\n            // 进行其他操作，使用 conn 进行 gRPC 通信\n            // ...\n            // 等待程序退出\n            select {}\n    }\n    ```\n    \n      在这个示例中，我们使用 goroutine 启动了 HTTP 服务器和 gRPC 服务器，并在主函数中创建了一个与其他 gRPC 服务器的连接。\n    \n      注意在连接其他 gRPC 服务器时，我们使用了 `grpc.Dial` 函数，并传递了 `grpc.WithTransportCredentials(credentials.NewInsecure())` 选项来创建一个不安全的连接。你应该根据实际情况选择正确的连接配置，例如使用安全的连接和认证。\n    \n      最后，使用 `select {}` 阻塞主函数，使程序保持运行状态，直到显式退出。\n    \n      请根据你的实际需求，将代码中的注释部分替换为适当的 gRPC 服务注册和其他操作代码。\n    \n\n\n7. 连接阻塞\n    \n    ```Go\n            // 主要就是 grpc.WithBlock()\n            \n            conn2, err2 := grpc.Dial(*addr2, grpc.WithTransportCredentials(insecure.NewCredentials()),grpc.WithBlock())\n            \n    ```\n    \n8. 循环变量副本\n    \n      for i := 1; i <= *rpc_num; i++ {\n    \n      if i == *rpc_id {\n    \n      continue // 跳过与 当前相同的 端口号 ，不能和自己连接\n    \n      }\n    \n      go func(){\n    \n      conn[i], err = grpc.Dial(rpc_addr[i], grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithBlock())\n    \n      if err != nil {\n    \n      log.Fatalf(\"Failed to connect to server %s: %v\", rpc_addr[i], err)\n    \n      return\n    \n      }\n    \n      log.Printf(\"Connect to %s OK\", rpc_addr[i])\n    \n      }()\n    \n      }\n    \n      这里有个提示信息但是没有报错，提示为：loop variable i captured by func litera\n    \n       \"loop variable i captured by func literal\" 意味着在你的代码中，匿名函数字面量（func literal）捕获了循环变量 i。\n    \n      在 Go 语言中，当你在循环体内使用匿名函数时，该匿名函数会形成一个闭包，它可以访问和引用外部作用域中的变量。在这种情况下，匿名函数引用了循环变量 i。然而，循环变量在每次迭代中的值会发生变化，这可能会导致一些意外的行为。\n    \n      为了避免这种问题，Go 语言引入了循环变量副本的概念。在每次迭代中，会为循环体内的匿名函数创建一个新的副本变量，以确保在闭包内部引用的是正确的值。这样可以避免循环变量值的竞争条件。\n    \n      解决这个问题的常见方法是在循环体内部创建一个局部变量，将循环变量的值复制给局部变量，然后在匿名函数中使用局部变量。例如：\n\n    ```Plaintext\n    for i := 1; i <= *rpc_num; i++ {\n        if i == *rpc_id {\n            continue\n        }\n        // 创建局部变量 iCopy 并将循环变量的值赋给它\n        iCopy := i\n        go func() {\n            conn[iCopy], err = grpc.Dial(rpc_addr[iCopy], grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithBlock())\n            if err != nil {\n                log.Fatalf(\"Failed to connect to server %s: %v\", rpc_addr[iCopy], err)\n                return\n            }\n            log.Printf(\"Connect to %s OK\", rpc_addr[iCopy])\n        }()\n    }\n    ```\n    \n      通过创建局部变量 iCopy 并使用它，你可以确保每个匿名函数引用的是该迭代的正确值，而不会受到循环变量的更改影响。\n\n\n\n\n\n\n\n\n\n# Atomic 包\n```go\npackage main\n\nimport (\n    \"log\"\n    \"net/http\"\n    \"runtime\"\n    \"sync/atomic\"\n)\n\nvar count int32\n\nfunc test(w http.ResponseWriter, r *http.Request) {\n    currentCount := atomic.LoadInt32(&count)\n    atomic.AddInt32(&count, 1)\n    log.Println(\"count:\", currentCount)\n}\nfunc main() {\n    runtime.GOMAXPROCS(runtime.NumCPU() - 1)\n    http.HandleFunc(\"/\", test)\n    http.ListenAndServe(\":8080\", nil)\n}\n```\n\n\n\n# Done Wait 同步\n Go 内存模型中的术语。它说明了在调用 `Done` 方法之前，它会与任何由它解除阻塞的 `Wait` 调用之后的返回之前进行\"同步在\"（synchronizes before）的关系。\n\n具体解释如下：\n\n1. `Done` 方法是用于通知等待组（WaitGroup）中某个操作的完成。\n2. `Wait` 方法是等待等待组中所有操作完成的调用。\n3. \"同步在\"（synchronizes before）是 Go 内存模型中的同步关系，指示在同一个 goroutine 中，一个操作的执行在另一个操作之前进行了同步。\n\n根据这句话的解释，当一个 goroutine 调用 `Done` 方法时，它会在解除等待组中的某个操作的阻塞之前与该操作的返回之前进行同步。\n\n具体来说，如果一个 goroutine 在调用 `Wait` 方法等待等待组中的操作时被阻塞，那么当另一个 goroutine 调用 `Done` 方法通知该操作的完成时，调用 `Done` 的 goroutine 会在被阻塞的 goroutine 返回之前进行同步。这确保了在 `Done` 方法解除阻塞之后，等待的 goroutine 可以安全地继续执行。\n\n总之，这句话的含义是在 Go 内存模型中，`Done` 方法的调用会在解除阻塞的 `Wait` 调用的返回之前进行同步。这个同步关系确保了等待组的协同操作的正确性和可靠性。","source":"_posts/编程语言/GO_lang/go 高级.md","raw":"\n\t\n# 常见库\n## Flag 包\n### flag包基本使用\n[官方文档](https://studygolang.com/pkgdoc)]\n[参考文档](https://www.liwenzhou.com/posts/Go/flag/)\n\n\n#### 导入flag包\n\n```go\nimport flag\n```\n\n#### flag参数类型\n\nflag包支持的命令行参数类型有`bool`、`int`、`int64`、`uint`、`uint64`、`float` `float64`、`string`、`duration`。\n\n| flag参数     | 有效值                                                                          |\n| ---------- | ---------------------------------------------------------------------------- |\n| 字符串flag    | 合法字符串                                                                        |\n| 整数flag     | 1234、0664、0x1234等类型，也可以是负数。                                                  |\n| 浮点数flag    | 合法浮点数                                                                        |\n| bool类型flag | 1, 0, t, f, T, F, true, false, TRUE, FALSE, True, False。                     |\n| 时间段flag    | 任何合法的时间段字符串。如\"300ms\"、\"-1.5h\"、“2h45m”。合法的单位有\"ns\"、“us” /“µs”、“ms”、“s”、“m”、“h”。 |\n\n#### 定义命令行flag参数\n\n有以下两种常用的定义命令行`flag`参数的方法。\n\n### flag.Type()\n\n基本格式如下：\n\n`flag.Type(flag名, 默认值, 帮助信息)*Type` 例如我们要定义姓名、年龄、婚否三个命令行参数，我们可以按如下方式定义：\n\n```go\nname := flag.String(\"name\", \"张三\", \"姓名\")\nage := flag.Int(\"age\", 18, \"年龄\")\nmarried := flag.Bool(\"married\", false, \"婚否\")\ndelay := flag.Duration(\"d\", 0, \"时间间隔\")\n```\n\n需要注意的是，此时`name`、`age`、`married`、`delay`均为对应类型的指针。\n\n#### flag.TypeVar()\n\n基本格式如下： `flag.TypeVar(Type指针, flag名, 默认值, 帮助信息)` 例如我们要定义姓名、年龄、婚否三个命令行参数，我们可以按如下方式定义：\n\n```go\nvar name string\nvar age int\nvar married bool\nvar delay time.Duration\nflag.StringVar(&name, \"name\", \"张三\", \"姓名\")\nflag.IntVar(&age, \"age\", 18, \"年龄\")\nflag.BoolVar(&married, \"married\", false, \"婚否\")\nflag.DurationVar(&delay, \"d\", 0, \"时间间隔\")\n```\n\n#### flag.Parse()\n\n通过以上两种方法定义好命令行flag参数后，需要通过调用`flag.Parse()`来对命令行参数进行解析。\n\n支持的命令行参数格式有以下几种：\n\n- `-flag xxx` （使用空格，一个`-`符号）\n- `--flag xxx` （使用空格，两个`-`符号）\n- `-flag=xxx` （使用等号，一个`-`符号）\n- `--flag=xxx` （使用等号，两个`-`符号）\n\n其中，布尔类型的参数必须使用等号的方式指定。\n\nFlag解析在第一个非flag参数（单个\"-“不是flag参数）之前停止，或者在终止符”–“之后停止。\n\n#### flag其他函数\n\n```go\nflag.Args()  ////返回命令行参数后的其他参数，以[]string类型\nflag.NArg()  //返回命令行参数后的其他参数个数\nflag.NFlag() //返回使用的命令行参数个数\n```\n\n#### 完整示例\n\n##### 定义\n\n```go\nfunc main() {\n\t//定义命令行参数方式1\n\tvar name string\n\tvar age int\n\tvar married bool\n\tvar delay time.Duration\n\tflag.StringVar(&name, \"name\", \"张三\", \"姓名\")\n\tflag.IntVar(&age, \"age\", 18, \"年龄\")\n\tflag.BoolVar(&married, \"married\", false, \"婚否\")\n\tflag.DurationVar(&delay, \"d\", 0, \"延迟的时间间隔\")\n\n\t//解析命令行参数\n\tflag.Parse()\n\tfmt.Println(name, age, married, delay)\n\t//返回命令行参数后的其他参数\n\tfmt.Println(flag.Args())\n\t//返回命令行参数后的其他参数个数\n\tfmt.Println(flag.NArg())\n\t//返回使用的命令行参数个数\n\tfmt.Println(flag.NFlag())\n}\n```\n\n##### 使用\n\n命令行参数使用提示：\n\n```bash\n$ ./flag_demo -help\nUsage of ./flag_demo:\n  -age int\n        年龄 (default 18)\n  -d duration\n        时间间隔\n  -married\n        婚否\n  -name string\n        姓名 (default \"张三\")\n```\n\n正常使用命令行flag参数：\n\n```bash\n$ ./flag_demo -name 沙河娜扎 --age 28 -married=false -d=1h30m\n沙河娜扎 28 false 1h30m0s\n[]\n0\n4\n```\n\n使用非flag命令行参数：\n\n```bash\n$ ./flag_demo a b c\n张三 18 false 0s\n[a b c]\n3\n0\n```\n\n\n\n\n## Log 包\n日志相关，[参考](ttps://blog.csdn.net/cold___play/article/details/130744302)\n\n### 基本结构\n常量列表：\n\n- Ldate         日期 年/月/日\n- Ltime         时间 时:分:秒\n- Lmicroseconds 时间 .毫秒于Ltime之后\n- Llongfile     完整文件名:行号\n- Lshortfile    文件名，此标志位优先于 Llongfile\n- LstdFlags     = Ldate 并且 Ltime\n\n功能说明：标志位常量控制日志格式。\n\n示例：\n```go\nfunc main() {\n\tlog.SetFlags(log.Lshortfile | log.LstdFlags)\n\tlog.Println(\"log:\") //2023/05/18 12:09:57 constantsDemo.go:15: log:\n}\n```\n\n函数列表:\n```go\nfunc Fatal(v ...interface{})\nfunc Fatalf(format string, v ...interface{})\nfunc Fatalln(v ...interface{})\nfunc Flags() int\nfunc Panic(v ...interface{})\nfunc Panicf(format string, v ...interface{})\nfunc Panicln(v ...interface{})\nfunc Prefix() string\nfunc Print(v ...interface{})\nfunc Printf(format string, v ...interface{})\nfunc Println(v ...interface{})\nfunc SetFlags(flag int)\nfunc SetOutput(w io.Writer)\nfunc SetPrefix(prefix string)\nfunc New(out io.Writer, prefix string, flag int) *Logger\nfunc (l *Logger) Fatal(v ...interface{})\nfunc (l *Logger) Fatalf(format string, v ...interface{})\nfunc (l *Logger) Fatalln(v ...interface{})\nfunc (l *Logger) Flags() int\nfunc (l *Logger) Output(calldepth int, s string) error\nfunc (l *Logger) Panic(v ...interface{})\nfunc (l *Logger) Panicf(format string, v ...interface{})\nfunc (l *Logger) Panicln(v ...interface{})\nfunc (l *Logger) Prefix() string\nfunc (l *Logger) Print(v ...interface{})\nfunc (l *Logger) Printf(format string, v ...interface{})\nfunc (l *Logger) Println(v ...interface{})\nfunc (l *Logger) SetFlags(flag int)\nfunc (l *Logger) SetPrefix(prefix string)\n```\n### 自定义 logger:\n```go\nfunc New(out io.Writer, prefix string, flag int) *Logger\n```\n参数列表：\n\tout 输出目标\n\tprefix 输出前缀\n\tflag 格式配置标识值\n返回值：\n\t自定义的logger\n功能说明：\n\t这个方法用来自定义logger，指定输出目标、格式等\n示例：\n```go\nfunc main() {\n\tl := log.New(os.Stderr, \"logger\", log.Ldate)\n\tl.Println(\"log to stderr sample\")//logger2023/05/18 log to stderr sample\n}\n```\n\n###  Fatal系列函数\n#### 1.1 func Fatal(v …interface{})\n参数列表：\n\tv 待输出参数列表\n返回值：\n\t无\n功能说明：\n\t打印日志并退出。相当于调用Print()并os.Exit(1)\n#### 1.2 func Fatalf(format string, v …interface{})\n参数列表：\n\tformat 输出格式\n\tv 带输出参数列表\n返回值：\n\t无\n功能说明：\n\t按格式输出日志，并退出。相当于调用Printf()并调用os.Exit(1)\n#### 1.3 func Fatalln(v …interface{})\n参数列表：\n\tv\n返回值：\n\t无\n功能说明：\n\t打印一行日志并退出。相当于调用Println()并os.Exit(1)\n#### 1.4 func (l \\*Logger) Fatal(v …interface{})\n参数列表：\n\tv 待输出参数列表\n返回值：\n\t无\n功能说明：\n\t打印日志并退出。相当于调用l.Print()并os.Exit(1)\n#### 1.5 func Fatalf(format string, v …interface{})\n参数列表：\n\tformat 输出格式\n\tv 带输出参数列表\n返回值：\n\t无\n功能说明：\n\t按格式输出日志，并退出。相当于调用l.Printf()并调用os.Exit(1)\n#### 1.6 func (l \\*Logger) Fatalln(v …interface{})\n参数列表：\n\tv\n返回值：\n\t无\n功能说明：\n\t打印一行日志并退出。相当于调用l.Println()并os.Exit(1)\n#### 示例\n```go\n\n\nfunc main() {\n\tage := 25\n\tlog.Fatal(\"Hi & Bye ! Age = \", age) // this will print \"Hi & Bye ! Age = 25\"\n\tlog.Println(\"This will not be called.\")\n\n\tname := \"golang\"\n\tlog.Fatalf(\"%8d,%8s\", 23, name) //2013/03/10 16:08:49       23,  golang\n\n\tlog.Fatalln(\"bye!\") //2013/03/10 16:14:54 bye!\\n\n\n\tl := log.New(os.Stdout, \"\", log.LstdFlags)\n\tage = 25\n\tl.Fatal(\"Hi & Bye ! Age = \", age) // this will print \"Hi & Bye ! Age = 25\"\n\tl.Println(\"This will not be called.\")\n\n\tl = log.New(os.Stdout, \"\", log.LstdFlags)\n\t//l.Fatalf(\"%s\", \"hello\")\n\tname = \"golang\"\n\tl.Fatalf(\"%8d,%8s\", 23, name) //2013/03/10 16:08:49       23,  golang\n\n\tl = log.New(os.Stdout, \"\", log.LstdFlags)\n\tl.Fatalln(\"bye!\") //2013/03/10 16:14:54 bye!\\n\n}\n```\n### Flags系列函数\n#### 2.1 func Flags() int\n参数列表：\n\t无\n返回值：\n\t默认logger的配置值\n功能说明：\n\t返回默认logger配置值。\n#### 2.2 func (l \\*Logger) Flags() int\n参数列表：\n\t无\n返回值：\n\t当前logger的配置值\n功能说明：\n\t返回当前logger配置值。\n#### 2.3 func SetFlags(flag int)\n参数列表：\n\tflag logger配置值\n返回值：\n\t无\n功能说明：\n\t这个方法用来设置标准logger的配置，默认为3（logger.LstdFlags）\n#### 2.4 func (l \\*Logger) SetFlags(flag int)\n参数列表：\n\tflag logger配置值\n返回值：\n\t无\n功能说明：\n\t这个方法用来设置标准logger的配置，默认为3（logger.LstdFlags）\n#### 示例\n```go\nfunc main() {\n\tfmt.Println(\"standard flags :\", log.Flags()) //standard flags : 3\n\t//the flags constants\n\tfmt.Println(log.Ldate)         //1\n\tfmt.Println(log.Ltime)         //2\n\tfmt.Println(log.Lmicroseconds) //4\n\tfmt.Println(log.Llongfile)     //8\n\tfmt.Println(log.Lshortfile)    //16\n\tfmt.Println(log.LstdFlags)     //LstdFlags     = Ldate | Ltime   3\n\n\tl := log.New(os.Stdout, \"\", log.LstdFlags)\n\tfmt.Println(\"logger l's flags :\", l.Flags()) //logger l's flags : 3\n\n\tlog.Println(log.Flags()) //2013/03/10 17:46:53 3\n\tlog.SetFlags(log.Ldate)\n\tlog.Println(log.Flags()) //2013/03/10 1\n\tlog.SetFlags(log.LstdFlags | log.Lshortfile)\n\tlog.Println(log.Flags()) //2013/03/10 17:46:53 setflags.go:17: 19\n\n\tl = log.New(os.Stdout, \"\", log.LstdFlags)\n\tl.Println(l.Flags()) //2013/03/10 17:46:53 3\n\tl.SetFlags(log.Ldate)\n\tl.Println(l.Flags()) //2013/03/10 1\n\tl.SetFlags(log.LstdFlags | log.Lshortfile)\n\tl.Println(l.Flags()) //2013/03/10 17:46:53 setflags.go:17: 19\n}\n```\n\n### Panic系列函数\n#### 3.1 func (l \\*Logger) Panic(v …interface{})\n参数列表：\n\tv 待输出参数列表\n返回值：\n\t无\n功能说明：\n\t这个方法相当于调用l.Print()及panic()\n#### 3.2 func (l \\*Logger) Panicf(format string, v …interface{})\n参数列表：\n\tformat 输出格式\n\tv 待输出参数列表\n返回值：\n\t无\n功能说明：\n\t相当于调用l.Printf()，之后调用panic()\n#### 3.3 func (l \\*Logger) Panicln(v …interface{})\n参数列表：\n\tv 待输出参数列表\n返回值：\n\t无\n功能说明：\n\t相当于调用l.Println()并调用panic()\n#### 3.4 func Panic(v …interface{})\n参数列表：\n\tv 待输出参数列表\n返回值：\n\t无\n功能说明：\n\t这个方法相当于调用Print()及panic()\n#### 3.5 func Panicf(format string, v …interface{})\n参数列表：\n\tformat 输出格式\n\tv 待输出参数列表\n返回值：\n\t- 无\n功能说明：\n\t相当于调用Printf()，之后调用panic()\n#### 3.6 func Panicln(v …interface{})\n参数列表：\n\tv 待输出参数列表\n返回值：\n\t无\n功能说明：\n\t相当于调用Println()并调用panic()\n#### 示例\n```go\nfunc main() {\n\tl := log.New(os.Stdout, \"\", log.LstdFlags)\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tfmt.Println(err) //output : \"call panic and stop\"\n\t\t\thandleException()\n\t\t}\n\t}()\n\tl.Panic(\"call panic and stop\")\n\tlog.Println(\"this will not be called.\")\n\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tif err == \"3q\" {\n\t\t\t\tlog.Println(\"you are welcome\")\n\t\t\t}\n\t\t}\n\t}()\n\tl = log.New(os.Stdout, \"\", log.LstdFlags)\n\tl.Panicf(\"%d%s\", 3, \"q\")\n\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tif err == \"3q\\n\" {\n\t\t\t\tlog.Println(\"you are welcome\")\n\t\t\t}\n\t\t}\n\t}()\n\tl = log.New(os.Stdout, \"\", log.LstdFlags)\n\tl.Panicln(\"3q\")\n}\n\nfunc handleException() {\n\tlog.Println(\"recovering...\")\n}\n```\n\n### Print系列函数\n#### 4.1 func (l \\*Logger) Print(v …interface{})\n参数列表：\n\tv 待输出参数列表\n返回值：\n\t无\n功能说明：\n\t输出日志到logger。参数处理方式同fmt.Print\n#### 4.2 func (l \\*Logger) Printf(format string, v …interface{})\n参数列表：\n\tformat 输出格式\n\tv 待输出参数列表\n返回值：\n\t无\n功能说明：\n\t调用l.Output输出日志到logger l。参数处理方式同fmt.Printf\n#### 4.3 func (l \\*Logger) Println(v …interface{})\n参数列表：\n\tv 待输出参数列表\n返回值：\n\t无\n功能说明：\n\t调用Output打印日志到当前logger，参数处理方式同fmt.Println\n####  4.4 func Print(v …interface{})\n参数列表：\n\tv 待输出参数列表\n返回值：\n\t无\n功能说明：\n\t输出日志到标准logger。参数处理方式同fmt.Print\n#### 4.5 func Printf(format string, v …interface{})\n参数列表：\n\tformat 输出格式\n\tv 待输出参数列表\n返回值：\n\t无\n功能说明：\n\t调用Output输出日志到标准logger。参数处理方式同fmt.Printf\n#### 4.6 func Println(v …interface{})\n参数列表：\n\tv\n返回值：\n\t无\n功能说明：\n\t调用Output打印日志到标准logger，参数处理方式同fmt.Println\n#### 示例\n```go\nfunc main() {\n\tl := log.New(os.Stdout, \"\", log.LstdFlags)\n\tl.Print(\"string\", 1, 2.3) //2013/03/10 17:26:06 string1 2.3\n\n\tl = log.New(os.Stdout, \"\", log.LstdFlags)\n\tl.Printf(\"%s\", \"hello\") //hello\n\tname := \"golang\"\n\tl.Printf(\"%8d,%8s\", 23, name) //2013/03/10 16:08:49       23,  golang\n\n\tl = log.New(os.Stdout, \"\", log.LstdFlags)\n\tl.Println(\"hello\") //2013/03/10 17:35:28 hello\\n\n\n\tlog.Print(\"string\", 1, 2.3) //2013/03/10 17:26:06 string1 2.3\n\n\tlog.Printf(\"%s\", \"hello\") //hello\n\tname = \"golang\"\n\tlog.Printf(\"%8d,%8s\", 23, name) //2013/03/10 16:08:49       23,  golang\n\n\tlog.Println(\"hello\") //2013/03/10 17:35:28 hello\\n\n}\n```\n\n### 其它函数\n#### 5.1 func (l \\*Logger) Prefix() string\n参数列表：\n\t无\n返回值：\n\tlogger前缀，字符串类型\n功能说明：\n\t返回当前logger的输出前缀\n#### 5.2 func Prefix() string\n参数列表：\n\t无\n返回值：\n\t标准logger前缀，字符串类型\n功能说明：\n\t返回标准logger的输出前缀\n#### 5.3 func SetPrefix(prefix string)\n参数列表：\n\tprefix 前缀\n返回值：\n\t无\n功能说明：\n\t设置logger的输出前缀\n#### 5.4 func SetPrefix(prefix string)\n参数列表：\n\tprefix 前缀\n返回值：\n\t无\n功能说明：\n\t设置logger的输出前缀\n#### 5.5 func (l \\*Logger) Output(calldepth int, s string) error\n参数列表：\n\tcalldepth 深度\n\ts 字符串\n返回值：\n\terror 错误\n功能说明：\n\t输出日志事件。字符串s包含待打印内容，跟在预定义的prefix后面，并且根据flags设置会有区分。如果s末尾没有换行符，这个方法会默认加上一个。calldepth目前预定义均为2,以后会用来支持通用场景，支持其他值配置。（本人注：日志输出不建议直接使用该方法）\n#### 5.6 func SetOutput(w io.Writer)\n参数列表：\n\tw 目标流，io.Writer类型\n返回值：\n\t无\n功能说明：\n\t设置标准logger的输出目标\n#### 示例\n```go\nfunc main() {\n\tl := log.New(os.Stdout, \"\", log.LstdFlags)\n\tfmt.Print(l.Prefix()) //this will print nothing\n\tl.Println(1)          //2013/03/10 17:02:05 1\n\tl.SetPrefix(\"log:\")\n\tfmt.Println(l.Prefix()) //log:\n\tl.Println(2)            //log:2013/03/10 17:02:05 2\n\n\tfmt.Print(log.Prefix()) //this will print nothing\n\tlog.Println(1)          //2013/03/10 17:02:05 1\n\tlog.SetPrefix(\"log:\")\n\tfmt.Println(log.Prefix()) //log:\n\tlog.Println(2)            //log:2013/03/10 17:02:05 2\n\n\tl = log.New(os.Stdout, \"\", log.LstdFlags)\n\tfmt.Print(l.Prefix()) //this will print nothing\n\tl.Println(1)          //2013/03/10 17:02:05 1\n\tl.SetPrefix(\"log:\")\n\tfmt.Println(l.Prefix()) //log:\n\n\tl.Println(2) //log:2013/03/10 17:02:05 2\n\n\tfmt.Print(log.Prefix()) //this will print nothing\n\tlog.Println(1)          //2013/03/10 17:02:05 1\n\tlog.SetPrefix(\"log:\")\n\tfmt.Println(log.Prefix()) //log:\n\tlog.Println(2)            //log:2013/03/10 17:02:05 2\n\n\tl = log.New(os.Stdout, \"log->\", log.Ldate)\n\tl.Output(2, \"log output\")\n\n\tfile, err := os.OpenFile(\"sample.txt\", os.O_WRONLY, 0666)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer file.Close()\n\tlog.SetOutput(file)\n\tlog.Println(\"log to file\")\n}\n```\n\n\n## Badger 包\n[参考](https://juejin.cn/post/6844903814571491335)\n[官方文档](https://pkg.go.dev/github.com/dgraph-io/badger#Txn)\nbadger是一个纯Go实现的快速的嵌入式K/V数据库，针对LSM tree做了优化。\n### 安装\n\n`$ go get github.com/dgraph-io/badger/...`\n\n### 数据库\n\n打开一个数据库\n\n```go\nopts := badger.DefaultOptions\nopts.Dir = \"/tmp/badger\" \nopts.ValueDir = \"/tmp/badger\" \ndb, err := badger.Open(opts) \nif err != nil {\n\tlog.Fatal(err) \n} \ndefer db.Close()\n```\n### 存储\n\n#### 存储kv\n\n使用 Txn.Set()方法\n\n```go\nerr := db.Update(func(txn *badger.Txn) error {   \n\terr := txn.Set([]byte(\"answer\"), []byte(\"42\"))   \n\treturn err \n})\n```\n#### 批量设置\n```go\nwb := db.NewWriteBatch() \ndefer wb.Cancel() \nfor i := 0; i < N; i++ {\n\terr := wb.Set(key(i), value(i), 0) // Will create txns as needed. \n\thandle(err) \n} \nhandle(wb.Flush()) // Wait for all txns to finish.\n```\nWriteBatch不允许任何读取。对于读-修改-写，应该使用事务API。\n\n##### 设置生存时间 TTL\n\nBadger 允许在键上设置一个可选的生存时间 (TTL) 值。一旦 TTL 结束，KEY 将不再是可检索的，并且将进行垃圾收集。TTL 可以使用 Txn.SetWithTTL() 设置为一个`time.Duration`的值\n\n##### 设置元数据\n\n`Txn.SetWithMeta()` 设置用户元数据\n\n使用 `Txn.SetEntry()` 可以一次性设置 key, value, user metatadata 和 TTL\n\n##### 遍历 keys\n\n要遍历键，我们可以使用迭代器，可以使用 `Txn.NewIterator()`方法获得迭代器。迭代按字节字典排序顺序进行。\n```go\nerr := db.View(func(txn *badger.Txn) error { // badger 的 view 方法创建一个只读事务\n\topts := badger.DefaultIteratorOptions   \n\topts.PrefetchSize = 10   \n\tit := txn.NewIterator(opts)   \n\tdefer it.Close()   \n\tfor it.Rewind(); it.Valid(); it.Next() {\n\t    item := it.Item() \n\t    k := item.Key()     \n\t    err := item.Value(func(v []byte) error {\n\t        fmt.Printf(\"key=%s, value=%s\\n\", k, v)       \n\t        return nil     \n\t        })     \n\t    if err != nil {       \n\t\t    return err\n\t\t}   \n\t}   \n\treturn nil \n})\n```\n###### 前缀扫描\n\n要遍历键前缀，可以将 Seek() 和 ValidForPrefix() 组合使用：（这里的前缀是键值的）\n```go\ndb.View(func(txn *badger.Txn) error {\n\tit := txn.NewIterator(badger.DefaultIteratorOptions)\n\tdefer it.Close()   \n\tprefix := []byte(\"1234\")   \n\tfor it.Seek(prefix); it.ValidForPrefix(prefix); it.Next() {\n\t\titem := it.Item()    \n\t\tk := item.Key()     \n\t\terr := item.Value(func(v []byte) error {\n\t\t\tfmt.Printf(\"key=%s, value=%s\\n\", k, v)       \n\t\t\treturn nil     \n\t\t})     \n\t\tif err != nil {       \n\t\t\treturn err     \n\t\t}   \n\t}   \n\treturn nil \n})\n```\n###### 键的遍历\n\nBadger支持一种独特的迭代模式，称为只有键的迭代。它比常规迭代快几个数量级，因为它只涉及对 lsm 树的访问，而 lsm 树通常完全驻留在 RAM 中。要启用只有键的迭代，您需要设置 IteratorOptions 。PrefetchValues 字段为 false 。这还可以用于在迭代期间对选定的键执行稀疏读取，只在需要时调用 item.Value() 。(获取键，而不获取对应的值)\n```go\nerr := db.View(func(txn *badger.Txn) error {   \n\topts := badger.DefaultIteratorOptions   \n\topts.PrefetchValues = false   \n\tit := txn.NewIterator(opts)   \n\tdefer it.Close()   \n\tfor it.Rewind(); it.Valid(); it.Next() {\n\t\titem := it.Item()     \n\t\tk := item.Key()     \n\t\tfmt.Printf(\"key=%s\\n\", k)   \n\t}   \n\treturn nil \n})\n```\n\n### 数据流\n\nBadger 提供了一个流框架，它可以并发地遍历数据库的全部或部分，将数据转换为自定义键值，并连续地将数据流输出，以便通过网络发送、写入磁盘，甚至写入 Badger。这是比使用单个迭代器更快的遍历 Badger 的方法。Stream 在管理模式和正常模式下都支持Badger 。\n```go\nstream := db.NewStream() \n// db.NewStreamAt(readTs) for managed mode. \n// -- Optional settings \nstream.NumGo = 16          // Set number of goroutines to use for iteration.\nstream.Prefix = []byte(\"some-prefix\") // Leave nil for iteration over the whole DB. \nstream.LogPrefix = \"Badger.Streaming\" // For identifying stream logs. Outputs to Logger. \n// ChooseKey is called concurrently for every key. If left nil, assumes true by default. \nstream.ChooseKey = func(item *badger.Item) bool {   \n\treturn bytes.HasSuffix(item.Key(), []byte(\"er\")) \n\t// 这个例子中判断后缀 “er” \n} \n// KeyToList is called concurrently for chosen keys. This can be used to convert \n// Badger data into custom key-values. If nil, uses stream.ToList, a default \n// implementation, which picks all valid key-values. \nstream.KeyToList = nil \n// -- End of optional settings. \n// Send is called serially, while Stream.Orchestrate is running. 用于序列化并处理流操作的结果\nstream.Send = func(list *pb.KVList) error {   \n\treturn proto.MarshalText(w, list) // Write to w. \n\t} \n// Run the stream \nif err := stream.Orchestrate(context.Background()); err != nil {   \n\treturn err \n} // Done.\n```\n\n\n### 删除一个key\n\n使用`Txn.Delete()` 方法删除一个key\n\n### 获取 key value\n\n通过 txn.Get 获取 value\n```go\nerr := db.View(func(txn *badger.Txn) error {   \n\titem, err := txn.Get([]byte(\"answer\"))   \n\thandle(err)   \n\tvar valNot, valCopy []byte   \n\terr := item.Value(func(val []byte) error {     \n\t// This func with val would only be called if item.Value encounters no error.     \n\t// Accessing val here is valid.     \n\tfmt.Printf(\"The answer is: %s\\n\", val)     \n\t// Copying or parsing val is valid.     \n\tvalCopy = append([]byte{}, val...)     // 三个点（`...`）的语法，表示将切片 `val` 展开，将其中的元素逐个添加到新的切片 `valCopy` 中。\n\t// Assigning val slice to another variable is NOT OK.     \n\tvalNot = val // Do not do this.     \n\treturn nil   \n})   \nhandle(err)   // DO NOT access val here. It is the most common cause of bugs.\nfmt.Printf(\"NEVER do this. %s\\n\", valNot)   \n// You must copy it to use it outside item.Value(...).   \nfmt.Printf(\"The answer is: %s\\n\", valCopy)   \n// Alternatively, you could also use item.ValueCopy().   \nvalCopy, err = item.ValueCopy(nil)   \nhandle(err)   \nfmt.Printf(\"The answer is: %s\\n\", valCopy)   \nreturn nil \n})\n```\n\n如果不存在 `Txn.Get()` 将会返回一个 `ErrKeyNotFound` 错误\n\n请注意，Get()返回的值只在事务打开时有效。如果需要在事务外部使用值，则必须使用copy() 将其复制到另一个字节片。\n\n### 事务\n\n##### 只读事务\n\n只读事务使用 DB.View()方法\n```go\nerr := db.View(func(txn *badger.Txn) error {  \n\t// Your code here…   \n\treturn nil \n})\n```\n\n##### 读写事务锁\n\n读写事务可以使用 DB.Update()方法\n```go\nerr := db.Update(func(txn *badger.Txn) error {   \n\t// Your code here…   \n\treturn nil \n})\n```\n\n##### 手动管理事务\n\n直接使用`DB.NewTransaction()`函数，手动创建和提交事务。它接受一个布尔参数来指定是否需要读写事务。对于读写事务，需要调用`Txn.Commit()`来确保事务已提交。对于只读事务，调用 `txn.reject()`就可以了。`commit()`也在内部调用 `txn .reject()`来清除事务，因此只需调用Txn.Commit()就足以执行读写事务。\n\n但是，如果您的代码由于某种原因(出错)没有调用`Txn.Commit()`。就需要在defer中调用 `txn . reject()`\n```go\n// Start a writable transaction. \ntxn := db.NewTransaction(true) \ndefer txn.Discard() \n// Use the transaction... \nerr := txn.Set([]byte(\"answer\"), []byte(\"42\")) \nif err != nil {     return err } \n// Commit the transaction and check for error. \nif err := txn.Commit(); err != nil {     \n\treturn err \n}\n```\n\n\n\n## Error 包\n```go\n// 创建一个新 的 error 类型 数据\nerrors.New(\"dest id is not cur id\") \n```\n\n## Server 常用\n\n1. 获取 URL 的路径参数\n    \n      比如： 前端访问：http://127.0.0.1:8080/haha ， 如何获取 haha 这个字符串？ 看代码：\n    \n    ```Bash\n    package main\n    \n    import (\n            \"fmt\"\n            \"net/http\"\n    )\n    \n    func handler(w http.ResponseWriter, r *http.Request) {\n            // 从请求URL中获取路径参数\n            param := r.URL.Path[len(\"/\"):]\n    \n            // 输出获取到的字符串\n            fmt.Println(param)\n    \n            // 在响应中返回获取到的字符串\n            fmt.Fprintf(w, \"Received: %s\", param)\n    }\n    \n    func main() {\n            http.HandleFunc(\"/\", handler)\n            http.ListenAndServe(\":80\", nil)\n    }\n    ```\n    \n2. http 状态码返回\n    \n    ```Bash\n    package main\n    \n    import (\n            \"fmt\"\n            \"net/http\"\n    )\n    func handleRequest(w http.ResponseWriter, r *http.Request) {\n            // 模拟根据请求处理的逻辑\n            if r.URL.Path == \"/\" {\n                    // 处理成功，返回HTTP 200\n                    w.WriteHeader(http.StatusOK)\n                    fmt.Fprintf(w, \"Success\")\n            } else {\n                    // 处理失败，返回HTTP 404\n                    w.WriteHeader(http.StatusNotFound)\n                    fmt.Fprintf(w, \"Not Found\")\n            }\n    }\n    func main() {\n            http.HandleFunc(\"/\", handleRequest)\n            http.ListenAndServe(\":80\", nil)\n    }\n    ```\n    \n3. 闭包\n    \n    ```Bash\n    在Go语言中，http.HandleFunc()函数的第二个参数是一个函数类型，它必须是满足http.HandlerFunc函数签名的函数。该函数接收两个参数：http.ResponseWriter和*http.Request。\n    如果你想在handleRequest函数中传入其他参数，可以使用闭包（Closure）的方式。\n    以下是一个示例代码，展示如何在handleRequest函数中传入其他参数：\n    go\n    复制\n    package main\n    import (\n            \"fmt\"\n            \"net/http\"\n    )\n    \n    func handleRequest(customParam string) http.HandlerFunc {\n            return func(w http.ResponseWriter, r *http.Request) {\n                    // 在这里可以使用 customParam 和 w、r 来处理请求\n                    fmt.Println(\"Custom parameter:\", customParam)\n                    fmt.Fprintf(w, \"Hello, World!\")\n            }\n    }\n    \n    func main() {\n            param := \"custom value\"\n            http.HandleFunc(\"/\", handleRequest(param))\n            http.ListenAndServe(\":8080\", nil)\n    }\n    在上述代码中，我们定义了一个handleRequest函数，它接收一个类型为string的参数customParam。handleRequest函数返回一个函数，该函数满足http.HandlerFunc函数签名。\n    在返回的函数中，我们可以使用闭包的方式访问customParam以及http.ResponseWriter和*http.Request参数，并进行相应的处理。\n    在main函数中，我们定义了一个param变量作为自定义参数的值。然后，我们通过handleRequest(param)将param传递给handleRequest函数，并返回一个满足http.HandlerFunc函数签名的函数。\n    最后，我们使用http.HandleFunc()来将路径\"/\"与返回的处理函数进行绑定，并通过http.ListenAndServe()监听HTTP请求\n    ```\n    \n4. net 和 http同时使用\n    \n      Go 语言中，可以同时使用 `net` 和 `http` 包来监听同一个接口，但是需要小心处理并避免冲突。\n    \n      `net` 包提供了底层的网络功能，可以通过 `net.Listen` 函数来监听指定的网络地址和端口。而 `http` 包是建立在 `net` 包之上的，提供了更高级的 HTTP 服务器和客户端功能。\n    \n      以下是一个示例代码，同时使用 `net` 和 `http` 监听同一个接口：\n    \n      \n    \n    ```Plaintext\n    package main\n    import (\n            \"fmt\"\n            \"net\"\n            \"net/http\"\n    )\n    \n    func main() {\n            // 使用 net 包监听指定的网络地址和端口\n            listener, err := net.Listen(\"tcp\", \"localhost:8080\")\n            if err != nil {\n                    fmt.Println(\"Error listening:\", err)\n                    return\n            }\n            defer listener.Close()\n            // 启动 HTTP 服务器\n            go func() {\n                    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n                            fmt.Fprintf(w, \"Hello, HTTP!\")\n                    })\n                    err := http.Serve(listener, nil)\n                    if err != nil {\n                            fmt.Println(\"Error serving HTTP:\", err)\n                            return\n                    }\n            }()\n    \n            // 其他的网络处理逻辑...\n            // ...\n            // 等待程序退出\n            select {}\n    }\n    ```\n    \n      在上述示例中，我们使用 `net.Listen` 函数监听 `localhost:8080`，然后使用 `http` 包启动了一个 HTTP 服务器。通过 `http.HandleFunc` 函数，我们定义了一个简单的处理函数来响应 HTTP 请求。最后，通过 `http.Serve` 函数将监听器与 HTTP 服务器关联起来。\n    \n      你可以在 `// 其他的网络处理逻辑...` 的部分添加其他网络处理逻辑，如基于 `net` 包的 TCP 或 UDP 服务器。只需确保网络处理逻辑不会与 HTTP 服务器冲突，比如使用不同的端口或处理不同的网络协议。\n    \n      需要注意的是，当使用 `http.Serve` 函数时，它将阻塞当前的 goroutine，因此我们在示例中使用了 `select {}` 来阻止 `main` 函数退出。这样可以保持服务器的运行，直到显式地退出程序。\n    \n5. mymux\n    \n      `myMux := http.NewServeMux()` 这条语句用于创建一个新的 `ServeMux` 对象。\n    \n      在 Go 的 `http` 包中，`ServeMux` 是一个 HTTP 请求多路复用器（multiplexer），用于将收到的 HTTP 请求分发到相应的处理器。`ServeMux` 类型实现了 `http.Handler` 接口，因此它本身可以作为一个处理器来处理请求。\n    \n      通过调用 `http.NewServeMux()` 函数，我们可以创建一个新的 `ServeMux` 对象，它将用于注册和管理不同路径的处理器。\n    \n      例如，下面是一个简单示例，使用 `ServeMux` 对象来管理不同路径的处理器：\n    \n      \n    \n    ```Plaintext\n    package main\n    import (\n            \"fmt\"\n            \"net/http\"\n    )\n    \n    func main() {\n            myMux := http.NewServeMux()\n    \n            myMux.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n                    fmt.Fprintf(w, \"Hello, World!\")\n            })\n    \n            myMux.HandleFunc(\"/about\", func(w http.ResponseWriter, r *http.Request) {\n                    fmt.Fprintf(w, \"About page\")\n            })\n            server := &http.Server{\n                    Addr:    \":8080\",\n                    Handler: myMux,\n            }\n            server.ListenAndServe()\n    }\n    ```\n    \n      在上述示例中，我们首先使用 `http.NewServeMux()` 创建了一个新的 `ServeMux` 对象 `myMux`。然后，我们使用 `myMux.HandleFunc` 方法来注册处理器函数，每个函数对应一个特定的路径。\n    \n      最后，我们创建了一个 `http.Server` 对象，并将 `myMux` 对象作为处理器指定给该服务器。这样，当服务器收到请求时，就会使用 `myMux` 对象来根据请求的路径选择相应的处理器函数进行处理。\n    \n      总结起来，`myMux := http.NewServeMux()` 用于创建一个 `ServeMux` 对象，以便注册和管理不同路径的处理器，并根据路径选择相应的处理函数来处理请求。\n    \n6. go routine 实现并发执行\n    \n      Go 的 goroutine 来实现并发执行。以下是一个示例代码，演示了如何同时运行 HTTP 服务、gRPC 服务和连接其他 gRPC 服务器：\n    \n    \n    ```go\n    package main\n    import (\n            \"log\"\n            \"net\"\n            \"net/http\"\n            \"google.golang.org/grpc\"\n            \"google.golang.org/grpc/credentials\"\n    )\n    \n    func main() {\n            // 创建监听器\n            lis, err := net.Listen(\"tcp\", \":8080\")\n            if err != nil {\n                    log.Fatalf(\"Failed to listen: %v\", err)\n            }\n    \n            // 启动 HTTP 服务器\n            go func() {\n                    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n                            w.Write([]byte(\"Hello, HTTP!\"))\n                    })\n                    if err := http.Serve(lis, nil); err != nil {\n                            log.Fatalf(\"HTTP failed to serve: %v\", err)\n                    }\n            }()\n    \n            // 启动 gRPC 服务器\n            go func() {\n                    s := grpc.NewServer()\n                    // 注册 gRPC 服务\n                    // ...\n                    if err := s.Serve(lis); err != nil {\n                            log.Fatalf(\"gRPC failed to serve: %v\", err)\n                    }\n            }()\n    \n            // 连接其他 gRPC 服务器\n            conn, err := grpc.Dial(\"other_server_address\", grpc.WithTransportCredentials(credentials.NewInsecure()))\n            if err != nil {\n                    log.Fatalf(\"Failed to connect to other server: %v\", err)\n            }\n            defer conn.Close()\n            // 进行其他操作，使用 conn 进行 gRPC 通信\n            // ...\n            // 等待程序退出\n            select {}\n    }\n    ```\n    \n      在这个示例中，我们使用 goroutine 启动了 HTTP 服务器和 gRPC 服务器，并在主函数中创建了一个与其他 gRPC 服务器的连接。\n    \n      注意在连接其他 gRPC 服务器时，我们使用了 `grpc.Dial` 函数，并传递了 `grpc.WithTransportCredentials(credentials.NewInsecure())` 选项来创建一个不安全的连接。你应该根据实际情况选择正确的连接配置，例如使用安全的连接和认证。\n    \n      最后，使用 `select {}` 阻塞主函数，使程序保持运行状态，直到显式退出。\n    \n      请根据你的实际需求，将代码中的注释部分替换为适当的 gRPC 服务注册和其他操作代码。\n    \n\n\n7. 连接阻塞\n    \n    ```Go\n            // 主要就是 grpc.WithBlock()\n            \n            conn2, err2 := grpc.Dial(*addr2, grpc.WithTransportCredentials(insecure.NewCredentials()),grpc.WithBlock())\n            \n    ```\n    \n8. 循环变量副本\n    \n      for i := 1; i <= *rpc_num; i++ {\n    \n      if i == *rpc_id {\n    \n      continue // 跳过与 当前相同的 端口号 ，不能和自己连接\n    \n      }\n    \n      go func(){\n    \n      conn[i], err = grpc.Dial(rpc_addr[i], grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithBlock())\n    \n      if err != nil {\n    \n      log.Fatalf(\"Failed to connect to server %s: %v\", rpc_addr[i], err)\n    \n      return\n    \n      }\n    \n      log.Printf(\"Connect to %s OK\", rpc_addr[i])\n    \n      }()\n    \n      }\n    \n      这里有个提示信息但是没有报错，提示为：loop variable i captured by func litera\n    \n       \"loop variable i captured by func literal\" 意味着在你的代码中，匿名函数字面量（func literal）捕获了循环变量 i。\n    \n      在 Go 语言中，当你在循环体内使用匿名函数时，该匿名函数会形成一个闭包，它可以访问和引用外部作用域中的变量。在这种情况下，匿名函数引用了循环变量 i。然而，循环变量在每次迭代中的值会发生变化，这可能会导致一些意外的行为。\n    \n      为了避免这种问题，Go 语言引入了循环变量副本的概念。在每次迭代中，会为循环体内的匿名函数创建一个新的副本变量，以确保在闭包内部引用的是正确的值。这样可以避免循环变量值的竞争条件。\n    \n      解决这个问题的常见方法是在循环体内部创建一个局部变量，将循环变量的值复制给局部变量，然后在匿名函数中使用局部变量。例如：\n\n    ```Plaintext\n    for i := 1; i <= *rpc_num; i++ {\n        if i == *rpc_id {\n            continue\n        }\n        // 创建局部变量 iCopy 并将循环变量的值赋给它\n        iCopy := i\n        go func() {\n            conn[iCopy], err = grpc.Dial(rpc_addr[iCopy], grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithBlock())\n            if err != nil {\n                log.Fatalf(\"Failed to connect to server %s: %v\", rpc_addr[iCopy], err)\n                return\n            }\n            log.Printf(\"Connect to %s OK\", rpc_addr[iCopy])\n        }()\n    }\n    ```\n    \n      通过创建局部变量 iCopy 并使用它，你可以确保每个匿名函数引用的是该迭代的正确值，而不会受到循环变量的更改影响。\n\n\n\n\n\n\n\n\n\n# Atomic 包\n```go\npackage main\n\nimport (\n    \"log\"\n    \"net/http\"\n    \"runtime\"\n    \"sync/atomic\"\n)\n\nvar count int32\n\nfunc test(w http.ResponseWriter, r *http.Request) {\n    currentCount := atomic.LoadInt32(&count)\n    atomic.AddInt32(&count, 1)\n    log.Println(\"count:\", currentCount)\n}\nfunc main() {\n    runtime.GOMAXPROCS(runtime.NumCPU() - 1)\n    http.HandleFunc(\"/\", test)\n    http.ListenAndServe(\":8080\", nil)\n}\n```\n\n\n\n# Done Wait 同步\n Go 内存模型中的术语。它说明了在调用 `Done` 方法之前，它会与任何由它解除阻塞的 `Wait` 调用之后的返回之前进行\"同步在\"（synchronizes before）的关系。\n\n具体解释如下：\n\n1. `Done` 方法是用于通知等待组（WaitGroup）中某个操作的完成。\n2. `Wait` 方法是等待等待组中所有操作完成的调用。\n3. \"同步在\"（synchronizes before）是 Go 内存模型中的同步关系，指示在同一个 goroutine 中，一个操作的执行在另一个操作之前进行了同步。\n\n根据这句话的解释，当一个 goroutine 调用 `Done` 方法时，它会在解除等待组中的某个操作的阻塞之前与该操作的返回之前进行同步。\n\n具体来说，如果一个 goroutine 在调用 `Wait` 方法等待等待组中的操作时被阻塞，那么当另一个 goroutine 调用 `Done` 方法通知该操作的完成时，调用 `Done` 的 goroutine 会在被阻塞的 goroutine 返回之前进行同步。这确保了在 `Done` 方法解除阻塞之后，等待的 goroutine 可以安全地继续执行。\n\n总之，这句话的含义是在 Go 内存模型中，`Done` 方法的调用会在解除阻塞的 `Wait` 调用的返回之前进行同步。这个同步关系确保了等待组的协同操作的正确性和可靠性。","slug":"编程语言/GO_lang/go 高级","published":1,"date":"2024-04-22T13:14:48.678Z","updated":"2024-04-22T04:39:53.107Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0q002ikgg492ns6q5o","content":"<h1 id=\"常见库\"><a href=\"#常见库\" class=\"headerlink\" title=\"常见库\"></a>常见库</h1><h2 id=\"Flag-包\"><a href=\"#Flag-包\" class=\"headerlink\" title=\"Flag 包\"></a>Flag 包</h2><h3 id=\"flag包基本使用\"><a href=\"#flag包基本使用\" class=\"headerlink\" title=\"flag包基本使用\"></a>flag包基本使用</h3><p><a href=\"https://studygolang.com/pkgdoc\">官方文档</a>]<br><a href=\"https://www.liwenzhou.com/posts/Go/flag/\">参考文档</a></p>\n<h4 id=\"导入flag包\"><a href=\"#导入flag包\" class=\"headerlink\" title=\"导入flag包\"></a>导入flag包</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> flag</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"flag参数类型\"><a href=\"#flag参数类型\" class=\"headerlink\" title=\"flag参数类型\"></a>flag参数类型</h4><p>flag包支持的命令行参数类型有<code>bool</code>、<code>int</code>、<code>int64</code>、<code>uint</code>、<code>uint64</code>、<code>float</code> <code>float64</code>、<code>string</code>、<code>duration</code>。</p>\n<table>\n<thead>\n<tr>\n<th>flag参数</th>\n<th>有效值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>字符串flag</td>\n<td>合法字符串</td>\n</tr>\n<tr>\n<td>整数flag</td>\n<td>1234、0664、0x1234等类型，也可以是负数。</td>\n</tr>\n<tr>\n<td>浮点数flag</td>\n<td>合法浮点数</td>\n</tr>\n<tr>\n<td>bool类型flag</td>\n<td>1, 0, t, f, T, F, true, false, TRUE, FALSE, True, False。</td>\n</tr>\n<tr>\n<td>时间段flag</td>\n<td>任何合法的时间段字符串。如”300ms”、”-1.5h”、“2h45m”。合法的单位有”ns”、“us” &#x2F;“µs”、“ms”、“s”、“m”、“h”。</td>\n</tr>\n</tbody></table>\n<h4 id=\"定义命令行flag参数\"><a href=\"#定义命令行flag参数\" class=\"headerlink\" title=\"定义命令行flag参数\"></a>定义命令行flag参数</h4><p>有以下两种常用的定义命令行<code>flag</code>参数的方法。</p>\n<h3 id=\"flag-Type\"><a href=\"#flag-Type\" class=\"headerlink\" title=\"flag.Type()\"></a>flag.Type()</h3><p>基本格式如下：</p>\n<p><code>flag.Type(flag名, 默认值, 帮助信息)*Type</code> 例如我们要定义姓名、年龄、婚否三个命令行参数，我们可以按如下方式定义：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name := flag.String(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;张三&quot;</span>, <span class=\"string\">&quot;姓名&quot;</span>)</span><br><span class=\"line\">age := flag.Int(<span class=\"string\">&quot;age&quot;</span>, <span class=\"number\">18</span>, <span class=\"string\">&quot;年龄&quot;</span>)</span><br><span class=\"line\">married := flag.Bool(<span class=\"string\">&quot;married&quot;</span>, <span class=\"literal\">false</span>, <span class=\"string\">&quot;婚否&quot;</span>)</span><br><span class=\"line\">delay := flag.Duration(<span class=\"string\">&quot;d&quot;</span>, <span class=\"number\">0</span>, <span class=\"string\">&quot;时间间隔&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，此时<code>name</code>、<code>age</code>、<code>married</code>、<code>delay</code>均为对应类型的指针。</p>\n<h4 id=\"flag-TypeVar\"><a href=\"#flag-TypeVar\" class=\"headerlink\" title=\"flag.TypeVar()\"></a>flag.TypeVar()</h4><p>基本格式如下： <code>flag.TypeVar(Type指针, flag名, 默认值, 帮助信息)</code> 例如我们要定义姓名、年龄、婚否三个命令行参数，我们可以按如下方式定义：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name <span class=\"type\">string</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> age <span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> married <span class=\"type\">bool</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> delay time.Duration</span><br><span class=\"line\">flag.StringVar(&amp;name, <span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;张三&quot;</span>, <span class=\"string\">&quot;姓名&quot;</span>)</span><br><span class=\"line\">flag.IntVar(&amp;age, <span class=\"string\">&quot;age&quot;</span>, <span class=\"number\">18</span>, <span class=\"string\">&quot;年龄&quot;</span>)</span><br><span class=\"line\">flag.BoolVar(&amp;married, <span class=\"string\">&quot;married&quot;</span>, <span class=\"literal\">false</span>, <span class=\"string\">&quot;婚否&quot;</span>)</span><br><span class=\"line\">flag.DurationVar(&amp;delay, <span class=\"string\">&quot;d&quot;</span>, <span class=\"number\">0</span>, <span class=\"string\">&quot;时间间隔&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"flag-Parse\"><a href=\"#flag-Parse\" class=\"headerlink\" title=\"flag.Parse()\"></a>flag.Parse()</h4><p>通过以上两种方法定义好命令行flag参数后，需要通过调用<code>flag.Parse()</code>来对命令行参数进行解析。</p>\n<p>支持的命令行参数格式有以下几种：</p>\n<ul>\n<li><code>-flag xxx</code> （使用空格，一个<code>-</code>符号）</li>\n<li><code>--flag xxx</code> （使用空格，两个<code>-</code>符号）</li>\n<li><code>-flag=xxx</code> （使用等号，一个<code>-</code>符号）</li>\n<li><code>--flag=xxx</code> （使用等号，两个<code>-</code>符号）</li>\n</ul>\n<p>其中，布尔类型的参数必须使用等号的方式指定。</p>\n<p>Flag解析在第一个非flag参数（单个”-“不是flag参数）之前停止，或者在终止符”–“之后停止。</p>\n<h4 id=\"flag其他函数\"><a href=\"#flag其他函数\" class=\"headerlink\" title=\"flag其他函数\"></a>flag其他函数</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flag.Args()  <span class=\"comment\">////返回命令行参数后的其他参数，以[]string类型</span></span><br><span class=\"line\">flag.NArg()  <span class=\"comment\">//返回命令行参数后的其他参数个数</span></span><br><span class=\"line\">flag.NFlag() <span class=\"comment\">//返回使用的命令行参数个数</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"完整示例\"><a href=\"#完整示例\" class=\"headerlink\" title=\"完整示例\"></a>完整示例</h4><h5 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h5><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//定义命令行参数方式1</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> name <span class=\"type\">string</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> age <span class=\"type\">int</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> married <span class=\"type\">bool</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> delay time.Duration</span><br><span class=\"line\">\tflag.StringVar(&amp;name, <span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;张三&quot;</span>, <span class=\"string\">&quot;姓名&quot;</span>)</span><br><span class=\"line\">\tflag.IntVar(&amp;age, <span class=\"string\">&quot;age&quot;</span>, <span class=\"number\">18</span>, <span class=\"string\">&quot;年龄&quot;</span>)</span><br><span class=\"line\">\tflag.BoolVar(&amp;married, <span class=\"string\">&quot;married&quot;</span>, <span class=\"literal\">false</span>, <span class=\"string\">&quot;婚否&quot;</span>)</span><br><span class=\"line\">\tflag.DurationVar(&amp;delay, <span class=\"string\">&quot;d&quot;</span>, <span class=\"number\">0</span>, <span class=\"string\">&quot;延迟的时间间隔&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//解析命令行参数</span></span><br><span class=\"line\">\tflag.Parse()</span><br><span class=\"line\">\tfmt.Println(name, age, married, delay)</span><br><span class=\"line\">\t<span class=\"comment\">//返回命令行参数后的其他参数</span></span><br><span class=\"line\">\tfmt.Println(flag.Args())</span><br><span class=\"line\">\t<span class=\"comment\">//返回命令行参数后的其他参数个数</span></span><br><span class=\"line\">\tfmt.Println(flag.NArg())</span><br><span class=\"line\">\t<span class=\"comment\">//返回使用的命令行参数个数</span></span><br><span class=\"line\">\tfmt.Println(flag.NFlag())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h5><p>命令行参数使用提示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./flag_demo -<span class=\"built_in\">help</span></span><br><span class=\"line\">Usage of ./flag_demo:</span><br><span class=\"line\">  -age int</span><br><span class=\"line\">        年龄 (default 18)</span><br><span class=\"line\">  -d duration</span><br><span class=\"line\">        时间间隔</span><br><span class=\"line\">  -married</span><br><span class=\"line\">        婚否</span><br><span class=\"line\">  -name string</span><br><span class=\"line\">        姓名 (default <span class=\"string\">&quot;张三&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>正常使用命令行flag参数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./flag_demo -name 沙河娜扎 --age 28 -married=<span class=\"literal\">false</span> -d=1h30m</span><br><span class=\"line\">沙河娜扎 28 <span class=\"literal\">false</span> 1h30m0s</span><br><span class=\"line\">[]</span><br><span class=\"line\">0</span><br><span class=\"line\">4</span><br></pre></td></tr></table></figure>\n\n<p>使用非flag命令行参数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./flag_demo a b c</span><br><span class=\"line\">张三 18 <span class=\"literal\">false</span> 0s</span><br><span class=\"line\">[a b c]</span><br><span class=\"line\">3</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h2 id=\"Log-包\"><a href=\"#Log-包\" class=\"headerlink\" title=\"Log 包\"></a>Log 包</h2><p>日志相关，<a href=\"ttps://blog.csdn.net/cold___play/article/details/130744302\">参考</a></p>\n<h3 id=\"基本结构\"><a href=\"#基本结构\" class=\"headerlink\" title=\"基本结构\"></a>基本结构</h3><p>常量列表：</p>\n<ul>\n<li>Ldate         日期 年&#x2F;月&#x2F;日</li>\n<li>Ltime         时间 时:分:秒</li>\n<li>Lmicroseconds 时间 .毫秒于Ltime之后</li>\n<li>Llongfile     完整文件名:行号</li>\n<li>Lshortfile    文件名，此标志位优先于 Llongfile</li>\n<li>LstdFlags     &#x3D; Ldate 并且 Ltime</li>\n</ul>\n<p>功能说明：标志位常量控制日志格式。</p>\n<p>示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tlog.SetFlags(log.Lshortfile | log.LstdFlags)</span><br><span class=\"line\">\tlog.Println(<span class=\"string\">&quot;log:&quot;</span>) <span class=\"comment\">//2023/05/18 12:09:57 constantsDemo.go:15: log:</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>函数列表:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Fatal</span><span class=\"params\">(v ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Fatalf</span><span class=\"params\">(format <span class=\"type\">string</span>, v ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Fatalln</span><span class=\"params\">(v ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Flags</span><span class=\"params\">()</span></span> <span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Panic</span><span class=\"params\">(v ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Panicf</span><span class=\"params\">(format <span class=\"type\">string</span>, v ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Panicln</span><span class=\"params\">(v ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Prefix</span><span class=\"params\">()</span></span> <span class=\"type\">string</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Print</span><span class=\"params\">(v ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Printf</span><span class=\"params\">(format <span class=\"type\">string</span>, v ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Println</span><span class=\"params\">(v ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">SetFlags</span><span class=\"params\">(flag <span class=\"type\">int</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">SetOutput</span><span class=\"params\">(w io.Writer)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">SetPrefix</span><span class=\"params\">(prefix <span class=\"type\">string</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">(out io.Writer, prefix <span class=\"type\">string</span>, flag <span class=\"type\">int</span>)</span></span> *Logger</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *Logger)</span></span> Fatal(v ...<span class=\"keyword\">interface</span>&#123;&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *Logger)</span></span> Fatalf(format <span class=\"type\">string</span>, v ...<span class=\"keyword\">interface</span>&#123;&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *Logger)</span></span> Fatalln(v ...<span class=\"keyword\">interface</span>&#123;&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *Logger)</span></span> Flags() <span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *Logger)</span></span> Output(calldepth <span class=\"type\">int</span>, s <span class=\"type\">string</span>) <span class=\"type\">error</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *Logger)</span></span> Panic(v ...<span class=\"keyword\">interface</span>&#123;&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *Logger)</span></span> Panicf(format <span class=\"type\">string</span>, v ...<span class=\"keyword\">interface</span>&#123;&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *Logger)</span></span> Panicln(v ...<span class=\"keyword\">interface</span>&#123;&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *Logger)</span></span> Prefix() <span class=\"type\">string</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *Logger)</span></span> Print(v ...<span class=\"keyword\">interface</span>&#123;&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *Logger)</span></span> Printf(format <span class=\"type\">string</span>, v ...<span class=\"keyword\">interface</span>&#123;&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *Logger)</span></span> Println(v ...<span class=\"keyword\">interface</span>&#123;&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *Logger)</span></span> SetFlags(flag <span class=\"type\">int</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *Logger)</span></span> SetPrefix(prefix <span class=\"type\">string</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"自定义-logger\"><a href=\"#自定义-logger\" class=\"headerlink\" title=\"自定义 logger:\"></a>自定义 logger:</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">(out io.Writer, prefix <span class=\"type\">string</span>, flag <span class=\"type\">int</span>)</span></span> *Logger</span><br></pre></td></tr></table></figure>\n<p>参数列表：<br>    out 输出目标<br>    prefix 输出前缀<br>    flag 格式配置标识值<br>返回值：<br>    自定义的logger<br>功能说明：<br>    这个方法用来自定义logger，指定输出目标、格式等<br>示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tl := log.New(os.Stderr, <span class=\"string\">&quot;logger&quot;</span>, log.Ldate)</span><br><span class=\"line\">\tl.Println(<span class=\"string\">&quot;log to stderr sample&quot;</span>)<span class=\"comment\">//logger2023/05/18 log to stderr sample</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Fatal系列函数\"><a href=\"#Fatal系列函数\" class=\"headerlink\" title=\"Fatal系列函数\"></a>Fatal系列函数</h3><h4 id=\"1-1-func-Fatal-v-…interface\"><a href=\"#1-1-func-Fatal-v-…interface\" class=\"headerlink\" title=\"1.1 func Fatal(v …interface{})\"></a>1.1 func Fatal(v …interface{})</h4><p>参数列表：<br>    v 待输出参数列表<br>返回值：<br>    无<br>功能说明：<br>    打印日志并退出。相当于调用Print()并os.Exit(1)</p>\n<h4 id=\"1-2-func-Fatalf-format-string-v-…interface\"><a href=\"#1-2-func-Fatalf-format-string-v-…interface\" class=\"headerlink\" title=\"1.2 func Fatalf(format string, v …interface{})\"></a>1.2 func Fatalf(format string, v …interface{})</h4><p>参数列表：<br>    format 输出格式<br>    v 带输出参数列表<br>返回值：<br>    无<br>功能说明：<br>    按格式输出日志，并退出。相当于调用Printf()并调用os.Exit(1)</p>\n<h4 id=\"1-3-func-Fatalln-v-…interface\"><a href=\"#1-3-func-Fatalln-v-…interface\" class=\"headerlink\" title=\"1.3 func Fatalln(v …interface{})\"></a>1.3 func Fatalln(v …interface{})</h4><p>参数列表：<br>    v<br>返回值：<br>    无<br>功能说明：<br>    打印一行日志并退出。相当于调用Println()并os.Exit(1)</p>\n<h4 id=\"1-4-func-l-Logger-Fatal-v-…interface\"><a href=\"#1-4-func-l-Logger-Fatal-v-…interface\" class=\"headerlink\" title=\"1.4 func (l *Logger) Fatal(v …interface{})\"></a>1.4 func (l *Logger) Fatal(v …interface{})</h4><p>参数列表：<br>    v 待输出参数列表<br>返回值：<br>    无<br>功能说明：<br>    打印日志并退出。相当于调用l.Print()并os.Exit(1)</p>\n<h4 id=\"1-5-func-Fatalf-format-string-v-…interface\"><a href=\"#1-5-func-Fatalf-format-string-v-…interface\" class=\"headerlink\" title=\"1.5 func Fatalf(format string, v …interface{})\"></a>1.5 func Fatalf(format string, v …interface{})</h4><p>参数列表：<br>    format 输出格式<br>    v 带输出参数列表<br>返回值：<br>    无<br>功能说明：<br>    按格式输出日志，并退出。相当于调用l.Printf()并调用os.Exit(1)</p>\n<h4 id=\"1-6-func-l-Logger-Fatalln-v-…interface\"><a href=\"#1-6-func-l-Logger-Fatalln-v-…interface\" class=\"headerlink\" title=\"1.6 func (l *Logger) Fatalln(v …interface{})\"></a>1.6 func (l *Logger) Fatalln(v …interface{})</h4><p>参数列表：<br>    v<br>返回值：<br>    无<br>功能说明：<br>    打印一行日志并退出。相当于调用l.Println()并os.Exit(1)</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tage := <span class=\"number\">25</span></span><br><span class=\"line\">\tlog.Fatal(<span class=\"string\">&quot;Hi &amp; Bye ! Age = &quot;</span>, age) <span class=\"comment\">// this will print &quot;Hi &amp; Bye ! Age = 25&quot;</span></span><br><span class=\"line\">\tlog.Println(<span class=\"string\">&quot;This will not be called.&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\tname := <span class=\"string\">&quot;golang&quot;</span></span><br><span class=\"line\">\tlog.Fatalf(<span class=\"string\">&quot;%8d,%8s&quot;</span>, <span class=\"number\">23</span>, name) <span class=\"comment\">//2013/03/10 16:08:49       23,  golang</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tlog.Fatalln(<span class=\"string\">&quot;bye!&quot;</span>) <span class=\"comment\">//2013/03/10 16:14:54 bye!\\n</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tl := log.New(os.Stdout, <span class=\"string\">&quot;&quot;</span>, log.LstdFlags)</span><br><span class=\"line\">\tage = <span class=\"number\">25</span></span><br><span class=\"line\">\tl.Fatal(<span class=\"string\">&quot;Hi &amp; Bye ! Age = &quot;</span>, age) <span class=\"comment\">// this will print &quot;Hi &amp; Bye ! Age = 25&quot;</span></span><br><span class=\"line\">\tl.Println(<span class=\"string\">&quot;This will not be called.&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\tl = log.New(os.Stdout, <span class=\"string\">&quot;&quot;</span>, log.LstdFlags)</span><br><span class=\"line\">\t<span class=\"comment\">//l.Fatalf(&quot;%s&quot;, &quot;hello&quot;)</span></span><br><span class=\"line\">\tname = <span class=\"string\">&quot;golang&quot;</span></span><br><span class=\"line\">\tl.Fatalf(<span class=\"string\">&quot;%8d,%8s&quot;</span>, <span class=\"number\">23</span>, name) <span class=\"comment\">//2013/03/10 16:08:49       23,  golang</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tl = log.New(os.Stdout, <span class=\"string\">&quot;&quot;</span>, log.LstdFlags)</span><br><span class=\"line\">\tl.Fatalln(<span class=\"string\">&quot;bye!&quot;</span>) <span class=\"comment\">//2013/03/10 16:14:54 bye!\\n</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Flags系列函数\"><a href=\"#Flags系列函数\" class=\"headerlink\" title=\"Flags系列函数\"></a>Flags系列函数</h3><h4 id=\"2-1-func-Flags-int\"><a href=\"#2-1-func-Flags-int\" class=\"headerlink\" title=\"2.1 func Flags() int\"></a>2.1 func Flags() int</h4><p>参数列表：<br>    无<br>返回值：<br>    默认logger的配置值<br>功能说明：<br>    返回默认logger配置值。</p>\n<h4 id=\"2-2-func-l-Logger-Flags-int\"><a href=\"#2-2-func-l-Logger-Flags-int\" class=\"headerlink\" title=\"2.2 func (l *Logger) Flags() int\"></a>2.2 func (l *Logger) Flags() int</h4><p>参数列表：<br>    无<br>返回值：<br>    当前logger的配置值<br>功能说明：<br>    返回当前logger配置值。</p>\n<h4 id=\"2-3-func-SetFlags-flag-int\"><a href=\"#2-3-func-SetFlags-flag-int\" class=\"headerlink\" title=\"2.3 func SetFlags(flag int)\"></a>2.3 func SetFlags(flag int)</h4><p>参数列表：<br>    flag logger配置值<br>返回值：<br>    无<br>功能说明：<br>    这个方法用来设置标准logger的配置，默认为3（logger.LstdFlags）</p>\n<h4 id=\"2-4-func-l-Logger-SetFlags-flag-int\"><a href=\"#2-4-func-l-Logger-SetFlags-flag-int\" class=\"headerlink\" title=\"2.4 func (l *Logger) SetFlags(flag int)\"></a>2.4 func (l *Logger) SetFlags(flag int)</h4><p>参数列表：<br>    flag logger配置值<br>返回值：<br>    无<br>功能说明：<br>    这个方法用来设置标准logger的配置，默认为3（logger.LstdFlags）</p>\n<h4 id=\"示例-1\"><a href=\"#示例-1\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;standard flags :&quot;</span>, log.Flags()) <span class=\"comment\">//standard flags : 3</span></span><br><span class=\"line\">\t<span class=\"comment\">//the flags constants</span></span><br><span class=\"line\">\tfmt.Println(log.Ldate)         <span class=\"comment\">//1</span></span><br><span class=\"line\">\tfmt.Println(log.Ltime)         <span class=\"comment\">//2</span></span><br><span class=\"line\">\tfmt.Println(log.Lmicroseconds) <span class=\"comment\">//4</span></span><br><span class=\"line\">\tfmt.Println(log.Llongfile)     <span class=\"comment\">//8</span></span><br><span class=\"line\">\tfmt.Println(log.Lshortfile)    <span class=\"comment\">//16</span></span><br><span class=\"line\">\tfmt.Println(log.LstdFlags)     <span class=\"comment\">//LstdFlags     = Ldate | Ltime   3</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tl := log.New(os.Stdout, <span class=\"string\">&quot;&quot;</span>, log.LstdFlags)</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;logger l&#x27;s flags :&quot;</span>, l.Flags()) <span class=\"comment\">//logger l&#x27;s flags : 3</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tlog.Println(log.Flags()) <span class=\"comment\">//2013/03/10 17:46:53 3</span></span><br><span class=\"line\">\tlog.SetFlags(log.Ldate)</span><br><span class=\"line\">\tlog.Println(log.Flags()) <span class=\"comment\">//2013/03/10 1</span></span><br><span class=\"line\">\tlog.SetFlags(log.LstdFlags | log.Lshortfile)</span><br><span class=\"line\">\tlog.Println(log.Flags()) <span class=\"comment\">//2013/03/10 17:46:53 setflags.go:17: 19</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tl = log.New(os.Stdout, <span class=\"string\">&quot;&quot;</span>, log.LstdFlags)</span><br><span class=\"line\">\tl.Println(l.Flags()) <span class=\"comment\">//2013/03/10 17:46:53 3</span></span><br><span class=\"line\">\tl.SetFlags(log.Ldate)</span><br><span class=\"line\">\tl.Println(l.Flags()) <span class=\"comment\">//2013/03/10 1</span></span><br><span class=\"line\">\tl.SetFlags(log.LstdFlags | log.Lshortfile)</span><br><span class=\"line\">\tl.Println(l.Flags()) <span class=\"comment\">//2013/03/10 17:46:53 setflags.go:17: 19</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Panic系列函数\"><a href=\"#Panic系列函数\" class=\"headerlink\" title=\"Panic系列函数\"></a>Panic系列函数</h3><h4 id=\"3-1-func-l-Logger-Panic-v-…interface\"><a href=\"#3-1-func-l-Logger-Panic-v-…interface\" class=\"headerlink\" title=\"3.1 func (l *Logger) Panic(v …interface{})\"></a>3.1 func (l *Logger) Panic(v …interface{})</h4><p>参数列表：<br>    v 待输出参数列表<br>返回值：<br>    无<br>功能说明：<br>    这个方法相当于调用l.Print()及panic()</p>\n<h4 id=\"3-2-func-l-Logger-Panicf-format-string-v-…interface\"><a href=\"#3-2-func-l-Logger-Panicf-format-string-v-…interface\" class=\"headerlink\" title=\"3.2 func (l *Logger) Panicf(format string, v …interface{})\"></a>3.2 func (l *Logger) Panicf(format string, v …interface{})</h4><p>参数列表：<br>    format 输出格式<br>    v 待输出参数列表<br>返回值：<br>    无<br>功能说明：<br>    相当于调用l.Printf()，之后调用panic()</p>\n<h4 id=\"3-3-func-l-Logger-Panicln-v-…interface\"><a href=\"#3-3-func-l-Logger-Panicln-v-…interface\" class=\"headerlink\" title=\"3.3 func (l *Logger) Panicln(v …interface{})\"></a>3.3 func (l *Logger) Panicln(v …interface{})</h4><p>参数列表：<br>    v 待输出参数列表<br>返回值：<br>    无<br>功能说明：<br>    相当于调用l.Println()并调用panic()</p>\n<h4 id=\"3-4-func-Panic-v-…interface\"><a href=\"#3-4-func-Panic-v-…interface\" class=\"headerlink\" title=\"3.4 func Panic(v …interface{})\"></a>3.4 func Panic(v …interface{})</h4><p>参数列表：<br>    v 待输出参数列表<br>返回值：<br>    无<br>功能说明：<br>    这个方法相当于调用Print()及panic()</p>\n<h4 id=\"3-5-func-Panicf-format-string-v-…interface\"><a href=\"#3-5-func-Panicf-format-string-v-…interface\" class=\"headerlink\" title=\"3.5 func Panicf(format string, v …interface{})\"></a>3.5 func Panicf(format string, v …interface{})</h4><p>参数列表：<br>    format 输出格式<br>    v 待输出参数列表<br>返回值：<br>    - 无<br>功能说明：<br>    相当于调用Printf()，之后调用panic()</p>\n<h4 id=\"3-6-func-Panicln-v-…interface\"><a href=\"#3-6-func-Panicln-v-…interface\" class=\"headerlink\" title=\"3.6 func Panicln(v …interface{})\"></a>3.6 func Panicln(v …interface{})</h4><p>参数列表：<br>    v 待输出参数列表<br>返回值：<br>    无<br>功能说明：<br>    相当于调用Println()并调用panic()</p>\n<h4 id=\"示例-2\"><a href=\"#示例-2\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tl := log.New(os.Stdout, <span class=\"string\">&quot;&quot;</span>, log.LstdFlags)</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err := <span class=\"built_in\">recover</span>(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tfmt.Println(err) <span class=\"comment\">//output : &quot;call panic and stop&quot;</span></span><br><span class=\"line\">\t\t\thandleException()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\tl.Panic(<span class=\"string\">&quot;call panic and stop&quot;</span>)</span><br><span class=\"line\">\tlog.Println(<span class=\"string\">&quot;this will not be called.&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err := <span class=\"built_in\">recover</span>(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err == <span class=\"string\">&quot;3q&quot;</span> &#123;</span><br><span class=\"line\">\t\t\t\tlog.Println(<span class=\"string\">&quot;you are welcome&quot;</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\tl = log.New(os.Stdout, <span class=\"string\">&quot;&quot;</span>, log.LstdFlags)</span><br><span class=\"line\">\tl.Panicf(<span class=\"string\">&quot;%d%s&quot;</span>, <span class=\"number\">3</span>, <span class=\"string\">&quot;q&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err := <span class=\"built_in\">recover</span>(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err == <span class=\"string\">&quot;3q\\n&quot;</span> &#123;</span><br><span class=\"line\">\t\t\t\tlog.Println(<span class=\"string\">&quot;you are welcome&quot;</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\tl = log.New(os.Stdout, <span class=\"string\">&quot;&quot;</span>, log.LstdFlags)</span><br><span class=\"line\">\tl.Panicln(<span class=\"string\">&quot;3q&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">handleException</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tlog.Println(<span class=\"string\">&quot;recovering...&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Print系列函数\"><a href=\"#Print系列函数\" class=\"headerlink\" title=\"Print系列函数\"></a>Print系列函数</h3><h4 id=\"4-1-func-l-Logger-Print-v-…interface\"><a href=\"#4-1-func-l-Logger-Print-v-…interface\" class=\"headerlink\" title=\"4.1 func (l *Logger) Print(v …interface{})\"></a>4.1 func (l *Logger) Print(v …interface{})</h4><p>参数列表：<br>    v 待输出参数列表<br>返回值：<br>    无<br>功能说明：<br>    输出日志到logger。参数处理方式同fmt.Print</p>\n<h4 id=\"4-2-func-l-Logger-Printf-format-string-v-…interface\"><a href=\"#4-2-func-l-Logger-Printf-format-string-v-…interface\" class=\"headerlink\" title=\"4.2 func (l *Logger) Printf(format string, v …interface{})\"></a>4.2 func (l *Logger) Printf(format string, v …interface{})</h4><p>参数列表：<br>    format 输出格式<br>    v 待输出参数列表<br>返回值：<br>    无<br>功能说明：<br>    调用l.Output输出日志到logger l。参数处理方式同fmt.Printf</p>\n<h4 id=\"4-3-func-l-Logger-Println-v-…interface\"><a href=\"#4-3-func-l-Logger-Println-v-…interface\" class=\"headerlink\" title=\"4.3 func (l *Logger) Println(v …interface{})\"></a>4.3 func (l *Logger) Println(v …interface{})</h4><p>参数列表：<br>    v 待输出参数列表<br>返回值：<br>    无<br>功能说明：<br>    调用Output打印日志到当前logger，参数处理方式同fmt.Println</p>\n<h4 id=\"4-4-func-Print-v-…interface\"><a href=\"#4-4-func-Print-v-…interface\" class=\"headerlink\" title=\"4.4 func Print(v …interface{})\"></a>4.4 func Print(v …interface{})</h4><p>参数列表：<br>    v 待输出参数列表<br>返回值：<br>    无<br>功能说明：<br>    输出日志到标准logger。参数处理方式同fmt.Print</p>\n<h4 id=\"4-5-func-Printf-format-string-v-…interface\"><a href=\"#4-5-func-Printf-format-string-v-…interface\" class=\"headerlink\" title=\"4.5 func Printf(format string, v …interface{})\"></a>4.5 func Printf(format string, v …interface{})</h4><p>参数列表：<br>    format 输出格式<br>    v 待输出参数列表<br>返回值：<br>    无<br>功能说明：<br>    调用Output输出日志到标准logger。参数处理方式同fmt.Printf</p>\n<h4 id=\"4-6-func-Println-v-…interface\"><a href=\"#4-6-func-Println-v-…interface\" class=\"headerlink\" title=\"4.6 func Println(v …interface{})\"></a>4.6 func Println(v …interface{})</h4><p>参数列表：<br>    v<br>返回值：<br>    无<br>功能说明：<br>    调用Output打印日志到标准logger，参数处理方式同fmt.Println</p>\n<h4 id=\"示例-3\"><a href=\"#示例-3\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tl := log.New(os.Stdout, <span class=\"string\">&quot;&quot;</span>, log.LstdFlags)</span><br><span class=\"line\">\tl.Print(<span class=\"string\">&quot;string&quot;</span>, <span class=\"number\">1</span>, <span class=\"number\">2.3</span>) <span class=\"comment\">//2013/03/10 17:26:06 string1 2.3</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tl = log.New(os.Stdout, <span class=\"string\">&quot;&quot;</span>, log.LstdFlags)</span><br><span class=\"line\">\tl.Printf(<span class=\"string\">&quot;%s&quot;</span>, <span class=\"string\">&quot;hello&quot;</span>) <span class=\"comment\">//hello</span></span><br><span class=\"line\">\tname := <span class=\"string\">&quot;golang&quot;</span></span><br><span class=\"line\">\tl.Printf(<span class=\"string\">&quot;%8d,%8s&quot;</span>, <span class=\"number\">23</span>, name) <span class=\"comment\">//2013/03/10 16:08:49       23,  golang</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tl = log.New(os.Stdout, <span class=\"string\">&quot;&quot;</span>, log.LstdFlags)</span><br><span class=\"line\">\tl.Println(<span class=\"string\">&quot;hello&quot;</span>) <span class=\"comment\">//2013/03/10 17:35:28 hello\\n</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tlog.Print(<span class=\"string\">&quot;string&quot;</span>, <span class=\"number\">1</span>, <span class=\"number\">2.3</span>) <span class=\"comment\">//2013/03/10 17:26:06 string1 2.3</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tlog.Printf(<span class=\"string\">&quot;%s&quot;</span>, <span class=\"string\">&quot;hello&quot;</span>) <span class=\"comment\">//hello</span></span><br><span class=\"line\">\tname = <span class=\"string\">&quot;golang&quot;</span></span><br><span class=\"line\">\tlog.Printf(<span class=\"string\">&quot;%8d,%8s&quot;</span>, <span class=\"number\">23</span>, name) <span class=\"comment\">//2013/03/10 16:08:49       23,  golang</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tlog.Println(<span class=\"string\">&quot;hello&quot;</span>) <span class=\"comment\">//2013/03/10 17:35:28 hello\\n</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"其它函数\"><a href=\"#其它函数\" class=\"headerlink\" title=\"其它函数\"></a>其它函数</h3><h4 id=\"5-1-func-l-Logger-Prefix-string\"><a href=\"#5-1-func-l-Logger-Prefix-string\" class=\"headerlink\" title=\"5.1 func (l *Logger) Prefix() string\"></a>5.1 func (l *Logger) Prefix() string</h4><p>参数列表：<br>    无<br>返回值：<br>    logger前缀，字符串类型<br>功能说明：<br>    返回当前logger的输出前缀</p>\n<h4 id=\"5-2-func-Prefix-string\"><a href=\"#5-2-func-Prefix-string\" class=\"headerlink\" title=\"5.2 func Prefix() string\"></a>5.2 func Prefix() string</h4><p>参数列表：<br>    无<br>返回值：<br>    标准logger前缀，字符串类型<br>功能说明：<br>    返回标准logger的输出前缀</p>\n<h4 id=\"5-3-func-SetPrefix-prefix-string\"><a href=\"#5-3-func-SetPrefix-prefix-string\" class=\"headerlink\" title=\"5.3 func SetPrefix(prefix string)\"></a>5.3 func SetPrefix(prefix string)</h4><p>参数列表：<br>    prefix 前缀<br>返回值：<br>    无<br>功能说明：<br>    设置logger的输出前缀</p>\n<h4 id=\"5-4-func-SetPrefix-prefix-string\"><a href=\"#5-4-func-SetPrefix-prefix-string\" class=\"headerlink\" title=\"5.4 func SetPrefix(prefix string)\"></a>5.4 func SetPrefix(prefix string)</h4><p>参数列表：<br>    prefix 前缀<br>返回值：<br>    无<br>功能说明：<br>    设置logger的输出前缀</p>\n<h4 id=\"5-5-func-l-Logger-Output-calldepth-int-s-string-error\"><a href=\"#5-5-func-l-Logger-Output-calldepth-int-s-string-error\" class=\"headerlink\" title=\"5.5 func (l *Logger) Output(calldepth int, s string) error\"></a>5.5 func (l *Logger) Output(calldepth int, s string) error</h4><p>参数列表：<br>    calldepth 深度<br>    s 字符串<br>返回值：<br>    error 错误<br>功能说明：<br>    输出日志事件。字符串s包含待打印内容，跟在预定义的prefix后面，并且根据flags设置会有区分。如果s末尾没有换行符，这个方法会默认加上一个。calldepth目前预定义均为2,以后会用来支持通用场景，支持其他值配置。（本人注：日志输出不建议直接使用该方法）</p>\n<h4 id=\"5-6-func-SetOutput-w-io-Writer\"><a href=\"#5-6-func-SetOutput-w-io-Writer\" class=\"headerlink\" title=\"5.6 func SetOutput(w io.Writer)\"></a>5.6 func SetOutput(w io.Writer)</h4><p>参数列表：<br>    w 目标流，io.Writer类型<br>返回值：<br>    无<br>功能说明：<br>    设置标准logger的输出目标</p>\n<h4 id=\"示例-4\"><a href=\"#示例-4\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tl := log.New(os.Stdout, <span class=\"string\">&quot;&quot;</span>, log.LstdFlags)</span><br><span class=\"line\">\tfmt.Print(l.Prefix()) <span class=\"comment\">//this will print nothing</span></span><br><span class=\"line\">\tl.Println(<span class=\"number\">1</span>)          <span class=\"comment\">//2013/03/10 17:02:05 1</span></span><br><span class=\"line\">\tl.SetPrefix(<span class=\"string\">&quot;log:&quot;</span>)</span><br><span class=\"line\">\tfmt.Println(l.Prefix()) <span class=\"comment\">//log:</span></span><br><span class=\"line\">\tl.Println(<span class=\"number\">2</span>)            <span class=\"comment\">//log:2013/03/10 17:02:05 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Print(log.Prefix()) <span class=\"comment\">//this will print nothing</span></span><br><span class=\"line\">\tlog.Println(<span class=\"number\">1</span>)          <span class=\"comment\">//2013/03/10 17:02:05 1</span></span><br><span class=\"line\">\tlog.SetPrefix(<span class=\"string\">&quot;log:&quot;</span>)</span><br><span class=\"line\">\tfmt.Println(log.Prefix()) <span class=\"comment\">//log:</span></span><br><span class=\"line\">\tlog.Println(<span class=\"number\">2</span>)            <span class=\"comment\">//log:2013/03/10 17:02:05 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tl = log.New(os.Stdout, <span class=\"string\">&quot;&quot;</span>, log.LstdFlags)</span><br><span class=\"line\">\tfmt.Print(l.Prefix()) <span class=\"comment\">//this will print nothing</span></span><br><span class=\"line\">\tl.Println(<span class=\"number\">1</span>)          <span class=\"comment\">//2013/03/10 17:02:05 1</span></span><br><span class=\"line\">\tl.SetPrefix(<span class=\"string\">&quot;log:&quot;</span>)</span><br><span class=\"line\">\tfmt.Println(l.Prefix()) <span class=\"comment\">//log:</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tl.Println(<span class=\"number\">2</span>) <span class=\"comment\">//log:2013/03/10 17:02:05 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Print(log.Prefix()) <span class=\"comment\">//this will print nothing</span></span><br><span class=\"line\">\tlog.Println(<span class=\"number\">1</span>)          <span class=\"comment\">//2013/03/10 17:02:05 1</span></span><br><span class=\"line\">\tlog.SetPrefix(<span class=\"string\">&quot;log:&quot;</span>)</span><br><span class=\"line\">\tfmt.Println(log.Prefix()) <span class=\"comment\">//log:</span></span><br><span class=\"line\">\tlog.Println(<span class=\"number\">2</span>)            <span class=\"comment\">//log:2013/03/10 17:02:05 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tl = log.New(os.Stdout, <span class=\"string\">&quot;log-&gt;&quot;</span>, log.Ldate)</span><br><span class=\"line\">\tl.Output(<span class=\"number\">2</span>, <span class=\"string\">&quot;log output&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\tfile, err := os.OpenFile(<span class=\"string\">&quot;sample.txt&quot;</span>, os.O_WRONLY, <span class=\"number\">0666</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> file.Close()</span><br><span class=\"line\">\tlog.SetOutput(file)</span><br><span class=\"line\">\tlog.Println(<span class=\"string\">&quot;log to file&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Badger-包\"><a href=\"#Badger-包\" class=\"headerlink\" title=\"Badger 包\"></a>Badger 包</h2><p><a href=\"https://juejin.cn/post/6844903814571491335\">参考</a><br><a href=\"https://pkg.go.dev/github.com/dgraph-io/badger#Txn\">官方文档</a><br>badger是一个纯Go实现的快速的嵌入式K&#x2F;V数据库，针对LSM tree做了优化。</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p><code>$ go get github.com/dgraph-io/badger/...</code></p>\n<h3 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h3><p>打开一个数据库</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">opts := badger.DefaultOptions</span><br><span class=\"line\">opts.Dir = <span class=\"string\">&quot;/tmp/badger&quot;</span> </span><br><span class=\"line\">opts.ValueDir = <span class=\"string\">&quot;/tmp/badger&quot;</span> </span><br><span class=\"line\">db, err := badger.Open(opts) </span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\tlog.Fatal(err) </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">defer</span> db.Close()</span><br></pre></td></tr></table></figure>\n<h3 id=\"存储\"><a href=\"#存储\" class=\"headerlink\" title=\"存储\"></a>存储</h3><h4 id=\"存储kv\"><a href=\"#存储kv\" class=\"headerlink\" title=\"存储kv\"></a>存储kv</h4><p>使用 Txn.Set()方法</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">err := db.Update(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(txn *badger.Txn)</span></span> <span class=\"type\">error</span> &#123;   </span><br><span class=\"line\">\terr := txn.Set([]<span class=\"type\">byte</span>(<span class=\"string\">&quot;answer&quot;</span>), []<span class=\"type\">byte</span>(<span class=\"string\">&quot;42&quot;</span>))   </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> err </span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"批量设置\"><a href=\"#批量设置\" class=\"headerlink\" title=\"批量设置\"></a>批量设置</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wb := db.NewWriteBatch() </span><br><span class=\"line\"><span class=\"keyword\">defer</span> wb.Cancel() </span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; N; i++ &#123;</span><br><span class=\"line\">\terr := wb.Set(key(i), value(i), <span class=\"number\">0</span>) <span class=\"comment\">// Will create txns as needed. </span></span><br><span class=\"line\">\thandle(err) </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">handle(wb.Flush()) <span class=\"comment\">// Wait for all txns to finish.</span></span><br></pre></td></tr></table></figure>\n<p>WriteBatch不允许任何读取。对于读-修改-写，应该使用事务API。</p>\n<h5 id=\"设置生存时间-TTL\"><a href=\"#设置生存时间-TTL\" class=\"headerlink\" title=\"设置生存时间 TTL\"></a>设置生存时间 TTL</h5><p>Badger 允许在键上设置一个可选的生存时间 (TTL) 值。一旦 TTL 结束，KEY 将不再是可检索的，并且将进行垃圾收集。TTL 可以使用 Txn.SetWithTTL() 设置为一个<code>time.Duration</code>的值</p>\n<h5 id=\"设置元数据\"><a href=\"#设置元数据\" class=\"headerlink\" title=\"设置元数据\"></a>设置元数据</h5><p><code>Txn.SetWithMeta()</code> 设置用户元数据</p>\n<p>使用 <code>Txn.SetEntry()</code> 可以一次性设置 key, value, user metatadata 和 TTL</p>\n<h5 id=\"遍历-keys\"><a href=\"#遍历-keys\" class=\"headerlink\" title=\"遍历 keys\"></a>遍历 keys</h5><p>要遍历键，我们可以使用迭代器，可以使用 <code>Txn.NewIterator()</code>方法获得迭代器。迭代按字节字典排序顺序进行。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">err := db.View(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(txn *badger.Txn)</span></span> <span class=\"type\">error</span> &#123; <span class=\"comment\">// badger 的 view 方法创建一个只读事务</span></span><br><span class=\"line\">\topts := badger.DefaultIteratorOptions   </span><br><span class=\"line\">\topts.PrefetchSize = <span class=\"number\">10</span>   </span><br><span class=\"line\">\tit := txn.NewIterator(opts)   </span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> it.Close()   </span><br><span class=\"line\">\t<span class=\"keyword\">for</span> it.Rewind(); it.Valid(); it.Next() &#123;</span><br><span class=\"line\">\t    item := it.Item() </span><br><span class=\"line\">\t    k := item.Key()     </span><br><span class=\"line\">\t    err := item.Value(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(v []<span class=\"type\">byte</span>)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\t        fmt.Printf(<span class=\"string\">&quot;key=%s, value=%s\\n&quot;</span>, k, v)       </span><br><span class=\"line\">\t        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>     </span><br><span class=\"line\">\t        &#125;)     </span><br><span class=\"line\">\t    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;       </span><br><span class=\"line\">\t\t    <span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t\t&#125;   </span><br><span class=\"line\">\t&#125;   </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span> </span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h6 id=\"前缀扫描\"><a href=\"#前缀扫描\" class=\"headerlink\" title=\"前缀扫描\"></a>前缀扫描</h6><p>要遍历键前缀，可以将 Seek() 和 ValidForPrefix() 组合使用：（这里的前缀是键值的）</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.View(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(txn *badger.Txn)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\tit := txn.NewIterator(badger.DefaultIteratorOptions)</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> it.Close()   </span><br><span class=\"line\">\tprefix := []<span class=\"type\">byte</span>(<span class=\"string\">&quot;1234&quot;</span>)   </span><br><span class=\"line\">\t<span class=\"keyword\">for</span> it.Seek(prefix); it.ValidForPrefix(prefix); it.Next() &#123;</span><br><span class=\"line\">\t\titem := it.Item()    </span><br><span class=\"line\">\t\tk := item.Key()     </span><br><span class=\"line\">\t\terr := item.Value(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(v []<span class=\"type\">byte</span>)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\t\t\tfmt.Printf(<span class=\"string\">&quot;key=%s, value=%s\\n&quot;</span>, k, v)       </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>     </span><br><span class=\"line\">\t\t&#125;)     </span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;       </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> err     </span><br><span class=\"line\">\t\t&#125;   </span><br><span class=\"line\">\t&#125;   </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span> </span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h6 id=\"键的遍历\"><a href=\"#键的遍历\" class=\"headerlink\" title=\"键的遍历\"></a>键的遍历</h6><p>Badger支持一种独特的迭代模式，称为只有键的迭代。它比常规迭代快几个数量级，因为它只涉及对 lsm 树的访问，而 lsm 树通常完全驻留在 RAM 中。要启用只有键的迭代，您需要设置 IteratorOptions 。PrefetchValues 字段为 false 。这还可以用于在迭代期间对选定的键执行稀疏读取，只在需要时调用 item.Value() 。(获取键，而不获取对应的值)</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">err := db.View(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(txn *badger.Txn)</span></span> <span class=\"type\">error</span> &#123;   </span><br><span class=\"line\">\topts := badger.DefaultIteratorOptions   </span><br><span class=\"line\">\topts.PrefetchValues = <span class=\"literal\">false</span>   </span><br><span class=\"line\">\tit := txn.NewIterator(opts)   </span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> it.Close()   </span><br><span class=\"line\">\t<span class=\"keyword\">for</span> it.Rewind(); it.Valid(); it.Next() &#123;</span><br><span class=\"line\">\t\titem := it.Item()     </span><br><span class=\"line\">\t\tk := item.Key()     </span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">&quot;key=%s\\n&quot;</span>, k)   </span><br><span class=\"line\">\t&#125;   </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span> </span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数据流\"><a href=\"#数据流\" class=\"headerlink\" title=\"数据流\"></a>数据流</h3><p>Badger 提供了一个流框架，它可以并发地遍历数据库的全部或部分，将数据转换为自定义键值，并连续地将数据流输出，以便通过网络发送、写入磁盘，甚至写入 Badger。这是比使用单个迭代器更快的遍历 Badger 的方法。Stream 在管理模式和正常模式下都支持Badger 。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stream := db.NewStream() </span><br><span class=\"line\"><span class=\"comment\">// db.NewStreamAt(readTs) for managed mode. </span></span><br><span class=\"line\"><span class=\"comment\">// -- Optional settings </span></span><br><span class=\"line\">stream.NumGo = <span class=\"number\">16</span>          <span class=\"comment\">// Set number of goroutines to use for iteration.</span></span><br><span class=\"line\">stream.Prefix = []<span class=\"type\">byte</span>(<span class=\"string\">&quot;some-prefix&quot;</span>) <span class=\"comment\">// Leave nil for iteration over the whole DB. </span></span><br><span class=\"line\">stream.LogPrefix = <span class=\"string\">&quot;Badger.Streaming&quot;</span> <span class=\"comment\">// For identifying stream logs. Outputs to Logger. </span></span><br><span class=\"line\"><span class=\"comment\">// ChooseKey is called concurrently for every key. If left nil, assumes true by default. </span></span><br><span class=\"line\">stream.ChooseKey = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(item *badger.Item)</span></span> <span class=\"type\">bool</span> &#123;   </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> bytes.HasSuffix(item.Key(), []<span class=\"type\">byte</span>(<span class=\"string\">&quot;er&quot;</span>)) </span><br><span class=\"line\">\t<span class=\"comment\">// 这个例子中判断后缀 “er” </span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"comment\">// KeyToList is called concurrently for chosen keys. This can be used to convert </span></span><br><span class=\"line\"><span class=\"comment\">// Badger data into custom key-values. If nil, uses stream.ToList, a default </span></span><br><span class=\"line\"><span class=\"comment\">// implementation, which picks all valid key-values. </span></span><br><span class=\"line\">stream.KeyToList = <span class=\"literal\">nil</span> </span><br><span class=\"line\"><span class=\"comment\">// -- End of optional settings. </span></span><br><span class=\"line\"><span class=\"comment\">// Send is called serially, while Stream.Orchestrate is running. 用于序列化并处理流操作的结果</span></span><br><span class=\"line\">stream.Send = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(list *pb.KVList)</span></span> <span class=\"type\">error</span> &#123;   </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> proto.MarshalText(w, list) <span class=\"comment\">// Write to w. </span></span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\"><span class=\"comment\">// Run the stream </span></span><br><span class=\"line\"><span class=\"keyword\">if</span> err := stream.Orchestrate(context.Background()); err != <span class=\"literal\">nil</span> &#123;   </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> err </span><br><span class=\"line\">&#125; <span class=\"comment\">// Done.</span></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"删除一个key\"><a href=\"#删除一个key\" class=\"headerlink\" title=\"删除一个key\"></a>删除一个key</h3><p>使用<code>Txn.Delete()</code> 方法删除一个key</p>\n<h3 id=\"获取-key-value\"><a href=\"#获取-key-value\" class=\"headerlink\" title=\"获取 key value\"></a>获取 key value</h3><p>通过 txn.Get 获取 value</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">err := db.View(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(txn *badger.Txn)</span></span> <span class=\"type\">error</span> &#123;   </span><br><span class=\"line\">\titem, err := txn.Get([]<span class=\"type\">byte</span>(<span class=\"string\">&quot;answer&quot;</span>))   </span><br><span class=\"line\">\thandle(err)   </span><br><span class=\"line\">\t<span class=\"keyword\">var</span> valNot, valCopy []<span class=\"type\">byte</span>   </span><br><span class=\"line\">\terr := item.Value(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(val []<span class=\"type\">byte</span>)</span></span> <span class=\"type\">error</span> &#123;     </span><br><span class=\"line\">\t<span class=\"comment\">// This func with val would only be called if item.Value encounters no error.     </span></span><br><span class=\"line\">\t<span class=\"comment\">// Accessing val here is valid.     </span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;The answer is: %s\\n&quot;</span>, val)     </span><br><span class=\"line\">\t<span class=\"comment\">// Copying or parsing val is valid.     </span></span><br><span class=\"line\">\tvalCopy = <span class=\"built_in\">append</span>([]<span class=\"type\">byte</span>&#123;&#125;, val...)     <span class=\"comment\">// 三个点（`...`）的语法，表示将切片 `val` 展开，将其中的元素逐个添加到新的切片 `valCopy` 中。</span></span><br><span class=\"line\">\t<span class=\"comment\">// Assigning val slice to another variable is NOT OK.     </span></span><br><span class=\"line\">\tvalNot = val <span class=\"comment\">// Do not do this.     </span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>   </span><br><span class=\"line\">&#125;)   </span><br><span class=\"line\">handle(err)   <span class=\"comment\">// DO NOT access val here. It is the most common cause of bugs.</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;NEVER do this. %s\\n&quot;</span>, valNot)   </span><br><span class=\"line\"><span class=\"comment\">// You must copy it to use it outside item.Value(...).   </span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;The answer is: %s\\n&quot;</span>, valCopy)   </span><br><span class=\"line\"><span class=\"comment\">// Alternatively, you could also use item.ValueCopy().   </span></span><br><span class=\"line\">valCopy, err = item.ValueCopy(<span class=\"literal\">nil</span>)   </span><br><span class=\"line\">handle(err)   </span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;The answer is: %s\\n&quot;</span>, valCopy)   </span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"literal\">nil</span> </span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>如果不存在 <code>Txn.Get()</code> 将会返回一个 <code>ErrKeyNotFound</code> 错误</p>\n<p>请注意，Get()返回的值只在事务打开时有效。如果需要在事务外部使用值，则必须使用copy() 将其复制到另一个字节片。</p>\n<h3 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h3><h5 id=\"只读事务\"><a href=\"#只读事务\" class=\"headerlink\" title=\"只读事务\"></a>只读事务</h5><p>只读事务使用 DB.View()方法</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">err := db.View(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(txn *badger.Txn)</span></span> <span class=\"type\">error</span> &#123;  </span><br><span class=\"line\">\t<span class=\"comment\">// Your code here…   </span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span> </span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"读写事务锁\"><a href=\"#读写事务锁\" class=\"headerlink\" title=\"读写事务锁\"></a>读写事务锁</h5><p>读写事务可以使用 DB.Update()方法</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">err := db.Update(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(txn *badger.Txn)</span></span> <span class=\"type\">error</span> &#123;   </span><br><span class=\"line\">\t<span class=\"comment\">// Your code here…   </span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span> </span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"手动管理事务\"><a href=\"#手动管理事务\" class=\"headerlink\" title=\"手动管理事务\"></a>手动管理事务</h5><p>直接使用<code>DB.NewTransaction()</code>函数，手动创建和提交事务。它接受一个布尔参数来指定是否需要读写事务。对于读写事务，需要调用<code>Txn.Commit()</code>来确保事务已提交。对于只读事务，调用 <code>txn.reject()</code>就可以了。<code>commit()</code>也在内部调用 <code>txn .reject()</code>来清除事务，因此只需调用Txn.Commit()就足以执行读写事务。</p>\n<p>但是，如果您的代码由于某种原因(出错)没有调用<code>Txn.Commit()</code>。就需要在defer中调用 <code>txn . reject()</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Start a writable transaction. </span></span><br><span class=\"line\">txn := db.NewTransaction(<span class=\"literal\">true</span>) </span><br><span class=\"line\"><span class=\"keyword\">defer</span> txn.Discard() </span><br><span class=\"line\"><span class=\"comment\">// Use the transaction... </span></span><br><span class=\"line\">err := txn.Set([]<span class=\"type\">byte</span>(<span class=\"string\">&quot;answer&quot;</span>), []<span class=\"type\">byte</span>(<span class=\"string\">&quot;42&quot;</span>)) </span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;     <span class=\"keyword\">return</span> err &#125; </span><br><span class=\"line\"><span class=\"comment\">// Commit the transaction and check for error. </span></span><br><span class=\"line\"><span class=\"keyword\">if</span> err := txn.Commit(); err != <span class=\"literal\">nil</span> &#123;     </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> err </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Error-包\"><a href=\"#Error-包\" class=\"headerlink\" title=\"Error 包\"></a>Error 包</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个新 的 error 类型 数据</span></span><br><span class=\"line\">errors.New(<span class=\"string\">&quot;dest id is not cur id&quot;</span>) </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Server-常用\"><a href=\"#Server-常用\" class=\"headerlink\" title=\"Server 常用\"></a>Server 常用</h2><ol>\n<li><p>获取 URL 的路径参数</p>\n<p>   比如： 前端访问：<a href=\"http://127.0.0.1:8080/haha\">http://127.0.0.1:8080/haha</a> ， 如何获取 haha 这个字符串？ 看代码：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">        <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">        <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func handler(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">        // 从请求URL中获取路径参数</span><br><span class=\"line\">        param := r.URL.Path[len(<span class=\"string\">&quot;/&quot;</span>):]</span><br><span class=\"line\"></span><br><span class=\"line\">        // 输出获取到的字符串</span><br><span class=\"line\">        fmt.Println(param)</span><br><span class=\"line\"></span><br><span class=\"line\">        // 在响应中返回获取到的字符串</span><br><span class=\"line\">        fmt.Fprintf(w, <span class=\"string\">&quot;Received: %s&quot;</span>, param)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func <span class=\"function\"><span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">        http.HandleFunc(<span class=\"string\">&quot;/&quot;</span>, handler)</span><br><span class=\"line\">        http.ListenAndServe(<span class=\"string\">&quot;:80&quot;</span>, nil)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>http 状态码返回</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">        <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">        <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\">func handleRequest(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">        // 模拟根据请求处理的逻辑</span><br><span class=\"line\">        <span class=\"keyword\">if</span> r.URL.Path == <span class=\"string\">&quot;/&quot;</span> &#123;</span><br><span class=\"line\">                // 处理成功，返回HTTP 200</span><br><span class=\"line\">                w.WriteHeader(http.StatusOK)</span><br><span class=\"line\">                fmt.Fprintf(w, <span class=\"string\">&quot;Success&quot;</span>)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                // 处理失败，返回HTTP 404</span><br><span class=\"line\">                w.WriteHeader(http.StatusNotFound)</span><br><span class=\"line\">                fmt.Fprintf(w, <span class=\"string\">&quot;Not Found&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func <span class=\"function\"><span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">        http.HandleFunc(<span class=\"string\">&quot;/&quot;</span>, handleRequest)</span><br><span class=\"line\">        http.ListenAndServe(<span class=\"string\">&quot;:80&quot;</span>, nil)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>闭包</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在Go语言中，http.HandleFunc()函数的第二个参数是一个函数类型，它必须是满足http.HandlerFunc函数签名的函数。该函数接收两个参数：http.ResponseWriter和*http.Request。</span><br><span class=\"line\">如果你想在handleRequest函数中传入其他参数，可以使用闭包（Closure）的方式。</span><br><span class=\"line\">以下是一个示例代码，展示如何在handleRequest函数中传入其他参数：</span><br><span class=\"line\">go</span><br><span class=\"line\">复制</span><br><span class=\"line\">package main</span><br><span class=\"line\">import (</span><br><span class=\"line\">        <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">        <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func handleRequest(customParam string) http.HandlerFunc &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">                // 在这里可以使用 customParam 和 w、r 来处理请求</span><br><span class=\"line\">                fmt.Println(<span class=\"string\">&quot;Custom parameter:&quot;</span>, customParam)</span><br><span class=\"line\">                fmt.Fprintf(w, <span class=\"string\">&quot;Hello, World!&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func <span class=\"function\"><span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">        param := <span class=\"string\">&quot;custom value&quot;</span></span><br><span class=\"line\">        http.HandleFunc(<span class=\"string\">&quot;/&quot;</span>, handleRequest(param))</span><br><span class=\"line\">        http.ListenAndServe(<span class=\"string\">&quot;:8080&quot;</span>, nil)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">在上述代码中，我们定义了一个handleRequest函数，它接收一个类型为string的参数customParam。handleRequest函数返回一个函数，该函数满足http.HandlerFunc函数签名。</span><br><span class=\"line\">在返回的函数中，我们可以使用闭包的方式访问customParam以及http.ResponseWriter和*http.Request参数，并进行相应的处理。</span><br><span class=\"line\">在main函数中，我们定义了一个param变量作为自定义参数的值。然后，我们通过handleRequest(param)将param传递给handleRequest函数，并返回一个满足http.HandlerFunc函数签名的函数。</span><br><span class=\"line\">最后，我们使用http.HandleFunc()来将路径<span class=\"string\">&quot;/&quot;</span>与返回的处理函数进行绑定，并通过http.ListenAndServe()监听HTTP请求</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>net 和 http同时使用</p>\n<p>   Go 语言中，可以同时使用 <code>net</code> 和 <code>http</code> 包来监听同一个接口，但是需要小心处理并避免冲突。</p>\n<p>   <code>net</code> 包提供了底层的网络功能，可以通过 <code>net.Listen</code> 函数来监听指定的网络地址和端口。而 <code>http</code> 包是建立在 <code>net</code> 包之上的，提供了更高级的 HTTP 服务器和客户端功能。</p>\n<p>   以下是一个示例代码，同时使用 <code>net</code> 和 <code>http</code> 监听同一个接口：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\">import (</span><br><span class=\"line\">        &quot;fmt&quot;</span><br><span class=\"line\">        &quot;net&quot;</span><br><span class=\"line\">        &quot;net/http&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">        // 使用 net 包监听指定的网络地址和端口</span><br><span class=\"line\">        listener, err := net.Listen(&quot;tcp&quot;, &quot;localhost:8080&quot;)</span><br><span class=\"line\">        if err != nil &#123;</span><br><span class=\"line\">                fmt.Println(&quot;Error listening:&quot;, err)</span><br><span class=\"line\">                return</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        defer listener.Close()</span><br><span class=\"line\">        // 启动 HTTP 服务器</span><br><span class=\"line\">        go func() &#123;</span><br><span class=\"line\">                http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">                        fmt.Fprintf(w, &quot;Hello, HTTP!&quot;)</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                err := http.Serve(listener, nil)</span><br><span class=\"line\">                if err != nil &#123;</span><br><span class=\"line\">                        fmt.Println(&quot;Error serving HTTP:&quot;, err)</span><br><span class=\"line\">                        return</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">        // 其他的网络处理逻辑...</span><br><span class=\"line\">        // ...</span><br><span class=\"line\">        // 等待程序退出</span><br><span class=\"line\">        select &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>   在上述示例中，我们使用 <code>net.Listen</code> 函数监听 <code>localhost:8080</code>，然后使用 <code>http</code> 包启动了一个 HTTP 服务器。通过 <code>http.HandleFunc</code> 函数，我们定义了一个简单的处理函数来响应 HTTP 请求。最后，通过 <code>http.Serve</code> 函数将监听器与 HTTP 服务器关联起来。</p>\n<p>   你可以在 <code>// 其他的网络处理逻辑...</code> 的部分添加其他网络处理逻辑，如基于 <code>net</code> 包的 TCP 或 UDP 服务器。只需确保网络处理逻辑不会与 HTTP 服务器冲突，比如使用不同的端口或处理不同的网络协议。</p>\n<p>   需要注意的是，当使用 <code>http.Serve</code> 函数时，它将阻塞当前的 goroutine，因此我们在示例中使用了 <code>select &#123;&#125;</code> 来阻止 <code>main</code> 函数退出。这样可以保持服务器的运行，直到显式地退出程序。</p>\n</li>\n<li><p>mymux</p>\n<p>   <code>myMux := http.NewServeMux()</code> 这条语句用于创建一个新的 <code>ServeMux</code> 对象。</p>\n<p>   在 Go 的 <code>http</code> 包中，<code>ServeMux</code> 是一个 HTTP 请求多路复用器（multiplexer），用于将收到的 HTTP 请求分发到相应的处理器。<code>ServeMux</code> 类型实现了 <code>http.Handler</code> 接口，因此它本身可以作为一个处理器来处理请求。</p>\n<p>   通过调用 <code>http.NewServeMux()</code> 函数，我们可以创建一个新的 <code>ServeMux</code> 对象，它将用于注册和管理不同路径的处理器。</p>\n<p>   例如，下面是一个简单示例，使用 <code>ServeMux</code> 对象来管理不同路径的处理器：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\">import (</span><br><span class=\"line\">        &quot;fmt&quot;</span><br><span class=\"line\">        &quot;net/http&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">        myMux := http.NewServeMux()</span><br><span class=\"line\"></span><br><span class=\"line\">        myMux.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">                fmt.Fprintf(w, &quot;Hello, World!&quot;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">        myMux.HandleFunc(&quot;/about&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">                fmt.Fprintf(w, &quot;About page&quot;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        server := &amp;http.Server&#123;</span><br><span class=\"line\">                Addr:    &quot;:8080&quot;,</span><br><span class=\"line\">                Handler: myMux,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        server.ListenAndServe()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>   在上述示例中，我们首先使用 <code>http.NewServeMux()</code> 创建了一个新的 <code>ServeMux</code> 对象 <code>myMux</code>。然后，我们使用 <code>myMux.HandleFunc</code> 方法来注册处理器函数，每个函数对应一个特定的路径。</p>\n<p>   最后，我们创建了一个 <code>http.Server</code> 对象，并将 <code>myMux</code> 对象作为处理器指定给该服务器。这样，当服务器收到请求时，就会使用 <code>myMux</code> 对象来根据请求的路径选择相应的处理器函数进行处理。</p>\n<p>   总结起来，<code>myMux := http.NewServeMux()</code> 用于创建一个 <code>ServeMux</code> 对象，以便注册和管理不同路径的处理器，并根据路径选择相应的处理函数来处理请求。</p>\n</li>\n<li><p>go routine 实现并发执行</p>\n<p>   Go 的 goroutine 来实现并发执行。以下是一个示例代码，演示了如何同时运行 HTTP 服务、gRPC 服务和连接其他 gRPC 服务器：</p>\n <figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">        <span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">        <span class=\"string\">&quot;net&quot;</span></span><br><span class=\"line\">        <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">        <span class=\"string\">&quot;google.golang.org/grpc&quot;</span></span><br><span class=\"line\">        <span class=\"string\">&quot;google.golang.org/grpc/credentials&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建监听器</span></span><br><span class=\"line\">        lis, err := net.Listen(<span class=\"string\">&quot;tcp&quot;</span>, <span class=\"string\">&quot;:8080&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                log.Fatalf(<span class=\"string\">&quot;Failed to listen: %v&quot;</span>, err)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 启动 HTTP 服务器</span></span><br><span class=\"line\">        <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">                http.HandleFunc(<span class=\"string\">&quot;/&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">                        w.Write([]<span class=\"type\">byte</span>(<span class=\"string\">&quot;Hello, HTTP!&quot;</span>))</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> err := http.Serve(lis, <span class=\"literal\">nil</span>); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                        log.Fatalf(<span class=\"string\">&quot;HTTP failed to serve: %v&quot;</span>, err)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 启动 gRPC 服务器</span></span><br><span class=\"line\">        <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">                s := grpc.NewServer()</span><br><span class=\"line\">                <span class=\"comment\">// 注册 gRPC 服务</span></span><br><span class=\"line\">                <span class=\"comment\">// ...</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> err := s.Serve(lis); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                        log.Fatalf(<span class=\"string\">&quot;gRPC failed to serve: %v&quot;</span>, err)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 连接其他 gRPC 服务器</span></span><br><span class=\"line\">        conn, err := grpc.Dial(<span class=\"string\">&quot;other_server_address&quot;</span>, grpc.WithTransportCredentials(credentials.NewInsecure()))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                log.Fatalf(<span class=\"string\">&quot;Failed to connect to other server: %v&quot;</span>, err)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">defer</span> conn.Close()</span><br><span class=\"line\">        <span class=\"comment\">// 进行其他操作，使用 conn 进行 gRPC 通信</span></span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        <span class=\"comment\">// 等待程序退出</span></span><br><span class=\"line\">        <span class=\"keyword\">select</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>   在这个示例中，我们使用 goroutine 启动了 HTTP 服务器和 gRPC 服务器，并在主函数中创建了一个与其他 gRPC 服务器的连接。</p>\n<p>   注意在连接其他 gRPC 服务器时，我们使用了 <code>grpc.Dial</code> 函数，并传递了 <code>grpc.WithTransportCredentials(credentials.NewInsecure())</code> 选项来创建一个不安全的连接。你应该根据实际情况选择正确的连接配置，例如使用安全的连接和认证。</p>\n<p>   最后，使用 <code>select &#123;&#125;</code> 阻塞主函数，使程序保持运行状态，直到显式退出。</p>\n<p>   请根据你的实际需求，将代码中的注释部分替换为适当的 gRPC 服务注册和其他操作代码。</p>\n</li>\n<li><p>连接阻塞</p>\n <figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 主要就是 grpc.WithBlock()</span></span><br><span class=\"line\"></span><br><span class=\"line\">conn2, err2 := grpc.Dial(*addr2, grpc.WithTransportCredentials(insecure.NewCredentials()),grpc.WithBlock())</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>循环变量副本</p>\n<p>   for i :&#x3D; 1; i &lt;&#x3D; *rpc_num; i++ {</p>\n<p>   if i &#x3D;&#x3D; *rpc_id {</p>\n<p>   continue &#x2F;&#x2F; 跳过与 当前相同的 端口号 ，不能和自己连接</p>\n<p>   }</p>\n<p>   go func(){</p>\n<p>   conn[i], err &#x3D; grpc.Dial(rpc_addr[i], grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithBlock())</p>\n<p>   if err !&#x3D; nil {</p>\n<p>   log.Fatalf(“Failed to connect to server %s: %v”, rpc_addr[i], err)</p>\n<p>   return</p>\n<p>   }</p>\n<p>   log.Printf(“Connect to %s OK”, rpc_addr[i])</p>\n<p>   }()</p>\n<p>   }</p>\n<p>   这里有个提示信息但是没有报错，提示为：loop variable i captured by func litera</p>\n<p>    “loop variable i captured by func literal” 意味着在你的代码中，匿名函数字面量（func literal）捕获了循环变量 i。</p>\n<p>   在 Go 语言中，当你在循环体内使用匿名函数时，该匿名函数会形成一个闭包，它可以访问和引用外部作用域中的变量。在这种情况下，匿名函数引用了循环变量 i。然而，循环变量在每次迭代中的值会发生变化，这可能会导致一些意外的行为。</p>\n<p>   为了避免这种问题，Go 语言引入了循环变量副本的概念。在每次迭代中，会为循环体内的匿名函数创建一个新的副本变量，以确保在闭包内部引用的是正确的值。这样可以避免循环变量值的竞争条件。</p>\n<p>   解决这个问题的常见方法是在循环体内部创建一个局部变量，将循环变量的值复制给局部变量，然后在匿名函数中使用局部变量。例如：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for i := 1; i &lt;= *rpc_num; i++ &#123;</span><br><span class=\"line\">    if i == *rpc_id &#123;</span><br><span class=\"line\">        continue</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 创建局部变量 iCopy 并将循环变量的值赋给它</span><br><span class=\"line\">    iCopy := i</span><br><span class=\"line\">    go func() &#123;</span><br><span class=\"line\">        conn[iCopy], err = grpc.Dial(rpc_addr[iCopy], grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithBlock())</span><br><span class=\"line\">        if err != nil &#123;</span><br><span class=\"line\">            log.Fatalf(&quot;Failed to connect to server %s: %v&quot;, rpc_addr[iCopy], err)</span><br><span class=\"line\">            return</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        log.Printf(&quot;Connect to %s OK&quot;, rpc_addr[iCopy])</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>   通过创建局部变量 iCopy 并使用它，你可以确保每个匿名函数引用的是该迭代的正确值，而不会受到循环变量的更改影响。</p>\n</li>\n</ol>\n<h1 id=\"Atomic-包\"><a href=\"#Atomic-包\" class=\"headerlink\" title=\"Atomic 包\"></a>Atomic 包</h1><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;runtime&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;sync/atomic&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> count <span class=\"type\">int32</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">test</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    currentCount := atomic.LoadInt32(&amp;count)</span><br><span class=\"line\">    atomic.AddInt32(&amp;count, <span class=\"number\">1</span>)</span><br><span class=\"line\">    log.Println(<span class=\"string\">&quot;count:&quot;</span>, currentCount)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    runtime.GOMAXPROCS(runtime.NumCPU() - <span class=\"number\">1</span>)</span><br><span class=\"line\">    http.HandleFunc(<span class=\"string\">&quot;/&quot;</span>, test)</span><br><span class=\"line\">    http.ListenAndServe(<span class=\"string\">&quot;:8080&quot;</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"Done-Wait-同步\"><a href=\"#Done-Wait-同步\" class=\"headerlink\" title=\"Done Wait 同步\"></a>Done Wait 同步</h1><p> Go 内存模型中的术语。它说明了在调用 <code>Done</code> 方法之前，它会与任何由它解除阻塞的 <code>Wait</code> 调用之后的返回之前进行”同步在”（synchronizes before）的关系。</p>\n<p>具体解释如下：</p>\n<ol>\n<li><code>Done</code> 方法是用于通知等待组（WaitGroup）中某个操作的完成。</li>\n<li><code>Wait</code> 方法是等待等待组中所有操作完成的调用。</li>\n<li>“同步在”（synchronizes before）是 Go 内存模型中的同步关系，指示在同一个 goroutine 中，一个操作的执行在另一个操作之前进行了同步。</li>\n</ol>\n<p>根据这句话的解释，当一个 goroutine 调用 <code>Done</code> 方法时，它会在解除等待组中的某个操作的阻塞之前与该操作的返回之前进行同步。</p>\n<p>具体来说，如果一个 goroutine 在调用 <code>Wait</code> 方法等待等待组中的操作时被阻塞，那么当另一个 goroutine 调用 <code>Done</code> 方法通知该操作的完成时，调用 <code>Done</code> 的 goroutine 会在被阻塞的 goroutine 返回之前进行同步。这确保了在 <code>Done</code> 方法解除阻塞之后，等待的 goroutine 可以安全地继续执行。</p>\n<p>总之，这句话的含义是在 Go 内存模型中，<code>Done</code> 方法的调用会在解除阻塞的 <code>Wait</code> 调用的返回之前进行同步。这个同步关系确保了等待组的协同操作的正确性和可靠性。</p>\n","excerpt":"","more":"<h1 id=\"常见库\"><a href=\"#常见库\" class=\"headerlink\" title=\"常见库\"></a>常见库</h1><h2 id=\"Flag-包\"><a href=\"#Flag-包\" class=\"headerlink\" title=\"Flag 包\"></a>Flag 包</h2><h3 id=\"flag包基本使用\"><a href=\"#flag包基本使用\" class=\"headerlink\" title=\"flag包基本使用\"></a>flag包基本使用</h3><p><a href=\"https://studygolang.com/pkgdoc\">官方文档</a>]<br><a href=\"https://www.liwenzhou.com/posts/Go/flag/\">参考文档</a></p>\n<h4 id=\"导入flag包\"><a href=\"#导入flag包\" class=\"headerlink\" title=\"导入flag包\"></a>导入flag包</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> flag</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"flag参数类型\"><a href=\"#flag参数类型\" class=\"headerlink\" title=\"flag参数类型\"></a>flag参数类型</h4><p>flag包支持的命令行参数类型有<code>bool</code>、<code>int</code>、<code>int64</code>、<code>uint</code>、<code>uint64</code>、<code>float</code> <code>float64</code>、<code>string</code>、<code>duration</code>。</p>\n<table>\n<thead>\n<tr>\n<th>flag参数</th>\n<th>有效值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>字符串flag</td>\n<td>合法字符串</td>\n</tr>\n<tr>\n<td>整数flag</td>\n<td>1234、0664、0x1234等类型，也可以是负数。</td>\n</tr>\n<tr>\n<td>浮点数flag</td>\n<td>合法浮点数</td>\n</tr>\n<tr>\n<td>bool类型flag</td>\n<td>1, 0, t, f, T, F, true, false, TRUE, FALSE, True, False。</td>\n</tr>\n<tr>\n<td>时间段flag</td>\n<td>任何合法的时间段字符串。如”300ms”、”-1.5h”、“2h45m”。合法的单位有”ns”、“us” &#x2F;“µs”、“ms”、“s”、“m”、“h”。</td>\n</tr>\n</tbody></table>\n<h4 id=\"定义命令行flag参数\"><a href=\"#定义命令行flag参数\" class=\"headerlink\" title=\"定义命令行flag参数\"></a>定义命令行flag参数</h4><p>有以下两种常用的定义命令行<code>flag</code>参数的方法。</p>\n<h3 id=\"flag-Type\"><a href=\"#flag-Type\" class=\"headerlink\" title=\"flag.Type()\"></a>flag.Type()</h3><p>基本格式如下：</p>\n<p><code>flag.Type(flag名, 默认值, 帮助信息)*Type</code> 例如我们要定义姓名、年龄、婚否三个命令行参数，我们可以按如下方式定义：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name := flag.String(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;张三&quot;</span>, <span class=\"string\">&quot;姓名&quot;</span>)</span><br><span class=\"line\">age := flag.Int(<span class=\"string\">&quot;age&quot;</span>, <span class=\"number\">18</span>, <span class=\"string\">&quot;年龄&quot;</span>)</span><br><span class=\"line\">married := flag.Bool(<span class=\"string\">&quot;married&quot;</span>, <span class=\"literal\">false</span>, <span class=\"string\">&quot;婚否&quot;</span>)</span><br><span class=\"line\">delay := flag.Duration(<span class=\"string\">&quot;d&quot;</span>, <span class=\"number\">0</span>, <span class=\"string\">&quot;时间间隔&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，此时<code>name</code>、<code>age</code>、<code>married</code>、<code>delay</code>均为对应类型的指针。</p>\n<h4 id=\"flag-TypeVar\"><a href=\"#flag-TypeVar\" class=\"headerlink\" title=\"flag.TypeVar()\"></a>flag.TypeVar()</h4><p>基本格式如下： <code>flag.TypeVar(Type指针, flag名, 默认值, 帮助信息)</code> 例如我们要定义姓名、年龄、婚否三个命令行参数，我们可以按如下方式定义：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name <span class=\"type\">string</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> age <span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> married <span class=\"type\">bool</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> delay time.Duration</span><br><span class=\"line\">flag.StringVar(&amp;name, <span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;张三&quot;</span>, <span class=\"string\">&quot;姓名&quot;</span>)</span><br><span class=\"line\">flag.IntVar(&amp;age, <span class=\"string\">&quot;age&quot;</span>, <span class=\"number\">18</span>, <span class=\"string\">&quot;年龄&quot;</span>)</span><br><span class=\"line\">flag.BoolVar(&amp;married, <span class=\"string\">&quot;married&quot;</span>, <span class=\"literal\">false</span>, <span class=\"string\">&quot;婚否&quot;</span>)</span><br><span class=\"line\">flag.DurationVar(&amp;delay, <span class=\"string\">&quot;d&quot;</span>, <span class=\"number\">0</span>, <span class=\"string\">&quot;时间间隔&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"flag-Parse\"><a href=\"#flag-Parse\" class=\"headerlink\" title=\"flag.Parse()\"></a>flag.Parse()</h4><p>通过以上两种方法定义好命令行flag参数后，需要通过调用<code>flag.Parse()</code>来对命令行参数进行解析。</p>\n<p>支持的命令行参数格式有以下几种：</p>\n<ul>\n<li><code>-flag xxx</code> （使用空格，一个<code>-</code>符号）</li>\n<li><code>--flag xxx</code> （使用空格，两个<code>-</code>符号）</li>\n<li><code>-flag=xxx</code> （使用等号，一个<code>-</code>符号）</li>\n<li><code>--flag=xxx</code> （使用等号，两个<code>-</code>符号）</li>\n</ul>\n<p>其中，布尔类型的参数必须使用等号的方式指定。</p>\n<p>Flag解析在第一个非flag参数（单个”-“不是flag参数）之前停止，或者在终止符”–“之后停止。</p>\n<h4 id=\"flag其他函数\"><a href=\"#flag其他函数\" class=\"headerlink\" title=\"flag其他函数\"></a>flag其他函数</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flag.Args()  <span class=\"comment\">////返回命令行参数后的其他参数，以[]string类型</span></span><br><span class=\"line\">flag.NArg()  <span class=\"comment\">//返回命令行参数后的其他参数个数</span></span><br><span class=\"line\">flag.NFlag() <span class=\"comment\">//返回使用的命令行参数个数</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"完整示例\"><a href=\"#完整示例\" class=\"headerlink\" title=\"完整示例\"></a>完整示例</h4><h5 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h5><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//定义命令行参数方式1</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> name <span class=\"type\">string</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> age <span class=\"type\">int</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> married <span class=\"type\">bool</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> delay time.Duration</span><br><span class=\"line\">\tflag.StringVar(&amp;name, <span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;张三&quot;</span>, <span class=\"string\">&quot;姓名&quot;</span>)</span><br><span class=\"line\">\tflag.IntVar(&amp;age, <span class=\"string\">&quot;age&quot;</span>, <span class=\"number\">18</span>, <span class=\"string\">&quot;年龄&quot;</span>)</span><br><span class=\"line\">\tflag.BoolVar(&amp;married, <span class=\"string\">&quot;married&quot;</span>, <span class=\"literal\">false</span>, <span class=\"string\">&quot;婚否&quot;</span>)</span><br><span class=\"line\">\tflag.DurationVar(&amp;delay, <span class=\"string\">&quot;d&quot;</span>, <span class=\"number\">0</span>, <span class=\"string\">&quot;延迟的时间间隔&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//解析命令行参数</span></span><br><span class=\"line\">\tflag.Parse()</span><br><span class=\"line\">\tfmt.Println(name, age, married, delay)</span><br><span class=\"line\">\t<span class=\"comment\">//返回命令行参数后的其他参数</span></span><br><span class=\"line\">\tfmt.Println(flag.Args())</span><br><span class=\"line\">\t<span class=\"comment\">//返回命令行参数后的其他参数个数</span></span><br><span class=\"line\">\tfmt.Println(flag.NArg())</span><br><span class=\"line\">\t<span class=\"comment\">//返回使用的命令行参数个数</span></span><br><span class=\"line\">\tfmt.Println(flag.NFlag())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h5><p>命令行参数使用提示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./flag_demo -<span class=\"built_in\">help</span></span><br><span class=\"line\">Usage of ./flag_demo:</span><br><span class=\"line\">  -age int</span><br><span class=\"line\">        年龄 (default 18)</span><br><span class=\"line\">  -d duration</span><br><span class=\"line\">        时间间隔</span><br><span class=\"line\">  -married</span><br><span class=\"line\">        婚否</span><br><span class=\"line\">  -name string</span><br><span class=\"line\">        姓名 (default <span class=\"string\">&quot;张三&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>正常使用命令行flag参数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./flag_demo -name 沙河娜扎 --age 28 -married=<span class=\"literal\">false</span> -d=1h30m</span><br><span class=\"line\">沙河娜扎 28 <span class=\"literal\">false</span> 1h30m0s</span><br><span class=\"line\">[]</span><br><span class=\"line\">0</span><br><span class=\"line\">4</span><br></pre></td></tr></table></figure>\n\n<p>使用非flag命令行参数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./flag_demo a b c</span><br><span class=\"line\">张三 18 <span class=\"literal\">false</span> 0s</span><br><span class=\"line\">[a b c]</span><br><span class=\"line\">3</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h2 id=\"Log-包\"><a href=\"#Log-包\" class=\"headerlink\" title=\"Log 包\"></a>Log 包</h2><p>日志相关，<a href=\"ttps://blog.csdn.net/cold___play/article/details/130744302\">参考</a></p>\n<h3 id=\"基本结构\"><a href=\"#基本结构\" class=\"headerlink\" title=\"基本结构\"></a>基本结构</h3><p>常量列表：</p>\n<ul>\n<li>Ldate         日期 年&#x2F;月&#x2F;日</li>\n<li>Ltime         时间 时:分:秒</li>\n<li>Lmicroseconds 时间 .毫秒于Ltime之后</li>\n<li>Llongfile     完整文件名:行号</li>\n<li>Lshortfile    文件名，此标志位优先于 Llongfile</li>\n<li>LstdFlags     &#x3D; Ldate 并且 Ltime</li>\n</ul>\n<p>功能说明：标志位常量控制日志格式。</p>\n<p>示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tlog.SetFlags(log.Lshortfile | log.LstdFlags)</span><br><span class=\"line\">\tlog.Println(<span class=\"string\">&quot;log:&quot;</span>) <span class=\"comment\">//2023/05/18 12:09:57 constantsDemo.go:15: log:</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>函数列表:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Fatal</span><span class=\"params\">(v ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Fatalf</span><span class=\"params\">(format <span class=\"type\">string</span>, v ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Fatalln</span><span class=\"params\">(v ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Flags</span><span class=\"params\">()</span></span> <span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Panic</span><span class=\"params\">(v ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Panicf</span><span class=\"params\">(format <span class=\"type\">string</span>, v ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Panicln</span><span class=\"params\">(v ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Prefix</span><span class=\"params\">()</span></span> <span class=\"type\">string</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Print</span><span class=\"params\">(v ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Printf</span><span class=\"params\">(format <span class=\"type\">string</span>, v ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Println</span><span class=\"params\">(v ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">SetFlags</span><span class=\"params\">(flag <span class=\"type\">int</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">SetOutput</span><span class=\"params\">(w io.Writer)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">SetPrefix</span><span class=\"params\">(prefix <span class=\"type\">string</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">(out io.Writer, prefix <span class=\"type\">string</span>, flag <span class=\"type\">int</span>)</span></span> *Logger</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *Logger)</span></span> Fatal(v ...<span class=\"keyword\">interface</span>&#123;&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *Logger)</span></span> Fatalf(format <span class=\"type\">string</span>, v ...<span class=\"keyword\">interface</span>&#123;&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *Logger)</span></span> Fatalln(v ...<span class=\"keyword\">interface</span>&#123;&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *Logger)</span></span> Flags() <span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *Logger)</span></span> Output(calldepth <span class=\"type\">int</span>, s <span class=\"type\">string</span>) <span class=\"type\">error</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *Logger)</span></span> Panic(v ...<span class=\"keyword\">interface</span>&#123;&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *Logger)</span></span> Panicf(format <span class=\"type\">string</span>, v ...<span class=\"keyword\">interface</span>&#123;&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *Logger)</span></span> Panicln(v ...<span class=\"keyword\">interface</span>&#123;&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *Logger)</span></span> Prefix() <span class=\"type\">string</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *Logger)</span></span> Print(v ...<span class=\"keyword\">interface</span>&#123;&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *Logger)</span></span> Printf(format <span class=\"type\">string</span>, v ...<span class=\"keyword\">interface</span>&#123;&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *Logger)</span></span> Println(v ...<span class=\"keyword\">interface</span>&#123;&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *Logger)</span></span> SetFlags(flag <span class=\"type\">int</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *Logger)</span></span> SetPrefix(prefix <span class=\"type\">string</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"自定义-logger\"><a href=\"#自定义-logger\" class=\"headerlink\" title=\"自定义 logger:\"></a>自定义 logger:</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">(out io.Writer, prefix <span class=\"type\">string</span>, flag <span class=\"type\">int</span>)</span></span> *Logger</span><br></pre></td></tr></table></figure>\n<p>参数列表：<br>    out 输出目标<br>    prefix 输出前缀<br>    flag 格式配置标识值<br>返回值：<br>    自定义的logger<br>功能说明：<br>    这个方法用来自定义logger，指定输出目标、格式等<br>示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tl := log.New(os.Stderr, <span class=\"string\">&quot;logger&quot;</span>, log.Ldate)</span><br><span class=\"line\">\tl.Println(<span class=\"string\">&quot;log to stderr sample&quot;</span>)<span class=\"comment\">//logger2023/05/18 log to stderr sample</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Fatal系列函数\"><a href=\"#Fatal系列函数\" class=\"headerlink\" title=\"Fatal系列函数\"></a>Fatal系列函数</h3><h4 id=\"1-1-func-Fatal-v-…interface\"><a href=\"#1-1-func-Fatal-v-…interface\" class=\"headerlink\" title=\"1.1 func Fatal(v …interface{})\"></a>1.1 func Fatal(v …interface{})</h4><p>参数列表：<br>    v 待输出参数列表<br>返回值：<br>    无<br>功能说明：<br>    打印日志并退出。相当于调用Print()并os.Exit(1)</p>\n<h4 id=\"1-2-func-Fatalf-format-string-v-…interface\"><a href=\"#1-2-func-Fatalf-format-string-v-…interface\" class=\"headerlink\" title=\"1.2 func Fatalf(format string, v …interface{})\"></a>1.2 func Fatalf(format string, v …interface{})</h4><p>参数列表：<br>    format 输出格式<br>    v 带输出参数列表<br>返回值：<br>    无<br>功能说明：<br>    按格式输出日志，并退出。相当于调用Printf()并调用os.Exit(1)</p>\n<h4 id=\"1-3-func-Fatalln-v-…interface\"><a href=\"#1-3-func-Fatalln-v-…interface\" class=\"headerlink\" title=\"1.3 func Fatalln(v …interface{})\"></a>1.3 func Fatalln(v …interface{})</h4><p>参数列表：<br>    v<br>返回值：<br>    无<br>功能说明：<br>    打印一行日志并退出。相当于调用Println()并os.Exit(1)</p>\n<h4 id=\"1-4-func-l-Logger-Fatal-v-…interface\"><a href=\"#1-4-func-l-Logger-Fatal-v-…interface\" class=\"headerlink\" title=\"1.4 func (l *Logger) Fatal(v …interface{})\"></a>1.4 func (l *Logger) Fatal(v …interface{})</h4><p>参数列表：<br>    v 待输出参数列表<br>返回值：<br>    无<br>功能说明：<br>    打印日志并退出。相当于调用l.Print()并os.Exit(1)</p>\n<h4 id=\"1-5-func-Fatalf-format-string-v-…interface\"><a href=\"#1-5-func-Fatalf-format-string-v-…interface\" class=\"headerlink\" title=\"1.5 func Fatalf(format string, v …interface{})\"></a>1.5 func Fatalf(format string, v …interface{})</h4><p>参数列表：<br>    format 输出格式<br>    v 带输出参数列表<br>返回值：<br>    无<br>功能说明：<br>    按格式输出日志，并退出。相当于调用l.Printf()并调用os.Exit(1)</p>\n<h4 id=\"1-6-func-l-Logger-Fatalln-v-…interface\"><a href=\"#1-6-func-l-Logger-Fatalln-v-…interface\" class=\"headerlink\" title=\"1.6 func (l *Logger) Fatalln(v …interface{})\"></a>1.6 func (l *Logger) Fatalln(v …interface{})</h4><p>参数列表：<br>    v<br>返回值：<br>    无<br>功能说明：<br>    打印一行日志并退出。相当于调用l.Println()并os.Exit(1)</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tage := <span class=\"number\">25</span></span><br><span class=\"line\">\tlog.Fatal(<span class=\"string\">&quot;Hi &amp; Bye ! Age = &quot;</span>, age) <span class=\"comment\">// this will print &quot;Hi &amp; Bye ! Age = 25&quot;</span></span><br><span class=\"line\">\tlog.Println(<span class=\"string\">&quot;This will not be called.&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\tname := <span class=\"string\">&quot;golang&quot;</span></span><br><span class=\"line\">\tlog.Fatalf(<span class=\"string\">&quot;%8d,%8s&quot;</span>, <span class=\"number\">23</span>, name) <span class=\"comment\">//2013/03/10 16:08:49       23,  golang</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tlog.Fatalln(<span class=\"string\">&quot;bye!&quot;</span>) <span class=\"comment\">//2013/03/10 16:14:54 bye!\\n</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tl := log.New(os.Stdout, <span class=\"string\">&quot;&quot;</span>, log.LstdFlags)</span><br><span class=\"line\">\tage = <span class=\"number\">25</span></span><br><span class=\"line\">\tl.Fatal(<span class=\"string\">&quot;Hi &amp; Bye ! Age = &quot;</span>, age) <span class=\"comment\">// this will print &quot;Hi &amp; Bye ! Age = 25&quot;</span></span><br><span class=\"line\">\tl.Println(<span class=\"string\">&quot;This will not be called.&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\tl = log.New(os.Stdout, <span class=\"string\">&quot;&quot;</span>, log.LstdFlags)</span><br><span class=\"line\">\t<span class=\"comment\">//l.Fatalf(&quot;%s&quot;, &quot;hello&quot;)</span></span><br><span class=\"line\">\tname = <span class=\"string\">&quot;golang&quot;</span></span><br><span class=\"line\">\tl.Fatalf(<span class=\"string\">&quot;%8d,%8s&quot;</span>, <span class=\"number\">23</span>, name) <span class=\"comment\">//2013/03/10 16:08:49       23,  golang</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tl = log.New(os.Stdout, <span class=\"string\">&quot;&quot;</span>, log.LstdFlags)</span><br><span class=\"line\">\tl.Fatalln(<span class=\"string\">&quot;bye!&quot;</span>) <span class=\"comment\">//2013/03/10 16:14:54 bye!\\n</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Flags系列函数\"><a href=\"#Flags系列函数\" class=\"headerlink\" title=\"Flags系列函数\"></a>Flags系列函数</h3><h4 id=\"2-1-func-Flags-int\"><a href=\"#2-1-func-Flags-int\" class=\"headerlink\" title=\"2.1 func Flags() int\"></a>2.1 func Flags() int</h4><p>参数列表：<br>    无<br>返回值：<br>    默认logger的配置值<br>功能说明：<br>    返回默认logger配置值。</p>\n<h4 id=\"2-2-func-l-Logger-Flags-int\"><a href=\"#2-2-func-l-Logger-Flags-int\" class=\"headerlink\" title=\"2.2 func (l *Logger) Flags() int\"></a>2.2 func (l *Logger) Flags() int</h4><p>参数列表：<br>    无<br>返回值：<br>    当前logger的配置值<br>功能说明：<br>    返回当前logger配置值。</p>\n<h4 id=\"2-3-func-SetFlags-flag-int\"><a href=\"#2-3-func-SetFlags-flag-int\" class=\"headerlink\" title=\"2.3 func SetFlags(flag int)\"></a>2.3 func SetFlags(flag int)</h4><p>参数列表：<br>    flag logger配置值<br>返回值：<br>    无<br>功能说明：<br>    这个方法用来设置标准logger的配置，默认为3（logger.LstdFlags）</p>\n<h4 id=\"2-4-func-l-Logger-SetFlags-flag-int\"><a href=\"#2-4-func-l-Logger-SetFlags-flag-int\" class=\"headerlink\" title=\"2.4 func (l *Logger) SetFlags(flag int)\"></a>2.4 func (l *Logger) SetFlags(flag int)</h4><p>参数列表：<br>    flag logger配置值<br>返回值：<br>    无<br>功能说明：<br>    这个方法用来设置标准logger的配置，默认为3（logger.LstdFlags）</p>\n<h4 id=\"示例-1\"><a href=\"#示例-1\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;standard flags :&quot;</span>, log.Flags()) <span class=\"comment\">//standard flags : 3</span></span><br><span class=\"line\">\t<span class=\"comment\">//the flags constants</span></span><br><span class=\"line\">\tfmt.Println(log.Ldate)         <span class=\"comment\">//1</span></span><br><span class=\"line\">\tfmt.Println(log.Ltime)         <span class=\"comment\">//2</span></span><br><span class=\"line\">\tfmt.Println(log.Lmicroseconds) <span class=\"comment\">//4</span></span><br><span class=\"line\">\tfmt.Println(log.Llongfile)     <span class=\"comment\">//8</span></span><br><span class=\"line\">\tfmt.Println(log.Lshortfile)    <span class=\"comment\">//16</span></span><br><span class=\"line\">\tfmt.Println(log.LstdFlags)     <span class=\"comment\">//LstdFlags     = Ldate | Ltime   3</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tl := log.New(os.Stdout, <span class=\"string\">&quot;&quot;</span>, log.LstdFlags)</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;logger l&#x27;s flags :&quot;</span>, l.Flags()) <span class=\"comment\">//logger l&#x27;s flags : 3</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tlog.Println(log.Flags()) <span class=\"comment\">//2013/03/10 17:46:53 3</span></span><br><span class=\"line\">\tlog.SetFlags(log.Ldate)</span><br><span class=\"line\">\tlog.Println(log.Flags()) <span class=\"comment\">//2013/03/10 1</span></span><br><span class=\"line\">\tlog.SetFlags(log.LstdFlags | log.Lshortfile)</span><br><span class=\"line\">\tlog.Println(log.Flags()) <span class=\"comment\">//2013/03/10 17:46:53 setflags.go:17: 19</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tl = log.New(os.Stdout, <span class=\"string\">&quot;&quot;</span>, log.LstdFlags)</span><br><span class=\"line\">\tl.Println(l.Flags()) <span class=\"comment\">//2013/03/10 17:46:53 3</span></span><br><span class=\"line\">\tl.SetFlags(log.Ldate)</span><br><span class=\"line\">\tl.Println(l.Flags()) <span class=\"comment\">//2013/03/10 1</span></span><br><span class=\"line\">\tl.SetFlags(log.LstdFlags | log.Lshortfile)</span><br><span class=\"line\">\tl.Println(l.Flags()) <span class=\"comment\">//2013/03/10 17:46:53 setflags.go:17: 19</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Panic系列函数\"><a href=\"#Panic系列函数\" class=\"headerlink\" title=\"Panic系列函数\"></a>Panic系列函数</h3><h4 id=\"3-1-func-l-Logger-Panic-v-…interface\"><a href=\"#3-1-func-l-Logger-Panic-v-…interface\" class=\"headerlink\" title=\"3.1 func (l *Logger) Panic(v …interface{})\"></a>3.1 func (l *Logger) Panic(v …interface{})</h4><p>参数列表：<br>    v 待输出参数列表<br>返回值：<br>    无<br>功能说明：<br>    这个方法相当于调用l.Print()及panic()</p>\n<h4 id=\"3-2-func-l-Logger-Panicf-format-string-v-…interface\"><a href=\"#3-2-func-l-Logger-Panicf-format-string-v-…interface\" class=\"headerlink\" title=\"3.2 func (l *Logger) Panicf(format string, v …interface{})\"></a>3.2 func (l *Logger) Panicf(format string, v …interface{})</h4><p>参数列表：<br>    format 输出格式<br>    v 待输出参数列表<br>返回值：<br>    无<br>功能说明：<br>    相当于调用l.Printf()，之后调用panic()</p>\n<h4 id=\"3-3-func-l-Logger-Panicln-v-…interface\"><a href=\"#3-3-func-l-Logger-Panicln-v-…interface\" class=\"headerlink\" title=\"3.3 func (l *Logger) Panicln(v …interface{})\"></a>3.3 func (l *Logger) Panicln(v …interface{})</h4><p>参数列表：<br>    v 待输出参数列表<br>返回值：<br>    无<br>功能说明：<br>    相当于调用l.Println()并调用panic()</p>\n<h4 id=\"3-4-func-Panic-v-…interface\"><a href=\"#3-4-func-Panic-v-…interface\" class=\"headerlink\" title=\"3.4 func Panic(v …interface{})\"></a>3.4 func Panic(v …interface{})</h4><p>参数列表：<br>    v 待输出参数列表<br>返回值：<br>    无<br>功能说明：<br>    这个方法相当于调用Print()及panic()</p>\n<h4 id=\"3-5-func-Panicf-format-string-v-…interface\"><a href=\"#3-5-func-Panicf-format-string-v-…interface\" class=\"headerlink\" title=\"3.5 func Panicf(format string, v …interface{})\"></a>3.5 func Panicf(format string, v …interface{})</h4><p>参数列表：<br>    format 输出格式<br>    v 待输出参数列表<br>返回值：<br>    - 无<br>功能说明：<br>    相当于调用Printf()，之后调用panic()</p>\n<h4 id=\"3-6-func-Panicln-v-…interface\"><a href=\"#3-6-func-Panicln-v-…interface\" class=\"headerlink\" title=\"3.6 func Panicln(v …interface{})\"></a>3.6 func Panicln(v …interface{})</h4><p>参数列表：<br>    v 待输出参数列表<br>返回值：<br>    无<br>功能说明：<br>    相当于调用Println()并调用panic()</p>\n<h4 id=\"示例-2\"><a href=\"#示例-2\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tl := log.New(os.Stdout, <span class=\"string\">&quot;&quot;</span>, log.LstdFlags)</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err := <span class=\"built_in\">recover</span>(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tfmt.Println(err) <span class=\"comment\">//output : &quot;call panic and stop&quot;</span></span><br><span class=\"line\">\t\t\thandleException()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\tl.Panic(<span class=\"string\">&quot;call panic and stop&quot;</span>)</span><br><span class=\"line\">\tlog.Println(<span class=\"string\">&quot;this will not be called.&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err := <span class=\"built_in\">recover</span>(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err == <span class=\"string\">&quot;3q&quot;</span> &#123;</span><br><span class=\"line\">\t\t\t\tlog.Println(<span class=\"string\">&quot;you are welcome&quot;</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\tl = log.New(os.Stdout, <span class=\"string\">&quot;&quot;</span>, log.LstdFlags)</span><br><span class=\"line\">\tl.Panicf(<span class=\"string\">&quot;%d%s&quot;</span>, <span class=\"number\">3</span>, <span class=\"string\">&quot;q&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err := <span class=\"built_in\">recover</span>(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err == <span class=\"string\">&quot;3q\\n&quot;</span> &#123;</span><br><span class=\"line\">\t\t\t\tlog.Println(<span class=\"string\">&quot;you are welcome&quot;</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\tl = log.New(os.Stdout, <span class=\"string\">&quot;&quot;</span>, log.LstdFlags)</span><br><span class=\"line\">\tl.Panicln(<span class=\"string\">&quot;3q&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">handleException</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tlog.Println(<span class=\"string\">&quot;recovering...&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Print系列函数\"><a href=\"#Print系列函数\" class=\"headerlink\" title=\"Print系列函数\"></a>Print系列函数</h3><h4 id=\"4-1-func-l-Logger-Print-v-…interface\"><a href=\"#4-1-func-l-Logger-Print-v-…interface\" class=\"headerlink\" title=\"4.1 func (l *Logger) Print(v …interface{})\"></a>4.1 func (l *Logger) Print(v …interface{})</h4><p>参数列表：<br>    v 待输出参数列表<br>返回值：<br>    无<br>功能说明：<br>    输出日志到logger。参数处理方式同fmt.Print</p>\n<h4 id=\"4-2-func-l-Logger-Printf-format-string-v-…interface\"><a href=\"#4-2-func-l-Logger-Printf-format-string-v-…interface\" class=\"headerlink\" title=\"4.2 func (l *Logger) Printf(format string, v …interface{})\"></a>4.2 func (l *Logger) Printf(format string, v …interface{})</h4><p>参数列表：<br>    format 输出格式<br>    v 待输出参数列表<br>返回值：<br>    无<br>功能说明：<br>    调用l.Output输出日志到logger l。参数处理方式同fmt.Printf</p>\n<h4 id=\"4-3-func-l-Logger-Println-v-…interface\"><a href=\"#4-3-func-l-Logger-Println-v-…interface\" class=\"headerlink\" title=\"4.3 func (l *Logger) Println(v …interface{})\"></a>4.3 func (l *Logger) Println(v …interface{})</h4><p>参数列表：<br>    v 待输出参数列表<br>返回值：<br>    无<br>功能说明：<br>    调用Output打印日志到当前logger，参数处理方式同fmt.Println</p>\n<h4 id=\"4-4-func-Print-v-…interface\"><a href=\"#4-4-func-Print-v-…interface\" class=\"headerlink\" title=\"4.4 func Print(v …interface{})\"></a>4.4 func Print(v …interface{})</h4><p>参数列表：<br>    v 待输出参数列表<br>返回值：<br>    无<br>功能说明：<br>    输出日志到标准logger。参数处理方式同fmt.Print</p>\n<h4 id=\"4-5-func-Printf-format-string-v-…interface\"><a href=\"#4-5-func-Printf-format-string-v-…interface\" class=\"headerlink\" title=\"4.5 func Printf(format string, v …interface{})\"></a>4.5 func Printf(format string, v …interface{})</h4><p>参数列表：<br>    format 输出格式<br>    v 待输出参数列表<br>返回值：<br>    无<br>功能说明：<br>    调用Output输出日志到标准logger。参数处理方式同fmt.Printf</p>\n<h4 id=\"4-6-func-Println-v-…interface\"><a href=\"#4-6-func-Println-v-…interface\" class=\"headerlink\" title=\"4.6 func Println(v …interface{})\"></a>4.6 func Println(v …interface{})</h4><p>参数列表：<br>    v<br>返回值：<br>    无<br>功能说明：<br>    调用Output打印日志到标准logger，参数处理方式同fmt.Println</p>\n<h4 id=\"示例-3\"><a href=\"#示例-3\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tl := log.New(os.Stdout, <span class=\"string\">&quot;&quot;</span>, log.LstdFlags)</span><br><span class=\"line\">\tl.Print(<span class=\"string\">&quot;string&quot;</span>, <span class=\"number\">1</span>, <span class=\"number\">2.3</span>) <span class=\"comment\">//2013/03/10 17:26:06 string1 2.3</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tl = log.New(os.Stdout, <span class=\"string\">&quot;&quot;</span>, log.LstdFlags)</span><br><span class=\"line\">\tl.Printf(<span class=\"string\">&quot;%s&quot;</span>, <span class=\"string\">&quot;hello&quot;</span>) <span class=\"comment\">//hello</span></span><br><span class=\"line\">\tname := <span class=\"string\">&quot;golang&quot;</span></span><br><span class=\"line\">\tl.Printf(<span class=\"string\">&quot;%8d,%8s&quot;</span>, <span class=\"number\">23</span>, name) <span class=\"comment\">//2013/03/10 16:08:49       23,  golang</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tl = log.New(os.Stdout, <span class=\"string\">&quot;&quot;</span>, log.LstdFlags)</span><br><span class=\"line\">\tl.Println(<span class=\"string\">&quot;hello&quot;</span>) <span class=\"comment\">//2013/03/10 17:35:28 hello\\n</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tlog.Print(<span class=\"string\">&quot;string&quot;</span>, <span class=\"number\">1</span>, <span class=\"number\">2.3</span>) <span class=\"comment\">//2013/03/10 17:26:06 string1 2.3</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tlog.Printf(<span class=\"string\">&quot;%s&quot;</span>, <span class=\"string\">&quot;hello&quot;</span>) <span class=\"comment\">//hello</span></span><br><span class=\"line\">\tname = <span class=\"string\">&quot;golang&quot;</span></span><br><span class=\"line\">\tlog.Printf(<span class=\"string\">&quot;%8d,%8s&quot;</span>, <span class=\"number\">23</span>, name) <span class=\"comment\">//2013/03/10 16:08:49       23,  golang</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tlog.Println(<span class=\"string\">&quot;hello&quot;</span>) <span class=\"comment\">//2013/03/10 17:35:28 hello\\n</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"其它函数\"><a href=\"#其它函数\" class=\"headerlink\" title=\"其它函数\"></a>其它函数</h3><h4 id=\"5-1-func-l-Logger-Prefix-string\"><a href=\"#5-1-func-l-Logger-Prefix-string\" class=\"headerlink\" title=\"5.1 func (l *Logger) Prefix() string\"></a>5.1 func (l *Logger) Prefix() string</h4><p>参数列表：<br>    无<br>返回值：<br>    logger前缀，字符串类型<br>功能说明：<br>    返回当前logger的输出前缀</p>\n<h4 id=\"5-2-func-Prefix-string\"><a href=\"#5-2-func-Prefix-string\" class=\"headerlink\" title=\"5.2 func Prefix() string\"></a>5.2 func Prefix() string</h4><p>参数列表：<br>    无<br>返回值：<br>    标准logger前缀，字符串类型<br>功能说明：<br>    返回标准logger的输出前缀</p>\n<h4 id=\"5-3-func-SetPrefix-prefix-string\"><a href=\"#5-3-func-SetPrefix-prefix-string\" class=\"headerlink\" title=\"5.3 func SetPrefix(prefix string)\"></a>5.3 func SetPrefix(prefix string)</h4><p>参数列表：<br>    prefix 前缀<br>返回值：<br>    无<br>功能说明：<br>    设置logger的输出前缀</p>\n<h4 id=\"5-4-func-SetPrefix-prefix-string\"><a href=\"#5-4-func-SetPrefix-prefix-string\" class=\"headerlink\" title=\"5.4 func SetPrefix(prefix string)\"></a>5.4 func SetPrefix(prefix string)</h4><p>参数列表：<br>    prefix 前缀<br>返回值：<br>    无<br>功能说明：<br>    设置logger的输出前缀</p>\n<h4 id=\"5-5-func-l-Logger-Output-calldepth-int-s-string-error\"><a href=\"#5-5-func-l-Logger-Output-calldepth-int-s-string-error\" class=\"headerlink\" title=\"5.5 func (l *Logger) Output(calldepth int, s string) error\"></a>5.5 func (l *Logger) Output(calldepth int, s string) error</h4><p>参数列表：<br>    calldepth 深度<br>    s 字符串<br>返回值：<br>    error 错误<br>功能说明：<br>    输出日志事件。字符串s包含待打印内容，跟在预定义的prefix后面，并且根据flags设置会有区分。如果s末尾没有换行符，这个方法会默认加上一个。calldepth目前预定义均为2,以后会用来支持通用场景，支持其他值配置。（本人注：日志输出不建议直接使用该方法）</p>\n<h4 id=\"5-6-func-SetOutput-w-io-Writer\"><a href=\"#5-6-func-SetOutput-w-io-Writer\" class=\"headerlink\" title=\"5.6 func SetOutput(w io.Writer)\"></a>5.6 func SetOutput(w io.Writer)</h4><p>参数列表：<br>    w 目标流，io.Writer类型<br>返回值：<br>    无<br>功能说明：<br>    设置标准logger的输出目标</p>\n<h4 id=\"示例-4\"><a href=\"#示例-4\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tl := log.New(os.Stdout, <span class=\"string\">&quot;&quot;</span>, log.LstdFlags)</span><br><span class=\"line\">\tfmt.Print(l.Prefix()) <span class=\"comment\">//this will print nothing</span></span><br><span class=\"line\">\tl.Println(<span class=\"number\">1</span>)          <span class=\"comment\">//2013/03/10 17:02:05 1</span></span><br><span class=\"line\">\tl.SetPrefix(<span class=\"string\">&quot;log:&quot;</span>)</span><br><span class=\"line\">\tfmt.Println(l.Prefix()) <span class=\"comment\">//log:</span></span><br><span class=\"line\">\tl.Println(<span class=\"number\">2</span>)            <span class=\"comment\">//log:2013/03/10 17:02:05 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Print(log.Prefix()) <span class=\"comment\">//this will print nothing</span></span><br><span class=\"line\">\tlog.Println(<span class=\"number\">1</span>)          <span class=\"comment\">//2013/03/10 17:02:05 1</span></span><br><span class=\"line\">\tlog.SetPrefix(<span class=\"string\">&quot;log:&quot;</span>)</span><br><span class=\"line\">\tfmt.Println(log.Prefix()) <span class=\"comment\">//log:</span></span><br><span class=\"line\">\tlog.Println(<span class=\"number\">2</span>)            <span class=\"comment\">//log:2013/03/10 17:02:05 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tl = log.New(os.Stdout, <span class=\"string\">&quot;&quot;</span>, log.LstdFlags)</span><br><span class=\"line\">\tfmt.Print(l.Prefix()) <span class=\"comment\">//this will print nothing</span></span><br><span class=\"line\">\tl.Println(<span class=\"number\">1</span>)          <span class=\"comment\">//2013/03/10 17:02:05 1</span></span><br><span class=\"line\">\tl.SetPrefix(<span class=\"string\">&quot;log:&quot;</span>)</span><br><span class=\"line\">\tfmt.Println(l.Prefix()) <span class=\"comment\">//log:</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tl.Println(<span class=\"number\">2</span>) <span class=\"comment\">//log:2013/03/10 17:02:05 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Print(log.Prefix()) <span class=\"comment\">//this will print nothing</span></span><br><span class=\"line\">\tlog.Println(<span class=\"number\">1</span>)          <span class=\"comment\">//2013/03/10 17:02:05 1</span></span><br><span class=\"line\">\tlog.SetPrefix(<span class=\"string\">&quot;log:&quot;</span>)</span><br><span class=\"line\">\tfmt.Println(log.Prefix()) <span class=\"comment\">//log:</span></span><br><span class=\"line\">\tlog.Println(<span class=\"number\">2</span>)            <span class=\"comment\">//log:2013/03/10 17:02:05 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tl = log.New(os.Stdout, <span class=\"string\">&quot;log-&gt;&quot;</span>, log.Ldate)</span><br><span class=\"line\">\tl.Output(<span class=\"number\">2</span>, <span class=\"string\">&quot;log output&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\tfile, err := os.OpenFile(<span class=\"string\">&quot;sample.txt&quot;</span>, os.O_WRONLY, <span class=\"number\">0666</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> file.Close()</span><br><span class=\"line\">\tlog.SetOutput(file)</span><br><span class=\"line\">\tlog.Println(<span class=\"string\">&quot;log to file&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Badger-包\"><a href=\"#Badger-包\" class=\"headerlink\" title=\"Badger 包\"></a>Badger 包</h2><p><a href=\"https://juejin.cn/post/6844903814571491335\">参考</a><br><a href=\"https://pkg.go.dev/github.com/dgraph-io/badger#Txn\">官方文档</a><br>badger是一个纯Go实现的快速的嵌入式K&#x2F;V数据库，针对LSM tree做了优化。</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p><code>$ go get github.com/dgraph-io/badger/...</code></p>\n<h3 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h3><p>打开一个数据库</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">opts := badger.DefaultOptions</span><br><span class=\"line\">opts.Dir = <span class=\"string\">&quot;/tmp/badger&quot;</span> </span><br><span class=\"line\">opts.ValueDir = <span class=\"string\">&quot;/tmp/badger&quot;</span> </span><br><span class=\"line\">db, err := badger.Open(opts) </span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\tlog.Fatal(err) </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">defer</span> db.Close()</span><br></pre></td></tr></table></figure>\n<h3 id=\"存储\"><a href=\"#存储\" class=\"headerlink\" title=\"存储\"></a>存储</h3><h4 id=\"存储kv\"><a href=\"#存储kv\" class=\"headerlink\" title=\"存储kv\"></a>存储kv</h4><p>使用 Txn.Set()方法</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">err := db.Update(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(txn *badger.Txn)</span></span> <span class=\"type\">error</span> &#123;   </span><br><span class=\"line\">\terr := txn.Set([]<span class=\"type\">byte</span>(<span class=\"string\">&quot;answer&quot;</span>), []<span class=\"type\">byte</span>(<span class=\"string\">&quot;42&quot;</span>))   </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> err </span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"批量设置\"><a href=\"#批量设置\" class=\"headerlink\" title=\"批量设置\"></a>批量设置</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wb := db.NewWriteBatch() </span><br><span class=\"line\"><span class=\"keyword\">defer</span> wb.Cancel() </span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; N; i++ &#123;</span><br><span class=\"line\">\terr := wb.Set(key(i), value(i), <span class=\"number\">0</span>) <span class=\"comment\">// Will create txns as needed. </span></span><br><span class=\"line\">\thandle(err) </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">handle(wb.Flush()) <span class=\"comment\">// Wait for all txns to finish.</span></span><br></pre></td></tr></table></figure>\n<p>WriteBatch不允许任何读取。对于读-修改-写，应该使用事务API。</p>\n<h5 id=\"设置生存时间-TTL\"><a href=\"#设置生存时间-TTL\" class=\"headerlink\" title=\"设置生存时间 TTL\"></a>设置生存时间 TTL</h5><p>Badger 允许在键上设置一个可选的生存时间 (TTL) 值。一旦 TTL 结束，KEY 将不再是可检索的，并且将进行垃圾收集。TTL 可以使用 Txn.SetWithTTL() 设置为一个<code>time.Duration</code>的值</p>\n<h5 id=\"设置元数据\"><a href=\"#设置元数据\" class=\"headerlink\" title=\"设置元数据\"></a>设置元数据</h5><p><code>Txn.SetWithMeta()</code> 设置用户元数据</p>\n<p>使用 <code>Txn.SetEntry()</code> 可以一次性设置 key, value, user metatadata 和 TTL</p>\n<h5 id=\"遍历-keys\"><a href=\"#遍历-keys\" class=\"headerlink\" title=\"遍历 keys\"></a>遍历 keys</h5><p>要遍历键，我们可以使用迭代器，可以使用 <code>Txn.NewIterator()</code>方法获得迭代器。迭代按字节字典排序顺序进行。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">err := db.View(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(txn *badger.Txn)</span></span> <span class=\"type\">error</span> &#123; <span class=\"comment\">// badger 的 view 方法创建一个只读事务</span></span><br><span class=\"line\">\topts := badger.DefaultIteratorOptions   </span><br><span class=\"line\">\topts.PrefetchSize = <span class=\"number\">10</span>   </span><br><span class=\"line\">\tit := txn.NewIterator(opts)   </span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> it.Close()   </span><br><span class=\"line\">\t<span class=\"keyword\">for</span> it.Rewind(); it.Valid(); it.Next() &#123;</span><br><span class=\"line\">\t    item := it.Item() </span><br><span class=\"line\">\t    k := item.Key()     </span><br><span class=\"line\">\t    err := item.Value(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(v []<span class=\"type\">byte</span>)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\t        fmt.Printf(<span class=\"string\">&quot;key=%s, value=%s\\n&quot;</span>, k, v)       </span><br><span class=\"line\">\t        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>     </span><br><span class=\"line\">\t        &#125;)     </span><br><span class=\"line\">\t    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;       </span><br><span class=\"line\">\t\t    <span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t\t&#125;   </span><br><span class=\"line\">\t&#125;   </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span> </span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h6 id=\"前缀扫描\"><a href=\"#前缀扫描\" class=\"headerlink\" title=\"前缀扫描\"></a>前缀扫描</h6><p>要遍历键前缀，可以将 Seek() 和 ValidForPrefix() 组合使用：（这里的前缀是键值的）</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.View(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(txn *badger.Txn)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\tit := txn.NewIterator(badger.DefaultIteratorOptions)</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> it.Close()   </span><br><span class=\"line\">\tprefix := []<span class=\"type\">byte</span>(<span class=\"string\">&quot;1234&quot;</span>)   </span><br><span class=\"line\">\t<span class=\"keyword\">for</span> it.Seek(prefix); it.ValidForPrefix(prefix); it.Next() &#123;</span><br><span class=\"line\">\t\titem := it.Item()    </span><br><span class=\"line\">\t\tk := item.Key()     </span><br><span class=\"line\">\t\terr := item.Value(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(v []<span class=\"type\">byte</span>)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\t\t\tfmt.Printf(<span class=\"string\">&quot;key=%s, value=%s\\n&quot;</span>, k, v)       </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>     </span><br><span class=\"line\">\t\t&#125;)     </span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;       </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> err     </span><br><span class=\"line\">\t\t&#125;   </span><br><span class=\"line\">\t&#125;   </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span> </span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h6 id=\"键的遍历\"><a href=\"#键的遍历\" class=\"headerlink\" title=\"键的遍历\"></a>键的遍历</h6><p>Badger支持一种独特的迭代模式，称为只有键的迭代。它比常规迭代快几个数量级，因为它只涉及对 lsm 树的访问，而 lsm 树通常完全驻留在 RAM 中。要启用只有键的迭代，您需要设置 IteratorOptions 。PrefetchValues 字段为 false 。这还可以用于在迭代期间对选定的键执行稀疏读取，只在需要时调用 item.Value() 。(获取键，而不获取对应的值)</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">err := db.View(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(txn *badger.Txn)</span></span> <span class=\"type\">error</span> &#123;   </span><br><span class=\"line\">\topts := badger.DefaultIteratorOptions   </span><br><span class=\"line\">\topts.PrefetchValues = <span class=\"literal\">false</span>   </span><br><span class=\"line\">\tit := txn.NewIterator(opts)   </span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> it.Close()   </span><br><span class=\"line\">\t<span class=\"keyword\">for</span> it.Rewind(); it.Valid(); it.Next() &#123;</span><br><span class=\"line\">\t\titem := it.Item()     </span><br><span class=\"line\">\t\tk := item.Key()     </span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">&quot;key=%s\\n&quot;</span>, k)   </span><br><span class=\"line\">\t&#125;   </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span> </span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数据流\"><a href=\"#数据流\" class=\"headerlink\" title=\"数据流\"></a>数据流</h3><p>Badger 提供了一个流框架，它可以并发地遍历数据库的全部或部分，将数据转换为自定义键值，并连续地将数据流输出，以便通过网络发送、写入磁盘，甚至写入 Badger。这是比使用单个迭代器更快的遍历 Badger 的方法。Stream 在管理模式和正常模式下都支持Badger 。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stream := db.NewStream() </span><br><span class=\"line\"><span class=\"comment\">// db.NewStreamAt(readTs) for managed mode. </span></span><br><span class=\"line\"><span class=\"comment\">// -- Optional settings </span></span><br><span class=\"line\">stream.NumGo = <span class=\"number\">16</span>          <span class=\"comment\">// Set number of goroutines to use for iteration.</span></span><br><span class=\"line\">stream.Prefix = []<span class=\"type\">byte</span>(<span class=\"string\">&quot;some-prefix&quot;</span>) <span class=\"comment\">// Leave nil for iteration over the whole DB. </span></span><br><span class=\"line\">stream.LogPrefix = <span class=\"string\">&quot;Badger.Streaming&quot;</span> <span class=\"comment\">// For identifying stream logs. Outputs to Logger. </span></span><br><span class=\"line\"><span class=\"comment\">// ChooseKey is called concurrently for every key. If left nil, assumes true by default. </span></span><br><span class=\"line\">stream.ChooseKey = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(item *badger.Item)</span></span> <span class=\"type\">bool</span> &#123;   </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> bytes.HasSuffix(item.Key(), []<span class=\"type\">byte</span>(<span class=\"string\">&quot;er&quot;</span>)) </span><br><span class=\"line\">\t<span class=\"comment\">// 这个例子中判断后缀 “er” </span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"comment\">// KeyToList is called concurrently for chosen keys. This can be used to convert </span></span><br><span class=\"line\"><span class=\"comment\">// Badger data into custom key-values. If nil, uses stream.ToList, a default </span></span><br><span class=\"line\"><span class=\"comment\">// implementation, which picks all valid key-values. </span></span><br><span class=\"line\">stream.KeyToList = <span class=\"literal\">nil</span> </span><br><span class=\"line\"><span class=\"comment\">// -- End of optional settings. </span></span><br><span class=\"line\"><span class=\"comment\">// Send is called serially, while Stream.Orchestrate is running. 用于序列化并处理流操作的结果</span></span><br><span class=\"line\">stream.Send = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(list *pb.KVList)</span></span> <span class=\"type\">error</span> &#123;   </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> proto.MarshalText(w, list) <span class=\"comment\">// Write to w. </span></span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\"><span class=\"comment\">// Run the stream </span></span><br><span class=\"line\"><span class=\"keyword\">if</span> err := stream.Orchestrate(context.Background()); err != <span class=\"literal\">nil</span> &#123;   </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> err </span><br><span class=\"line\">&#125; <span class=\"comment\">// Done.</span></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"删除一个key\"><a href=\"#删除一个key\" class=\"headerlink\" title=\"删除一个key\"></a>删除一个key</h3><p>使用<code>Txn.Delete()</code> 方法删除一个key</p>\n<h3 id=\"获取-key-value\"><a href=\"#获取-key-value\" class=\"headerlink\" title=\"获取 key value\"></a>获取 key value</h3><p>通过 txn.Get 获取 value</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">err := db.View(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(txn *badger.Txn)</span></span> <span class=\"type\">error</span> &#123;   </span><br><span class=\"line\">\titem, err := txn.Get([]<span class=\"type\">byte</span>(<span class=\"string\">&quot;answer&quot;</span>))   </span><br><span class=\"line\">\thandle(err)   </span><br><span class=\"line\">\t<span class=\"keyword\">var</span> valNot, valCopy []<span class=\"type\">byte</span>   </span><br><span class=\"line\">\terr := item.Value(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(val []<span class=\"type\">byte</span>)</span></span> <span class=\"type\">error</span> &#123;     </span><br><span class=\"line\">\t<span class=\"comment\">// This func with val would only be called if item.Value encounters no error.     </span></span><br><span class=\"line\">\t<span class=\"comment\">// Accessing val here is valid.     </span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;The answer is: %s\\n&quot;</span>, val)     </span><br><span class=\"line\">\t<span class=\"comment\">// Copying or parsing val is valid.     </span></span><br><span class=\"line\">\tvalCopy = <span class=\"built_in\">append</span>([]<span class=\"type\">byte</span>&#123;&#125;, val...)     <span class=\"comment\">// 三个点（`...`）的语法，表示将切片 `val` 展开，将其中的元素逐个添加到新的切片 `valCopy` 中。</span></span><br><span class=\"line\">\t<span class=\"comment\">// Assigning val slice to another variable is NOT OK.     </span></span><br><span class=\"line\">\tvalNot = val <span class=\"comment\">// Do not do this.     </span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>   </span><br><span class=\"line\">&#125;)   </span><br><span class=\"line\">handle(err)   <span class=\"comment\">// DO NOT access val here. It is the most common cause of bugs.</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;NEVER do this. %s\\n&quot;</span>, valNot)   </span><br><span class=\"line\"><span class=\"comment\">// You must copy it to use it outside item.Value(...).   </span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;The answer is: %s\\n&quot;</span>, valCopy)   </span><br><span class=\"line\"><span class=\"comment\">// Alternatively, you could also use item.ValueCopy().   </span></span><br><span class=\"line\">valCopy, err = item.ValueCopy(<span class=\"literal\">nil</span>)   </span><br><span class=\"line\">handle(err)   </span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;The answer is: %s\\n&quot;</span>, valCopy)   </span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"literal\">nil</span> </span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>如果不存在 <code>Txn.Get()</code> 将会返回一个 <code>ErrKeyNotFound</code> 错误</p>\n<p>请注意，Get()返回的值只在事务打开时有效。如果需要在事务外部使用值，则必须使用copy() 将其复制到另一个字节片。</p>\n<h3 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h3><h5 id=\"只读事务\"><a href=\"#只读事务\" class=\"headerlink\" title=\"只读事务\"></a>只读事务</h5><p>只读事务使用 DB.View()方法</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">err := db.View(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(txn *badger.Txn)</span></span> <span class=\"type\">error</span> &#123;  </span><br><span class=\"line\">\t<span class=\"comment\">// Your code here…   </span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span> </span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"读写事务锁\"><a href=\"#读写事务锁\" class=\"headerlink\" title=\"读写事务锁\"></a>读写事务锁</h5><p>读写事务可以使用 DB.Update()方法</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">err := db.Update(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(txn *badger.Txn)</span></span> <span class=\"type\">error</span> &#123;   </span><br><span class=\"line\">\t<span class=\"comment\">// Your code here…   </span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span> </span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"手动管理事务\"><a href=\"#手动管理事务\" class=\"headerlink\" title=\"手动管理事务\"></a>手动管理事务</h5><p>直接使用<code>DB.NewTransaction()</code>函数，手动创建和提交事务。它接受一个布尔参数来指定是否需要读写事务。对于读写事务，需要调用<code>Txn.Commit()</code>来确保事务已提交。对于只读事务，调用 <code>txn.reject()</code>就可以了。<code>commit()</code>也在内部调用 <code>txn .reject()</code>来清除事务，因此只需调用Txn.Commit()就足以执行读写事务。</p>\n<p>但是，如果您的代码由于某种原因(出错)没有调用<code>Txn.Commit()</code>。就需要在defer中调用 <code>txn . reject()</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Start a writable transaction. </span></span><br><span class=\"line\">txn := db.NewTransaction(<span class=\"literal\">true</span>) </span><br><span class=\"line\"><span class=\"keyword\">defer</span> txn.Discard() </span><br><span class=\"line\"><span class=\"comment\">// Use the transaction... </span></span><br><span class=\"line\">err := txn.Set([]<span class=\"type\">byte</span>(<span class=\"string\">&quot;answer&quot;</span>), []<span class=\"type\">byte</span>(<span class=\"string\">&quot;42&quot;</span>)) </span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;     <span class=\"keyword\">return</span> err &#125; </span><br><span class=\"line\"><span class=\"comment\">// Commit the transaction and check for error. </span></span><br><span class=\"line\"><span class=\"keyword\">if</span> err := txn.Commit(); err != <span class=\"literal\">nil</span> &#123;     </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> err </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Error-包\"><a href=\"#Error-包\" class=\"headerlink\" title=\"Error 包\"></a>Error 包</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个新 的 error 类型 数据</span></span><br><span class=\"line\">errors.New(<span class=\"string\">&quot;dest id is not cur id&quot;</span>) </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Server-常用\"><a href=\"#Server-常用\" class=\"headerlink\" title=\"Server 常用\"></a>Server 常用</h2><ol>\n<li><p>获取 URL 的路径参数</p>\n<p>   比如： 前端访问：<a href=\"http://127.0.0.1:8080/haha\">http://127.0.0.1:8080/haha</a> ， 如何获取 haha 这个字符串？ 看代码：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">        <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">        <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func handler(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">        // 从请求URL中获取路径参数</span><br><span class=\"line\">        param := r.URL.Path[len(<span class=\"string\">&quot;/&quot;</span>):]</span><br><span class=\"line\"></span><br><span class=\"line\">        // 输出获取到的字符串</span><br><span class=\"line\">        fmt.Println(param)</span><br><span class=\"line\"></span><br><span class=\"line\">        // 在响应中返回获取到的字符串</span><br><span class=\"line\">        fmt.Fprintf(w, <span class=\"string\">&quot;Received: %s&quot;</span>, param)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func <span class=\"function\"><span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">        http.HandleFunc(<span class=\"string\">&quot;/&quot;</span>, handler)</span><br><span class=\"line\">        http.ListenAndServe(<span class=\"string\">&quot;:80&quot;</span>, nil)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>http 状态码返回</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">        <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">        <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\">func handleRequest(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">        // 模拟根据请求处理的逻辑</span><br><span class=\"line\">        <span class=\"keyword\">if</span> r.URL.Path == <span class=\"string\">&quot;/&quot;</span> &#123;</span><br><span class=\"line\">                // 处理成功，返回HTTP 200</span><br><span class=\"line\">                w.WriteHeader(http.StatusOK)</span><br><span class=\"line\">                fmt.Fprintf(w, <span class=\"string\">&quot;Success&quot;</span>)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                // 处理失败，返回HTTP 404</span><br><span class=\"line\">                w.WriteHeader(http.StatusNotFound)</span><br><span class=\"line\">                fmt.Fprintf(w, <span class=\"string\">&quot;Not Found&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func <span class=\"function\"><span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">        http.HandleFunc(<span class=\"string\">&quot;/&quot;</span>, handleRequest)</span><br><span class=\"line\">        http.ListenAndServe(<span class=\"string\">&quot;:80&quot;</span>, nil)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>闭包</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在Go语言中，http.HandleFunc()函数的第二个参数是一个函数类型，它必须是满足http.HandlerFunc函数签名的函数。该函数接收两个参数：http.ResponseWriter和*http.Request。</span><br><span class=\"line\">如果你想在handleRequest函数中传入其他参数，可以使用闭包（Closure）的方式。</span><br><span class=\"line\">以下是一个示例代码，展示如何在handleRequest函数中传入其他参数：</span><br><span class=\"line\">go</span><br><span class=\"line\">复制</span><br><span class=\"line\">package main</span><br><span class=\"line\">import (</span><br><span class=\"line\">        <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">        <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func handleRequest(customParam string) http.HandlerFunc &#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">                // 在这里可以使用 customParam 和 w、r 来处理请求</span><br><span class=\"line\">                fmt.Println(<span class=\"string\">&quot;Custom parameter:&quot;</span>, customParam)</span><br><span class=\"line\">                fmt.Fprintf(w, <span class=\"string\">&quot;Hello, World!&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func <span class=\"function\"><span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">        param := <span class=\"string\">&quot;custom value&quot;</span></span><br><span class=\"line\">        http.HandleFunc(<span class=\"string\">&quot;/&quot;</span>, handleRequest(param))</span><br><span class=\"line\">        http.ListenAndServe(<span class=\"string\">&quot;:8080&quot;</span>, nil)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">在上述代码中，我们定义了一个handleRequest函数，它接收一个类型为string的参数customParam。handleRequest函数返回一个函数，该函数满足http.HandlerFunc函数签名。</span><br><span class=\"line\">在返回的函数中，我们可以使用闭包的方式访问customParam以及http.ResponseWriter和*http.Request参数，并进行相应的处理。</span><br><span class=\"line\">在main函数中，我们定义了一个param变量作为自定义参数的值。然后，我们通过handleRequest(param)将param传递给handleRequest函数，并返回一个满足http.HandlerFunc函数签名的函数。</span><br><span class=\"line\">最后，我们使用http.HandleFunc()来将路径<span class=\"string\">&quot;/&quot;</span>与返回的处理函数进行绑定，并通过http.ListenAndServe()监听HTTP请求</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>net 和 http同时使用</p>\n<p>   Go 语言中，可以同时使用 <code>net</code> 和 <code>http</code> 包来监听同一个接口，但是需要小心处理并避免冲突。</p>\n<p>   <code>net</code> 包提供了底层的网络功能，可以通过 <code>net.Listen</code> 函数来监听指定的网络地址和端口。而 <code>http</code> 包是建立在 <code>net</code> 包之上的，提供了更高级的 HTTP 服务器和客户端功能。</p>\n<p>   以下是一个示例代码，同时使用 <code>net</code> 和 <code>http</code> 监听同一个接口：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\">import (</span><br><span class=\"line\">        &quot;fmt&quot;</span><br><span class=\"line\">        &quot;net&quot;</span><br><span class=\"line\">        &quot;net/http&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">        // 使用 net 包监听指定的网络地址和端口</span><br><span class=\"line\">        listener, err := net.Listen(&quot;tcp&quot;, &quot;localhost:8080&quot;)</span><br><span class=\"line\">        if err != nil &#123;</span><br><span class=\"line\">                fmt.Println(&quot;Error listening:&quot;, err)</span><br><span class=\"line\">                return</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        defer listener.Close()</span><br><span class=\"line\">        // 启动 HTTP 服务器</span><br><span class=\"line\">        go func() &#123;</span><br><span class=\"line\">                http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">                        fmt.Fprintf(w, &quot;Hello, HTTP!&quot;)</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                err := http.Serve(listener, nil)</span><br><span class=\"line\">                if err != nil &#123;</span><br><span class=\"line\">                        fmt.Println(&quot;Error serving HTTP:&quot;, err)</span><br><span class=\"line\">                        return</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">        // 其他的网络处理逻辑...</span><br><span class=\"line\">        // ...</span><br><span class=\"line\">        // 等待程序退出</span><br><span class=\"line\">        select &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>   在上述示例中，我们使用 <code>net.Listen</code> 函数监听 <code>localhost:8080</code>，然后使用 <code>http</code> 包启动了一个 HTTP 服务器。通过 <code>http.HandleFunc</code> 函数，我们定义了一个简单的处理函数来响应 HTTP 请求。最后，通过 <code>http.Serve</code> 函数将监听器与 HTTP 服务器关联起来。</p>\n<p>   你可以在 <code>// 其他的网络处理逻辑...</code> 的部分添加其他网络处理逻辑，如基于 <code>net</code> 包的 TCP 或 UDP 服务器。只需确保网络处理逻辑不会与 HTTP 服务器冲突，比如使用不同的端口或处理不同的网络协议。</p>\n<p>   需要注意的是，当使用 <code>http.Serve</code> 函数时，它将阻塞当前的 goroutine，因此我们在示例中使用了 <code>select &#123;&#125;</code> 来阻止 <code>main</code> 函数退出。这样可以保持服务器的运行，直到显式地退出程序。</p>\n</li>\n<li><p>mymux</p>\n<p>   <code>myMux := http.NewServeMux()</code> 这条语句用于创建一个新的 <code>ServeMux</code> 对象。</p>\n<p>   在 Go 的 <code>http</code> 包中，<code>ServeMux</code> 是一个 HTTP 请求多路复用器（multiplexer），用于将收到的 HTTP 请求分发到相应的处理器。<code>ServeMux</code> 类型实现了 <code>http.Handler</code> 接口，因此它本身可以作为一个处理器来处理请求。</p>\n<p>   通过调用 <code>http.NewServeMux()</code> 函数，我们可以创建一个新的 <code>ServeMux</code> 对象，它将用于注册和管理不同路径的处理器。</p>\n<p>   例如，下面是一个简单示例，使用 <code>ServeMux</code> 对象来管理不同路径的处理器：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\">import (</span><br><span class=\"line\">        &quot;fmt&quot;</span><br><span class=\"line\">        &quot;net/http&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">        myMux := http.NewServeMux()</span><br><span class=\"line\"></span><br><span class=\"line\">        myMux.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">                fmt.Fprintf(w, &quot;Hello, World!&quot;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">        myMux.HandleFunc(&quot;/about&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">                fmt.Fprintf(w, &quot;About page&quot;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        server := &amp;http.Server&#123;</span><br><span class=\"line\">                Addr:    &quot;:8080&quot;,</span><br><span class=\"line\">                Handler: myMux,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        server.ListenAndServe()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>   在上述示例中，我们首先使用 <code>http.NewServeMux()</code> 创建了一个新的 <code>ServeMux</code> 对象 <code>myMux</code>。然后，我们使用 <code>myMux.HandleFunc</code> 方法来注册处理器函数，每个函数对应一个特定的路径。</p>\n<p>   最后，我们创建了一个 <code>http.Server</code> 对象，并将 <code>myMux</code> 对象作为处理器指定给该服务器。这样，当服务器收到请求时，就会使用 <code>myMux</code> 对象来根据请求的路径选择相应的处理器函数进行处理。</p>\n<p>   总结起来，<code>myMux := http.NewServeMux()</code> 用于创建一个 <code>ServeMux</code> 对象，以便注册和管理不同路径的处理器，并根据路径选择相应的处理函数来处理请求。</p>\n</li>\n<li><p>go routine 实现并发执行</p>\n<p>   Go 的 goroutine 来实现并发执行。以下是一个示例代码，演示了如何同时运行 HTTP 服务、gRPC 服务和连接其他 gRPC 服务器：</p>\n <figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">        <span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">        <span class=\"string\">&quot;net&quot;</span></span><br><span class=\"line\">        <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">        <span class=\"string\">&quot;google.golang.org/grpc&quot;</span></span><br><span class=\"line\">        <span class=\"string\">&quot;google.golang.org/grpc/credentials&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建监听器</span></span><br><span class=\"line\">        lis, err := net.Listen(<span class=\"string\">&quot;tcp&quot;</span>, <span class=\"string\">&quot;:8080&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                log.Fatalf(<span class=\"string\">&quot;Failed to listen: %v&quot;</span>, err)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 启动 HTTP 服务器</span></span><br><span class=\"line\">        <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">                http.HandleFunc(<span class=\"string\">&quot;/&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">                        w.Write([]<span class=\"type\">byte</span>(<span class=\"string\">&quot;Hello, HTTP!&quot;</span>))</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> err := http.Serve(lis, <span class=\"literal\">nil</span>); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                        log.Fatalf(<span class=\"string\">&quot;HTTP failed to serve: %v&quot;</span>, err)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 启动 gRPC 服务器</span></span><br><span class=\"line\">        <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">                s := grpc.NewServer()</span><br><span class=\"line\">                <span class=\"comment\">// 注册 gRPC 服务</span></span><br><span class=\"line\">                <span class=\"comment\">// ...</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> err := s.Serve(lis); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                        log.Fatalf(<span class=\"string\">&quot;gRPC failed to serve: %v&quot;</span>, err)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 连接其他 gRPC 服务器</span></span><br><span class=\"line\">        conn, err := grpc.Dial(<span class=\"string\">&quot;other_server_address&quot;</span>, grpc.WithTransportCredentials(credentials.NewInsecure()))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                log.Fatalf(<span class=\"string\">&quot;Failed to connect to other server: %v&quot;</span>, err)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">defer</span> conn.Close()</span><br><span class=\"line\">        <span class=\"comment\">// 进行其他操作，使用 conn 进行 gRPC 通信</span></span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        <span class=\"comment\">// 等待程序退出</span></span><br><span class=\"line\">        <span class=\"keyword\">select</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>   在这个示例中，我们使用 goroutine 启动了 HTTP 服务器和 gRPC 服务器，并在主函数中创建了一个与其他 gRPC 服务器的连接。</p>\n<p>   注意在连接其他 gRPC 服务器时，我们使用了 <code>grpc.Dial</code> 函数，并传递了 <code>grpc.WithTransportCredentials(credentials.NewInsecure())</code> 选项来创建一个不安全的连接。你应该根据实际情况选择正确的连接配置，例如使用安全的连接和认证。</p>\n<p>   最后，使用 <code>select &#123;&#125;</code> 阻塞主函数，使程序保持运行状态，直到显式退出。</p>\n<p>   请根据你的实际需求，将代码中的注释部分替换为适当的 gRPC 服务注册和其他操作代码。</p>\n</li>\n<li><p>连接阻塞</p>\n <figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 主要就是 grpc.WithBlock()</span></span><br><span class=\"line\"></span><br><span class=\"line\">conn2, err2 := grpc.Dial(*addr2, grpc.WithTransportCredentials(insecure.NewCredentials()),grpc.WithBlock())</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>循环变量副本</p>\n<p>   for i :&#x3D; 1; i &lt;&#x3D; *rpc_num; i++ {</p>\n<p>   if i &#x3D;&#x3D; *rpc_id {</p>\n<p>   continue &#x2F;&#x2F; 跳过与 当前相同的 端口号 ，不能和自己连接</p>\n<p>   }</p>\n<p>   go func(){</p>\n<p>   conn[i], err &#x3D; grpc.Dial(rpc_addr[i], grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithBlock())</p>\n<p>   if err !&#x3D; nil {</p>\n<p>   log.Fatalf(“Failed to connect to server %s: %v”, rpc_addr[i], err)</p>\n<p>   return</p>\n<p>   }</p>\n<p>   log.Printf(“Connect to %s OK”, rpc_addr[i])</p>\n<p>   }()</p>\n<p>   }</p>\n<p>   这里有个提示信息但是没有报错，提示为：loop variable i captured by func litera</p>\n<p>    “loop variable i captured by func literal” 意味着在你的代码中，匿名函数字面量（func literal）捕获了循环变量 i。</p>\n<p>   在 Go 语言中，当你在循环体内使用匿名函数时，该匿名函数会形成一个闭包，它可以访问和引用外部作用域中的变量。在这种情况下，匿名函数引用了循环变量 i。然而，循环变量在每次迭代中的值会发生变化，这可能会导致一些意外的行为。</p>\n<p>   为了避免这种问题，Go 语言引入了循环变量副本的概念。在每次迭代中，会为循环体内的匿名函数创建一个新的副本变量，以确保在闭包内部引用的是正确的值。这样可以避免循环变量值的竞争条件。</p>\n<p>   解决这个问题的常见方法是在循环体内部创建一个局部变量，将循环变量的值复制给局部变量，然后在匿名函数中使用局部变量。例如：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for i := 1; i &lt;= *rpc_num; i++ &#123;</span><br><span class=\"line\">    if i == *rpc_id &#123;</span><br><span class=\"line\">        continue</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 创建局部变量 iCopy 并将循环变量的值赋给它</span><br><span class=\"line\">    iCopy := i</span><br><span class=\"line\">    go func() &#123;</span><br><span class=\"line\">        conn[iCopy], err = grpc.Dial(rpc_addr[iCopy], grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithBlock())</span><br><span class=\"line\">        if err != nil &#123;</span><br><span class=\"line\">            log.Fatalf(&quot;Failed to connect to server %s: %v&quot;, rpc_addr[iCopy], err)</span><br><span class=\"line\">            return</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        log.Printf(&quot;Connect to %s OK&quot;, rpc_addr[iCopy])</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>   通过创建局部变量 iCopy 并使用它，你可以确保每个匿名函数引用的是该迭代的正确值，而不会受到循环变量的更改影响。</p>\n</li>\n</ol>\n<h1 id=\"Atomic-包\"><a href=\"#Atomic-包\" class=\"headerlink\" title=\"Atomic 包\"></a>Atomic 包</h1><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;runtime&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;sync/atomic&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> count <span class=\"type\">int32</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">test</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    currentCount := atomic.LoadInt32(&amp;count)</span><br><span class=\"line\">    atomic.AddInt32(&amp;count, <span class=\"number\">1</span>)</span><br><span class=\"line\">    log.Println(<span class=\"string\">&quot;count:&quot;</span>, currentCount)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    runtime.GOMAXPROCS(runtime.NumCPU() - <span class=\"number\">1</span>)</span><br><span class=\"line\">    http.HandleFunc(<span class=\"string\">&quot;/&quot;</span>, test)</span><br><span class=\"line\">    http.ListenAndServe(<span class=\"string\">&quot;:8080&quot;</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"Done-Wait-同步\"><a href=\"#Done-Wait-同步\" class=\"headerlink\" title=\"Done Wait 同步\"></a>Done Wait 同步</h1><p> Go 内存模型中的术语。它说明了在调用 <code>Done</code> 方法之前，它会与任何由它解除阻塞的 <code>Wait</code> 调用之后的返回之前进行”同步在”（synchronizes before）的关系。</p>\n<p>具体解释如下：</p>\n<ol>\n<li><code>Done</code> 方法是用于通知等待组（WaitGroup）中某个操作的完成。</li>\n<li><code>Wait</code> 方法是等待等待组中所有操作完成的调用。</li>\n<li>“同步在”（synchronizes before）是 Go 内存模型中的同步关系，指示在同一个 goroutine 中，一个操作的执行在另一个操作之前进行了同步。</li>\n</ol>\n<p>根据这句话的解释，当一个 goroutine 调用 <code>Done</code> 方法时，它会在解除等待组中的某个操作的阻塞之前与该操作的返回之前进行同步。</p>\n<p>具体来说，如果一个 goroutine 在调用 <code>Wait</code> 方法等待等待组中的操作时被阻塞，那么当另一个 goroutine 调用 <code>Done</code> 方法通知该操作的完成时，调用 <code>Done</code> 的 goroutine 会在被阻塞的 goroutine 返回之前进行同步。这确保了在 <code>Done</code> 方法解除阻塞之后，等待的 goroutine 可以安全地继续执行。</p>\n<p>总之，这句话的含义是在 Go 内存模型中，<code>Done</code> 方法的调用会在解除阻塞的 <code>Wait</code> 调用的返回之前进行同步。这个同步关系确保了等待组的协同操作的正确性和可靠性。</p>\n"},{"_content":"[在线调试平台](https://go.dev/play/p/yGTd4MtgD5)\n\n| 项目         | 地址  |     |     |\n| ---------- | --- | --- | --- |\n| [[grpc_1]] |     |     |     |\n|            |     |     |     |\n[[go 基础]]\n\n[[go 高级]]\n\n","source":"_posts/编程语言/GO_lang/go语言学习记录.md","raw":"[在线调试平台](https://go.dev/play/p/yGTd4MtgD5)\n\n| 项目         | 地址  |     |     |\n| ---------- | --- | --- | --- |\n| [[grpc_1]] |     |     |     |\n|            |     |     |     |\n[[go 基础]]\n\n[[go 高级]]\n\n","slug":"编程语言/GO_lang/go语言学习记录","published":1,"date":"2024-04-22T13:14:48.680Z","updated":"2024-03-17T08:15:12.437Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0q002jkgg4bbpleicw","content":"<p><a href=\"https://go.dev/play/p/yGTd4MtgD5\">在线调试平台</a></p>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th>地址</th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>[[grpc_1]]</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>[[go 基础]]</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p>[[go 高级]]</p>\n","excerpt":"","more":"<p><a href=\"https://go.dev/play/p/yGTd4MtgD5\">在线调试平台</a></p>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th>地址</th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>[[grpc_1]]</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>[[go 基础]]</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p>[[go 高级]]</p>\n"},{"_content":"\n# Raft 协议\n参考：[Raft-4：Raft 协议的基础工作流程_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1nu4y167WM?p=5&spm_id_from=pageDriver&vd_source=59461060c1867e9bf731e467ae6f00b5)\n知识点：Paxos\n核心原理：在多个副本之间进行投票和决策，以确保数据的一致性。\n两个阶段：\n1. prepare: 提案者提出一个提议，发送给其他所有参与者，每个参与者都参与投票。如果大多数参与者同意这个协议，则进入 accept 阶段。\n2. accept：提案者再次向所有参与者发送一个包含提议编号和提议内容的消息，如果大多数参与者再次同意这个提议，则该提议被视为有效并被接受。\n关键特性：\n\t去中心化设计：没有单一的领导者节点负责做出最终决策，相反，任何节点都可以成为提案者或者接收者。\nRaft：\n基本流程：\n1. 多个 server 共同选举产生一个 Leader，负责响应客户端的请求。\n2. Leader 通过一致性协议，将客户端的指令发送到所有节点上。\n3. 每个节点将客户端的指令以 Entry的形式保存到自己的 Log 中，此时 Entry 状态为 uncommited 。\n4. 当有多数节点共同保存了 Entry 后，就可以执行 Entry 中的客户端指令，提交到 State 状态机中，此时 Entry 更新为 commited 状态。\n![[Pasted image 20240320211915.png]]\n理解  Raft 中的 Term：\n1. Raft 将时间线分割为多个 term （任期）；\n2. 一个任期有一个 id ，分两个阶段：\n\t1. 选举 election：选举出一个 leader。如果选举失败，此 term（任期）快速结束。\n\t2. 操作：进行执行任务。\n![[Pasted image 20240320211822.png]]\n\n\n理解 Raft 中的 状态机制\nRaft 协议会为每一个服务器记录一个状态，状态有三种：\n\t1. Follower：负责同步 Leader 的操作日志。\n\t2. Candidate\n\t3. Leader：\n1. 所有节点都是从 Follower 开始，Follower 负责同步 Leader 的操作日志。\n2. Leader 会给 Follower 发送心跳。\n3. Follower 收到心跳超时（随机值），转入 Candidate 状态，发起选举，如果成功，则变成 Leader；\n4. 新的 Leader 会向所有其他节点发送心跳。\n5. 此时其他节点无论是什么状态，都会变成 Follower\n![[Pasted image 20240320211748.png]]\n\nRaft 协议会为每一个服务器记录两个超时：\n1. 选举超时。\n2. \n\nRaft 和 Paxos 类似，但是更容易理解，也更容易实现。\nRaft 主要是用来竞选主节点。\n单个 Candidate 的竞选\n有三种节点：Follower、Candidate 和 Leader。Leader 会周期性的发送心跳包给 Follower。每个 Follower 都设置了一个随机的竞选超时时间，一般为 150ms~300ms，如果在这个时间内没有收到 Leader 的心跳包，就会变成 Candidate，进入竞选阶段。\n\n- 下图表示一个分布式系统的最初阶段，此时只有 Follower，没有 Leader。Follower A 等待一个随机的竞选超时时间之后，没收到 Leader 发来的心跳包，因此进入竞选阶段。\n  \n\n- 此时 A 发送投票请求给其它所有节点。\n\n- 其它节点会对请求进行回复，如果超过一半的节点回复了，那么该 Candidate 就会变成 Leader。\n\n- 之后 Leader 会周期性地发送心跳包给 Follower，Follower 接收到心跳包，会重新开始计时。\n\n## 多个 Candidate 竞选\n\n- 如果有多个 Follower 成为 Candidate，并且所获得票数相同，那么就需要重新开始投票，例如下图中 Candidate B 和 Candidate D 都获得两票，因此需要重新开始投票。\n\n\n- 当重新开始投票时，由于每个节点设置的随机竞选超时时间不同，因此能下一次再次出现多个 Candidate 并获得同样票数的概率很低。\n\n## 日志复制\n\n- 来自客户端的修改都会被传入 Leader。注意该修改还未被提交，只是写入日志中。\n\n\n\n- Leader 会把修改复制到所有 Follower。\n\n  \n\n- Leader 会等待大多数的 Follower 也进行了修改，然后才将修改提交。\n\n- 此时 Leader 会通知的所有 Follower 让它们也提交修改，此时所有节点的值达成一致\n","source":"_posts/项目经历/TinyKV/Raft 协议.md","raw":"\n# Raft 协议\n参考：[Raft-4：Raft 协议的基础工作流程_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1nu4y167WM?p=5&spm_id_from=pageDriver&vd_source=59461060c1867e9bf731e467ae6f00b5)\n知识点：Paxos\n核心原理：在多个副本之间进行投票和决策，以确保数据的一致性。\n两个阶段：\n1. prepare: 提案者提出一个提议，发送给其他所有参与者，每个参与者都参与投票。如果大多数参与者同意这个协议，则进入 accept 阶段。\n2. accept：提案者再次向所有参与者发送一个包含提议编号和提议内容的消息，如果大多数参与者再次同意这个提议，则该提议被视为有效并被接受。\n关键特性：\n\t去中心化设计：没有单一的领导者节点负责做出最终决策，相反，任何节点都可以成为提案者或者接收者。\nRaft：\n基本流程：\n1. 多个 server 共同选举产生一个 Leader，负责响应客户端的请求。\n2. Leader 通过一致性协议，将客户端的指令发送到所有节点上。\n3. 每个节点将客户端的指令以 Entry的形式保存到自己的 Log 中，此时 Entry 状态为 uncommited 。\n4. 当有多数节点共同保存了 Entry 后，就可以执行 Entry 中的客户端指令，提交到 State 状态机中，此时 Entry 更新为 commited 状态。\n![[Pasted image 20240320211915.png]]\n理解  Raft 中的 Term：\n1. Raft 将时间线分割为多个 term （任期）；\n2. 一个任期有一个 id ，分两个阶段：\n\t1. 选举 election：选举出一个 leader。如果选举失败，此 term（任期）快速结束。\n\t2. 操作：进行执行任务。\n![[Pasted image 20240320211822.png]]\n\n\n理解 Raft 中的 状态机制\nRaft 协议会为每一个服务器记录一个状态，状态有三种：\n\t1. Follower：负责同步 Leader 的操作日志。\n\t2. Candidate\n\t3. Leader：\n1. 所有节点都是从 Follower 开始，Follower 负责同步 Leader 的操作日志。\n2. Leader 会给 Follower 发送心跳。\n3. Follower 收到心跳超时（随机值），转入 Candidate 状态，发起选举，如果成功，则变成 Leader；\n4. 新的 Leader 会向所有其他节点发送心跳。\n5. 此时其他节点无论是什么状态，都会变成 Follower\n![[Pasted image 20240320211748.png]]\n\nRaft 协议会为每一个服务器记录两个超时：\n1. 选举超时。\n2. \n\nRaft 和 Paxos 类似，但是更容易理解，也更容易实现。\nRaft 主要是用来竞选主节点。\n单个 Candidate 的竞选\n有三种节点：Follower、Candidate 和 Leader。Leader 会周期性的发送心跳包给 Follower。每个 Follower 都设置了一个随机的竞选超时时间，一般为 150ms~300ms，如果在这个时间内没有收到 Leader 的心跳包，就会变成 Candidate，进入竞选阶段。\n\n- 下图表示一个分布式系统的最初阶段，此时只有 Follower，没有 Leader。Follower A 等待一个随机的竞选超时时间之后，没收到 Leader 发来的心跳包，因此进入竞选阶段。\n  \n\n- 此时 A 发送投票请求给其它所有节点。\n\n- 其它节点会对请求进行回复，如果超过一半的节点回复了，那么该 Candidate 就会变成 Leader。\n\n- 之后 Leader 会周期性地发送心跳包给 Follower，Follower 接收到心跳包，会重新开始计时。\n\n## 多个 Candidate 竞选\n\n- 如果有多个 Follower 成为 Candidate，并且所获得票数相同，那么就需要重新开始投票，例如下图中 Candidate B 和 Candidate D 都获得两票，因此需要重新开始投票。\n\n\n- 当重新开始投票时，由于每个节点设置的随机竞选超时时间不同，因此能下一次再次出现多个 Candidate 并获得同样票数的概率很低。\n\n## 日志复制\n\n- 来自客户端的修改都会被传入 Leader。注意该修改还未被提交，只是写入日志中。\n\n\n\n- Leader 会把修改复制到所有 Follower。\n\n  \n\n- Leader 会等待大多数的 Follower 也进行了修改，然后才将修改提交。\n\n- 此时 Leader 会通知的所有 Follower 让它们也提交修改，此时所有节点的值达成一致\n","slug":"项目经历/TinyKV/Raft 协议","published":1,"date":"2024-04-22T13:14:49.243Z","updated":"2024-03-20T13:51:38.345Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0q002kkgg4dm1r4c89","content":"<h1 id=\"Raft-协议\"><a href=\"#Raft-协议\" class=\"headerlink\" title=\"Raft 协议\"></a>Raft 协议</h1><p>参考：<a href=\"https://www.bilibili.com/video/BV1nu4y167WM?p=5&spm_id_from=pageDriver&vd_source=59461060c1867e9bf731e467ae6f00b5\">Raft-4：Raft 协议的基础工作流程_哔哩哔哩_bilibili</a><br>知识点：Paxos<br>核心原理：在多个副本之间进行投票和决策，以确保数据的一致性。<br>两个阶段：</p>\n<ol>\n<li>prepare: 提案者提出一个提议，发送给其他所有参与者，每个参与者都参与投票。如果大多数参与者同意这个协议，则进入 accept 阶段。</li>\n<li>accept：提案者再次向所有参与者发送一个包含提议编号和提议内容的消息，如果大多数参与者再次同意这个提议，则该提议被视为有效并被接受。<br>关键特性：<br> 去中心化设计：没有单一的领导者节点负责做出最终决策，相反，任何节点都可以成为提案者或者接收者。<br>Raft：<br>基本流程：</li>\n<li>多个 server 共同选举产生一个 Leader，负责响应客户端的请求。</li>\n<li>Leader 通过一致性协议，将客户端的指令发送到所有节点上。</li>\n<li>每个节点将客户端的指令以 Entry的形式保存到自己的 Log 中，此时 Entry 状态为 uncommited 。</li>\n<li>当有多数节点共同保存了 Entry 后，就可以执行 Entry 中的客户端指令，提交到 State 状态机中，此时 Entry 更新为 commited 状态。<br>![[Pasted image 20240320211915.png]]<br>理解  Raft 中的 Term：</li>\n<li>Raft 将时间线分割为多个 term （任期）；</li>\n<li>一个任期有一个 id ，分两个阶段：<ol>\n<li>选举 election：选举出一个 leader。如果选举失败，此 term（任期）快速结束。</li>\n<li>操作：进行执行任务。<br>![[Pasted image 20240320211822.png]]</li>\n</ol>\n</li>\n</ol>\n<p>理解 Raft 中的 状态机制<br>Raft 协议会为每一个服务器记录一个状态，状态有三种：<br>    1. Follower：负责同步 Leader 的操作日志。<br>    2. Candidate<br>    3. Leader：</p>\n<ol>\n<li>所有节点都是从 Follower 开始，Follower 负责同步 Leader 的操作日志。</li>\n<li>Leader 会给 Follower 发送心跳。</li>\n<li>Follower 收到心跳超时（随机值），转入 Candidate 状态，发起选举，如果成功，则变成 Leader；</li>\n<li>新的 Leader 会向所有其他节点发送心跳。</li>\n<li>此时其他节点无论是什么状态，都会变成 Follower<br>![[Pasted image 20240320211748.png]]</li>\n</ol>\n<p>Raft 协议会为每一个服务器记录两个超时：</p>\n<ol>\n<li>选举超时。</li>\n<li></li>\n</ol>\n<p>Raft 和 Paxos 类似，但是更容易理解，也更容易实现。<br>Raft 主要是用来竞选主节点。<br>单个 Candidate 的竞选<br>有三种节点：Follower、Candidate 和 Leader。Leader 会周期性的发送心跳包给 Follower。每个 Follower 都设置了一个随机的竞选超时时间，一般为 150ms~300ms，如果在这个时间内没有收到 Leader 的心跳包，就会变成 Candidate，进入竞选阶段。</p>\n<ul>\n<li><p>下图表示一个分布式系统的最初阶段，此时只有 Follower，没有 Leader。Follower A 等待一个随机的竞选超时时间之后，没收到 Leader 发来的心跳包，因此进入竞选阶段。</p>\n</li>\n<li><p>此时 A 发送投票请求给其它所有节点。</p>\n</li>\n<li><p>其它节点会对请求进行回复，如果超过一半的节点回复了，那么该 Candidate 就会变成 Leader。</p>\n</li>\n<li><p>之后 Leader 会周期性地发送心跳包给 Follower，Follower 接收到心跳包，会重新开始计时。</p>\n</li>\n</ul>\n<h2 id=\"多个-Candidate-竞选\"><a href=\"#多个-Candidate-竞选\" class=\"headerlink\" title=\"多个 Candidate 竞选\"></a>多个 Candidate 竞选</h2><ul>\n<li><p>如果有多个 Follower 成为 Candidate，并且所获得票数相同，那么就需要重新开始投票，例如下图中 Candidate B 和 Candidate D 都获得两票，因此需要重新开始投票。</p>\n</li>\n<li><p>当重新开始投票时，由于每个节点设置的随机竞选超时时间不同，因此能下一次再次出现多个 Candidate 并获得同样票数的概率很低。</p>\n</li>\n</ul>\n<h2 id=\"日志复制\"><a href=\"#日志复制\" class=\"headerlink\" title=\"日志复制\"></a>日志复制</h2><ul>\n<li><p>来自客户端的修改都会被传入 Leader。注意该修改还未被提交，只是写入日志中。</p>\n</li>\n<li><p>Leader 会把修改复制到所有 Follower。</p>\n</li>\n<li><p>Leader 会等待大多数的 Follower 也进行了修改，然后才将修改提交。</p>\n</li>\n<li><p>此时 Leader 会通知的所有 Follower 让它们也提交修改，此时所有节点的值达成一致</p>\n</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"Raft-协议\"><a href=\"#Raft-协议\" class=\"headerlink\" title=\"Raft 协议\"></a>Raft 协议</h1><p>参考：<a href=\"https://www.bilibili.com/video/BV1nu4y167WM?p=5&spm_id_from=pageDriver&vd_source=59461060c1867e9bf731e467ae6f00b5\">Raft-4：Raft 协议的基础工作流程_哔哩哔哩_bilibili</a><br>知识点：Paxos<br>核心原理：在多个副本之间进行投票和决策，以确保数据的一致性。<br>两个阶段：</p>\n<ol>\n<li>prepare: 提案者提出一个提议，发送给其他所有参与者，每个参与者都参与投票。如果大多数参与者同意这个协议，则进入 accept 阶段。</li>\n<li>accept：提案者再次向所有参与者发送一个包含提议编号和提议内容的消息，如果大多数参与者再次同意这个提议，则该提议被视为有效并被接受。<br>关键特性：<br> 去中心化设计：没有单一的领导者节点负责做出最终决策，相反，任何节点都可以成为提案者或者接收者。<br>Raft：<br>基本流程：</li>\n<li>多个 server 共同选举产生一个 Leader，负责响应客户端的请求。</li>\n<li>Leader 通过一致性协议，将客户端的指令发送到所有节点上。</li>\n<li>每个节点将客户端的指令以 Entry的形式保存到自己的 Log 中，此时 Entry 状态为 uncommited 。</li>\n<li>当有多数节点共同保存了 Entry 后，就可以执行 Entry 中的客户端指令，提交到 State 状态机中，此时 Entry 更新为 commited 状态。<br>![[Pasted image 20240320211915.png]]<br>理解  Raft 中的 Term：</li>\n<li>Raft 将时间线分割为多个 term （任期）；</li>\n<li>一个任期有一个 id ，分两个阶段：<ol>\n<li>选举 election：选举出一个 leader。如果选举失败，此 term（任期）快速结束。</li>\n<li>操作：进行执行任务。<br>![[Pasted image 20240320211822.png]]</li>\n</ol>\n</li>\n</ol>\n<p>理解 Raft 中的 状态机制<br>Raft 协议会为每一个服务器记录一个状态，状态有三种：<br>    1. Follower：负责同步 Leader 的操作日志。<br>    2. Candidate<br>    3. Leader：</p>\n<ol>\n<li>所有节点都是从 Follower 开始，Follower 负责同步 Leader 的操作日志。</li>\n<li>Leader 会给 Follower 发送心跳。</li>\n<li>Follower 收到心跳超时（随机值），转入 Candidate 状态，发起选举，如果成功，则变成 Leader；</li>\n<li>新的 Leader 会向所有其他节点发送心跳。</li>\n<li>此时其他节点无论是什么状态，都会变成 Follower<br>![[Pasted image 20240320211748.png]]</li>\n</ol>\n<p>Raft 协议会为每一个服务器记录两个超时：</p>\n<ol>\n<li>选举超时。</li>\n<li></li>\n</ol>\n<p>Raft 和 Paxos 类似，但是更容易理解，也更容易实现。<br>Raft 主要是用来竞选主节点。<br>单个 Candidate 的竞选<br>有三种节点：Follower、Candidate 和 Leader。Leader 会周期性的发送心跳包给 Follower。每个 Follower 都设置了一个随机的竞选超时时间，一般为 150ms~300ms，如果在这个时间内没有收到 Leader 的心跳包，就会变成 Candidate，进入竞选阶段。</p>\n<ul>\n<li><p>下图表示一个分布式系统的最初阶段，此时只有 Follower，没有 Leader。Follower A 等待一个随机的竞选超时时间之后，没收到 Leader 发来的心跳包，因此进入竞选阶段。</p>\n</li>\n<li><p>此时 A 发送投票请求给其它所有节点。</p>\n</li>\n<li><p>其它节点会对请求进行回复，如果超过一半的节点回复了，那么该 Candidate 就会变成 Leader。</p>\n</li>\n<li><p>之后 Leader 会周期性地发送心跳包给 Follower，Follower 接收到心跳包，会重新开始计时。</p>\n</li>\n</ul>\n<h2 id=\"多个-Candidate-竞选\"><a href=\"#多个-Candidate-竞选\" class=\"headerlink\" title=\"多个 Candidate 竞选\"></a>多个 Candidate 竞选</h2><ul>\n<li><p>如果有多个 Follower 成为 Candidate，并且所获得票数相同，那么就需要重新开始投票，例如下图中 Candidate B 和 Candidate D 都获得两票，因此需要重新开始投票。</p>\n</li>\n<li><p>当重新开始投票时，由于每个节点设置的随机竞选超时时间不同，因此能下一次再次出现多个 Candidate 并获得同样票数的概率很低。</p>\n</li>\n</ul>\n<h2 id=\"日志复制\"><a href=\"#日志复制\" class=\"headerlink\" title=\"日志复制\"></a>日志复制</h2><ul>\n<li><p>来自客户端的修改都会被传入 Leader。注意该修改还未被提交，只是写入日志中。</p>\n</li>\n<li><p>Leader 会把修改复制到所有 Follower。</p>\n</li>\n<li><p>Leader 会等待大多数的 Follower 也进行了修改，然后才将修改提交。</p>\n</li>\n<li><p>此时 Leader 会通知的所有 Follower 让它们也提交修改，此时所有节点的值达成一致</p>\n</li>\n</ul>\n"},{"_content":"\n# Project 1\n# Project 2\n## Project 2 整体架构\n\n## Project 2A\n### Project 2A 整体架构\n本部分实现基础的 Raft 算法，且不需要考虑快照操作。我们共需要实现三个模块，分别为 RawNode、Raft 和 RaftLog，分别对应文件 `rawnode.go`、`raft.go` 和 `log.go` ，这三个模块，共同构成一层，我将其称为 `raft 层`。结构图如下\n![[image2.png]]\n- **RawNode**：该模块用来接收上层传来的信息，将信息下传给 Raft 模块。比如，上层传递一个 Msg 给 RawNode，这个 Msg 可能是 心跳请求、日志提交请求、日志追加请求等等。然后 RawNode 收到这个 Msg 之后，将其交给 Raft 模块去处理。比如，上层交给 RawNode 一个日志提交请求，然后 RawNode 将其交给 Raft ，如果该节点是领导人，那么其就会追加这条日志，然后发送给其他节点进行同步。另外，RawNode 不仅用来接受请求然后传递给 Raft，还要用来收到 Raft 的同步结果然后传递给上层。RawNode 要负责检查 Raft 模块是否已有同步好的日志需要应用、是否有 Msg 需要发送、是否有日志需要持久化等等，然后把这些信息（Ready）交给上层，上层会据此进行处理。总的来说，RawNode 是 raft 层暴露给上层的一个模块，用来进行信息的传递。\n- **Raft**：整个 raft 层最关键的就是它，它就是实现 Raft 算法的核心模块。其中，领导人选举、日志追加、角色转换等等均是在这里实现。Raft 模块会接受 RawNode 发来的信息，然后在进群中进行相关的同步操作，同步结果不需要主动返回给 RawNode，因为 RawNode 自己会进行检查。\n- **RaftLog**：该模块用来暂存节点的日志条目，同时还要维护一些日志指针，如 committed、applied 等等。\n\n总结一下，RawNode 是 raft 层中暴露在外面的模块，用于该层与上层的信息交互，Raft 模块是 raft 层中的核心模块，算法的核心逻辑均在该模块实现，RaftLog 用来暂存日志信息，并维护相关指针。\n### Project 2 AA｜Project 2 AB\n#### 消息类型以及基本逻辑\n1. case pb.MessageType_MsgHup:\n\t1. 选举的本地消息，由 Tick() 触发。\n\t2. 如果发生选举超时，节点应将“MessageType_MsgHup”传递给其 Step 方法并开始新的选举，向其他所有节点发送 MsgRequestVote；\n\t3. 一旦收到了这个消息，说明就是要重新开始一次选举。\n\t\n2. case pb.MessageType_MsgBeat:\n\t1. 本地心跳信息。表示当前节点的时钟前进，判断心跳超时和选举超时并进行相应的处理。\n\t2. 注意只有 Leader 需要处理这个消息。\n\t\n3. case pb.MessageType_MsgPropose:\n\t1. 注意只有 Leader 会处理这个消息。 \n\t2. Leader 收到此消息需要将日志广播给其他节点。\n\t\t1. 发送时，如果要发送的 Index 已经被压缩了，转为发送快照。\n\t\t2. 否则发送 MsgAppend。\n\t\t3. 如果 MsgAppend 被接收者拒绝，Leader 会调整 next，重新进行前置判断，如果无需发快照，则按照新的 next 重新发送 MsgAppend。\n\t3. 发送方：由 Raft 层的上层构造此 msg 表示一次追加日志。此外，becomeLeader 时也会发送一个空 Entry 的 propose（也会被 广播）。\n\t\n4. case pb.MessageType_MsgAppend:\n\t1. 发送方：如上，一般 propose 之后触发，由 Leader 发送给其他节点来同步日志条目。\n\t2. 接收方：\n\t\t1. 判断 Msg 的 Term 是否大于等于自己的 Term，是则更新，否则拒绝；\n\t\t2. 拒绝，如果 prevLogIndex > r.RaftLog.LastIndex() 说明中间有日志缺失。否则往下；\n\t\t3. 拒绝，如果接收者日志中没有包含这样一个条目：即该条目的 Term 在 prevLogIndex 上不能和 prevLogTerm 匹配上。否则往下；\n\t\t4. 追加新条目，同时删除冲突条目，冲突条目的判别方式和论文中的一致；\n\t\t5. 当前节点更新 committedIndex 时，要比较 Leader 已知已经提交的最高的日志条目的索引 m.Commit 或者是上一个新条目的索引，然后取两者的最小值。为\n\t\t6. 接受；\n\t\n5. case pb.MessageType_MsgAppendResponse:\n\t1. 只有 Leader 会处理该 Msg，其余角色直接忽略；\n\t2. 如果被 reject 了，那么重置 next。重置规则为将旧的 next --，然后比较 m.Index + 1，最后取小的那个赋值给 next，然后重新进行日志 / 快照追加；\n\t3. 如果没有 reject，则更新 match 和 next。next 赋值为 m.Index + 1，match 赋值为 next - 1 ；\n\t4. 按照论文的思路更新 commit。假设存在 N 满足N > commitIndex，使得大多数的 matchIndex[i] ≥ N以及log[N].term == currentTerm 成立，则令 commitIndex = N。为了快速更新，这里先将节点按照 match 进行了递增排序，这样就可以快速确定 N 的位置。\n\n6. case pb.MessageType_MsgRequestVote:\n\t1. 判断 Msg 的 Term 是否大于等于自己的 Term，是则更新，否则拒绝；\n\t2. 如果 votedFor 不为空或者不等于 candidateID，则说明该节点以及投过票了，直接拒绝。否则往下；\n\t3. Candidate 的日志至少和自己一样新，那么就给其投票，否者拒绝。新旧判断逻辑如下：\n\t    - 如果两份日志最后的条目的任期号不同，那么任期号大的日志更加新\n\t    - 如果两份日志最后的条目任期号相同，那么日志比较长的那个就更加新；\n\tCandidate 会通过 r.votes 记录下都有哪些节点同意哪些节点拒绝，当同意的票数过半时，即可成为 Leader，当拒绝的票数过半时，则转变为 Follower。\n\t\t\n7. case pb.MessageType_MsgRequestVoteResponse:\n\t1. 只有 Candidate 会处理该 Msg，其余节点收到后直接忽略；\n\t2. 根据 m.Reject 更新 r.votes[m.From]，即记录投票结果；\n\t3. 算出同意的票数 agrNum 和拒绝的票数 denNum；\n\t4. 如果同意的票数过半，那么直接成为 Leader；\n\t5. 如果拒绝的票数过半，那么直接成为 Follower\n8. case pb.MessageType_MsgSnapshot:\n\t1. Project2C 中才会实现，所以该 Msg 在 Project2C 处\n\t\n9. case pb.MessageType_MsgHeartbeat:\n\t1. 发送：\n\t\t1. 每当 Leader 的 heartbeatTimeout 达到时，就会给其余所有节点发送 MsgHeartbeat；\n\t2. 接收与处理：\n\t\t1. 判断 Msg 的 Term 是否大于等于自己的 Term，是则更新，否则拒绝；\n\t\t2. 重置选举计时 r.electionElapsed\n\t\t3. 发送 MsgHeartbeatResponse\n\t\t4. Commit:  min(r.RaftLog.committed, r.Prs[to].Match), 确保了心跳消息中的 Commit 字段不会超过已经在目标节点上提交的日志索引，使得心跳消息不需要推进 Commit。\n\t\n10. case pb.MessageType_MsgHeartbeatResponse:\n\t1. 发送：\n\t\t1. 当节点收到 MsgHeartbeat 时，会相应的回复 MsgHeartbeatResponse；\n\t2. 接收与处理：\n\t\t1. 只有 Leader 会处理 MsgHeartbeatResponse，其余角色直接忽略；\n\t\t2. 通过 m.Commit 判断节点是否落后了，如果是，则进行日志追加；\n\t\n11. case pb.MessageType_MsgTransferLeader:\n\t1. 用于上层请求转移 Leader，Project3 使用。\n\t\t\t\n12. case pb.MessageType_MsgTimeoutNow:\n\t1. 节点收到后清空 r.electionElapsed，并即刻发起选举\n\n#### 消息使用的字段\n\n| MessageType\\msg_nr  | MsgType | To  | From | Term | LogTerm | Index | Entries | Commit | Snapshot | Reject |\n| ------------------- | ------- | --- | ---- | ---- | ------- | ----- | ------- | ------ | -------- | ------ |\n| Hup                 | √       |     |      |      |         |       |         |        |          |        |\n| Beat                | √       |     |      |      |         |       |         |        |          |        |\n| Propose             | √       | √   |      |      |         |       | √       |        |          |        |\n| RequestVote         | √       | √   | √    | √    | √       | √     |         |        |          |        |\n| requestVoteResponse | √       | √   | √    | √    | 。       | 。     |         |        |          | √      |\n| Heartbeat           | √       | √   | √    | √    |         |       |         | √      |          |        |\n| HeartbeatResponse   | √       | √   | √    | √    |         |       |         |        |          |        |\n| Append              | √       | √   | √    | √    | √       | √     | √       | √      |          |        |\n| AppendResponse      | √       | √   | √    | √    |         | √     |         |        |          | √      |\n| Snapshot            | √       | √   | √    | √    |         |       |         | √      | √        |        |\n| TransferLeader      | √       | √   | √    |      |         |       |         |        |          |        |\n| TimeoutNow          | √       | √   | √    |      |         |       |         |        |          |        |\n注意点：\n1. Hup 和 Beat 一定是本地消息，而 Propose 不一定是本地消息，可能是外部构造的不再 Raft 内部调用 Step 处理，所以：From 不使用但是 To 需要使用。\n2. TimeoutNow 也是 本地消息，即刻发起选举。\n3. 对于 MessageType_MsgAppend：\n\t1. LogTerm 为要发送的条目的前一个条目的 Term，即论文中的 prevLogTerm\n\t2. Index 为要发送的条目的前一个条目的 Index，即论文中的 prevLogIndex\n\t3. 当前节点 (Leader) 的 committedIndex\n4. 对于 MessageType_MsgAppendResponse：\n\t1. Index：r.RaftLog.LastIndex()；该字段用于 Leader 更快地去更新 next\n5. Reject 两个功能，一个 投票一个 在 append\n\t不同的是，propose 的 entry 无论是不是一个空的，都会被当成一个新的 entry 进行添加，而 Appen 的 entry，则可能被拒绝或者截取部分。\n\n#### 推进器 Step()\nStep() 作为驱动器，用来接收上层发来的 Msg，然后根据不同的角色和不同的 MsgType 进行不同的处理。\n#### 计时器 tick()\n该函数起到计时器的作用，即逻辑时钟。每调用一次，就要增加节点的心跳计时（ r.electionElapsed），如果是 Leader，就要增加自己的选举计时（ r.heartbeatElapsed），然后，应按照角色进行对应的操作。\n\n#### log.go\n\n#### 关键点｜易错点\n1. raft 的 id 是从 0 开始的，但是 0 是无效 id ：const RaftInvalidIndex uint64 = 0\n2. entry 的 index 指的是 在 storage 中的 索引，而不是在数组中的下标。\n\t下标计算： index - entries\\[0\\].Index\n3. 注意每一个 entry 都有一个自己的 **term**\n4. Leader 不会自己发起一个新的选举。\n5. 注意变成 Candidate 后发现，只有一个节点，再直接变成 Leader。\n6. 注意某一个消息处理时如果遍历 Prs 且跳过了当前节点的 id ，需要额外考虑一下集群只有一个节点的情况。\n7. becomeCandidate 和 发送 请求 投票要分开进行\n8. allEntries() 描述中需要排除 排除虚拟条目，但是实际上，\n\t// if ent.Data != nil { // 如果 这里的 ent 的 Data 是空的,说明 entry 无效\n\t// }\n\t不需要排除，这个是在 测试中确定的。\n9. handleRequestVoteResponse  除了统计同意的个数，还需要统计 拒绝的个数。\n#### TODO\n**随机选举时间问题**\n\n- 如果 et 太小，会过早开始选举，导致 term 比测试预期大。如果太大，会很晚发生选举，导致 term 比测试预期小。而且如果按照etcd那样一直递增，最后时间会非常长，直接卡住。我最后把它限制在 10~20 之间，通过测试。\n\n**leader 更新 committed 之后要告知 follower**\n\n- eader 收到 appendResp 后，会相应的更新自己的 committed，但是更新之后一定要把更新结果告知`全部` follower，即另外发送一个 appendResp 。如果不这样的话，最后一轮完成后，集群的 committed 会不同步。并且为了防止死循环，leader 只能在 committed 发生变化的时候去通知 follower。\n\n**测试要求 msg 是nil，而不是空切片**\n\n- TestRawNodeRestartFromSnapshot2C 中，want 里的 msg 为 nil，即测试点预期 newRaft 处的 msg 应该为 nil，而不是 make 一个空切片。\n\n### Project 2 AB\n空空如也\n### Project 2 AC\n#### RawNode 部分整体工作流程\n``` go\nfor {\n  select {\n  case <-s.Ticker:\n    Node.Tick()\n  default:\n    if Node.HasReady() {\n      rd := Node.Ready()\n      saveToStorage(rd.State, rd.Entries, rd.Snapshot)\n      send(rd.Messages)\n      for _, entry := range rd.CommittedEntries {\n        process(entry)\n      }\n      s.Node.Advance(rd)\n    }\n}\n```\n代码解释：\n1. RawNode 是 Raft 的包装器，上层 ( peer 层) 会不停的调用 RawNode 的 tick() 函数，进一步触发 Raft 的 tick() 函数。 \n2. 上层会定时从 RawNode 获取 Ready，首先上层通过 HasReady() 进行判断，如果有新的 Ready，上层会调用RawNode 的Ready()方法进行获取，RawNode 从 Raft 中 获取信息生成相应的 Ready 返回给上层应用，Raft 的信息则是存储在 RaftLog 之中。上层应用处理完 Ready 后，会调用 RawNode 的Advance() 方法进行推进，告诉 RawNode 之前的 Ready 已经被处理完成，然后你可以执行一些操作，比如修改 applied，stabled 等信息。 \n3. 上层应用可以直接调用 RawNode 提供的 Propose(data []byte) ，Step(m pb.Message) 等方法，RawNode 会将这些请求统一包装成 Message，通过 Raft 提供的 Step(m pb.Message) 输入信息。\n\n#### HasReady()\nRawNode 通过 HasReady() 来判断 Raft 模块是否已经有同步完成并且需要上层处理的信息，包括：\n- 是否有需要持久化的状态；\n- 是否有需要持久化的条目；\n- 是否有需要应用的快照；\n- 是否有需要应用的条目；\n- 是否有需要发送的 Msg\n\n其中，最后一点的 Msg，就是 Raft 模块中节点间相互发送的 Msg。也就是说，节点间发送的 Msg 是通过 RawNode 先发送给上层，然后上层在将其发送给对应节点的。\n\n如果 HasReady() 返回 true，那么上层就会调用 Ready() 来获取具体要做的事情，和上述 HasReady() 的判断一一对应。该方法直接调用 rn.newReady() 生成一个 Ready() 结构体然后返回即可。\n#### Advance()\n当上层处理完 Ready 后，调用 Advance() 来推进整个状态机。Advance() 的实现就按照 Ready 结构体一点点更改 RawNode 的状态即可，包括：\n\n- prevHardSt 变更；\n- stabled 指针变更；\n- applied 指针变更；\n- 清空 rn.Raft.msgs；\n- 丢弃被压缩的暂存日志；\n- 清空 pendingSnapshot；\n\n#### 思考&总结\n1. RawNode 是 Raft 的封装，保存 Raft 的一部分状态\n### Project 2A  总结&思考\n#### 一些思考\n> 对于某个 Raft 变为 Candidate 提出选举，是当场给自己投一票 还是 同样构造一个 msg 发给自己处理？从 term 的角度思考。\n\t1. 假设发消息。可能导致当前 Raft 先收到其他 Raft 的投票请求，从而自己没有给自己投票。\n\t2. 因此当场给自己投一票。这样也减少了自己和自己的发消息多余操作。\n\t\n> 如果当前的 Raft 就是自己本身，开始一个新的选举之后  term 要增加吗？\n\t增加。\n\n\n> 如果超时，是先增加  term 还是先发送 MsgHup 消息？\n\t先增加 term。如果先发送消息，那么在消息队列中，这个消息前面的消息会认为这个 Raft 还是没有超时（实际上已经超时了）\n\n> 先发心跳包等到响应再增加 Elapsed 还是 先增加？\n\t先增加。万一响应收不到了，Elapsed 还是要增加的。\n\n> Message 中 Commit 字段的作用？\n\t表示提交索引（commit index）。在 Raft 一致性算法中，每个节点都会维护一个提交索引。提交索引表示在该索引之前的所有日志条目都已经被安全地复制到了大多数节点，并且可以被应用到状态机中。换句话说，提交索引是已经达成共识并可以执行的日志条目的最高索引。\n\n> RaftLog 中 committed | applied | stabled 三个字段？\n\tcommitted：已知在多数节点上的稳定存储中的最高日志位置。\n\tapplied：已经应用到状态机的最大 log 位置\n\tstabled： 已经被持久化存储的最大 log 位置。\n\n> 持久化存储中到底要存储什么？\n\t1. \"Save log entries to stable storage\"（将日志条目保存到稳定存储）：在 Raft 中，每个节点会维护一个日志（log），其中包含按顺序记录的操作或状态变化。当节点接收到来自客户端的命令或其他节点的日志复制请求时，它将这些日志条目追加到自己的日志中。为了确保数据的持久性和可靠性，节点需要将这些日志条目保存到稳定存储介质（如磁盘）上，以便在节点重启或发生故障时能够恢复日志的状态。\n\t2. \"Save hard state like the term, commit index, and vote to stable storage\"（将任期、提交索引和投票信息等硬状态保存到稳定存储）：除了日志条目之外，Raft 还维护了一些重要的状态信息，称为硬状态。这些硬状态包括当前任期（term）、已提交的索引（commit index）和投票信息（如上一次投票的候选人ID等）。这些硬状态的变化需要被持久化保存，以确保在节点重启或发生故障时能够恢复到正确的状态。\n\n> MemoryStorage  中 ents\\[i\\] has raft log position i+snapshot.Metadata.Index 的含义？\n\t`ents[i]` 表示 Raft 日志中的第 `i` 个条目。该条目的 Raft 日志位置是通过 `i + snapshot.Metadata.Index` 来确定的。\n\t在 Raft 算法中，为了支持快照（snapshot）功能，可以将当前节点的状态和日志压缩成一个快照。快照包含了快照的元数据信息以及存储在快照中的状态和日志条目。\n\t在代码中的 `ents` 切片中，存储了一系列的日志条目。为了与快照中的日志条目对应起来，`ents[i]` 的 Raft 日志位置是通过 `i + snapshot.Metadata.Index` 计算得出的。\n\t具体来说，`snapshot.Metadata.Index` 表示快照元数据中的索引值，它指示了快照中第一个条目的索引。然后，对于 `ents` 切片中的第 `i` 个条目，其在 Raft 日志中的位置就是 `i + snapshot.Metadata.Index`。\n\t这样的计算方式可以确保在应用快照之后，`ents` 切片中的日志条目仍然与 Raft 日志中的对应位置保持一致。\n\t需要注意的是，`snapshot.Metadata.Index` 是快照元数据中的一个字段，用于表示快照中第一个条目的索引。在给出的代码中，`snapshot` 是一个 `Metadata` 类型的字段，可能是一个结构体或变量，用于存储快照的元数据信息。\n\t也就是说  0 号位置的 Index 就是 `snapshot.Metadata.Index`\n\n> RaftLog 中的 entries  和 Storage 中的 ents 有什么区别？\n\t1. entries 是 从下标 1 开始作为有效记录；ents 是从下表 0 开始作为有效记录。\n\t2. .ents\\[0\\].Index 始终是有效的，用来作为基础索引\n\n> RaftLog.storage.Snapshot() 和 RaftLog.pendingSnapshot 中的区别\n\t一个永久快照，一个临时快照。\n\n\n> 心跳 heatbeat 时间和选举 election 时间的关系\n\t1. heatbeat 只有 Leader 发送；election 时间是非 leader  需要维护的信息，以便即使开始一个选举。\n\n> 收到陌生 Raft 的信息，该怎么处理？\n\t1. 可能是一个新的节点，需要添加到已有结构中。\n\t2. 什么情况下添加？\n\t\t1. 首先只有这个新的 Raft 发送消息时才能被旧 Raft 知道，但是陌生 Raft 的工作消息直接处理可能会出问题，所以应该使用 heatbeat 作为新 Raft 的识别消息（谁收到了这个消息谁添加节点）。那么：\n\t\t2. 选举过程：\n\t\t\t1. Candidate 收到 heatbeat：多一个投票人，不会导致选举失败 。\n\t\t\t2. 其他角色 收到 heatbeat：更不会影响选举。\n\t\t3. 工作过程：\n\t\t\t1. Leader 收到 heatbeat：多一个工作者，不会导致工作错误 。\n\t\t\t2. 其他角色 收到 heatbeat：更不会影响工作（因为不会给 这个 Raft 发送工作消息）。\n\t3. 总结：任何情况下，收到 新 Raft 的 heatbeat 时，可将其添加到当前 Raft 的记录中（最好同时向这个新 Raft 同步一下当前系统的情况）。\n\n\n\nsendAppendResponse 不需要 回复 ----嘛嘛嘛？？？？？？？\n\n\n#### 总结一下 commmit|applied|stable 的修改时机\n\n//\tsnapshot/first.....applied....committed....stabled.....last\n//\t--------|------------------------------------------------|\n//\t                          log entries\n#### RaftLog.committed 修改时机总结\n1. 在  newRaft() 中调用 newLog() 时被初始化为 storage 中 hardState 的 Commit\n2. Leader 在 发送 MessageType_MsgAppend 时发送当前 commited\n3. Raft 在收到 MessageType_MsgAppend 并更新 RaftLog.entries 之后，将 commited 置为以下两者的最小值\n\t1. Leader 的 committed： m.Commit\n\t2. Leader 以为的 此 Raft 的 Committed：m.Index+uint64(len(m.Entries))\n4. Leader 在收到 AppendEntriesResponse 之后 将自己的 commited 置为 当前 Term 的Entry 被大多数 Peers 中 都 Match 的最小 Index。\n5. Leader 在 发送 MessageType_MsgHeartbeat 时发送 min(r.RaftLog.committed, r.Prs[to].Match) （确保心跳消息中的 Commit 字段不会超过已经和目标j节点同步的日志索引，从而使得心跳消息不会推进 committed ）\n6. Raft 收到 Lead 的  MessageType_MsgHeartbeat 之后，如果发现 m.Commit（Leader 认为的提交） >= r.RaftLog.committed （Raft 自认为的提交），说明当前 Raft 的 RaftLog.entries 中有一部分 Leader 认为还未提交（需要被覆盖）。修改 committed 值为\n\tmin(m.Commit, r.RaftLog.LastIndex())\n#### RaftLog.applied 修改时机总结\n1. 在  newRaft() 中调用 newLog() 时被初始化为 storage 中 的 ent[0].Index 或者 初始化为 0，表示初始没有被 applied 的 entry。\n2. 在 Advance() 中第一次修改。\n\n#### RaftLog.stabled 修改时机总结\n1. 在  newRaft() 中调用 newLog() 时被初始化为 storage 中 ent 最后一个 entry 的 Index。\n2. r.RaftLog.stabled = m.Index\n3. rn.Raft.RaftLog.stabled = rd.Entries[len(rd.Entries)-1].Index\n\n\n\n\n#### r.Prs 的 Match & Next\n1. 收到 Propose 时 if lastIndex == 0 Propose\n\n\n## Project 2B\n### Project 2B 整体流程\nProject2B 实现了 rawNode 之上的上层应用，即真正开始多线程集群操作，引入了 peer 和 region 的概念。同时，除了实现上层的调用，Project2B 还需要通过调用 RaftStorage 中的接口真正实现写落盘。 store、peer、region 三者的关系如下：\n![[Pasted image 20240420190155.png]]\n1. Store：每一个节点叫做一个 store，也就是一个节点上面只有一个 Store。代码里面叫 RaftStore，后面统一使用 RaftStore 代称。 \n2. Peer：一个 RaftStore 里面会包含多个 peer，一个 RaftStore 里面的所有 peer 公用同一个底层存储，也就是多个 peer 公用同一个 badger 实例。 \n3. Region：一个 Region 叫做一个 Raft group，即同属一个 raft 集群，一个 region 包含多个 peer，这些 peer 散落在不同的 RaftStore 上。\n\n\n这里将 Rawnode-Raft-RaftLog 统称为 raft 层，把要实现的部分称为 peer 层。peer 层首先接收来自 client 的 RaftCmdRequest，其中包含着不同的`命令请求`，接着它会把这些请求逐一以 entry 的形式传递给 raft 层，当然，这个 peer 应该是 Leader，不然 client 会找下一个 peer 继续试。raft 层收到条目后，会在集群内部进行同步，这就是 project2a 的内容。同步的过程中，peer 层会不时询问 raft 层有哪些已经同步好的 entry 可以拿来应用（执行）？哪些 entry 需要持久化？有没有快照需要应用？等等。三层的交互如下图所示：\n![[Pasted image 20240421125735.png]]\n此模块要完善两个文件，分别为 `peer_msg_handler.go` 和 `peer_storage.go`\n\n\n\nhttps://github.com/sakura-ysy/TinyKV-2022-doc/blob/main/doc/project2.md?spm=a2c6h.13046898.publish-article.80.37936ffauECnFr&file=project2.md\n\n\n\n### TODO\ntype peer struct 中为什么// Instance of the Raft module\n    是 RaftGroup \\*raft.RawNode  \n一个 region 包含多个 peer 怎么理解\n\n\n\n\n\n\n\n## Project 2C\nProject 2C 整体流程\n\n\n\n### RawNode 中 hardState  和 \n\n# Project 3\nhttps://www.inlighting.org/archives/tinykv-project3\n\n\n# 技巧\n## 日志输出\n```go\nlog.Infof(\"Raft init with config={len(peers)=%d}, \"+\n        \"peerid=%d, log commitid=%d, applied=%d, stabled=%d\",\n        len(c.peers),\n        rsp.id, rsp.RaftLog.committed, rsp.RaftLog.applied, rsp.RaftLog.stabled)\n        \nlog.Fatal(err)\n\nlog.Infof(\"peerid = %d becomes leader\", r.id)\n```\n# 总结\n\n\n\n## TODO\n\n// TODO 这里的 stabled 在 newlog 的时候赋值过一次，应该不会是 0 ，为什么会判断一次stabled\n    if l.stabled == 0 {\n        return l.entries\n        // log.Infof(\"stabled = %d\", l.stabled)\n    }\n \n// TODO 什么时候 修改 committed \n> sendAppend 时没有修改\n> handle AppendEntriesRespinse 时修改了。\nhttps://github.com/LX-676655103/Tinykv-2021/blob/course/raft/log.go\n\n\n// TODO 怎么处理 新 leader 中未 commit 的部分\n？从当前的逻辑来看，只有 当前 term 也产生 log 时 才会顺便更新前面的log\n\n\n// TODO 第一次收到 Lead 的消息时，需要进怎么样的处理\n\n// TODO noop Entry 会发送吗，\n\n// TODO r.Prs[r.id].Match 是  handlePropose 时修改。\n\n\nTODO  搞清楚  Next 和 Match 之间的关系。\nTODO 快照的同步逻辑\n# 参考\n\nhttps://github.com/LX-676655103/Tinykv-2021/blob/course/raft/raft.go#L967\nhttps://github.com/sakura-ysy/TinyKV-2022-doc/\n\n\nhttps://chenyunong.com/2021/08/04/TinyKV-Project2/\nhttps://www.inlighting.org/archives/tinykv-project2","source":"_posts/项目经历/TinyKV/TinyKV 项目日志.md","raw":"\n# Project 1\n# Project 2\n## Project 2 整体架构\n\n## Project 2A\n### Project 2A 整体架构\n本部分实现基础的 Raft 算法，且不需要考虑快照操作。我们共需要实现三个模块，分别为 RawNode、Raft 和 RaftLog，分别对应文件 `rawnode.go`、`raft.go` 和 `log.go` ，这三个模块，共同构成一层，我将其称为 `raft 层`。结构图如下\n![[image2.png]]\n- **RawNode**：该模块用来接收上层传来的信息，将信息下传给 Raft 模块。比如，上层传递一个 Msg 给 RawNode，这个 Msg 可能是 心跳请求、日志提交请求、日志追加请求等等。然后 RawNode 收到这个 Msg 之后，将其交给 Raft 模块去处理。比如，上层交给 RawNode 一个日志提交请求，然后 RawNode 将其交给 Raft ，如果该节点是领导人，那么其就会追加这条日志，然后发送给其他节点进行同步。另外，RawNode 不仅用来接受请求然后传递给 Raft，还要用来收到 Raft 的同步结果然后传递给上层。RawNode 要负责检查 Raft 模块是否已有同步好的日志需要应用、是否有 Msg 需要发送、是否有日志需要持久化等等，然后把这些信息（Ready）交给上层，上层会据此进行处理。总的来说，RawNode 是 raft 层暴露给上层的一个模块，用来进行信息的传递。\n- **Raft**：整个 raft 层最关键的就是它，它就是实现 Raft 算法的核心模块。其中，领导人选举、日志追加、角色转换等等均是在这里实现。Raft 模块会接受 RawNode 发来的信息，然后在进群中进行相关的同步操作，同步结果不需要主动返回给 RawNode，因为 RawNode 自己会进行检查。\n- **RaftLog**：该模块用来暂存节点的日志条目，同时还要维护一些日志指针，如 committed、applied 等等。\n\n总结一下，RawNode 是 raft 层中暴露在外面的模块，用于该层与上层的信息交互，Raft 模块是 raft 层中的核心模块，算法的核心逻辑均在该模块实现，RaftLog 用来暂存日志信息，并维护相关指针。\n### Project 2 AA｜Project 2 AB\n#### 消息类型以及基本逻辑\n1. case pb.MessageType_MsgHup:\n\t1. 选举的本地消息，由 Tick() 触发。\n\t2. 如果发生选举超时，节点应将“MessageType_MsgHup”传递给其 Step 方法并开始新的选举，向其他所有节点发送 MsgRequestVote；\n\t3. 一旦收到了这个消息，说明就是要重新开始一次选举。\n\t\n2. case pb.MessageType_MsgBeat:\n\t1. 本地心跳信息。表示当前节点的时钟前进，判断心跳超时和选举超时并进行相应的处理。\n\t2. 注意只有 Leader 需要处理这个消息。\n\t\n3. case pb.MessageType_MsgPropose:\n\t1. 注意只有 Leader 会处理这个消息。 \n\t2. Leader 收到此消息需要将日志广播给其他节点。\n\t\t1. 发送时，如果要发送的 Index 已经被压缩了，转为发送快照。\n\t\t2. 否则发送 MsgAppend。\n\t\t3. 如果 MsgAppend 被接收者拒绝，Leader 会调整 next，重新进行前置判断，如果无需发快照，则按照新的 next 重新发送 MsgAppend。\n\t3. 发送方：由 Raft 层的上层构造此 msg 表示一次追加日志。此外，becomeLeader 时也会发送一个空 Entry 的 propose（也会被 广播）。\n\t\n4. case pb.MessageType_MsgAppend:\n\t1. 发送方：如上，一般 propose 之后触发，由 Leader 发送给其他节点来同步日志条目。\n\t2. 接收方：\n\t\t1. 判断 Msg 的 Term 是否大于等于自己的 Term，是则更新，否则拒绝；\n\t\t2. 拒绝，如果 prevLogIndex > r.RaftLog.LastIndex() 说明中间有日志缺失。否则往下；\n\t\t3. 拒绝，如果接收者日志中没有包含这样一个条目：即该条目的 Term 在 prevLogIndex 上不能和 prevLogTerm 匹配上。否则往下；\n\t\t4. 追加新条目，同时删除冲突条目，冲突条目的判别方式和论文中的一致；\n\t\t5. 当前节点更新 committedIndex 时，要比较 Leader 已知已经提交的最高的日志条目的索引 m.Commit 或者是上一个新条目的索引，然后取两者的最小值。为\n\t\t6. 接受；\n\t\n5. case pb.MessageType_MsgAppendResponse:\n\t1. 只有 Leader 会处理该 Msg，其余角色直接忽略；\n\t2. 如果被 reject 了，那么重置 next。重置规则为将旧的 next --，然后比较 m.Index + 1，最后取小的那个赋值给 next，然后重新进行日志 / 快照追加；\n\t3. 如果没有 reject，则更新 match 和 next。next 赋值为 m.Index + 1，match 赋值为 next - 1 ；\n\t4. 按照论文的思路更新 commit。假设存在 N 满足N > commitIndex，使得大多数的 matchIndex[i] ≥ N以及log[N].term == currentTerm 成立，则令 commitIndex = N。为了快速更新，这里先将节点按照 match 进行了递增排序，这样就可以快速确定 N 的位置。\n\n6. case pb.MessageType_MsgRequestVote:\n\t1. 判断 Msg 的 Term 是否大于等于自己的 Term，是则更新，否则拒绝；\n\t2. 如果 votedFor 不为空或者不等于 candidateID，则说明该节点以及投过票了，直接拒绝。否则往下；\n\t3. Candidate 的日志至少和自己一样新，那么就给其投票，否者拒绝。新旧判断逻辑如下：\n\t    - 如果两份日志最后的条目的任期号不同，那么任期号大的日志更加新\n\t    - 如果两份日志最后的条目任期号相同，那么日志比较长的那个就更加新；\n\tCandidate 会通过 r.votes 记录下都有哪些节点同意哪些节点拒绝，当同意的票数过半时，即可成为 Leader，当拒绝的票数过半时，则转变为 Follower。\n\t\t\n7. case pb.MessageType_MsgRequestVoteResponse:\n\t1. 只有 Candidate 会处理该 Msg，其余节点收到后直接忽略；\n\t2. 根据 m.Reject 更新 r.votes[m.From]，即记录投票结果；\n\t3. 算出同意的票数 agrNum 和拒绝的票数 denNum；\n\t4. 如果同意的票数过半，那么直接成为 Leader；\n\t5. 如果拒绝的票数过半，那么直接成为 Follower\n8. case pb.MessageType_MsgSnapshot:\n\t1. Project2C 中才会实现，所以该 Msg 在 Project2C 处\n\t\n9. case pb.MessageType_MsgHeartbeat:\n\t1. 发送：\n\t\t1. 每当 Leader 的 heartbeatTimeout 达到时，就会给其余所有节点发送 MsgHeartbeat；\n\t2. 接收与处理：\n\t\t1. 判断 Msg 的 Term 是否大于等于自己的 Term，是则更新，否则拒绝；\n\t\t2. 重置选举计时 r.electionElapsed\n\t\t3. 发送 MsgHeartbeatResponse\n\t\t4. Commit:  min(r.RaftLog.committed, r.Prs[to].Match), 确保了心跳消息中的 Commit 字段不会超过已经在目标节点上提交的日志索引，使得心跳消息不需要推进 Commit。\n\t\n10. case pb.MessageType_MsgHeartbeatResponse:\n\t1. 发送：\n\t\t1. 当节点收到 MsgHeartbeat 时，会相应的回复 MsgHeartbeatResponse；\n\t2. 接收与处理：\n\t\t1. 只有 Leader 会处理 MsgHeartbeatResponse，其余角色直接忽略；\n\t\t2. 通过 m.Commit 判断节点是否落后了，如果是，则进行日志追加；\n\t\n11. case pb.MessageType_MsgTransferLeader:\n\t1. 用于上层请求转移 Leader，Project3 使用。\n\t\t\t\n12. case pb.MessageType_MsgTimeoutNow:\n\t1. 节点收到后清空 r.electionElapsed，并即刻发起选举\n\n#### 消息使用的字段\n\n| MessageType\\msg_nr  | MsgType | To  | From | Term | LogTerm | Index | Entries | Commit | Snapshot | Reject |\n| ------------------- | ------- | --- | ---- | ---- | ------- | ----- | ------- | ------ | -------- | ------ |\n| Hup                 | √       |     |      |      |         |       |         |        |          |        |\n| Beat                | √       |     |      |      |         |       |         |        |          |        |\n| Propose             | √       | √   |      |      |         |       | √       |        |          |        |\n| RequestVote         | √       | √   | √    | √    | √       | √     |         |        |          |        |\n| requestVoteResponse | √       | √   | √    | √    | 。       | 。     |         |        |          | √      |\n| Heartbeat           | √       | √   | √    | √    |         |       |         | √      |          |        |\n| HeartbeatResponse   | √       | √   | √    | √    |         |       |         |        |          |        |\n| Append              | √       | √   | √    | √    | √       | √     | √       | √      |          |        |\n| AppendResponse      | √       | √   | √    | √    |         | √     |         |        |          | √      |\n| Snapshot            | √       | √   | √    | √    |         |       |         | √      | √        |        |\n| TransferLeader      | √       | √   | √    |      |         |       |         |        |          |        |\n| TimeoutNow          | √       | √   | √    |      |         |       |         |        |          |        |\n注意点：\n1. Hup 和 Beat 一定是本地消息，而 Propose 不一定是本地消息，可能是外部构造的不再 Raft 内部调用 Step 处理，所以：From 不使用但是 To 需要使用。\n2. TimeoutNow 也是 本地消息，即刻发起选举。\n3. 对于 MessageType_MsgAppend：\n\t1. LogTerm 为要发送的条目的前一个条目的 Term，即论文中的 prevLogTerm\n\t2. Index 为要发送的条目的前一个条目的 Index，即论文中的 prevLogIndex\n\t3. 当前节点 (Leader) 的 committedIndex\n4. 对于 MessageType_MsgAppendResponse：\n\t1. Index：r.RaftLog.LastIndex()；该字段用于 Leader 更快地去更新 next\n5. Reject 两个功能，一个 投票一个 在 append\n\t不同的是，propose 的 entry 无论是不是一个空的，都会被当成一个新的 entry 进行添加，而 Appen 的 entry，则可能被拒绝或者截取部分。\n\n#### 推进器 Step()\nStep() 作为驱动器，用来接收上层发来的 Msg，然后根据不同的角色和不同的 MsgType 进行不同的处理。\n#### 计时器 tick()\n该函数起到计时器的作用，即逻辑时钟。每调用一次，就要增加节点的心跳计时（ r.electionElapsed），如果是 Leader，就要增加自己的选举计时（ r.heartbeatElapsed），然后，应按照角色进行对应的操作。\n\n#### log.go\n\n#### 关键点｜易错点\n1. raft 的 id 是从 0 开始的，但是 0 是无效 id ：const RaftInvalidIndex uint64 = 0\n2. entry 的 index 指的是 在 storage 中的 索引，而不是在数组中的下标。\n\t下标计算： index - entries\\[0\\].Index\n3. 注意每一个 entry 都有一个自己的 **term**\n4. Leader 不会自己发起一个新的选举。\n5. 注意变成 Candidate 后发现，只有一个节点，再直接变成 Leader。\n6. 注意某一个消息处理时如果遍历 Prs 且跳过了当前节点的 id ，需要额外考虑一下集群只有一个节点的情况。\n7. becomeCandidate 和 发送 请求 投票要分开进行\n8. allEntries() 描述中需要排除 排除虚拟条目，但是实际上，\n\t// if ent.Data != nil { // 如果 这里的 ent 的 Data 是空的,说明 entry 无效\n\t// }\n\t不需要排除，这个是在 测试中确定的。\n9. handleRequestVoteResponse  除了统计同意的个数，还需要统计 拒绝的个数。\n#### TODO\n**随机选举时间问题**\n\n- 如果 et 太小，会过早开始选举，导致 term 比测试预期大。如果太大，会很晚发生选举，导致 term 比测试预期小。而且如果按照etcd那样一直递增，最后时间会非常长，直接卡住。我最后把它限制在 10~20 之间，通过测试。\n\n**leader 更新 committed 之后要告知 follower**\n\n- eader 收到 appendResp 后，会相应的更新自己的 committed，但是更新之后一定要把更新结果告知`全部` follower，即另外发送一个 appendResp 。如果不这样的话，最后一轮完成后，集群的 committed 会不同步。并且为了防止死循环，leader 只能在 committed 发生变化的时候去通知 follower。\n\n**测试要求 msg 是nil，而不是空切片**\n\n- TestRawNodeRestartFromSnapshot2C 中，want 里的 msg 为 nil，即测试点预期 newRaft 处的 msg 应该为 nil，而不是 make 一个空切片。\n\n### Project 2 AB\n空空如也\n### Project 2 AC\n#### RawNode 部分整体工作流程\n``` go\nfor {\n  select {\n  case <-s.Ticker:\n    Node.Tick()\n  default:\n    if Node.HasReady() {\n      rd := Node.Ready()\n      saveToStorage(rd.State, rd.Entries, rd.Snapshot)\n      send(rd.Messages)\n      for _, entry := range rd.CommittedEntries {\n        process(entry)\n      }\n      s.Node.Advance(rd)\n    }\n}\n```\n代码解释：\n1. RawNode 是 Raft 的包装器，上层 ( peer 层) 会不停的调用 RawNode 的 tick() 函数，进一步触发 Raft 的 tick() 函数。 \n2. 上层会定时从 RawNode 获取 Ready，首先上层通过 HasReady() 进行判断，如果有新的 Ready，上层会调用RawNode 的Ready()方法进行获取，RawNode 从 Raft 中 获取信息生成相应的 Ready 返回给上层应用，Raft 的信息则是存储在 RaftLog 之中。上层应用处理完 Ready 后，会调用 RawNode 的Advance() 方法进行推进，告诉 RawNode 之前的 Ready 已经被处理完成，然后你可以执行一些操作，比如修改 applied，stabled 等信息。 \n3. 上层应用可以直接调用 RawNode 提供的 Propose(data []byte) ，Step(m pb.Message) 等方法，RawNode 会将这些请求统一包装成 Message，通过 Raft 提供的 Step(m pb.Message) 输入信息。\n\n#### HasReady()\nRawNode 通过 HasReady() 来判断 Raft 模块是否已经有同步完成并且需要上层处理的信息，包括：\n- 是否有需要持久化的状态；\n- 是否有需要持久化的条目；\n- 是否有需要应用的快照；\n- 是否有需要应用的条目；\n- 是否有需要发送的 Msg\n\n其中，最后一点的 Msg，就是 Raft 模块中节点间相互发送的 Msg。也就是说，节点间发送的 Msg 是通过 RawNode 先发送给上层，然后上层在将其发送给对应节点的。\n\n如果 HasReady() 返回 true，那么上层就会调用 Ready() 来获取具体要做的事情，和上述 HasReady() 的判断一一对应。该方法直接调用 rn.newReady() 生成一个 Ready() 结构体然后返回即可。\n#### Advance()\n当上层处理完 Ready 后，调用 Advance() 来推进整个状态机。Advance() 的实现就按照 Ready 结构体一点点更改 RawNode 的状态即可，包括：\n\n- prevHardSt 变更；\n- stabled 指针变更；\n- applied 指针变更；\n- 清空 rn.Raft.msgs；\n- 丢弃被压缩的暂存日志；\n- 清空 pendingSnapshot；\n\n#### 思考&总结\n1. RawNode 是 Raft 的封装，保存 Raft 的一部分状态\n### Project 2A  总结&思考\n#### 一些思考\n> 对于某个 Raft 变为 Candidate 提出选举，是当场给自己投一票 还是 同样构造一个 msg 发给自己处理？从 term 的角度思考。\n\t1. 假设发消息。可能导致当前 Raft 先收到其他 Raft 的投票请求，从而自己没有给自己投票。\n\t2. 因此当场给自己投一票。这样也减少了自己和自己的发消息多余操作。\n\t\n> 如果当前的 Raft 就是自己本身，开始一个新的选举之后  term 要增加吗？\n\t增加。\n\n\n> 如果超时，是先增加  term 还是先发送 MsgHup 消息？\n\t先增加 term。如果先发送消息，那么在消息队列中，这个消息前面的消息会认为这个 Raft 还是没有超时（实际上已经超时了）\n\n> 先发心跳包等到响应再增加 Elapsed 还是 先增加？\n\t先增加。万一响应收不到了，Elapsed 还是要增加的。\n\n> Message 中 Commit 字段的作用？\n\t表示提交索引（commit index）。在 Raft 一致性算法中，每个节点都会维护一个提交索引。提交索引表示在该索引之前的所有日志条目都已经被安全地复制到了大多数节点，并且可以被应用到状态机中。换句话说，提交索引是已经达成共识并可以执行的日志条目的最高索引。\n\n> RaftLog 中 committed | applied | stabled 三个字段？\n\tcommitted：已知在多数节点上的稳定存储中的最高日志位置。\n\tapplied：已经应用到状态机的最大 log 位置\n\tstabled： 已经被持久化存储的最大 log 位置。\n\n> 持久化存储中到底要存储什么？\n\t1. \"Save log entries to stable storage\"（将日志条目保存到稳定存储）：在 Raft 中，每个节点会维护一个日志（log），其中包含按顺序记录的操作或状态变化。当节点接收到来自客户端的命令或其他节点的日志复制请求时，它将这些日志条目追加到自己的日志中。为了确保数据的持久性和可靠性，节点需要将这些日志条目保存到稳定存储介质（如磁盘）上，以便在节点重启或发生故障时能够恢复日志的状态。\n\t2. \"Save hard state like the term, commit index, and vote to stable storage\"（将任期、提交索引和投票信息等硬状态保存到稳定存储）：除了日志条目之外，Raft 还维护了一些重要的状态信息，称为硬状态。这些硬状态包括当前任期（term）、已提交的索引（commit index）和投票信息（如上一次投票的候选人ID等）。这些硬状态的变化需要被持久化保存，以确保在节点重启或发生故障时能够恢复到正确的状态。\n\n> MemoryStorage  中 ents\\[i\\] has raft log position i+snapshot.Metadata.Index 的含义？\n\t`ents[i]` 表示 Raft 日志中的第 `i` 个条目。该条目的 Raft 日志位置是通过 `i + snapshot.Metadata.Index` 来确定的。\n\t在 Raft 算法中，为了支持快照（snapshot）功能，可以将当前节点的状态和日志压缩成一个快照。快照包含了快照的元数据信息以及存储在快照中的状态和日志条目。\n\t在代码中的 `ents` 切片中，存储了一系列的日志条目。为了与快照中的日志条目对应起来，`ents[i]` 的 Raft 日志位置是通过 `i + snapshot.Metadata.Index` 计算得出的。\n\t具体来说，`snapshot.Metadata.Index` 表示快照元数据中的索引值，它指示了快照中第一个条目的索引。然后，对于 `ents` 切片中的第 `i` 个条目，其在 Raft 日志中的位置就是 `i + snapshot.Metadata.Index`。\n\t这样的计算方式可以确保在应用快照之后，`ents` 切片中的日志条目仍然与 Raft 日志中的对应位置保持一致。\n\t需要注意的是，`snapshot.Metadata.Index` 是快照元数据中的一个字段，用于表示快照中第一个条目的索引。在给出的代码中，`snapshot` 是一个 `Metadata` 类型的字段，可能是一个结构体或变量，用于存储快照的元数据信息。\n\t也就是说  0 号位置的 Index 就是 `snapshot.Metadata.Index`\n\n> RaftLog 中的 entries  和 Storage 中的 ents 有什么区别？\n\t1. entries 是 从下标 1 开始作为有效记录；ents 是从下表 0 开始作为有效记录。\n\t2. .ents\\[0\\].Index 始终是有效的，用来作为基础索引\n\n> RaftLog.storage.Snapshot() 和 RaftLog.pendingSnapshot 中的区别\n\t一个永久快照，一个临时快照。\n\n\n> 心跳 heatbeat 时间和选举 election 时间的关系\n\t1. heatbeat 只有 Leader 发送；election 时间是非 leader  需要维护的信息，以便即使开始一个选举。\n\n> 收到陌生 Raft 的信息，该怎么处理？\n\t1. 可能是一个新的节点，需要添加到已有结构中。\n\t2. 什么情况下添加？\n\t\t1. 首先只有这个新的 Raft 发送消息时才能被旧 Raft 知道，但是陌生 Raft 的工作消息直接处理可能会出问题，所以应该使用 heatbeat 作为新 Raft 的识别消息（谁收到了这个消息谁添加节点）。那么：\n\t\t2. 选举过程：\n\t\t\t1. Candidate 收到 heatbeat：多一个投票人，不会导致选举失败 。\n\t\t\t2. 其他角色 收到 heatbeat：更不会影响选举。\n\t\t3. 工作过程：\n\t\t\t1. Leader 收到 heatbeat：多一个工作者，不会导致工作错误 。\n\t\t\t2. 其他角色 收到 heatbeat：更不会影响工作（因为不会给 这个 Raft 发送工作消息）。\n\t3. 总结：任何情况下，收到 新 Raft 的 heatbeat 时，可将其添加到当前 Raft 的记录中（最好同时向这个新 Raft 同步一下当前系统的情况）。\n\n\n\nsendAppendResponse 不需要 回复 ----嘛嘛嘛？？？？？？？\n\n\n#### 总结一下 commmit|applied|stable 的修改时机\n\n//\tsnapshot/first.....applied....committed....stabled.....last\n//\t--------|------------------------------------------------|\n//\t                          log entries\n#### RaftLog.committed 修改时机总结\n1. 在  newRaft() 中调用 newLog() 时被初始化为 storage 中 hardState 的 Commit\n2. Leader 在 发送 MessageType_MsgAppend 时发送当前 commited\n3. Raft 在收到 MessageType_MsgAppend 并更新 RaftLog.entries 之后，将 commited 置为以下两者的最小值\n\t1. Leader 的 committed： m.Commit\n\t2. Leader 以为的 此 Raft 的 Committed：m.Index+uint64(len(m.Entries))\n4. Leader 在收到 AppendEntriesResponse 之后 将自己的 commited 置为 当前 Term 的Entry 被大多数 Peers 中 都 Match 的最小 Index。\n5. Leader 在 发送 MessageType_MsgHeartbeat 时发送 min(r.RaftLog.committed, r.Prs[to].Match) （确保心跳消息中的 Commit 字段不会超过已经和目标j节点同步的日志索引，从而使得心跳消息不会推进 committed ）\n6. Raft 收到 Lead 的  MessageType_MsgHeartbeat 之后，如果发现 m.Commit（Leader 认为的提交） >= r.RaftLog.committed （Raft 自认为的提交），说明当前 Raft 的 RaftLog.entries 中有一部分 Leader 认为还未提交（需要被覆盖）。修改 committed 值为\n\tmin(m.Commit, r.RaftLog.LastIndex())\n#### RaftLog.applied 修改时机总结\n1. 在  newRaft() 中调用 newLog() 时被初始化为 storage 中 的 ent[0].Index 或者 初始化为 0，表示初始没有被 applied 的 entry。\n2. 在 Advance() 中第一次修改。\n\n#### RaftLog.stabled 修改时机总结\n1. 在  newRaft() 中调用 newLog() 时被初始化为 storage 中 ent 最后一个 entry 的 Index。\n2. r.RaftLog.stabled = m.Index\n3. rn.Raft.RaftLog.stabled = rd.Entries[len(rd.Entries)-1].Index\n\n\n\n\n#### r.Prs 的 Match & Next\n1. 收到 Propose 时 if lastIndex == 0 Propose\n\n\n## Project 2B\n### Project 2B 整体流程\nProject2B 实现了 rawNode 之上的上层应用，即真正开始多线程集群操作，引入了 peer 和 region 的概念。同时，除了实现上层的调用，Project2B 还需要通过调用 RaftStorage 中的接口真正实现写落盘。 store、peer、region 三者的关系如下：\n![[Pasted image 20240420190155.png]]\n1. Store：每一个节点叫做一个 store，也就是一个节点上面只有一个 Store。代码里面叫 RaftStore，后面统一使用 RaftStore 代称。 \n2. Peer：一个 RaftStore 里面会包含多个 peer，一个 RaftStore 里面的所有 peer 公用同一个底层存储，也就是多个 peer 公用同一个 badger 实例。 \n3. Region：一个 Region 叫做一个 Raft group，即同属一个 raft 集群，一个 region 包含多个 peer，这些 peer 散落在不同的 RaftStore 上。\n\n\n这里将 Rawnode-Raft-RaftLog 统称为 raft 层，把要实现的部分称为 peer 层。peer 层首先接收来自 client 的 RaftCmdRequest，其中包含着不同的`命令请求`，接着它会把这些请求逐一以 entry 的形式传递给 raft 层，当然，这个 peer 应该是 Leader，不然 client 会找下一个 peer 继续试。raft 层收到条目后，会在集群内部进行同步，这就是 project2a 的内容。同步的过程中，peer 层会不时询问 raft 层有哪些已经同步好的 entry 可以拿来应用（执行）？哪些 entry 需要持久化？有没有快照需要应用？等等。三层的交互如下图所示：\n![[Pasted image 20240421125735.png]]\n此模块要完善两个文件，分别为 `peer_msg_handler.go` 和 `peer_storage.go`\n\n\n\nhttps://github.com/sakura-ysy/TinyKV-2022-doc/blob/main/doc/project2.md?spm=a2c6h.13046898.publish-article.80.37936ffauECnFr&file=project2.md\n\n\n\n### TODO\ntype peer struct 中为什么// Instance of the Raft module\n    是 RaftGroup \\*raft.RawNode  \n一个 region 包含多个 peer 怎么理解\n\n\n\n\n\n\n\n## Project 2C\nProject 2C 整体流程\n\n\n\n### RawNode 中 hardState  和 \n\n# Project 3\nhttps://www.inlighting.org/archives/tinykv-project3\n\n\n# 技巧\n## 日志输出\n```go\nlog.Infof(\"Raft init with config={len(peers)=%d}, \"+\n        \"peerid=%d, log commitid=%d, applied=%d, stabled=%d\",\n        len(c.peers),\n        rsp.id, rsp.RaftLog.committed, rsp.RaftLog.applied, rsp.RaftLog.stabled)\n        \nlog.Fatal(err)\n\nlog.Infof(\"peerid = %d becomes leader\", r.id)\n```\n# 总结\n\n\n\n## TODO\n\n// TODO 这里的 stabled 在 newlog 的时候赋值过一次，应该不会是 0 ，为什么会判断一次stabled\n    if l.stabled == 0 {\n        return l.entries\n        // log.Infof(\"stabled = %d\", l.stabled)\n    }\n \n// TODO 什么时候 修改 committed \n> sendAppend 时没有修改\n> handle AppendEntriesRespinse 时修改了。\nhttps://github.com/LX-676655103/Tinykv-2021/blob/course/raft/log.go\n\n\n// TODO 怎么处理 新 leader 中未 commit 的部分\n？从当前的逻辑来看，只有 当前 term 也产生 log 时 才会顺便更新前面的log\n\n\n// TODO 第一次收到 Lead 的消息时，需要进怎么样的处理\n\n// TODO noop Entry 会发送吗，\n\n// TODO r.Prs[r.id].Match 是  handlePropose 时修改。\n\n\nTODO  搞清楚  Next 和 Match 之间的关系。\nTODO 快照的同步逻辑\n# 参考\n\nhttps://github.com/LX-676655103/Tinykv-2021/blob/course/raft/raft.go#L967\nhttps://github.com/sakura-ysy/TinyKV-2022-doc/\n\n\nhttps://chenyunong.com/2021/08/04/TinyKV-Project2/\nhttps://www.inlighting.org/archives/tinykv-project2","slug":"项目经历/TinyKV/TinyKV 项目日志","published":1,"date":"2024-04-22T13:14:49.243Z","updated":"2024-04-22T02:39:45.960Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0q002lkgg47b5fconw","content":"<h1 id=\"Project-1\"><a href=\"#Project-1\" class=\"headerlink\" title=\"Project 1\"></a>Project 1</h1><h1 id=\"Project-2\"><a href=\"#Project-2\" class=\"headerlink\" title=\"Project 2\"></a>Project 2</h1><h2 id=\"Project-2-整体架构\"><a href=\"#Project-2-整体架构\" class=\"headerlink\" title=\"Project 2 整体架构\"></a>Project 2 整体架构</h2><h2 id=\"Project-2A\"><a href=\"#Project-2A\" class=\"headerlink\" title=\"Project 2A\"></a>Project 2A</h2><h3 id=\"Project-2A-整体架构\"><a href=\"#Project-2A-整体架构\" class=\"headerlink\" title=\"Project 2A 整体架构\"></a>Project 2A 整体架构</h3><p>本部分实现基础的 Raft 算法，且不需要考虑快照操作。我们共需要实现三个模块，分别为 RawNode、Raft 和 RaftLog，分别对应文件 <code>rawnode.go</code>、<code>raft.go</code> 和 <code>log.go</code> ，这三个模块，共同构成一层，我将其称为 <code>raft 层</code>。结构图如下<br>![[image2.png]]</p>\n<ul>\n<li><strong>RawNode</strong>：该模块用来接收上层传来的信息，将信息下传给 Raft 模块。比如，上层传递一个 Msg 给 RawNode，这个 Msg 可能是 心跳请求、日志提交请求、日志追加请求等等。然后 RawNode 收到这个 Msg 之后，将其交给 Raft 模块去处理。比如，上层交给 RawNode 一个日志提交请求，然后 RawNode 将其交给 Raft ，如果该节点是领导人，那么其就会追加这条日志，然后发送给其他节点进行同步。另外，RawNode 不仅用来接受请求然后传递给 Raft，还要用来收到 Raft 的同步结果然后传递给上层。RawNode 要负责检查 Raft 模块是否已有同步好的日志需要应用、是否有 Msg 需要发送、是否有日志需要持久化等等，然后把这些信息（Ready）交给上层，上层会据此进行处理。总的来说，RawNode 是 raft 层暴露给上层的一个模块，用来进行信息的传递。</li>\n<li><strong>Raft</strong>：整个 raft 层最关键的就是它，它就是实现 Raft 算法的核心模块。其中，领导人选举、日志追加、角色转换等等均是在这里实现。Raft 模块会接受 RawNode 发来的信息，然后在进群中进行相关的同步操作，同步结果不需要主动返回给 RawNode，因为 RawNode 自己会进行检查。</li>\n<li><strong>RaftLog</strong>：该模块用来暂存节点的日志条目，同时还要维护一些日志指针，如 committed、applied 等等。</li>\n</ul>\n<p>总结一下，RawNode 是 raft 层中暴露在外面的模块，用于该层与上层的信息交互，Raft 模块是 raft 层中的核心模块，算法的核心逻辑均在该模块实现，RaftLog 用来暂存日志信息，并维护相关指针。</p>\n<h3 id=\"Project-2-AA｜Project-2-AB\"><a href=\"#Project-2-AA｜Project-2-AB\" class=\"headerlink\" title=\"Project 2 AA｜Project 2 AB\"></a>Project 2 AA｜Project 2 AB</h3><h4 id=\"消息类型以及基本逻辑\"><a href=\"#消息类型以及基本逻辑\" class=\"headerlink\" title=\"消息类型以及基本逻辑\"></a>消息类型以及基本逻辑</h4><ol>\n<li><p>case pb.MessageType_MsgHup:</p>\n<ol>\n<li>选举的本地消息，由 Tick() 触发。</li>\n<li>如果发生选举超时，节点应将“MessageType_MsgHup”传递给其 Step 方法并开始新的选举，向其他所有节点发送 MsgRequestVote；</li>\n<li>一旦收到了这个消息，说明就是要重新开始一次选举。</li>\n</ol>\n</li>\n<li><p>case pb.MessageType_MsgBeat:</p>\n<ol>\n<li>本地心跳信息。表示当前节点的时钟前进，判断心跳超时和选举超时并进行相应的处理。</li>\n<li>注意只有 Leader 需要处理这个消息。</li>\n</ol>\n</li>\n<li><p>case pb.MessageType_MsgPropose:</p>\n<ol>\n<li>注意只有 Leader 会处理这个消息。 </li>\n<li>Leader 收到此消息需要将日志广播给其他节点。<ol>\n<li>发送时，如果要发送的 Index 已经被压缩了，转为发送快照。</li>\n<li>否则发送 MsgAppend。</li>\n<li>如果 MsgAppend 被接收者拒绝，Leader 会调整 next，重新进行前置判断，如果无需发快照，则按照新的 next 重新发送 MsgAppend。</li>\n</ol>\n</li>\n<li>发送方：由 Raft 层的上层构造此 msg 表示一次追加日志。此外，becomeLeader 时也会发送一个空 Entry 的 propose（也会被 广播）。</li>\n</ol>\n</li>\n<li><p>case pb.MessageType_MsgAppend:</p>\n<ol>\n<li>发送方：如上，一般 propose 之后触发，由 Leader 发送给其他节点来同步日志条目。</li>\n<li>接收方：<ol>\n<li>判断 Msg 的 Term 是否大于等于自己的 Term，是则更新，否则拒绝；</li>\n<li>拒绝，如果 prevLogIndex &gt; r.RaftLog.LastIndex() 说明中间有日志缺失。否则往下；</li>\n<li>拒绝，如果接收者日志中没有包含这样一个条目：即该条目的 Term 在 prevLogIndex 上不能和 prevLogTerm 匹配上。否则往下；</li>\n<li>追加新条目，同时删除冲突条目，冲突条目的判别方式和论文中的一致；</li>\n<li>当前节点更新 committedIndex 时，要比较 Leader 已知已经提交的最高的日志条目的索引 m.Commit 或者是上一个新条目的索引，然后取两者的最小值。为</li>\n<li>接受；</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>case pb.MessageType_MsgAppendResponse:</p>\n<ol>\n<li>只有 Leader 会处理该 Msg，其余角色直接忽略；</li>\n<li>如果被 reject 了，那么重置 next。重置规则为将旧的 next –，然后比较 m.Index + 1，最后取小的那个赋值给 next，然后重新进行日志 &#x2F; 快照追加；</li>\n<li>如果没有 reject，则更新 match 和 next。next 赋值为 m.Index + 1，match 赋值为 next - 1 ；</li>\n<li>按照论文的思路更新 commit。假设存在 N 满足N &gt; commitIndex，使得大多数的 matchIndex[i] ≥ N以及log[N].term &#x3D;&#x3D; currentTerm 成立，则令 commitIndex &#x3D; N。为了快速更新，这里先将节点按照 match 进行了递增排序，这样就可以快速确定 N 的位置。</li>\n</ol>\n</li>\n<li><p>case pb.MessageType_MsgRequestVote:</p>\n<ol>\n<li>判断 Msg 的 Term 是否大于等于自己的 Term，是则更新，否则拒绝；</li>\n<li>如果 votedFor 不为空或者不等于 candidateID，则说明该节点以及投过票了，直接拒绝。否则往下；</li>\n<li>Candidate 的日志至少和自己一样新，那么就给其投票，否者拒绝。新旧判断逻辑如下：<ul>\n<li>如果两份日志最后的条目的任期号不同，那么任期号大的日志更加新</li>\n<li>如果两份日志最后的条目任期号相同，那么日志比较长的那个就更加新；<br> Candidate 会通过 r.votes 记录下都有哪些节点同意哪些节点拒绝，当同意的票数过半时，即可成为 Leader，当拒绝的票数过半时，则转变为 Follower。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>case pb.MessageType_MsgRequestVoteResponse:</p>\n<ol>\n<li>只有 Candidate 会处理该 Msg，其余节点收到后直接忽略；</li>\n<li>根据 m.Reject 更新 r.votes[m.From]，即记录投票结果；</li>\n<li>算出同意的票数 agrNum 和拒绝的票数 denNum；</li>\n<li>如果同意的票数过半，那么直接成为 Leader；</li>\n<li>如果拒绝的票数过半，那么直接成为 Follower</li>\n</ol>\n</li>\n<li><p>case pb.MessageType_MsgSnapshot:</p>\n<ol>\n<li>Project2C 中才会实现，所以该 Msg 在 Project2C 处</li>\n</ol>\n</li>\n<li><p>case pb.MessageType_MsgHeartbeat:</p>\n<ol>\n<li>发送：<ol>\n<li>每当 Leader 的 heartbeatTimeout 达到时，就会给其余所有节点发送 MsgHeartbeat；</li>\n</ol>\n</li>\n<li>接收与处理：<ol>\n<li>判断 Msg 的 Term 是否大于等于自己的 Term，是则更新，否则拒绝；</li>\n<li>重置选举计时 r.electionElapsed</li>\n<li>发送 MsgHeartbeatResponse</li>\n<li>Commit:  min(r.RaftLog.committed, r.Prs[to].Match), 确保了心跳消息中的 Commit 字段不会超过已经在目标节点上提交的日志索引，使得心跳消息不需要推进 Commit。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>case pb.MessageType_MsgHeartbeatResponse:</p>\n<ol>\n<li>发送：<ol>\n<li>当节点收到 MsgHeartbeat 时，会相应的回复 MsgHeartbeatResponse；</li>\n</ol>\n</li>\n<li>接收与处理：<ol>\n<li>只有 Leader 会处理 MsgHeartbeatResponse，其余角色直接忽略；</li>\n<li>通过 m.Commit 判断节点是否落后了，如果是，则进行日志追加；</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>case pb.MessageType_MsgTransferLeader:</p>\n<ol>\n<li>用于上层请求转移 Leader，Project3 使用。</li>\n</ol>\n</li>\n<li><p>case pb.MessageType_MsgTimeoutNow:</p>\n<ol>\n<li>节点收到后清空 r.electionElapsed，并即刻发起选举</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"消息使用的字段\"><a href=\"#消息使用的字段\" class=\"headerlink\" title=\"消息使用的字段\"></a>消息使用的字段</h4><table>\n<thead>\n<tr>\n<th>MessageType\\msg_nr</th>\n<th>MsgType</th>\n<th>To</th>\n<th>From</th>\n<th>Term</th>\n<th>LogTerm</th>\n<th>Index</th>\n<th>Entries</th>\n<th>Commit</th>\n<th>Snapshot</th>\n<th>Reject</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Hup</td>\n<td>√</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Beat</td>\n<td>√</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Propose</td>\n<td>√</td>\n<td>√</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td>√</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>RequestVote</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>requestVoteResponse</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>。</td>\n<td>。</td>\n<td></td>\n<td></td>\n<td></td>\n<td>√</td>\n</tr>\n<tr>\n<td>Heartbeat</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td></td>\n<td></td>\n<td></td>\n<td>√</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>HeartbeatResponse</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Append</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>AppendResponse</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td></td>\n<td>√</td>\n<td></td>\n<td></td>\n<td></td>\n<td>√</td>\n</tr>\n<tr>\n<td>Snapshot</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td></td>\n<td></td>\n<td></td>\n<td>√</td>\n<td>√</td>\n<td></td>\n</tr>\n<tr>\n<td>TransferLeader</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>TimeoutNow</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>注意点：</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<ol>\n<li>Hup 和 Beat 一定是本地消息，而 Propose 不一定是本地消息，可能是外部构造的不再 Raft 内部调用 Step 处理，所以：From 不使用但是 To 需要使用。</li>\n<li>TimeoutNow 也是 本地消息，即刻发起选举。</li>\n<li>对于 MessageType_MsgAppend：<ol>\n<li>LogTerm 为要发送的条目的前一个条目的 Term，即论文中的 prevLogTerm</li>\n<li>Index 为要发送的条目的前一个条目的 Index，即论文中的 prevLogIndex</li>\n<li>当前节点 (Leader) 的 committedIndex</li>\n</ol>\n</li>\n<li>对于 MessageType_MsgAppendResponse：<ol>\n<li>Index：r.RaftLog.LastIndex()；该字段用于 Leader 更快地去更新 next</li>\n</ol>\n</li>\n<li>Reject 两个功能，一个 投票一个 在 append<br> 不同的是，propose 的 entry 无论是不是一个空的，都会被当成一个新的 entry 进行添加，而 Appen 的 entry，则可能被拒绝或者截取部分。</li>\n</ol>\n<h4 id=\"推进器-Step\"><a href=\"#推进器-Step\" class=\"headerlink\" title=\"推进器 Step()\"></a>推进器 Step()</h4><p>Step() 作为驱动器，用来接收上层发来的 Msg，然后根据不同的角色和不同的 MsgType 进行不同的处理。</p>\n<h4 id=\"计时器-tick\"><a href=\"#计时器-tick\" class=\"headerlink\" title=\"计时器 tick()\"></a>计时器 tick()</h4><p>该函数起到计时器的作用，即逻辑时钟。每调用一次，就要增加节点的心跳计时（ r.electionElapsed），如果是 Leader，就要增加自己的选举计时（ r.heartbeatElapsed），然后，应按照角色进行对应的操作。</p>\n<h4 id=\"log-go\"><a href=\"#log-go\" class=\"headerlink\" title=\"log.go\"></a>log.go</h4><h4 id=\"关键点｜易错点\"><a href=\"#关键点｜易错点\" class=\"headerlink\" title=\"关键点｜易错点\"></a>关键点｜易错点</h4><ol>\n<li>raft 的 id 是从 0 开始的，但是 0 是无效 id ：const RaftInvalidIndex uint64 &#x3D; 0</li>\n<li>entry 的 index 指的是 在 storage 中的 索引，而不是在数组中的下标。<br> 下标计算： index - entries[0].Index</li>\n<li>注意每一个 entry 都有一个自己的 <strong>term</strong></li>\n<li>Leader 不会自己发起一个新的选举。</li>\n<li>注意变成 Candidate 后发现，只有一个节点，再直接变成 Leader。</li>\n<li>注意某一个消息处理时如果遍历 Prs 且跳过了当前节点的 id ，需要额外考虑一下集群只有一个节点的情况。</li>\n<li>becomeCandidate 和 发送 请求 投票要分开进行</li>\n<li>allEntries() 描述中需要排除 排除虚拟条目，但是实际上，<br> &#x2F;&#x2F; if ent.Data !&#x3D; nil { &#x2F;&#x2F; 如果 这里的 ent 的 Data 是空的,说明 entry 无效<br> &#x2F;&#x2F; }<br> 不需要排除，这个是在 测试中确定的。</li>\n<li>handleRequestVoteResponse  除了统计同意的个数，还需要统计 拒绝的个数。</li>\n</ol>\n<h4 id=\"TODO\"><a href=\"#TODO\" class=\"headerlink\" title=\"TODO\"></a>TODO</h4><p><strong>随机选举时间问题</strong></p>\n<ul>\n<li>如果 et 太小，会过早开始选举，导致 term 比测试预期大。如果太大，会很晚发生选举，导致 term 比测试预期小。而且如果按照etcd那样一直递增，最后时间会非常长，直接卡住。我最后把它限制在 10~20 之间，通过测试。</li>\n</ul>\n<p><strong>leader 更新 committed 之后要告知 follower</strong></p>\n<ul>\n<li>eader 收到 appendResp 后，会相应的更新自己的 committed，但是更新之后一定要把更新结果告知<code>全部</code> follower，即另外发送一个 appendResp 。如果不这样的话，最后一轮完成后，集群的 committed 会不同步。并且为了防止死循环，leader 只能在 committed 发生变化的时候去通知 follower。</li>\n</ul>\n<p><strong>测试要求 msg 是nil，而不是空切片</strong></p>\n<ul>\n<li>TestRawNodeRestartFromSnapshot2C 中，want 里的 msg 为 nil，即测试点预期 newRaft 处的 msg 应该为 nil，而不是 make 一个空切片。</li>\n</ul>\n<h3 id=\"Project-2-AB\"><a href=\"#Project-2-AB\" class=\"headerlink\" title=\"Project 2 AB\"></a>Project 2 AB</h3><p>空空如也</p>\n<h3 id=\"Project-2-AC\"><a href=\"#Project-2-AC\" class=\"headerlink\" title=\"Project 2 AC\"></a>Project 2 AC</h3><h4 id=\"RawNode-部分整体工作流程\"><a href=\"#RawNode-部分整体工作流程\" class=\"headerlink\" title=\"RawNode 部分整体工作流程\"></a>RawNode 部分整体工作流程</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> &lt;-s.Ticker:</span><br><span class=\"line\">    Node.Tick()</span><br><span class=\"line\">  <span class=\"keyword\">default</span>:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> Node.HasReady() &#123;</span><br><span class=\"line\">      rd := Node.Ready()</span><br><span class=\"line\">      saveToStorage(rd.State, rd.Entries, rd.Snapshot)</span><br><span class=\"line\">      send(rd.Messages)</span><br><span class=\"line\">      <span class=\"keyword\">for</span> _, entry := <span class=\"keyword\">range</span> rd.CommittedEntries &#123;</span><br><span class=\"line\">        process(entry)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      s.Node.Advance(rd)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码解释：</p>\n<ol>\n<li>RawNode 是 Raft 的包装器，上层 ( peer 层) 会不停的调用 RawNode 的 tick() 函数，进一步触发 Raft 的 tick() 函数。 </li>\n<li>上层会定时从 RawNode 获取 Ready，首先上层通过 HasReady() 进行判断，如果有新的 Ready，上层会调用RawNode 的Ready()方法进行获取，RawNode 从 Raft 中 获取信息生成相应的 Ready 返回给上层应用，Raft 的信息则是存储在 RaftLog 之中。上层应用处理完 Ready 后，会调用 RawNode 的Advance() 方法进行推进，告诉 RawNode 之前的 Ready 已经被处理完成，然后你可以执行一些操作，比如修改 applied，stabled 等信息。 </li>\n<li>上层应用可以直接调用 RawNode 提供的 Propose(data []byte) ，Step(m pb.Message) 等方法，RawNode 会将这些请求统一包装成 Message，通过 Raft 提供的 Step(m pb.Message) 输入信息。</li>\n</ol>\n<h4 id=\"HasReady\"><a href=\"#HasReady\" class=\"headerlink\" title=\"HasReady()\"></a>HasReady()</h4><p>RawNode 通过 HasReady() 来判断 Raft 模块是否已经有同步完成并且需要上层处理的信息，包括：</p>\n<ul>\n<li>是否有需要持久化的状态；</li>\n<li>是否有需要持久化的条目；</li>\n<li>是否有需要应用的快照；</li>\n<li>是否有需要应用的条目；</li>\n<li>是否有需要发送的 Msg</li>\n</ul>\n<p>其中，最后一点的 Msg，就是 Raft 模块中节点间相互发送的 Msg。也就是说，节点间发送的 Msg 是通过 RawNode 先发送给上层，然后上层在将其发送给对应节点的。</p>\n<p>如果 HasReady() 返回 true，那么上层就会调用 Ready() 来获取具体要做的事情，和上述 HasReady() 的判断一一对应。该方法直接调用 rn.newReady() 生成一个 Ready() 结构体然后返回即可。</p>\n<h4 id=\"Advance\"><a href=\"#Advance\" class=\"headerlink\" title=\"Advance()\"></a>Advance()</h4><p>当上层处理完 Ready 后，调用 Advance() 来推进整个状态机。Advance() 的实现就按照 Ready 结构体一点点更改 RawNode 的状态即可，包括：</p>\n<ul>\n<li>prevHardSt 变更；</li>\n<li>stabled 指针变更；</li>\n<li>applied 指针变更；</li>\n<li>清空 rn.Raft.msgs；</li>\n<li>丢弃被压缩的暂存日志；</li>\n<li>清空 pendingSnapshot；</li>\n</ul>\n<h4 id=\"思考-总结\"><a href=\"#思考-总结\" class=\"headerlink\" title=\"思考&amp;总结\"></a>思考&amp;总结</h4><ol>\n<li>RawNode 是 Raft 的封装，保存 Raft 的一部分状态</li>\n</ol>\n<h3 id=\"Project-2A-总结-思考\"><a href=\"#Project-2A-总结-思考\" class=\"headerlink\" title=\"Project 2A  总结&amp;思考\"></a>Project 2A  总结&amp;思考</h3><h4 id=\"一些思考\"><a href=\"#一些思考\" class=\"headerlink\" title=\"一些思考\"></a>一些思考</h4><blockquote>\n<p>对于某个 Raft 变为 Candidate 提出选举，是当场给自己投一票 还是 同样构造一个 msg 发给自己处理？从 term 的角度思考。<br>    1. 假设发消息。可能导致当前 Raft 先收到其他 Raft 的投票请求，从而自己没有给自己投票。<br>    2. 因此当场给自己投一票。这样也减少了自己和自己的发消息多余操作。</p>\n</blockquote>\n<blockquote>\n<p>如果当前的 Raft 就是自己本身，开始一个新的选举之后  term 要增加吗？<br>    增加。</p>\n</blockquote>\n<blockquote>\n<p>如果超时，是先增加  term 还是先发送 MsgHup 消息？<br>    先增加 term。如果先发送消息，那么在消息队列中，这个消息前面的消息会认为这个 Raft 还是没有超时（实际上已经超时了）</p>\n</blockquote>\n<blockquote>\n<p>先发心跳包等到响应再增加 Elapsed 还是 先增加？<br>    先增加。万一响应收不到了，Elapsed 还是要增加的。</p>\n</blockquote>\n<blockquote>\n<p>Message 中 Commit 字段的作用？<br>    表示提交索引（commit index）。在 Raft 一致性算法中，每个节点都会维护一个提交索引。提交索引表示在该索引之前的所有日志条目都已经被安全地复制到了大多数节点，并且可以被应用到状态机中。换句话说，提交索引是已经达成共识并可以执行的日志条目的最高索引。</p>\n</blockquote>\n<blockquote>\n<p>RaftLog 中 committed | applied | stabled 三个字段？<br>    committed：已知在多数节点上的稳定存储中的最高日志位置。<br>    applied：已经应用到状态机的最大 log 位置<br>    stabled： 已经被持久化存储的最大 log 位置。</p>\n</blockquote>\n<blockquote>\n<p>持久化存储中到底要存储什么？<br>    1. “Save log entries to stable storage”（将日志条目保存到稳定存储）：在 Raft 中，每个节点会维护一个日志（log），其中包含按顺序记录的操作或状态变化。当节点接收到来自客户端的命令或其他节点的日志复制请求时，它将这些日志条目追加到自己的日志中。为了确保数据的持久性和可靠性，节点需要将这些日志条目保存到稳定存储介质（如磁盘）上，以便在节点重启或发生故障时能够恢复日志的状态。<br>    2. “Save hard state like the term, commit index, and vote to stable storage”（将任期、提交索引和投票信息等硬状态保存到稳定存储）：除了日志条目之外，Raft 还维护了一些重要的状态信息，称为硬状态。这些硬状态包括当前任期（term）、已提交的索引（commit index）和投票信息（如上一次投票的候选人ID等）。这些硬状态的变化需要被持久化保存，以确保在节点重启或发生故障时能够恢复到正确的状态。</p>\n</blockquote>\n<blockquote>\n<p>MemoryStorage  中 ents[i] has raft log position i+snapshot.Metadata.Index 的含义？<br>    <code>ents[i]</code> 表示 Raft 日志中的第 <code>i</code> 个条目。该条目的 Raft 日志位置是通过 <code>i + snapshot.Metadata.Index</code> 来确定的。<br>    在 Raft 算法中，为了支持快照（snapshot）功能，可以将当前节点的状态和日志压缩成一个快照。快照包含了快照的元数据信息以及存储在快照中的状态和日志条目。<br>    在代码中的 <code>ents</code> 切片中，存储了一系列的日志条目。为了与快照中的日志条目对应起来，<code>ents[i]</code> 的 Raft 日志位置是通过 <code>i + snapshot.Metadata.Index</code> 计算得出的。<br>    具体来说，<code>snapshot.Metadata.Index</code> 表示快照元数据中的索引值，它指示了快照中第一个条目的索引。然后，对于 <code>ents</code> 切片中的第 <code>i</code> 个条目，其在 Raft 日志中的位置就是 <code>i + snapshot.Metadata.Index</code>。<br>    这样的计算方式可以确保在应用快照之后，<code>ents</code> 切片中的日志条目仍然与 Raft 日志中的对应位置保持一致。<br>    需要注意的是，<code>snapshot.Metadata.Index</code> 是快照元数据中的一个字段，用于表示快照中第一个条目的索引。在给出的代码中，<code>snapshot</code> 是一个 <code>Metadata</code> 类型的字段，可能是一个结构体或变量，用于存储快照的元数据信息。<br>    也就是说  0 号位置的 Index 就是 <code>snapshot.Metadata.Index</code></p>\n</blockquote>\n<blockquote>\n<p>RaftLog 中的 entries  和 Storage 中的 ents 有什么区别？<br>    1. entries 是 从下标 1 开始作为有效记录；ents 是从下表 0 开始作为有效记录。<br>    2. .ents[0].Index 始终是有效的，用来作为基础索引</p>\n</blockquote>\n<blockquote>\n<p>RaftLog.storage.Snapshot() 和 RaftLog.pendingSnapshot 中的区别<br>    一个永久快照，一个临时快照。</p>\n</blockquote>\n<blockquote>\n<p>心跳 heatbeat 时间和选举 election 时间的关系<br>    1. heatbeat 只有 Leader 发送；election 时间是非 leader  需要维护的信息，以便即使开始一个选举。</p>\n</blockquote>\n<blockquote>\n<p>收到陌生 Raft 的信息，该怎么处理？<br>    1. 可能是一个新的节点，需要添加到已有结构中。<br>    2. 什么情况下添加？<br>        1. 首先只有这个新的 Raft 发送消息时才能被旧 Raft 知道，但是陌生 Raft 的工作消息直接处理可能会出问题，所以应该使用 heatbeat 作为新 Raft 的识别消息（谁收到了这个消息谁添加节点）。那么：<br>        2. 选举过程：<br>            1. Candidate 收到 heatbeat：多一个投票人，不会导致选举失败 。<br>            2. 其他角色 收到 heatbeat：更不会影响选举。<br>        3. 工作过程：<br>            1. Leader 收到 heatbeat：多一个工作者，不会导致工作错误 。<br>            2. 其他角色 收到 heatbeat：更不会影响工作（因为不会给 这个 Raft 发送工作消息）。<br>    3. 总结：任何情况下，收到 新 Raft 的 heatbeat 时，可将其添加到当前 Raft 的记录中（最好同时向这个新 Raft 同步一下当前系统的情况）。</p>\n</blockquote>\n<p>sendAppendResponse 不需要 回复 —-嘛嘛嘛？？？？？？？</p>\n<h4 id=\"总结一下-commmit-applied-stable-的修改时机\"><a href=\"#总结一下-commmit-applied-stable-的修改时机\" class=\"headerlink\" title=\"总结一下 commmit|applied|stable 的修改时机\"></a>总结一下 commmit|applied|stable 的修改时机</h4><p>&#x2F;&#x2F;\tsnapshot&#x2F;first…..applied….committed….stabled…..last<br>&#x2F;&#x2F;\t——–|————————————————|<br>&#x2F;&#x2F;\t                          log entries</p>\n<h4 id=\"RaftLog-committed-修改时机总结\"><a href=\"#RaftLog-committed-修改时机总结\" class=\"headerlink\" title=\"RaftLog.committed 修改时机总结\"></a>RaftLog.committed 修改时机总结</h4><ol>\n<li>在  newRaft() 中调用 newLog() 时被初始化为 storage 中 hardState 的 Commit</li>\n<li>Leader 在 发送 MessageType_MsgAppend 时发送当前 commited</li>\n<li>Raft 在收到 MessageType_MsgAppend 并更新 RaftLog.entries 之后，将 commited 置为以下两者的最小值<ol>\n<li>Leader 的 committed： m.Commit</li>\n<li>Leader 以为的 此 Raft 的 Committed：m.Index+uint64(len(m.Entries))</li>\n</ol>\n</li>\n<li>Leader 在收到 AppendEntriesResponse 之后 将自己的 commited 置为 当前 Term 的Entry 被大多数 Peers 中 都 Match 的最小 Index。</li>\n<li>Leader 在 发送 MessageType_MsgHeartbeat 时发送 min(r.RaftLog.committed, r.Prs[to].Match) （确保心跳消息中的 Commit 字段不会超过已经和目标j节点同步的日志索引，从而使得心跳消息不会推进 committed ）</li>\n<li>Raft 收到 Lead 的  MessageType_MsgHeartbeat 之后，如果发现 m.Commit（Leader 认为的提交） &gt;&#x3D; r.RaftLog.committed （Raft 自认为的提交），说明当前 Raft 的 RaftLog.entries 中有一部分 Leader 认为还未提交（需要被覆盖）。修改 committed 值为<br> min(m.Commit, r.RaftLog.LastIndex())</li>\n</ol>\n<h4 id=\"RaftLog-applied-修改时机总结\"><a href=\"#RaftLog-applied-修改时机总结\" class=\"headerlink\" title=\"RaftLog.applied 修改时机总结\"></a>RaftLog.applied 修改时机总结</h4><ol>\n<li>在  newRaft() 中调用 newLog() 时被初始化为 storage 中 的 ent[0].Index 或者 初始化为 0，表示初始没有被 applied 的 entry。</li>\n<li>在 Advance() 中第一次修改。</li>\n</ol>\n<h4 id=\"RaftLog-stabled-修改时机总结\"><a href=\"#RaftLog-stabled-修改时机总结\" class=\"headerlink\" title=\"RaftLog.stabled 修改时机总结\"></a>RaftLog.stabled 修改时机总结</h4><ol>\n<li>在  newRaft() 中调用 newLog() 时被初始化为 storage 中 ent 最后一个 entry 的 Index。</li>\n<li>r.RaftLog.stabled &#x3D; m.Index</li>\n<li>rn.Raft.RaftLog.stabled &#x3D; rd.Entries[len(rd.Entries)-1].Index</li>\n</ol>\n<h4 id=\"r-Prs-的-Match-Next\"><a href=\"#r-Prs-的-Match-Next\" class=\"headerlink\" title=\"r.Prs 的 Match &amp; Next\"></a>r.Prs 的 Match &amp; Next</h4><ol>\n<li>收到 Propose 时 if lastIndex &#x3D;&#x3D; 0 Propose</li>\n</ol>\n<h2 id=\"Project-2B\"><a href=\"#Project-2B\" class=\"headerlink\" title=\"Project 2B\"></a>Project 2B</h2><h3 id=\"Project-2B-整体流程\"><a href=\"#Project-2B-整体流程\" class=\"headerlink\" title=\"Project 2B 整体流程\"></a>Project 2B 整体流程</h3><p>Project2B 实现了 rawNode 之上的上层应用，即真正开始多线程集群操作，引入了 peer 和 region 的概念。同时，除了实现上层的调用，Project2B 还需要通过调用 RaftStorage 中的接口真正实现写落盘。 store、peer、region 三者的关系如下：<br>![[Pasted image 20240420190155.png]]</p>\n<ol>\n<li>Store：每一个节点叫做一个 store，也就是一个节点上面只有一个 Store。代码里面叫 RaftStore，后面统一使用 RaftStore 代称。 </li>\n<li>Peer：一个 RaftStore 里面会包含多个 peer，一个 RaftStore 里面的所有 peer 公用同一个底层存储，也就是多个 peer 公用同一个 badger 实例。 </li>\n<li>Region：一个 Region 叫做一个 Raft group，即同属一个 raft 集群，一个 region 包含多个 peer，这些 peer 散落在不同的 RaftStore 上。</li>\n</ol>\n<p>这里将 Rawnode-Raft-RaftLog 统称为 raft 层，把要实现的部分称为 peer 层。peer 层首先接收来自 client 的 RaftCmdRequest，其中包含着不同的<code>命令请求</code>，接着它会把这些请求逐一以 entry 的形式传递给 raft 层，当然，这个 peer 应该是 Leader，不然 client 会找下一个 peer 继续试。raft 层收到条目后，会在集群内部进行同步，这就是 project2a 的内容。同步的过程中，peer 层会不时询问 raft 层有哪些已经同步好的 entry 可以拿来应用（执行）？哪些 entry 需要持久化？有没有快照需要应用？等等。三层的交互如下图所示：<br>![[Pasted image 20240421125735.png]]<br>此模块要完善两个文件，分别为 <code>peer_msg_handler.go</code> 和 <code>peer_storage.go</code></p>\n<p><a href=\"https://github.com/sakura-ysy/TinyKV-2022-doc/blob/main/doc/project2.md?spm=a2c6h.13046898.publish-article.80.37936ffauECnFr&file=project2.md\">https://github.com/sakura-ysy/TinyKV-2022-doc/blob/main/doc/project2.md?spm=a2c6h.13046898.publish-article.80.37936ffauECnFr&amp;file=project2.md</a></p>\n<h3 id=\"TODO-1\"><a href=\"#TODO-1\" class=\"headerlink\" title=\"TODO\"></a>TODO</h3><p>type peer struct 中为什么&#x2F;&#x2F; Instance of the Raft module<br>    是 RaftGroup *raft.RawNode<br>一个 region 包含多个 peer 怎么理解</p>\n<h2 id=\"Project-2C\"><a href=\"#Project-2C\" class=\"headerlink\" title=\"Project 2C\"></a>Project 2C</h2><p>Project 2C 整体流程</p>\n<h3 id=\"RawNode-中-hardState-和\"><a href=\"#RawNode-中-hardState-和\" class=\"headerlink\" title=\"RawNode 中 hardState  和\"></a>RawNode 中 hardState  和</h3><h1 id=\"Project-3\"><a href=\"#Project-3\" class=\"headerlink\" title=\"Project 3\"></a>Project 3</h1><p><a href=\"https://www.inlighting.org/archives/tinykv-project3\">https://www.inlighting.org/archives/tinykv-project3</a></p>\n<h1 id=\"技巧\"><a href=\"#技巧\" class=\"headerlink\" title=\"技巧\"></a>技巧</h1><h2 id=\"日志输出\"><a href=\"#日志输出\" class=\"headerlink\" title=\"日志输出\"></a>日志输出</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log.Infof(<span class=\"string\">&quot;Raft init with config=&#123;len(peers)=%d&#125;, &quot;</span>+</span><br><span class=\"line\">        <span class=\"string\">&quot;peerid=%d, log commitid=%d, applied=%d, stabled=%d&quot;</span>,</span><br><span class=\"line\">        <span class=\"built_in\">len</span>(c.peers),</span><br><span class=\"line\">        rsp.id, rsp.RaftLog.committed, rsp.RaftLog.applied, rsp.RaftLog.stabled)</span><br><span class=\"line\">        </span><br><span class=\"line\">log.Fatal(err)</span><br><span class=\"line\"></span><br><span class=\"line\">log.Infof(<span class=\"string\">&quot;peerid = %d becomes leader&quot;</span>, r.id)</span><br></pre></td></tr></table></figure>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><h2 id=\"TODO-2\"><a href=\"#TODO-2\" class=\"headerlink\" title=\"TODO\"></a>TODO</h2><p>&#x2F;&#x2F; TODO 这里的 stabled 在 newlog 的时候赋值过一次，应该不会是 0 ，为什么会判断一次stabled<br>    if l.stabled &#x3D;&#x3D; 0 {<br>        return l.entries<br>        &#x2F;&#x2F; log.Infof(“stabled &#x3D; %d”, l.stabled)<br>    }<br> <br>&#x2F;&#x2F; TODO 什么时候 修改 committed </p>\n<blockquote>\n<p>sendAppend 时没有修改<br>handle AppendEntriesRespinse 时修改了。<br><a href=\"https://github.com/LX-676655103/Tinykv-2021/blob/course/raft/log.go\">https://github.com/LX-676655103/Tinykv-2021/blob/course/raft/log.go</a></p>\n</blockquote>\n<p>&#x2F;&#x2F; TODO 怎么处理 新 leader 中未 commit 的部分<br>？从当前的逻辑来看，只有 当前 term 也产生 log 时 才会顺便更新前面的log</p>\n<p>&#x2F;&#x2F; TODO 第一次收到 Lead 的消息时，需要进怎么样的处理</p>\n<p>&#x2F;&#x2F; TODO noop Entry 会发送吗，</p>\n<p>&#x2F;&#x2F; TODO r.Prs[r.id].Match 是  handlePropose 时修改。</p>\n<p>TODO  搞清楚  Next 和 Match 之间的关系。<br>TODO 快照的同步逻辑</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://github.com/LX-676655103/Tinykv-2021/blob/course/raft/raft.go#L967\">https://github.com/LX-676655103/Tinykv-2021/blob/course/raft/raft.go#L967</a><br><a href=\"https://github.com/sakura-ysy/TinyKV-2022-doc/\">https://github.com/sakura-ysy/TinyKV-2022-doc/</a></p>\n<p><a href=\"https://chenyunong.com/2021/08/04/TinyKV-Project2/\">https://chenyunong.com/2021/08/04/TinyKV-Project2/</a><br><a href=\"https://www.inlighting.org/archives/tinykv-project2\">https://www.inlighting.org/archives/tinykv-project2</a></p>\n","excerpt":"","more":"<h1 id=\"Project-1\"><a href=\"#Project-1\" class=\"headerlink\" title=\"Project 1\"></a>Project 1</h1><h1 id=\"Project-2\"><a href=\"#Project-2\" class=\"headerlink\" title=\"Project 2\"></a>Project 2</h1><h2 id=\"Project-2-整体架构\"><a href=\"#Project-2-整体架构\" class=\"headerlink\" title=\"Project 2 整体架构\"></a>Project 2 整体架构</h2><h2 id=\"Project-2A\"><a href=\"#Project-2A\" class=\"headerlink\" title=\"Project 2A\"></a>Project 2A</h2><h3 id=\"Project-2A-整体架构\"><a href=\"#Project-2A-整体架构\" class=\"headerlink\" title=\"Project 2A 整体架构\"></a>Project 2A 整体架构</h3><p>本部分实现基础的 Raft 算法，且不需要考虑快照操作。我们共需要实现三个模块，分别为 RawNode、Raft 和 RaftLog，分别对应文件 <code>rawnode.go</code>、<code>raft.go</code> 和 <code>log.go</code> ，这三个模块，共同构成一层，我将其称为 <code>raft 层</code>。结构图如下<br>![[image2.png]]</p>\n<ul>\n<li><strong>RawNode</strong>：该模块用来接收上层传来的信息，将信息下传给 Raft 模块。比如，上层传递一个 Msg 给 RawNode，这个 Msg 可能是 心跳请求、日志提交请求、日志追加请求等等。然后 RawNode 收到这个 Msg 之后，将其交给 Raft 模块去处理。比如，上层交给 RawNode 一个日志提交请求，然后 RawNode 将其交给 Raft ，如果该节点是领导人，那么其就会追加这条日志，然后发送给其他节点进行同步。另外，RawNode 不仅用来接受请求然后传递给 Raft，还要用来收到 Raft 的同步结果然后传递给上层。RawNode 要负责检查 Raft 模块是否已有同步好的日志需要应用、是否有 Msg 需要发送、是否有日志需要持久化等等，然后把这些信息（Ready）交给上层，上层会据此进行处理。总的来说，RawNode 是 raft 层暴露给上层的一个模块，用来进行信息的传递。</li>\n<li><strong>Raft</strong>：整个 raft 层最关键的就是它，它就是实现 Raft 算法的核心模块。其中，领导人选举、日志追加、角色转换等等均是在这里实现。Raft 模块会接受 RawNode 发来的信息，然后在进群中进行相关的同步操作，同步结果不需要主动返回给 RawNode，因为 RawNode 自己会进行检查。</li>\n<li><strong>RaftLog</strong>：该模块用来暂存节点的日志条目，同时还要维护一些日志指针，如 committed、applied 等等。</li>\n</ul>\n<p>总结一下，RawNode 是 raft 层中暴露在外面的模块，用于该层与上层的信息交互，Raft 模块是 raft 层中的核心模块，算法的核心逻辑均在该模块实现，RaftLog 用来暂存日志信息，并维护相关指针。</p>\n<h3 id=\"Project-2-AA｜Project-2-AB\"><a href=\"#Project-2-AA｜Project-2-AB\" class=\"headerlink\" title=\"Project 2 AA｜Project 2 AB\"></a>Project 2 AA｜Project 2 AB</h3><h4 id=\"消息类型以及基本逻辑\"><a href=\"#消息类型以及基本逻辑\" class=\"headerlink\" title=\"消息类型以及基本逻辑\"></a>消息类型以及基本逻辑</h4><ol>\n<li><p>case pb.MessageType_MsgHup:</p>\n<ol>\n<li>选举的本地消息，由 Tick() 触发。</li>\n<li>如果发生选举超时，节点应将“MessageType_MsgHup”传递给其 Step 方法并开始新的选举，向其他所有节点发送 MsgRequestVote；</li>\n<li>一旦收到了这个消息，说明就是要重新开始一次选举。</li>\n</ol>\n</li>\n<li><p>case pb.MessageType_MsgBeat:</p>\n<ol>\n<li>本地心跳信息。表示当前节点的时钟前进，判断心跳超时和选举超时并进行相应的处理。</li>\n<li>注意只有 Leader 需要处理这个消息。</li>\n</ol>\n</li>\n<li><p>case pb.MessageType_MsgPropose:</p>\n<ol>\n<li>注意只有 Leader 会处理这个消息。 </li>\n<li>Leader 收到此消息需要将日志广播给其他节点。<ol>\n<li>发送时，如果要发送的 Index 已经被压缩了，转为发送快照。</li>\n<li>否则发送 MsgAppend。</li>\n<li>如果 MsgAppend 被接收者拒绝，Leader 会调整 next，重新进行前置判断，如果无需发快照，则按照新的 next 重新发送 MsgAppend。</li>\n</ol>\n</li>\n<li>发送方：由 Raft 层的上层构造此 msg 表示一次追加日志。此外，becomeLeader 时也会发送一个空 Entry 的 propose（也会被 广播）。</li>\n</ol>\n</li>\n<li><p>case pb.MessageType_MsgAppend:</p>\n<ol>\n<li>发送方：如上，一般 propose 之后触发，由 Leader 发送给其他节点来同步日志条目。</li>\n<li>接收方：<ol>\n<li>判断 Msg 的 Term 是否大于等于自己的 Term，是则更新，否则拒绝；</li>\n<li>拒绝，如果 prevLogIndex &gt; r.RaftLog.LastIndex() 说明中间有日志缺失。否则往下；</li>\n<li>拒绝，如果接收者日志中没有包含这样一个条目：即该条目的 Term 在 prevLogIndex 上不能和 prevLogTerm 匹配上。否则往下；</li>\n<li>追加新条目，同时删除冲突条目，冲突条目的判别方式和论文中的一致；</li>\n<li>当前节点更新 committedIndex 时，要比较 Leader 已知已经提交的最高的日志条目的索引 m.Commit 或者是上一个新条目的索引，然后取两者的最小值。为</li>\n<li>接受；</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>case pb.MessageType_MsgAppendResponse:</p>\n<ol>\n<li>只有 Leader 会处理该 Msg，其余角色直接忽略；</li>\n<li>如果被 reject 了，那么重置 next。重置规则为将旧的 next –，然后比较 m.Index + 1，最后取小的那个赋值给 next，然后重新进行日志 &#x2F; 快照追加；</li>\n<li>如果没有 reject，则更新 match 和 next。next 赋值为 m.Index + 1，match 赋值为 next - 1 ；</li>\n<li>按照论文的思路更新 commit。假设存在 N 满足N &gt; commitIndex，使得大多数的 matchIndex[i] ≥ N以及log[N].term &#x3D;&#x3D; currentTerm 成立，则令 commitIndex &#x3D; N。为了快速更新，这里先将节点按照 match 进行了递增排序，这样就可以快速确定 N 的位置。</li>\n</ol>\n</li>\n<li><p>case pb.MessageType_MsgRequestVote:</p>\n<ol>\n<li>判断 Msg 的 Term 是否大于等于自己的 Term，是则更新，否则拒绝；</li>\n<li>如果 votedFor 不为空或者不等于 candidateID，则说明该节点以及投过票了，直接拒绝。否则往下；</li>\n<li>Candidate 的日志至少和自己一样新，那么就给其投票，否者拒绝。新旧判断逻辑如下：<ul>\n<li>如果两份日志最后的条目的任期号不同，那么任期号大的日志更加新</li>\n<li>如果两份日志最后的条目任期号相同，那么日志比较长的那个就更加新；<br> Candidate 会通过 r.votes 记录下都有哪些节点同意哪些节点拒绝，当同意的票数过半时，即可成为 Leader，当拒绝的票数过半时，则转变为 Follower。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>case pb.MessageType_MsgRequestVoteResponse:</p>\n<ol>\n<li>只有 Candidate 会处理该 Msg，其余节点收到后直接忽略；</li>\n<li>根据 m.Reject 更新 r.votes[m.From]，即记录投票结果；</li>\n<li>算出同意的票数 agrNum 和拒绝的票数 denNum；</li>\n<li>如果同意的票数过半，那么直接成为 Leader；</li>\n<li>如果拒绝的票数过半，那么直接成为 Follower</li>\n</ol>\n</li>\n<li><p>case pb.MessageType_MsgSnapshot:</p>\n<ol>\n<li>Project2C 中才会实现，所以该 Msg 在 Project2C 处</li>\n</ol>\n</li>\n<li><p>case pb.MessageType_MsgHeartbeat:</p>\n<ol>\n<li>发送：<ol>\n<li>每当 Leader 的 heartbeatTimeout 达到时，就会给其余所有节点发送 MsgHeartbeat；</li>\n</ol>\n</li>\n<li>接收与处理：<ol>\n<li>判断 Msg 的 Term 是否大于等于自己的 Term，是则更新，否则拒绝；</li>\n<li>重置选举计时 r.electionElapsed</li>\n<li>发送 MsgHeartbeatResponse</li>\n<li>Commit:  min(r.RaftLog.committed, r.Prs[to].Match), 确保了心跳消息中的 Commit 字段不会超过已经在目标节点上提交的日志索引，使得心跳消息不需要推进 Commit。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>case pb.MessageType_MsgHeartbeatResponse:</p>\n<ol>\n<li>发送：<ol>\n<li>当节点收到 MsgHeartbeat 时，会相应的回复 MsgHeartbeatResponse；</li>\n</ol>\n</li>\n<li>接收与处理：<ol>\n<li>只有 Leader 会处理 MsgHeartbeatResponse，其余角色直接忽略；</li>\n<li>通过 m.Commit 判断节点是否落后了，如果是，则进行日志追加；</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>case pb.MessageType_MsgTransferLeader:</p>\n<ol>\n<li>用于上层请求转移 Leader，Project3 使用。</li>\n</ol>\n</li>\n<li><p>case pb.MessageType_MsgTimeoutNow:</p>\n<ol>\n<li>节点收到后清空 r.electionElapsed，并即刻发起选举</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"消息使用的字段\"><a href=\"#消息使用的字段\" class=\"headerlink\" title=\"消息使用的字段\"></a>消息使用的字段</h4><table>\n<thead>\n<tr>\n<th>MessageType\\msg_nr</th>\n<th>MsgType</th>\n<th>To</th>\n<th>From</th>\n<th>Term</th>\n<th>LogTerm</th>\n<th>Index</th>\n<th>Entries</th>\n<th>Commit</th>\n<th>Snapshot</th>\n<th>Reject</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Hup</td>\n<td>√</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Beat</td>\n<td>√</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Propose</td>\n<td>√</td>\n<td>√</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td>√</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>RequestVote</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>requestVoteResponse</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>。</td>\n<td>。</td>\n<td></td>\n<td></td>\n<td></td>\n<td>√</td>\n</tr>\n<tr>\n<td>Heartbeat</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td></td>\n<td></td>\n<td></td>\n<td>√</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>HeartbeatResponse</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Append</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>AppendResponse</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td></td>\n<td>√</td>\n<td></td>\n<td></td>\n<td></td>\n<td>√</td>\n</tr>\n<tr>\n<td>Snapshot</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td></td>\n<td></td>\n<td></td>\n<td>√</td>\n<td>√</td>\n<td></td>\n</tr>\n<tr>\n<td>TransferLeader</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>TimeoutNow</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>注意点：</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<ol>\n<li>Hup 和 Beat 一定是本地消息，而 Propose 不一定是本地消息，可能是外部构造的不再 Raft 内部调用 Step 处理，所以：From 不使用但是 To 需要使用。</li>\n<li>TimeoutNow 也是 本地消息，即刻发起选举。</li>\n<li>对于 MessageType_MsgAppend：<ol>\n<li>LogTerm 为要发送的条目的前一个条目的 Term，即论文中的 prevLogTerm</li>\n<li>Index 为要发送的条目的前一个条目的 Index，即论文中的 prevLogIndex</li>\n<li>当前节点 (Leader) 的 committedIndex</li>\n</ol>\n</li>\n<li>对于 MessageType_MsgAppendResponse：<ol>\n<li>Index：r.RaftLog.LastIndex()；该字段用于 Leader 更快地去更新 next</li>\n</ol>\n</li>\n<li>Reject 两个功能，一个 投票一个 在 append<br> 不同的是，propose 的 entry 无论是不是一个空的，都会被当成一个新的 entry 进行添加，而 Appen 的 entry，则可能被拒绝或者截取部分。</li>\n</ol>\n<h4 id=\"推进器-Step\"><a href=\"#推进器-Step\" class=\"headerlink\" title=\"推进器 Step()\"></a>推进器 Step()</h4><p>Step() 作为驱动器，用来接收上层发来的 Msg，然后根据不同的角色和不同的 MsgType 进行不同的处理。</p>\n<h4 id=\"计时器-tick\"><a href=\"#计时器-tick\" class=\"headerlink\" title=\"计时器 tick()\"></a>计时器 tick()</h4><p>该函数起到计时器的作用，即逻辑时钟。每调用一次，就要增加节点的心跳计时（ r.electionElapsed），如果是 Leader，就要增加自己的选举计时（ r.heartbeatElapsed），然后，应按照角色进行对应的操作。</p>\n<h4 id=\"log-go\"><a href=\"#log-go\" class=\"headerlink\" title=\"log.go\"></a>log.go</h4><h4 id=\"关键点｜易错点\"><a href=\"#关键点｜易错点\" class=\"headerlink\" title=\"关键点｜易错点\"></a>关键点｜易错点</h4><ol>\n<li>raft 的 id 是从 0 开始的，但是 0 是无效 id ：const RaftInvalidIndex uint64 &#x3D; 0</li>\n<li>entry 的 index 指的是 在 storage 中的 索引，而不是在数组中的下标。<br> 下标计算： index - entries[0].Index</li>\n<li>注意每一个 entry 都有一个自己的 <strong>term</strong></li>\n<li>Leader 不会自己发起一个新的选举。</li>\n<li>注意变成 Candidate 后发现，只有一个节点，再直接变成 Leader。</li>\n<li>注意某一个消息处理时如果遍历 Prs 且跳过了当前节点的 id ，需要额外考虑一下集群只有一个节点的情况。</li>\n<li>becomeCandidate 和 发送 请求 投票要分开进行</li>\n<li>allEntries() 描述中需要排除 排除虚拟条目，但是实际上，<br> &#x2F;&#x2F; if ent.Data !&#x3D; nil { &#x2F;&#x2F; 如果 这里的 ent 的 Data 是空的,说明 entry 无效<br> &#x2F;&#x2F; }<br> 不需要排除，这个是在 测试中确定的。</li>\n<li>handleRequestVoteResponse  除了统计同意的个数，还需要统计 拒绝的个数。</li>\n</ol>\n<h4 id=\"TODO\"><a href=\"#TODO\" class=\"headerlink\" title=\"TODO\"></a>TODO</h4><p><strong>随机选举时间问题</strong></p>\n<ul>\n<li>如果 et 太小，会过早开始选举，导致 term 比测试预期大。如果太大，会很晚发生选举，导致 term 比测试预期小。而且如果按照etcd那样一直递增，最后时间会非常长，直接卡住。我最后把它限制在 10~20 之间，通过测试。</li>\n</ul>\n<p><strong>leader 更新 committed 之后要告知 follower</strong></p>\n<ul>\n<li>eader 收到 appendResp 后，会相应的更新自己的 committed，但是更新之后一定要把更新结果告知<code>全部</code> follower，即另外发送一个 appendResp 。如果不这样的话，最后一轮完成后，集群的 committed 会不同步。并且为了防止死循环，leader 只能在 committed 发生变化的时候去通知 follower。</li>\n</ul>\n<p><strong>测试要求 msg 是nil，而不是空切片</strong></p>\n<ul>\n<li>TestRawNodeRestartFromSnapshot2C 中，want 里的 msg 为 nil，即测试点预期 newRaft 处的 msg 应该为 nil，而不是 make 一个空切片。</li>\n</ul>\n<h3 id=\"Project-2-AB\"><a href=\"#Project-2-AB\" class=\"headerlink\" title=\"Project 2 AB\"></a>Project 2 AB</h3><p>空空如也</p>\n<h3 id=\"Project-2-AC\"><a href=\"#Project-2-AC\" class=\"headerlink\" title=\"Project 2 AC\"></a>Project 2 AC</h3><h4 id=\"RawNode-部分整体工作流程\"><a href=\"#RawNode-部分整体工作流程\" class=\"headerlink\" title=\"RawNode 部分整体工作流程\"></a>RawNode 部分整体工作流程</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> &lt;-s.Ticker:</span><br><span class=\"line\">    Node.Tick()</span><br><span class=\"line\">  <span class=\"keyword\">default</span>:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> Node.HasReady() &#123;</span><br><span class=\"line\">      rd := Node.Ready()</span><br><span class=\"line\">      saveToStorage(rd.State, rd.Entries, rd.Snapshot)</span><br><span class=\"line\">      send(rd.Messages)</span><br><span class=\"line\">      <span class=\"keyword\">for</span> _, entry := <span class=\"keyword\">range</span> rd.CommittedEntries &#123;</span><br><span class=\"line\">        process(entry)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      s.Node.Advance(rd)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码解释：</p>\n<ol>\n<li>RawNode 是 Raft 的包装器，上层 ( peer 层) 会不停的调用 RawNode 的 tick() 函数，进一步触发 Raft 的 tick() 函数。 </li>\n<li>上层会定时从 RawNode 获取 Ready，首先上层通过 HasReady() 进行判断，如果有新的 Ready，上层会调用RawNode 的Ready()方法进行获取，RawNode 从 Raft 中 获取信息生成相应的 Ready 返回给上层应用，Raft 的信息则是存储在 RaftLog 之中。上层应用处理完 Ready 后，会调用 RawNode 的Advance() 方法进行推进，告诉 RawNode 之前的 Ready 已经被处理完成，然后你可以执行一些操作，比如修改 applied，stabled 等信息。 </li>\n<li>上层应用可以直接调用 RawNode 提供的 Propose(data []byte) ，Step(m pb.Message) 等方法，RawNode 会将这些请求统一包装成 Message，通过 Raft 提供的 Step(m pb.Message) 输入信息。</li>\n</ol>\n<h4 id=\"HasReady\"><a href=\"#HasReady\" class=\"headerlink\" title=\"HasReady()\"></a>HasReady()</h4><p>RawNode 通过 HasReady() 来判断 Raft 模块是否已经有同步完成并且需要上层处理的信息，包括：</p>\n<ul>\n<li>是否有需要持久化的状态；</li>\n<li>是否有需要持久化的条目；</li>\n<li>是否有需要应用的快照；</li>\n<li>是否有需要应用的条目；</li>\n<li>是否有需要发送的 Msg</li>\n</ul>\n<p>其中，最后一点的 Msg，就是 Raft 模块中节点间相互发送的 Msg。也就是说，节点间发送的 Msg 是通过 RawNode 先发送给上层，然后上层在将其发送给对应节点的。</p>\n<p>如果 HasReady() 返回 true，那么上层就会调用 Ready() 来获取具体要做的事情，和上述 HasReady() 的判断一一对应。该方法直接调用 rn.newReady() 生成一个 Ready() 结构体然后返回即可。</p>\n<h4 id=\"Advance\"><a href=\"#Advance\" class=\"headerlink\" title=\"Advance()\"></a>Advance()</h4><p>当上层处理完 Ready 后，调用 Advance() 来推进整个状态机。Advance() 的实现就按照 Ready 结构体一点点更改 RawNode 的状态即可，包括：</p>\n<ul>\n<li>prevHardSt 变更；</li>\n<li>stabled 指针变更；</li>\n<li>applied 指针变更；</li>\n<li>清空 rn.Raft.msgs；</li>\n<li>丢弃被压缩的暂存日志；</li>\n<li>清空 pendingSnapshot；</li>\n</ul>\n<h4 id=\"思考-总结\"><a href=\"#思考-总结\" class=\"headerlink\" title=\"思考&amp;总结\"></a>思考&amp;总结</h4><ol>\n<li>RawNode 是 Raft 的封装，保存 Raft 的一部分状态</li>\n</ol>\n<h3 id=\"Project-2A-总结-思考\"><a href=\"#Project-2A-总结-思考\" class=\"headerlink\" title=\"Project 2A  总结&amp;思考\"></a>Project 2A  总结&amp;思考</h3><h4 id=\"一些思考\"><a href=\"#一些思考\" class=\"headerlink\" title=\"一些思考\"></a>一些思考</h4><blockquote>\n<p>对于某个 Raft 变为 Candidate 提出选举，是当场给自己投一票 还是 同样构造一个 msg 发给自己处理？从 term 的角度思考。<br>    1. 假设发消息。可能导致当前 Raft 先收到其他 Raft 的投票请求，从而自己没有给自己投票。<br>    2. 因此当场给自己投一票。这样也减少了自己和自己的发消息多余操作。</p>\n</blockquote>\n<blockquote>\n<p>如果当前的 Raft 就是自己本身，开始一个新的选举之后  term 要增加吗？<br>    增加。</p>\n</blockquote>\n<blockquote>\n<p>如果超时，是先增加  term 还是先发送 MsgHup 消息？<br>    先增加 term。如果先发送消息，那么在消息队列中，这个消息前面的消息会认为这个 Raft 还是没有超时（实际上已经超时了）</p>\n</blockquote>\n<blockquote>\n<p>先发心跳包等到响应再增加 Elapsed 还是 先增加？<br>    先增加。万一响应收不到了，Elapsed 还是要增加的。</p>\n</blockquote>\n<blockquote>\n<p>Message 中 Commit 字段的作用？<br>    表示提交索引（commit index）。在 Raft 一致性算法中，每个节点都会维护一个提交索引。提交索引表示在该索引之前的所有日志条目都已经被安全地复制到了大多数节点，并且可以被应用到状态机中。换句话说，提交索引是已经达成共识并可以执行的日志条目的最高索引。</p>\n</blockquote>\n<blockquote>\n<p>RaftLog 中 committed | applied | stabled 三个字段？<br>    committed：已知在多数节点上的稳定存储中的最高日志位置。<br>    applied：已经应用到状态机的最大 log 位置<br>    stabled： 已经被持久化存储的最大 log 位置。</p>\n</blockquote>\n<blockquote>\n<p>持久化存储中到底要存储什么？<br>    1. “Save log entries to stable storage”（将日志条目保存到稳定存储）：在 Raft 中，每个节点会维护一个日志（log），其中包含按顺序记录的操作或状态变化。当节点接收到来自客户端的命令或其他节点的日志复制请求时，它将这些日志条目追加到自己的日志中。为了确保数据的持久性和可靠性，节点需要将这些日志条目保存到稳定存储介质（如磁盘）上，以便在节点重启或发生故障时能够恢复日志的状态。<br>    2. “Save hard state like the term, commit index, and vote to stable storage”（将任期、提交索引和投票信息等硬状态保存到稳定存储）：除了日志条目之外，Raft 还维护了一些重要的状态信息，称为硬状态。这些硬状态包括当前任期（term）、已提交的索引（commit index）和投票信息（如上一次投票的候选人ID等）。这些硬状态的变化需要被持久化保存，以确保在节点重启或发生故障时能够恢复到正确的状态。</p>\n</blockquote>\n<blockquote>\n<p>MemoryStorage  中 ents[i] has raft log position i+snapshot.Metadata.Index 的含义？<br>    <code>ents[i]</code> 表示 Raft 日志中的第 <code>i</code> 个条目。该条目的 Raft 日志位置是通过 <code>i + snapshot.Metadata.Index</code> 来确定的。<br>    在 Raft 算法中，为了支持快照（snapshot）功能，可以将当前节点的状态和日志压缩成一个快照。快照包含了快照的元数据信息以及存储在快照中的状态和日志条目。<br>    在代码中的 <code>ents</code> 切片中，存储了一系列的日志条目。为了与快照中的日志条目对应起来，<code>ents[i]</code> 的 Raft 日志位置是通过 <code>i + snapshot.Metadata.Index</code> 计算得出的。<br>    具体来说，<code>snapshot.Metadata.Index</code> 表示快照元数据中的索引值，它指示了快照中第一个条目的索引。然后，对于 <code>ents</code> 切片中的第 <code>i</code> 个条目，其在 Raft 日志中的位置就是 <code>i + snapshot.Metadata.Index</code>。<br>    这样的计算方式可以确保在应用快照之后，<code>ents</code> 切片中的日志条目仍然与 Raft 日志中的对应位置保持一致。<br>    需要注意的是，<code>snapshot.Metadata.Index</code> 是快照元数据中的一个字段，用于表示快照中第一个条目的索引。在给出的代码中，<code>snapshot</code> 是一个 <code>Metadata</code> 类型的字段，可能是一个结构体或变量，用于存储快照的元数据信息。<br>    也就是说  0 号位置的 Index 就是 <code>snapshot.Metadata.Index</code></p>\n</blockquote>\n<blockquote>\n<p>RaftLog 中的 entries  和 Storage 中的 ents 有什么区别？<br>    1. entries 是 从下标 1 开始作为有效记录；ents 是从下表 0 开始作为有效记录。<br>    2. .ents[0].Index 始终是有效的，用来作为基础索引</p>\n</blockquote>\n<blockquote>\n<p>RaftLog.storage.Snapshot() 和 RaftLog.pendingSnapshot 中的区别<br>    一个永久快照，一个临时快照。</p>\n</blockquote>\n<blockquote>\n<p>心跳 heatbeat 时间和选举 election 时间的关系<br>    1. heatbeat 只有 Leader 发送；election 时间是非 leader  需要维护的信息，以便即使开始一个选举。</p>\n</blockquote>\n<blockquote>\n<p>收到陌生 Raft 的信息，该怎么处理？<br>    1. 可能是一个新的节点，需要添加到已有结构中。<br>    2. 什么情况下添加？<br>        1. 首先只有这个新的 Raft 发送消息时才能被旧 Raft 知道，但是陌生 Raft 的工作消息直接处理可能会出问题，所以应该使用 heatbeat 作为新 Raft 的识别消息（谁收到了这个消息谁添加节点）。那么：<br>        2. 选举过程：<br>            1. Candidate 收到 heatbeat：多一个投票人，不会导致选举失败 。<br>            2. 其他角色 收到 heatbeat：更不会影响选举。<br>        3. 工作过程：<br>            1. Leader 收到 heatbeat：多一个工作者，不会导致工作错误 。<br>            2. 其他角色 收到 heatbeat：更不会影响工作（因为不会给 这个 Raft 发送工作消息）。<br>    3. 总结：任何情况下，收到 新 Raft 的 heatbeat 时，可将其添加到当前 Raft 的记录中（最好同时向这个新 Raft 同步一下当前系统的情况）。</p>\n</blockquote>\n<p>sendAppendResponse 不需要 回复 —-嘛嘛嘛？？？？？？？</p>\n<h4 id=\"总结一下-commmit-applied-stable-的修改时机\"><a href=\"#总结一下-commmit-applied-stable-的修改时机\" class=\"headerlink\" title=\"总结一下 commmit|applied|stable 的修改时机\"></a>总结一下 commmit|applied|stable 的修改时机</h4><p>&#x2F;&#x2F;\tsnapshot&#x2F;first…..applied….committed….stabled…..last<br>&#x2F;&#x2F;\t——–|————————————————|<br>&#x2F;&#x2F;\t                          log entries</p>\n<h4 id=\"RaftLog-committed-修改时机总结\"><a href=\"#RaftLog-committed-修改时机总结\" class=\"headerlink\" title=\"RaftLog.committed 修改时机总结\"></a>RaftLog.committed 修改时机总结</h4><ol>\n<li>在  newRaft() 中调用 newLog() 时被初始化为 storage 中 hardState 的 Commit</li>\n<li>Leader 在 发送 MessageType_MsgAppend 时发送当前 commited</li>\n<li>Raft 在收到 MessageType_MsgAppend 并更新 RaftLog.entries 之后，将 commited 置为以下两者的最小值<ol>\n<li>Leader 的 committed： m.Commit</li>\n<li>Leader 以为的 此 Raft 的 Committed：m.Index+uint64(len(m.Entries))</li>\n</ol>\n</li>\n<li>Leader 在收到 AppendEntriesResponse 之后 将自己的 commited 置为 当前 Term 的Entry 被大多数 Peers 中 都 Match 的最小 Index。</li>\n<li>Leader 在 发送 MessageType_MsgHeartbeat 时发送 min(r.RaftLog.committed, r.Prs[to].Match) （确保心跳消息中的 Commit 字段不会超过已经和目标j节点同步的日志索引，从而使得心跳消息不会推进 committed ）</li>\n<li>Raft 收到 Lead 的  MessageType_MsgHeartbeat 之后，如果发现 m.Commit（Leader 认为的提交） &gt;&#x3D; r.RaftLog.committed （Raft 自认为的提交），说明当前 Raft 的 RaftLog.entries 中有一部分 Leader 认为还未提交（需要被覆盖）。修改 committed 值为<br> min(m.Commit, r.RaftLog.LastIndex())</li>\n</ol>\n<h4 id=\"RaftLog-applied-修改时机总结\"><a href=\"#RaftLog-applied-修改时机总结\" class=\"headerlink\" title=\"RaftLog.applied 修改时机总结\"></a>RaftLog.applied 修改时机总结</h4><ol>\n<li>在  newRaft() 中调用 newLog() 时被初始化为 storage 中 的 ent[0].Index 或者 初始化为 0，表示初始没有被 applied 的 entry。</li>\n<li>在 Advance() 中第一次修改。</li>\n</ol>\n<h4 id=\"RaftLog-stabled-修改时机总结\"><a href=\"#RaftLog-stabled-修改时机总结\" class=\"headerlink\" title=\"RaftLog.stabled 修改时机总结\"></a>RaftLog.stabled 修改时机总结</h4><ol>\n<li>在  newRaft() 中调用 newLog() 时被初始化为 storage 中 ent 最后一个 entry 的 Index。</li>\n<li>r.RaftLog.stabled &#x3D; m.Index</li>\n<li>rn.Raft.RaftLog.stabled &#x3D; rd.Entries[len(rd.Entries)-1].Index</li>\n</ol>\n<h4 id=\"r-Prs-的-Match-Next\"><a href=\"#r-Prs-的-Match-Next\" class=\"headerlink\" title=\"r.Prs 的 Match &amp; Next\"></a>r.Prs 的 Match &amp; Next</h4><ol>\n<li>收到 Propose 时 if lastIndex &#x3D;&#x3D; 0 Propose</li>\n</ol>\n<h2 id=\"Project-2B\"><a href=\"#Project-2B\" class=\"headerlink\" title=\"Project 2B\"></a>Project 2B</h2><h3 id=\"Project-2B-整体流程\"><a href=\"#Project-2B-整体流程\" class=\"headerlink\" title=\"Project 2B 整体流程\"></a>Project 2B 整体流程</h3><p>Project2B 实现了 rawNode 之上的上层应用，即真正开始多线程集群操作，引入了 peer 和 region 的概念。同时，除了实现上层的调用，Project2B 还需要通过调用 RaftStorage 中的接口真正实现写落盘。 store、peer、region 三者的关系如下：<br>![[Pasted image 20240420190155.png]]</p>\n<ol>\n<li>Store：每一个节点叫做一个 store，也就是一个节点上面只有一个 Store。代码里面叫 RaftStore，后面统一使用 RaftStore 代称。 </li>\n<li>Peer：一个 RaftStore 里面会包含多个 peer，一个 RaftStore 里面的所有 peer 公用同一个底层存储，也就是多个 peer 公用同一个 badger 实例。 </li>\n<li>Region：一个 Region 叫做一个 Raft group，即同属一个 raft 集群，一个 region 包含多个 peer，这些 peer 散落在不同的 RaftStore 上。</li>\n</ol>\n<p>这里将 Rawnode-Raft-RaftLog 统称为 raft 层，把要实现的部分称为 peer 层。peer 层首先接收来自 client 的 RaftCmdRequest，其中包含着不同的<code>命令请求</code>，接着它会把这些请求逐一以 entry 的形式传递给 raft 层，当然，这个 peer 应该是 Leader，不然 client 会找下一个 peer 继续试。raft 层收到条目后，会在集群内部进行同步，这就是 project2a 的内容。同步的过程中，peer 层会不时询问 raft 层有哪些已经同步好的 entry 可以拿来应用（执行）？哪些 entry 需要持久化？有没有快照需要应用？等等。三层的交互如下图所示：<br>![[Pasted image 20240421125735.png]]<br>此模块要完善两个文件，分别为 <code>peer_msg_handler.go</code> 和 <code>peer_storage.go</code></p>\n<p><a href=\"https://github.com/sakura-ysy/TinyKV-2022-doc/blob/main/doc/project2.md?spm=a2c6h.13046898.publish-article.80.37936ffauECnFr&file=project2.md\">https://github.com/sakura-ysy/TinyKV-2022-doc/blob/main/doc/project2.md?spm=a2c6h.13046898.publish-article.80.37936ffauECnFr&amp;file=project2.md</a></p>\n<h3 id=\"TODO-1\"><a href=\"#TODO-1\" class=\"headerlink\" title=\"TODO\"></a>TODO</h3><p>type peer struct 中为什么&#x2F;&#x2F; Instance of the Raft module<br>    是 RaftGroup *raft.RawNode<br>一个 region 包含多个 peer 怎么理解</p>\n<h2 id=\"Project-2C\"><a href=\"#Project-2C\" class=\"headerlink\" title=\"Project 2C\"></a>Project 2C</h2><p>Project 2C 整体流程</p>\n<h3 id=\"RawNode-中-hardState-和\"><a href=\"#RawNode-中-hardState-和\" class=\"headerlink\" title=\"RawNode 中 hardState  和\"></a>RawNode 中 hardState  和</h3><h1 id=\"Project-3\"><a href=\"#Project-3\" class=\"headerlink\" title=\"Project 3\"></a>Project 3</h1><p><a href=\"https://www.inlighting.org/archives/tinykv-project3\">https://www.inlighting.org/archives/tinykv-project3</a></p>\n<h1 id=\"技巧\"><a href=\"#技巧\" class=\"headerlink\" title=\"技巧\"></a>技巧</h1><h2 id=\"日志输出\"><a href=\"#日志输出\" class=\"headerlink\" title=\"日志输出\"></a>日志输出</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log.Infof(<span class=\"string\">&quot;Raft init with config=&#123;len(peers)=%d&#125;, &quot;</span>+</span><br><span class=\"line\">        <span class=\"string\">&quot;peerid=%d, log commitid=%d, applied=%d, stabled=%d&quot;</span>,</span><br><span class=\"line\">        <span class=\"built_in\">len</span>(c.peers),</span><br><span class=\"line\">        rsp.id, rsp.RaftLog.committed, rsp.RaftLog.applied, rsp.RaftLog.stabled)</span><br><span class=\"line\">        </span><br><span class=\"line\">log.Fatal(err)</span><br><span class=\"line\"></span><br><span class=\"line\">log.Infof(<span class=\"string\">&quot;peerid = %d becomes leader&quot;</span>, r.id)</span><br></pre></td></tr></table></figure>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><h2 id=\"TODO-2\"><a href=\"#TODO-2\" class=\"headerlink\" title=\"TODO\"></a>TODO</h2><p>&#x2F;&#x2F; TODO 这里的 stabled 在 newlog 的时候赋值过一次，应该不会是 0 ，为什么会判断一次stabled<br>    if l.stabled &#x3D;&#x3D; 0 {<br>        return l.entries<br>        &#x2F;&#x2F; log.Infof(“stabled &#x3D; %d”, l.stabled)<br>    }<br> <br>&#x2F;&#x2F; TODO 什么时候 修改 committed </p>\n<blockquote>\n<p>sendAppend 时没有修改<br>handle AppendEntriesRespinse 时修改了。<br><a href=\"https://github.com/LX-676655103/Tinykv-2021/blob/course/raft/log.go\">https://github.com/LX-676655103/Tinykv-2021/blob/course/raft/log.go</a></p>\n</blockquote>\n<p>&#x2F;&#x2F; TODO 怎么处理 新 leader 中未 commit 的部分<br>？从当前的逻辑来看，只有 当前 term 也产生 log 时 才会顺便更新前面的log</p>\n<p>&#x2F;&#x2F; TODO 第一次收到 Lead 的消息时，需要进怎么样的处理</p>\n<p>&#x2F;&#x2F; TODO noop Entry 会发送吗，</p>\n<p>&#x2F;&#x2F; TODO r.Prs[r.id].Match 是  handlePropose 时修改。</p>\n<p>TODO  搞清楚  Next 和 Match 之间的关系。<br>TODO 快照的同步逻辑</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://github.com/LX-676655103/Tinykv-2021/blob/course/raft/raft.go#L967\">https://github.com/LX-676655103/Tinykv-2021/blob/course/raft/raft.go#L967</a><br><a href=\"https://github.com/sakura-ysy/TinyKV-2022-doc/\">https://github.com/sakura-ysy/TinyKV-2022-doc/</a></p>\n<p><a href=\"https://chenyunong.com/2021/08/04/TinyKV-Project2/\">https://chenyunong.com/2021/08/04/TinyKV-Project2/</a><br><a href=\"https://www.inlighting.org/archives/tinykv-project2\">https://www.inlighting.org/archives/tinykv-project2</a></p>\n"},{"_content":"不行：\nnohup docker compose up > /dev/null 2>&1 &\n行：\ndocker compose up -d\n121.48.161.86\n\n\n\n插如新的字典信息：\nINSERT INTO `File` (`filename`, `size`, `isSecret`, `fileType`, `accessGroupId`, `lineCount`) VALUES\n ('base01_~FFXXFF~.txt', 25705231224, 0 , 0 , 1, 1000000000),\n ('base02_~FFXXFF~.txt', 25705106232, 0 , 0 , 1, 1000000000),\n ('base03_~FFXXFF~.txt', 25705041692, 0 , 0 , 1, 1000000000),\n ('base04_~FFXXFF~.txt', 25704512508, 0 , 0 , 1, 1000000000),\n ('base05_~FFXXFF~.txt', 25704626392, 0 , 0 , 1, 1000000000),\n ('base06_~FFXXFF~.txt', 9911144907,   0 , 0 , 1, 385579419);\n\n1. 关于剩余时间的添加：\n2. 已运行时间/百分比，","source":"_posts/项目经历/MimaPJ/MMPJ 日志.md","raw":"不行：\nnohup docker compose up > /dev/null 2>&1 &\n行：\ndocker compose up -d\n121.48.161.86\n\n\n\n插如新的字典信息：\nINSERT INTO `File` (`filename`, `size`, `isSecret`, `fileType`, `accessGroupId`, `lineCount`) VALUES\n ('base01_~FFXXFF~.txt', 25705231224, 0 , 0 , 1, 1000000000),\n ('base02_~FFXXFF~.txt', 25705106232, 0 , 0 , 1, 1000000000),\n ('base03_~FFXXFF~.txt', 25705041692, 0 , 0 , 1, 1000000000),\n ('base04_~FFXXFF~.txt', 25704512508, 0 , 0 , 1, 1000000000),\n ('base05_~FFXXFF~.txt', 25704626392, 0 , 0 , 1, 1000000000),\n ('base06_~FFXXFF~.txt', 9911144907,   0 , 0 , 1, 385579419);\n\n1. 关于剩余时间的添加：\n2. 已运行时间/百分比，","slug":"项目经历/MimaPJ/MMPJ 日志","published":1,"date":"2024-04-22T13:14:49.243Z","updated":"2024-04-09T01:08:01.385Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0q002mkgg49oy83wh6","content":"<p>不行：<br>nohup docker compose up &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;<br>行：<br>docker compose up -d<br>121.48.161.86</p>\n<p>插如新的字典信息：<br>INSERT INTO <code>File</code> (<code>filename</code>, <code>size</code>, <code>isSecret</code>, <code>fileType</code>, <code>accessGroupId</code>, <code>lineCount</code>) VALUES<br> (‘base01_<del>FFXXFF</del>.txt’, 25705231224, 0 , 0 , 1, 1000000000),<br> (‘base02_<del>FFXXFF</del>.txt’, 25705106232, 0 , 0 , 1, 1000000000),<br> (‘base03_<del>FFXXFF</del>.txt’, 25705041692, 0 , 0 , 1, 1000000000),<br> (‘base04_<del>FFXXFF</del>.txt’, 25704512508, 0 , 0 , 1, 1000000000),<br> (‘base05_<del>FFXXFF</del>.txt’, 25704626392, 0 , 0 , 1, 1000000000),<br> (‘base06_<del>FFXXFF</del>.txt’, 9911144907,   0 , 0 , 1, 385579419);</p>\n<ol>\n<li>关于剩余时间的添加：</li>\n<li>已运行时间&#x2F;百分比，</li>\n</ol>\n","excerpt":"","more":"<p>不行：<br>nohup docker compose up &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;<br>行：<br>docker compose up -d<br>121.48.161.86</p>\n<p>插如新的字典信息：<br>INSERT INTO <code>File</code> (<code>filename</code>, <code>size</code>, <code>isSecret</code>, <code>fileType</code>, <code>accessGroupId</code>, <code>lineCount</code>) VALUES<br> (‘base01_<del>FFXXFF</del>.txt’, 25705231224, 0 , 0 , 1, 1000000000),<br> (‘base02_<del>FFXXFF</del>.txt’, 25705106232, 0 , 0 , 1, 1000000000),<br> (‘base03_<del>FFXXFF</del>.txt’, 25705041692, 0 , 0 , 1, 1000000000),<br> (‘base04_<del>FFXXFF</del>.txt’, 25704512508, 0 , 0 , 1, 1000000000),<br> (‘base05_<del>FFXXFF</del>.txt’, 25704626392, 0 , 0 , 1, 1000000000),<br> (‘base06_<del>FFXXFF</del>.txt’, 9911144907,   0 , 0 , 1, 385579419);</p>\n<ol>\n<li>关于剩余时间的添加：</li>\n<li>已运行时间&#x2F;百分比，</li>\n</ol>\n"},{"_content":"# 参考文档\n[Smith-Cruise/TinyKV-White-Paper: Tutorial for TinyKV project in Talent Plan. (github.com)](https://github.com/Smith-Cruise/TinyKV-White-Paper)\n[源码解析](https://cn.pingcap.com/blog/the-design-and-implementation-of-multi-raft/#raftstore)\n# Project2 RaftKV\n## 背景知识\n### Raft\n[[Raft 协议]]\n### Raft GC\nRaft GC 是指在 Raft 一致性算法中用于清理日志条目的过程。在 Raft 中，每个节点都会维护一个日志，用于记录系统状态的变化。当日志变得庞大时，执行一致性操作的成本也会增加。为了限制日志的大小并提高性能，Raft 使用 Raft GC 机制来清理已经提交（committed）的日志条目。\n\nRaft GC 的基本原则是，一旦某个日志条目已经被提交并应用到状态机，就可以安全地删除该条目之前的所有条目。删除旧的日志条目可以释放存储空间，并减少后续一致性操作的开销。Raft GC 通常通过一些策略（例如基于索引或时间）来判断哪些日志条目可以安全删除。\n### Snapshot（快照）\nRaft 中的快照是一种机制，用于在节点的状态机状态较新的情况下压缩和清理日志。当日志变得很大时，将整个日志传输给新加入的节点可能会很耗时和耗带宽。为了解决这个问题，Raft 使用快照机制来捕获节点的状态，并将其保存为一个快照文件。\n\n快照包含了节点在某个特定时间点的状态机状态。当新节点加入集群时，它可以通过获取最新的快照来快速将自己带到当前状态，并只追加日志中从快照之后的新条目。这样可以大大减少传输和恢复的开销。\n\n快照通常是通过在节点的状态机达到某个预定阈值时触发，或者通过节点之间的协商来创建。创建快照后，旧的日志条目可以被截断和删除，只保留最新的日志条目和快照文件。\n## 任务目标\n1. 实现基本的 raft 算法。\n2. 在 Raft 上构建容错 KV 服务器。\n3. 添加 Raft GC 和 snapshot 的支持。\n### Part A\n#### 代码\n 1. 代码位于 raft/\n 2. 使用逻辑时钟实现，选举和超时时间\n 3. 粗略阅读一下 eraftpb.proto ， 消息接收和发送的定义\n 4. 注意，这里与标准 Raft 协议不同，将 HeartBeat 和 AppendEntries 分成不同的消息。\n 5. 大致步骤：\n\t 1. Leader election\n\t 2. Log replication\n\t 3. Raw node interface\n\n#### 实现 Raft 算法\n1. `Raft/Raft.go` 提供了 Raft 算法的核心，包括消息处理、驱动逻辑时钟等。\n##### Leader 选举 \n1. `raft.Raft.tick()` 可以将内部时钟前移一个\n2. 发送消息时仅将消息推入`raft.Raft.msgs`，因为测试代码会从这个里面的消息然后使用 `raft.Raft.Step()` 处理回应消息\n3. make project2aa 测试。\n##### 日志复制\n1. 先在发送方和接收方实现处理 “MsgAppend” 和 “MsgAppendResponse” 。\n2. `raft/log.go` 中的 `raft.RaftLog` 是关键结构。\n3. 需要通过`raft/Storage.go`中定义的`Storage `接口与上层应用程序交互，以获取日志条目和快照等持久化数据。\n4. make project2ab 进行测试。\n\n#### 实现 Rawnode 接口\n `raft/rawnode.go` 中的 `raft.RawNode` 是与上层应用交互的接口。\n 1. 包含 `raft.Raft` ，封装了时钟相关： `RawNode.Tick()`and `RawNode.Step()`，日志 ：`RawNode.Propose()`\n 2. 包含一个新的 结构 `Ready`，处理消息或推进逻辑时钟时，`raft.Raft` 可能需要与上层应用程序交互，例如：\n\t- 向其他对等方发送消息\n\t- 将日志项保存到稳定的存储中\n\t- 保存硬状态（如术语），提交索引，并投票到稳定存储\n\t- 将提交的日志条目应用于状态机\n\t- 等\n\t交互不会立即发生，相反，它们被封装在 “Ready” 中，并由 “RawNode” 返回。`Ready（）`到上层应用程序。这取决于上层应用程序何时调用 `Ready（）`并进行处理。在处理完返回的 Ready 之后，上层应用程序还需要调用一些函数，如 `RawNode.Advance（）` 更新 `raft.Raft` 的内部状态，如应用索引、稳定日志索引等。\n\n3. “makeproject2ac” 来测试实现\n\n也可以运行 “make project2a” 来测试整个A部分。\n\n> 提示。\n>\n> - 需要时添加任何状态到 `raft.Raft`, `raft.RaftLog`, `raft.RawNode` 和消息，在`eraftpb.proto` 中\n> - 测试中假设初始的 term 0\n> - 测试中假设新选举的 Leader 应该在任期内添加一个 noop 条目。 \n> - 测试中假设一旦领导者推进其提交索引，它将通过 “MessageType_MsgAppend” 消息广播提交索引。\n> - 测试中不会为本地 Message，`MessageType_MsgHup`, `MessageType_MsgBeat` 和 `MessageType_MsgPropose` 添加 term 号, \n> - 领导者和非领导者的日志条目附加有很大不同，有不同的来源，检查和处理，请小心。\n> - 不要忘记，peers 之间的选举超时时间应该不同。\n> - rawnode.go 中的一些包装函数可以通过 raft.Step(local message) 来实现\n> - 当启动一个新的 raft 时，从`Storage`中获取最后的稳定状态来初始化`raft.Raft`和`raft.Raft Log` \n\n### Part B\n使用 part A 中 实现的 Raft 模块构建一个容错键值存储服务。\n1. 键/值服务将是一个复制状态机，由多个使用 Raft 进行复制的键/值服务器组成。\n2. 只要大多数服务器处于活动状态并且可以通信，尽管存在其他故障或网络分区，您的键/值服务就应该继续处理客户端请求。\n> 三个术语：“Store”、“Peer” 和 “Region”（定义在 “proto/proto/metapb.proto” 中）\n> - Store 代表tinykv-server 的一个实例\n> - Peer 代表在 Store 上运行的 Raft 节点\n >- Region是 Peers 的集合，也称为 Raft group (现在不需要考虑Region的范围。 项目3中将进一步引入多个区域。)\n\n#### 代码\n查看 `kv/storage/raft_storage/raft_server.go` 中的 `RaftStorage` ：实现了 `Storage` 接口（与 Project1 中的单机存储不同），首先将每个写入和读取请求发送到 Raft，然后在 Raft 提交请求后才对底层引擎进行实际的写入和读取。\n`RaftStorage` 创建一个 `Raftstore` 来驱动 Raft。 当调用 `Reader` 或 `Write` 函数时，它实际上通过通道（ 通道是“raftWorker”的“raftCh”），并在 Raft 提交并应用命令后返回响应。 Reader 和 Write 函数的 kvrpc.Context 参数现在很有用，它从客户端的角度携带 Region 信息，并作为 RaftCmdRequest 的 header 传递。 这些信息可能不正确或过时，因此 raftstore 需要检查它们并决定是否提出请求。\n接下来，就到了TinyKV的核心——raftstore。 结构有点复杂，阅读 TiKV 参考资料可以更好地理解设计：\n\n- <https://pingcap.com/blog-cn/the-design-and-implementation-of-multi-raft/#raftstore>（中文版）\n- <https://pingcap.com/blog/design-and-implementation-of-multi-raft/#raftstore>（英文版）\n\nraftstore 的入口是 `Raftstore`，参见`kv/raftstore/raftstore.go`。 它启动一些工作线程异步处理特定任务，其中大多数现在不使用，因此您可以忽略它们。 你需要关注的是`raftWorker`。(kv/raftstore/raft_worker.go)\n\n整个过程分为两部分：raftworker 轮询 “raftCh” 以获取消息，包括驱动 Raft 模块的基本 tick 和建议作为 Raft 条目的 Raft 命令； 它从 Raft 模块获取并处理就绪，包括发送 raft 消息、持久化状态、将提交的条目应用到状态机。 申请后，将响应返回给客户。\n\n#### 实现对等存储 peer storage\n对等存储是您通过 A 部分中的 “Storage”  接口进行交互的内容，但除了 raft 日志之外，对等存储还管理其他持久化元数据，这对于重启后恢复一致状态机非常重要\n> `proto/proto/raft_serverpb.proto` 中定义了三个重要的状态：\n\n- RaftLocalState：用于存储当前 Raft 的 HardState 和最后一个 Log Index。\n- RaftApplyState：用于存储 Raft 最后应用的 Log 索引以及一些被截断的 Log 信息。\n- RegionLocalState：用于存储 Region 信息以及该 Store 上对应的 Peer 状态。 Normal 表示该 Peer 正常，Tombstone 表示该 Peer 已从 Region 中移除，无法加入 Raft Group。\n这些状态存储在两个 badger 实例中：raftdb 和 kvdb：\n- raftdb 存储 raft 日志和 `RaftLocalState`\n- kvdb 将键值数据存储在不同的列族 “RegionLocalState” 和 “RaftApplyState” 中。 可以把kvdb看成Raft论文中提到的状态机\n> why?\n> 实际上，可以只使用一个 badger 来存储 raft 日志和状态机数据。 分成两个实例只是为了与 TiKV 设计保持一致。\n\n| Key               | KeyFormat                        | Value             | DB   |\n| :---------------- | :------------------------------- | :---------------- | :--- |\n| raft_log_key      | 0x01 0x02 region_id 0x01 log_idx | Entry             | raft |\n| raft_state_key    | 0x01 0x02 region_id 0x02         | RaftLocalState    | raft |\n| apply_state_key   | 0x01 0x02 region_id 0x03         | RaftApplyState    | kv   |\n| region_state_key  | 0x01 0x03 region_id 0x01         | RegionLocalState  | kv   |\n这些元数据应该在 “PeerStorage” 中创建和更新。 创建 PeerStorage 时，请参阅 “kv/raftstore/peer_storage.go”。 它会初始化该 Peer 的RaftLocalState、RaftApplyState，或者重启时从底层引擎获取之前的值。 注意，RAFT_INIT_LOG_TERM 和 RAFT_INIT_LOG_INDEX 的值都是 5（只要大于 1），而不是 0。之所以不设置为 0，是为了与 conf 更改后被动创建 Peer 的情况区别。 你现在可能还不太明白，所以请记住这一点，当你实现 conf 更改时，详细信息将在project3b 中描述。\n\n这部分需要实现的代码只有一个函数：`PeerStorage.SaveReadyState`，该函数的作用是将 `raft.Ready` 中的数据保存到 badger 中，包括追加日志条目和保存 Raft 硬状态。\n\n>硬状态：更新 `RaftLocalState.HardState` 并保存。\n\n要追加日志条目，只需将 “raft.Ready.Entries” 中的所有日志条目保存到 raftdb 并删除任何以前追加的永远不会提交的日志条目。 另外，更新对等存储的 “RaftLocalState”并将其保存到 raftdb。\n> 提示：\n> - 使用 `WriteBatch` 立即保存这些状态。\n> - 有关如何读取和写入这些状态的信息，请参阅 `peer_storage.go` 中的其他函数。\n> - 设置环境变量 LOG_LEVEL=debug 这可以帮助您进行调试，另请参阅所有可用的[日志级别](../log/log.go)。\n\n### 实施 Raft Ready 流程\n在 Part A 部分，构建了一个基于 tick 的 Raft 模块。 现在您需要编写外部进程来驱动它。 大部分代码已经在 `kv/raftstore/peer_msg_handler.go` 和 `kv/raftstore/peer.go` 下实现。 所以你需要学习代码并完成 `proposeRaftCommand` 和 `HandleRaftReady` 的逻辑。 以下是对该框架的一些解释。\n\nRaft “RawNode” 已使用 “PeerStorage” 创建并存储在 “peer” 中。 在 Raft Worker 中，您可以看到它采用 “peer” 并通过 “peerMsgHandler” 包装它。  `peerMsgHandler` 主要有两个功能：一是 `HandleMsg` ，另一个是 `HandleRaftReady`。\n\n`HandleMsg` 处理从 raftCh 接收到的所有消息，包括 `MsgTypeTick` 调用 `RawNode.Tick()` 来驱动 Raft，`MsgTypeRaftCmd` 包装来自客户端的请求，以及 `MsgTypeRaftMessage` 是 Raft 对等点之间传输的消息 。 所有消息类型都在 `kv/raftstore/message/msg.go` 中定义。 具体大家可以查看一下，其中一些会在后面的部分用到。\n\n消息处理完毕后，Raft 节点应该有一些状态更新。 因此 `HandleRaftReady` 应该从 Raft 模块中做好准备并执行相应的操作，例如持久化日志条目、应用提交的条目\n并通过网络向其他对等点发送 raft 消息。\n\n在伪代码中，raftstore 使用 Raft，如下所示：\n\n``` go\nfor {\n  select {\n  case <-s.Ticker:\n    Node.Tick()\n  default:\n    if Node.HasReady() {\n      rd := Node.Ready()\n      saveToStorage(rd.State, rd.Entries, rd.Snapshot)\n      send(rd.Messages)\n      for _, entry := range rd.CommittedEntries {\n        process(entry)\n      }\n      s.Node.Advance(rd)\n    }\n}\n```   \n\n之后读取或写入的整个过程将是这样的：\n\n- 客户端调用RPC RawGet/RawPut/RawDelete/RawScan\n- RPC处理程序调用`RaftStorage`相关方法\n- `RaftStorage` 向 raftstore 发送 Raft 命令请求，并等待响应\n- `RaftStore` 将 Raft 命令请求作为 Raft 日志提出\n- Raft模块追加日志，并通过`PeerStorage`持久化\n- Raft模块提交日志\n- Raft Worker在Raft准备就绪时执行Raft命令，并通过回调返回响应\n- `RaftStorage` 接收回调的响应并返回到 RPC 处理程序\n- RPC 处理程序执行一些操作并将 RPC 响应返回给客户端。\n\n您应该运行“make project2b”来通过所有测试。 整个测试运行一个模拟集群，包括多个带有模拟网络的 TinyKV 实例。 它执行一些读写操作并检查返回值是否符合预期。\n\n需要注意的是，错误处理是通过测试的重要组成部分。 您可能已经注意到“proto/proto/errorpb.proto”中定义了一些错误，并且错误是 gRPC 响应的一个字段。 另外，实现了 error 接口的相应错误定义在 kv/raftstore/util/error.go 中，因此您可以将它们用作函数的返回值。\n\n这些错误主要与Region有关。 所以它也是`RaftCmdResponse`的`RaftResponseHeader`的成员。 当提出请求或应用命令时，可能会出现一些错误。 如果是这样，您应该返回带有错误的 raft 命令响应，然后错误将进一步传递给 gRPC 响应。 当返回带有错误的响应时，您可以使用 kv/raftstore/cmd_resp.go 中提供的 BindRespError 将这些错误转换为 errorpb.proto 中定义的错误。\n\n在这个阶段，你可能会考虑这些错误，其他的将在 project3 中处理：\n\n- ErrNotLeader：在跟随者上提议 raft 命令。 所以用它来让客户端尝试其他对等点。\n- ErrStaleCommand：可能由于领导者更改，某些日志未提交并被新领导者的日志覆盖。 但客户并不知道这一点，仍在等待回复。 因此，您应该返回此信息以让客户端知道并再次重试该命令。\n\n\n# TODO\n> why\nRAFT_INIT_LOG_TERM 和 RAFT_INIT_LOG_INDEX 的值都是 5（只要大于 1）\n\n> Config.Applied uint64 干嘛用的","source":"_posts/项目经历/TinyKV/TinyKV 项目要求.md","raw":"# 参考文档\n[Smith-Cruise/TinyKV-White-Paper: Tutorial for TinyKV project in Talent Plan. (github.com)](https://github.com/Smith-Cruise/TinyKV-White-Paper)\n[源码解析](https://cn.pingcap.com/blog/the-design-and-implementation-of-multi-raft/#raftstore)\n# Project2 RaftKV\n## 背景知识\n### Raft\n[[Raft 协议]]\n### Raft GC\nRaft GC 是指在 Raft 一致性算法中用于清理日志条目的过程。在 Raft 中，每个节点都会维护一个日志，用于记录系统状态的变化。当日志变得庞大时，执行一致性操作的成本也会增加。为了限制日志的大小并提高性能，Raft 使用 Raft GC 机制来清理已经提交（committed）的日志条目。\n\nRaft GC 的基本原则是，一旦某个日志条目已经被提交并应用到状态机，就可以安全地删除该条目之前的所有条目。删除旧的日志条目可以释放存储空间，并减少后续一致性操作的开销。Raft GC 通常通过一些策略（例如基于索引或时间）来判断哪些日志条目可以安全删除。\n### Snapshot（快照）\nRaft 中的快照是一种机制，用于在节点的状态机状态较新的情况下压缩和清理日志。当日志变得很大时，将整个日志传输给新加入的节点可能会很耗时和耗带宽。为了解决这个问题，Raft 使用快照机制来捕获节点的状态，并将其保存为一个快照文件。\n\n快照包含了节点在某个特定时间点的状态机状态。当新节点加入集群时，它可以通过获取最新的快照来快速将自己带到当前状态，并只追加日志中从快照之后的新条目。这样可以大大减少传输和恢复的开销。\n\n快照通常是通过在节点的状态机达到某个预定阈值时触发，或者通过节点之间的协商来创建。创建快照后，旧的日志条目可以被截断和删除，只保留最新的日志条目和快照文件。\n## 任务目标\n1. 实现基本的 raft 算法。\n2. 在 Raft 上构建容错 KV 服务器。\n3. 添加 Raft GC 和 snapshot 的支持。\n### Part A\n#### 代码\n 1. 代码位于 raft/\n 2. 使用逻辑时钟实现，选举和超时时间\n 3. 粗略阅读一下 eraftpb.proto ， 消息接收和发送的定义\n 4. 注意，这里与标准 Raft 协议不同，将 HeartBeat 和 AppendEntries 分成不同的消息。\n 5. 大致步骤：\n\t 1. Leader election\n\t 2. Log replication\n\t 3. Raw node interface\n\n#### 实现 Raft 算法\n1. `Raft/Raft.go` 提供了 Raft 算法的核心，包括消息处理、驱动逻辑时钟等。\n##### Leader 选举 \n1. `raft.Raft.tick()` 可以将内部时钟前移一个\n2. 发送消息时仅将消息推入`raft.Raft.msgs`，因为测试代码会从这个里面的消息然后使用 `raft.Raft.Step()` 处理回应消息\n3. make project2aa 测试。\n##### 日志复制\n1. 先在发送方和接收方实现处理 “MsgAppend” 和 “MsgAppendResponse” 。\n2. `raft/log.go` 中的 `raft.RaftLog` 是关键结构。\n3. 需要通过`raft/Storage.go`中定义的`Storage `接口与上层应用程序交互，以获取日志条目和快照等持久化数据。\n4. make project2ab 进行测试。\n\n#### 实现 Rawnode 接口\n `raft/rawnode.go` 中的 `raft.RawNode` 是与上层应用交互的接口。\n 1. 包含 `raft.Raft` ，封装了时钟相关： `RawNode.Tick()`and `RawNode.Step()`，日志 ：`RawNode.Propose()`\n 2. 包含一个新的 结构 `Ready`，处理消息或推进逻辑时钟时，`raft.Raft` 可能需要与上层应用程序交互，例如：\n\t- 向其他对等方发送消息\n\t- 将日志项保存到稳定的存储中\n\t- 保存硬状态（如术语），提交索引，并投票到稳定存储\n\t- 将提交的日志条目应用于状态机\n\t- 等\n\t交互不会立即发生，相反，它们被封装在 “Ready” 中，并由 “RawNode” 返回。`Ready（）`到上层应用程序。这取决于上层应用程序何时调用 `Ready（）`并进行处理。在处理完返回的 Ready 之后，上层应用程序还需要调用一些函数，如 `RawNode.Advance（）` 更新 `raft.Raft` 的内部状态，如应用索引、稳定日志索引等。\n\n3. “makeproject2ac” 来测试实现\n\n也可以运行 “make project2a” 来测试整个A部分。\n\n> 提示。\n>\n> - 需要时添加任何状态到 `raft.Raft`, `raft.RaftLog`, `raft.RawNode` 和消息，在`eraftpb.proto` 中\n> - 测试中假设初始的 term 0\n> - 测试中假设新选举的 Leader 应该在任期内添加一个 noop 条目。 \n> - 测试中假设一旦领导者推进其提交索引，它将通过 “MessageType_MsgAppend” 消息广播提交索引。\n> - 测试中不会为本地 Message，`MessageType_MsgHup`, `MessageType_MsgBeat` 和 `MessageType_MsgPropose` 添加 term 号, \n> - 领导者和非领导者的日志条目附加有很大不同，有不同的来源，检查和处理，请小心。\n> - 不要忘记，peers 之间的选举超时时间应该不同。\n> - rawnode.go 中的一些包装函数可以通过 raft.Step(local message) 来实现\n> - 当启动一个新的 raft 时，从`Storage`中获取最后的稳定状态来初始化`raft.Raft`和`raft.Raft Log` \n\n### Part B\n使用 part A 中 实现的 Raft 模块构建一个容错键值存储服务。\n1. 键/值服务将是一个复制状态机，由多个使用 Raft 进行复制的键/值服务器组成。\n2. 只要大多数服务器处于活动状态并且可以通信，尽管存在其他故障或网络分区，您的键/值服务就应该继续处理客户端请求。\n> 三个术语：“Store”、“Peer” 和 “Region”（定义在 “proto/proto/metapb.proto” 中）\n> - Store 代表tinykv-server 的一个实例\n> - Peer 代表在 Store 上运行的 Raft 节点\n >- Region是 Peers 的集合，也称为 Raft group (现在不需要考虑Region的范围。 项目3中将进一步引入多个区域。)\n\n#### 代码\n查看 `kv/storage/raft_storage/raft_server.go` 中的 `RaftStorage` ：实现了 `Storage` 接口（与 Project1 中的单机存储不同），首先将每个写入和读取请求发送到 Raft，然后在 Raft 提交请求后才对底层引擎进行实际的写入和读取。\n`RaftStorage` 创建一个 `Raftstore` 来驱动 Raft。 当调用 `Reader` 或 `Write` 函数时，它实际上通过通道（ 通道是“raftWorker”的“raftCh”），并在 Raft 提交并应用命令后返回响应。 Reader 和 Write 函数的 kvrpc.Context 参数现在很有用，它从客户端的角度携带 Region 信息，并作为 RaftCmdRequest 的 header 传递。 这些信息可能不正确或过时，因此 raftstore 需要检查它们并决定是否提出请求。\n接下来，就到了TinyKV的核心——raftstore。 结构有点复杂，阅读 TiKV 参考资料可以更好地理解设计：\n\n- <https://pingcap.com/blog-cn/the-design-and-implementation-of-multi-raft/#raftstore>（中文版）\n- <https://pingcap.com/blog/design-and-implementation-of-multi-raft/#raftstore>（英文版）\n\nraftstore 的入口是 `Raftstore`，参见`kv/raftstore/raftstore.go`。 它启动一些工作线程异步处理特定任务，其中大多数现在不使用，因此您可以忽略它们。 你需要关注的是`raftWorker`。(kv/raftstore/raft_worker.go)\n\n整个过程分为两部分：raftworker 轮询 “raftCh” 以获取消息，包括驱动 Raft 模块的基本 tick 和建议作为 Raft 条目的 Raft 命令； 它从 Raft 模块获取并处理就绪，包括发送 raft 消息、持久化状态、将提交的条目应用到状态机。 申请后，将响应返回给客户。\n\n#### 实现对等存储 peer storage\n对等存储是您通过 A 部分中的 “Storage”  接口进行交互的内容，但除了 raft 日志之外，对等存储还管理其他持久化元数据，这对于重启后恢复一致状态机非常重要\n> `proto/proto/raft_serverpb.proto` 中定义了三个重要的状态：\n\n- RaftLocalState：用于存储当前 Raft 的 HardState 和最后一个 Log Index。\n- RaftApplyState：用于存储 Raft 最后应用的 Log 索引以及一些被截断的 Log 信息。\n- RegionLocalState：用于存储 Region 信息以及该 Store 上对应的 Peer 状态。 Normal 表示该 Peer 正常，Tombstone 表示该 Peer 已从 Region 中移除，无法加入 Raft Group。\n这些状态存储在两个 badger 实例中：raftdb 和 kvdb：\n- raftdb 存储 raft 日志和 `RaftLocalState`\n- kvdb 将键值数据存储在不同的列族 “RegionLocalState” 和 “RaftApplyState” 中。 可以把kvdb看成Raft论文中提到的状态机\n> why?\n> 实际上，可以只使用一个 badger 来存储 raft 日志和状态机数据。 分成两个实例只是为了与 TiKV 设计保持一致。\n\n| Key               | KeyFormat                        | Value             | DB   |\n| :---------------- | :------------------------------- | :---------------- | :--- |\n| raft_log_key      | 0x01 0x02 region_id 0x01 log_idx | Entry             | raft |\n| raft_state_key    | 0x01 0x02 region_id 0x02         | RaftLocalState    | raft |\n| apply_state_key   | 0x01 0x02 region_id 0x03         | RaftApplyState    | kv   |\n| region_state_key  | 0x01 0x03 region_id 0x01         | RegionLocalState  | kv   |\n这些元数据应该在 “PeerStorage” 中创建和更新。 创建 PeerStorage 时，请参阅 “kv/raftstore/peer_storage.go”。 它会初始化该 Peer 的RaftLocalState、RaftApplyState，或者重启时从底层引擎获取之前的值。 注意，RAFT_INIT_LOG_TERM 和 RAFT_INIT_LOG_INDEX 的值都是 5（只要大于 1），而不是 0。之所以不设置为 0，是为了与 conf 更改后被动创建 Peer 的情况区别。 你现在可能还不太明白，所以请记住这一点，当你实现 conf 更改时，详细信息将在project3b 中描述。\n\n这部分需要实现的代码只有一个函数：`PeerStorage.SaveReadyState`，该函数的作用是将 `raft.Ready` 中的数据保存到 badger 中，包括追加日志条目和保存 Raft 硬状态。\n\n>硬状态：更新 `RaftLocalState.HardState` 并保存。\n\n要追加日志条目，只需将 “raft.Ready.Entries” 中的所有日志条目保存到 raftdb 并删除任何以前追加的永远不会提交的日志条目。 另外，更新对等存储的 “RaftLocalState”并将其保存到 raftdb。\n> 提示：\n> - 使用 `WriteBatch` 立即保存这些状态。\n> - 有关如何读取和写入这些状态的信息，请参阅 `peer_storage.go` 中的其他函数。\n> - 设置环境变量 LOG_LEVEL=debug 这可以帮助您进行调试，另请参阅所有可用的[日志级别](../log/log.go)。\n\n### 实施 Raft Ready 流程\n在 Part A 部分，构建了一个基于 tick 的 Raft 模块。 现在您需要编写外部进程来驱动它。 大部分代码已经在 `kv/raftstore/peer_msg_handler.go` 和 `kv/raftstore/peer.go` 下实现。 所以你需要学习代码并完成 `proposeRaftCommand` 和 `HandleRaftReady` 的逻辑。 以下是对该框架的一些解释。\n\nRaft “RawNode” 已使用 “PeerStorage” 创建并存储在 “peer” 中。 在 Raft Worker 中，您可以看到它采用 “peer” 并通过 “peerMsgHandler” 包装它。  `peerMsgHandler` 主要有两个功能：一是 `HandleMsg` ，另一个是 `HandleRaftReady`。\n\n`HandleMsg` 处理从 raftCh 接收到的所有消息，包括 `MsgTypeTick` 调用 `RawNode.Tick()` 来驱动 Raft，`MsgTypeRaftCmd` 包装来自客户端的请求，以及 `MsgTypeRaftMessage` 是 Raft 对等点之间传输的消息 。 所有消息类型都在 `kv/raftstore/message/msg.go` 中定义。 具体大家可以查看一下，其中一些会在后面的部分用到。\n\n消息处理完毕后，Raft 节点应该有一些状态更新。 因此 `HandleRaftReady` 应该从 Raft 模块中做好准备并执行相应的操作，例如持久化日志条目、应用提交的条目\n并通过网络向其他对等点发送 raft 消息。\n\n在伪代码中，raftstore 使用 Raft，如下所示：\n\n``` go\nfor {\n  select {\n  case <-s.Ticker:\n    Node.Tick()\n  default:\n    if Node.HasReady() {\n      rd := Node.Ready()\n      saveToStorage(rd.State, rd.Entries, rd.Snapshot)\n      send(rd.Messages)\n      for _, entry := range rd.CommittedEntries {\n        process(entry)\n      }\n      s.Node.Advance(rd)\n    }\n}\n```   \n\n之后读取或写入的整个过程将是这样的：\n\n- 客户端调用RPC RawGet/RawPut/RawDelete/RawScan\n- RPC处理程序调用`RaftStorage`相关方法\n- `RaftStorage` 向 raftstore 发送 Raft 命令请求，并等待响应\n- `RaftStore` 将 Raft 命令请求作为 Raft 日志提出\n- Raft模块追加日志，并通过`PeerStorage`持久化\n- Raft模块提交日志\n- Raft Worker在Raft准备就绪时执行Raft命令，并通过回调返回响应\n- `RaftStorage` 接收回调的响应并返回到 RPC 处理程序\n- RPC 处理程序执行一些操作并将 RPC 响应返回给客户端。\n\n您应该运行“make project2b”来通过所有测试。 整个测试运行一个模拟集群，包括多个带有模拟网络的 TinyKV 实例。 它执行一些读写操作并检查返回值是否符合预期。\n\n需要注意的是，错误处理是通过测试的重要组成部分。 您可能已经注意到“proto/proto/errorpb.proto”中定义了一些错误，并且错误是 gRPC 响应的一个字段。 另外，实现了 error 接口的相应错误定义在 kv/raftstore/util/error.go 中，因此您可以将它们用作函数的返回值。\n\n这些错误主要与Region有关。 所以它也是`RaftCmdResponse`的`RaftResponseHeader`的成员。 当提出请求或应用命令时，可能会出现一些错误。 如果是这样，您应该返回带有错误的 raft 命令响应，然后错误将进一步传递给 gRPC 响应。 当返回带有错误的响应时，您可以使用 kv/raftstore/cmd_resp.go 中提供的 BindRespError 将这些错误转换为 errorpb.proto 中定义的错误。\n\n在这个阶段，你可能会考虑这些错误，其他的将在 project3 中处理：\n\n- ErrNotLeader：在跟随者上提议 raft 命令。 所以用它来让客户端尝试其他对等点。\n- ErrStaleCommand：可能由于领导者更改，某些日志未提交并被新领导者的日志覆盖。 但客户并不知道这一点，仍在等待回复。 因此，您应该返回此信息以让客户端知道并再次重试该命令。\n\n\n# TODO\n> why\nRAFT_INIT_LOG_TERM 和 RAFT_INIT_LOG_INDEX 的值都是 5（只要大于 1）\n\n> Config.Applied uint64 干嘛用的","slug":"项目经历/TinyKV/TinyKV 项目要求","published":1,"date":"2024-04-22T13:14:49.258Z","updated":"2024-04-21T08:35:37.176Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0r002nkgg40vg6e4bk","content":"<h1 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h1><p><a href=\"https://github.com/Smith-Cruise/TinyKV-White-Paper\">Smith-Cruise&#x2F;TinyKV-White-Paper: Tutorial for TinyKV project in Talent Plan. (github.com)</a><br><a href=\"https://cn.pingcap.com/blog/the-design-and-implementation-of-multi-raft/#raftstore\">源码解析</a></p>\n<h1 id=\"Project2-RaftKV\"><a href=\"#Project2-RaftKV\" class=\"headerlink\" title=\"Project2 RaftKV\"></a>Project2 RaftKV</h1><h2 id=\"背景知识\"><a href=\"#背景知识\" class=\"headerlink\" title=\"背景知识\"></a>背景知识</h2><h3 id=\"Raft\"><a href=\"#Raft\" class=\"headerlink\" title=\"Raft\"></a>Raft</h3><p>[[Raft 协议]]</p>\n<h3 id=\"Raft-GC\"><a href=\"#Raft-GC\" class=\"headerlink\" title=\"Raft GC\"></a>Raft GC</h3><p>Raft GC 是指在 Raft 一致性算法中用于清理日志条目的过程。在 Raft 中，每个节点都会维护一个日志，用于记录系统状态的变化。当日志变得庞大时，执行一致性操作的成本也会增加。为了限制日志的大小并提高性能，Raft 使用 Raft GC 机制来清理已经提交（committed）的日志条目。</p>\n<p>Raft GC 的基本原则是，一旦某个日志条目已经被提交并应用到状态机，就可以安全地删除该条目之前的所有条目。删除旧的日志条目可以释放存储空间，并减少后续一致性操作的开销。Raft GC 通常通过一些策略（例如基于索引或时间）来判断哪些日志条目可以安全删除。</p>\n<h3 id=\"Snapshot（快照）\"><a href=\"#Snapshot（快照）\" class=\"headerlink\" title=\"Snapshot（快照）\"></a>Snapshot（快照）</h3><p>Raft 中的快照是一种机制，用于在节点的状态机状态较新的情况下压缩和清理日志。当日志变得很大时，将整个日志传输给新加入的节点可能会很耗时和耗带宽。为了解决这个问题，Raft 使用快照机制来捕获节点的状态，并将其保存为一个快照文件。</p>\n<p>快照包含了节点在某个特定时间点的状态机状态。当新节点加入集群时，它可以通过获取最新的快照来快速将自己带到当前状态，并只追加日志中从快照之后的新条目。这样可以大大减少传输和恢复的开销。</p>\n<p>快照通常是通过在节点的状态机达到某个预定阈值时触发，或者通过节点之间的协商来创建。创建快照后，旧的日志条目可以被截断和删除，只保留最新的日志条目和快照文件。</p>\n<h2 id=\"任务目标\"><a href=\"#任务目标\" class=\"headerlink\" title=\"任务目标\"></a>任务目标</h2><ol>\n<li>实现基本的 raft 算法。</li>\n<li>在 Raft 上构建容错 KV 服务器。</li>\n<li>添加 Raft GC 和 snapshot 的支持。</li>\n</ol>\n<h3 id=\"Part-A\"><a href=\"#Part-A\" class=\"headerlink\" title=\"Part A\"></a>Part A</h3><h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><ol>\n<li>代码位于 raft&#x2F;</li>\n<li>使用逻辑时钟实现，选举和超时时间</li>\n<li>粗略阅读一下 eraftpb.proto ， 消息接收和发送的定义</li>\n<li>注意，这里与标准 Raft 协议不同，将 HeartBeat 和 AppendEntries 分成不同的消息。</li>\n<li>大致步骤：<ol>\n<li>Leader election</li>\n<li>Log replication</li>\n<li>Raw node interface</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"实现-Raft-算法\"><a href=\"#实现-Raft-算法\" class=\"headerlink\" title=\"实现 Raft 算法\"></a>实现 Raft 算法</h4><ol>\n<li><code>Raft/Raft.go</code> 提供了 Raft 算法的核心，包括消息处理、驱动逻辑时钟等。</li>\n</ol>\n<h5 id=\"Leader-选举\"><a href=\"#Leader-选举\" class=\"headerlink\" title=\"Leader 选举\"></a>Leader 选举</h5><ol>\n<li><code>raft.Raft.tick()</code> 可以将内部时钟前移一个</li>\n<li>发送消息时仅将消息推入<code>raft.Raft.msgs</code>，因为测试代码会从这个里面的消息然后使用 <code>raft.Raft.Step()</code> 处理回应消息</li>\n<li>make project2aa 测试。</li>\n</ol>\n<h5 id=\"日志复制\"><a href=\"#日志复制\" class=\"headerlink\" title=\"日志复制\"></a>日志复制</h5><ol>\n<li>先在发送方和接收方实现处理 “MsgAppend” 和 “MsgAppendResponse” 。</li>\n<li><code>raft/log.go</code> 中的 <code>raft.RaftLog</code> 是关键结构。</li>\n<li>需要通过<code>raft/Storage.go</code>中定义的<code>Storage </code>接口与上层应用程序交互，以获取日志条目和快照等持久化数据。</li>\n<li>make project2ab 进行测试。</li>\n</ol>\n<h4 id=\"实现-Rawnode-接口\"><a href=\"#实现-Rawnode-接口\" class=\"headerlink\" title=\"实现 Rawnode 接口\"></a>实现 Rawnode 接口</h4><p> <code>raft/rawnode.go</code> 中的 <code>raft.RawNode</code> 是与上层应用交互的接口。</p>\n<ol>\n<li><p>包含 <code>raft.Raft</code> ，封装了时钟相关： <code>RawNode.Tick()</code>and <code>RawNode.Step()</code>，日志 ：<code>RawNode.Propose()</code></p>\n</li>\n<li><p>包含一个新的 结构 <code>Ready</code>，处理消息或推进逻辑时钟时，<code>raft.Raft</code> 可能需要与上层应用程序交互，例如：</p>\n<ul>\n<li>向其他对等方发送消息</li>\n<li>将日志项保存到稳定的存储中</li>\n<li>保存硬状态（如术语），提交索引，并投票到稳定存储</li>\n<li>将提交的日志条目应用于状态机</li>\n<li>等<br>交互不会立即发生，相反，它们被封装在 “Ready” 中，并由 “RawNode” 返回。<code>Ready（）</code>到上层应用程序。这取决于上层应用程序何时调用 <code>Ready（）</code>并进行处理。在处理完返回的 Ready 之后，上层应用程序还需要调用一些函数，如 <code>RawNode.Advance（）</code> 更新 <code>raft.Raft</code> 的内部状态，如应用索引、稳定日志索引等。</li>\n</ul>\n</li>\n<li><p>“makeproject2ac” 来测试实现</p>\n</li>\n</ol>\n<p>也可以运行 “make project2a” 来测试整个A部分。</p>\n<blockquote>\n<p>提示。</p>\n<ul>\n<li>需要时添加任何状态到 <code>raft.Raft</code>, <code>raft.RaftLog</code>, <code>raft.RawNode</code> 和消息，在<code>eraftpb.proto</code> 中</li>\n<li>测试中假设初始的 term 0</li>\n<li>测试中假设新选举的 Leader 应该在任期内添加一个 noop 条目。 </li>\n<li>测试中假设一旦领导者推进其提交索引，它将通过 “MessageType_MsgAppend” 消息广播提交索引。</li>\n<li>测试中不会为本地 Message，<code>MessageType_MsgHup</code>, <code>MessageType_MsgBeat</code> 和 <code>MessageType_MsgPropose</code> 添加 term 号, </li>\n<li>领导者和非领导者的日志条目附加有很大不同，有不同的来源，检查和处理，请小心。</li>\n<li>不要忘记，peers 之间的选举超时时间应该不同。</li>\n<li>rawnode.go 中的一些包装函数可以通过 raft.Step(local message) 来实现</li>\n<li>当启动一个新的 raft 时，从<code>Storage</code>中获取最后的稳定状态来初始化<code>raft.Raft</code>和<code>raft.Raft Log</code></li>\n</ul>\n</blockquote>\n<h3 id=\"Part-B\"><a href=\"#Part-B\" class=\"headerlink\" title=\"Part B\"></a>Part B</h3><p>使用 part A 中 实现的 Raft 模块构建一个容错键值存储服务。</p>\n<ol>\n<li>键&#x2F;值服务将是一个复制状态机，由多个使用 Raft 进行复制的键&#x2F;值服务器组成。</li>\n<li>只要大多数服务器处于活动状态并且可以通信，尽管存在其他故障或网络分区，您的键&#x2F;值服务就应该继续处理客户端请求。<blockquote>\n<p>三个术语：“Store”、“Peer” 和 “Region”（定义在 “proto&#x2F;proto&#x2F;metapb.proto” 中）</p>\n<ul>\n<li>Store 代表tinykv-server 的一个实例</li>\n<li>Peer 代表在 Store 上运行的 Raft 节点</li>\n<li>Region是 Peers 的集合，也称为 Raft group (现在不需要考虑Region的范围。 项目3中将进一步引入多个区域。)</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p>查看 <code>kv/storage/raft_storage/raft_server.go</code> 中的 <code>RaftStorage</code> ：实现了 <code>Storage</code> 接口（与 Project1 中的单机存储不同），首先将每个写入和读取请求发送到 Raft，然后在 Raft 提交请求后才对底层引擎进行实际的写入和读取。<br><code>RaftStorage</code> 创建一个 <code>Raftstore</code> 来驱动 Raft。 当调用 <code>Reader</code> 或 <code>Write</code> 函数时，它实际上通过通道（ 通道是“raftWorker”的“raftCh”），并在 Raft 提交并应用命令后返回响应。 Reader 和 Write 函数的 kvrpc.Context 参数现在很有用，它从客户端的角度携带 Region 信息，并作为 RaftCmdRequest 的 header 传递。 这些信息可能不正确或过时，因此 raftstore 需要检查它们并决定是否提出请求。<br>接下来，就到了TinyKV的核心——raftstore。 结构有点复杂，阅读 TiKV 参考资料可以更好地理解设计：</p>\n<ul>\n<li><a href=\"https://pingcap.com/blog-cn/the-design-and-implementation-of-multi-raft/#raftstore\">https://pingcap.com/blog-cn/the-design-and-implementation-of-multi-raft/#raftstore</a>（中文版）</li>\n<li><a href=\"https://pingcap.com/blog/design-and-implementation-of-multi-raft/#raftstore\">https://pingcap.com/blog/design-and-implementation-of-multi-raft/#raftstore</a>（英文版）</li>\n</ul>\n<p>raftstore 的入口是 <code>Raftstore</code>，参见<code>kv/raftstore/raftstore.go</code>。 它启动一些工作线程异步处理特定任务，其中大多数现在不使用，因此您可以忽略它们。 你需要关注的是<code>raftWorker</code>。(kv&#x2F;raftstore&#x2F;raft_worker.go)</p>\n<p>整个过程分为两部分：raftworker 轮询 “raftCh” 以获取消息，包括驱动 Raft 模块的基本 tick 和建议作为 Raft 条目的 Raft 命令； 它从 Raft 模块获取并处理就绪，包括发送 raft 消息、持久化状态、将提交的条目应用到状态机。 申请后，将响应返回给客户。</p>\n<h4 id=\"实现对等存储-peer-storage\"><a href=\"#实现对等存储-peer-storage\" class=\"headerlink\" title=\"实现对等存储 peer storage\"></a>实现对等存储 peer storage</h4><p>对等存储是您通过 A 部分中的 “Storage”  接口进行交互的内容，但除了 raft 日志之外，对等存储还管理其他持久化元数据，这对于重启后恢复一致状态机非常重要</p>\n<blockquote>\n<p><code>proto/proto/raft_serverpb.proto</code> 中定义了三个重要的状态：</p>\n</blockquote>\n<ul>\n<li>RaftLocalState：用于存储当前 Raft 的 HardState 和最后一个 Log Index。</li>\n<li>RaftApplyState：用于存储 Raft 最后应用的 Log 索引以及一些被截断的 Log 信息。</li>\n<li>RegionLocalState：用于存储 Region 信息以及该 Store 上对应的 Peer 状态。 Normal 表示该 Peer 正常，Tombstone 表示该 Peer 已从 Region 中移除，无法加入 Raft Group。<br>这些状态存储在两个 badger 实例中：raftdb 和 kvdb：</li>\n<li>raftdb 存储 raft 日志和 <code>RaftLocalState</code></li>\n<li>kvdb 将键值数据存储在不同的列族 “RegionLocalState” 和 “RaftApplyState” 中。 可以把kvdb看成Raft论文中提到的状态机<blockquote>\n<p>why?<br>实际上，可以只使用一个 badger 来存储 raft 日志和状态机数据。 分成两个实例只是为了与 TiKV 设计保持一致。</p>\n</blockquote>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Key</th>\n<th align=\"left\">KeyFormat</th>\n<th align=\"left\">Value</th>\n<th align=\"left\">DB</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">raft_log_key</td>\n<td align=\"left\">0x01 0x02 region_id 0x01 log_idx</td>\n<td align=\"left\">Entry</td>\n<td align=\"left\">raft</td>\n</tr>\n<tr>\n<td align=\"left\">raft_state_key</td>\n<td align=\"left\">0x01 0x02 region_id 0x02</td>\n<td align=\"left\">RaftLocalState</td>\n<td align=\"left\">raft</td>\n</tr>\n<tr>\n<td align=\"left\">apply_state_key</td>\n<td align=\"left\">0x01 0x02 region_id 0x03</td>\n<td align=\"left\">RaftApplyState</td>\n<td align=\"left\">kv</td>\n</tr>\n<tr>\n<td align=\"left\">region_state_key</td>\n<td align=\"left\">0x01 0x03 region_id 0x01</td>\n<td align=\"left\">RegionLocalState</td>\n<td align=\"left\">kv</td>\n</tr>\n<tr>\n<td align=\"left\">这些元数据应该在 “PeerStorage” 中创建和更新。 创建 PeerStorage 时，请参阅 “kv&#x2F;raftstore&#x2F;peer_storage.go”。 它会初始化该 Peer 的RaftLocalState、RaftApplyState，或者重启时从底层引擎获取之前的值。 注意，RAFT_INIT_LOG_TERM 和 RAFT_INIT_LOG_INDEX 的值都是 5（只要大于 1），而不是 0。之所以不设置为 0，是为了与 conf 更改后被动创建 Peer 的情况区别。 你现在可能还不太明白，所以请记住这一点，当你实现 conf 更改时，详细信息将在project3b 中描述。</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<p>这部分需要实现的代码只有一个函数：<code>PeerStorage.SaveReadyState</code>，该函数的作用是将 <code>raft.Ready</code> 中的数据保存到 badger 中，包括追加日志条目和保存 Raft 硬状态。</p>\n<blockquote>\n<p>硬状态：更新 <code>RaftLocalState.HardState</code> 并保存。</p>\n</blockquote>\n<p>要追加日志条目，只需将 “raft.Ready.Entries” 中的所有日志条目保存到 raftdb 并删除任何以前追加的永远不会提交的日志条目。 另外，更新对等存储的 “RaftLocalState”并将其保存到 raftdb。</p>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>使用 <code>WriteBatch</code> 立即保存这些状态。</li>\n<li>有关如何读取和写入这些状态的信息，请参阅 <code>peer_storage.go</code> 中的其他函数。</li>\n<li>设置环境变量 LOG_LEVEL&#x3D;debug 这可以帮助您进行调试，另请参阅所有可用的<a href=\"../log/log.go\">日志级别</a>。</li>\n</ul>\n</blockquote>\n<h3 id=\"实施-Raft-Ready-流程\"><a href=\"#实施-Raft-Ready-流程\" class=\"headerlink\" title=\"实施 Raft Ready 流程\"></a>实施 Raft Ready 流程</h3><p>在 Part A 部分，构建了一个基于 tick 的 Raft 模块。 现在您需要编写外部进程来驱动它。 大部分代码已经在 <code>kv/raftstore/peer_msg_handler.go</code> 和 <code>kv/raftstore/peer.go</code> 下实现。 所以你需要学习代码并完成 <code>proposeRaftCommand</code> 和 <code>HandleRaftReady</code> 的逻辑。 以下是对该框架的一些解释。</p>\n<p>Raft “RawNode” 已使用 “PeerStorage” 创建并存储在 “peer” 中。 在 Raft Worker 中，您可以看到它采用 “peer” 并通过 “peerMsgHandler” 包装它。  <code>peerMsgHandler</code> 主要有两个功能：一是 <code>HandleMsg</code> ，另一个是 <code>HandleRaftReady</code>。</p>\n<p><code>HandleMsg</code> 处理从 raftCh 接收到的所有消息，包括 <code>MsgTypeTick</code> 调用 <code>RawNode.Tick()</code> 来驱动 Raft，<code>MsgTypeRaftCmd</code> 包装来自客户端的请求，以及 <code>MsgTypeRaftMessage</code> 是 Raft 对等点之间传输的消息 。 所有消息类型都在 <code>kv/raftstore/message/msg.go</code> 中定义。 具体大家可以查看一下，其中一些会在后面的部分用到。</p>\n<p>消息处理完毕后，Raft 节点应该有一些状态更新。 因此 <code>HandleRaftReady</code> 应该从 Raft 模块中做好准备并执行相应的操作，例如持久化日志条目、应用提交的条目<br>并通过网络向其他对等点发送 raft 消息。</p>\n<p>在伪代码中，raftstore 使用 Raft，如下所示：</p>\n<pre><code class=\"go\">for &#123;\n  select &#123;\n  case &lt;-s.Ticker:\n    Node.Tick()\n  default:\n    if Node.HasReady() &#123;\n      rd := Node.Ready()\n      saveToStorage(rd.State, rd.Entries, rd.Snapshot)\n      send(rd.Messages)\n      for _, entry := range rd.CommittedEntries &#123;\n        process(entry)\n      &#125;\n      s.Node.Advance(rd)\n    &#125;\n&#125;\n</code></pre>\n<p>之后读取或写入的整个过程将是这样的：</p>\n<ul>\n<li>客户端调用RPC RawGet&#x2F;RawPut&#x2F;RawDelete&#x2F;RawScan</li>\n<li>RPC处理程序调用<code>RaftStorage</code>相关方法</li>\n<li><code>RaftStorage</code> 向 raftstore 发送 Raft 命令请求，并等待响应</li>\n<li><code>RaftStore</code> 将 Raft 命令请求作为 Raft 日志提出</li>\n<li>Raft模块追加日志，并通过<code>PeerStorage</code>持久化</li>\n<li>Raft模块提交日志</li>\n<li>Raft Worker在Raft准备就绪时执行Raft命令，并通过回调返回响应</li>\n<li><code>RaftStorage</code> 接收回调的响应并返回到 RPC 处理程序</li>\n<li>RPC 处理程序执行一些操作并将 RPC 响应返回给客户端。</li>\n</ul>\n<p>您应该运行“make project2b”来通过所有测试。 整个测试运行一个模拟集群，包括多个带有模拟网络的 TinyKV 实例。 它执行一些读写操作并检查返回值是否符合预期。</p>\n<p>需要注意的是，错误处理是通过测试的重要组成部分。 您可能已经注意到“proto&#x2F;proto&#x2F;errorpb.proto”中定义了一些错误，并且错误是 gRPC 响应的一个字段。 另外，实现了 error 接口的相应错误定义在 kv&#x2F;raftstore&#x2F;util&#x2F;error.go 中，因此您可以将它们用作函数的返回值。</p>\n<p>这些错误主要与Region有关。 所以它也是<code>RaftCmdResponse</code>的<code>RaftResponseHeader</code>的成员。 当提出请求或应用命令时，可能会出现一些错误。 如果是这样，您应该返回带有错误的 raft 命令响应，然后错误将进一步传递给 gRPC 响应。 当返回带有错误的响应时，您可以使用 kv&#x2F;raftstore&#x2F;cmd_resp.go 中提供的 BindRespError 将这些错误转换为 errorpb.proto 中定义的错误。</p>\n<p>在这个阶段，你可能会考虑这些错误，其他的将在 project3 中处理：</p>\n<ul>\n<li>ErrNotLeader：在跟随者上提议 raft 命令。 所以用它来让客户端尝试其他对等点。</li>\n<li>ErrStaleCommand：可能由于领导者更改，某些日志未提交并被新领导者的日志覆盖。 但客户并不知道这一点，仍在等待回复。 因此，您应该返回此信息以让客户端知道并再次重试该命令。</li>\n</ul>\n<h1 id=\"TODO\"><a href=\"#TODO\" class=\"headerlink\" title=\"TODO\"></a>TODO</h1><blockquote>\n<p>why<br>RAFT_INIT_LOG_TERM 和 RAFT_INIT_LOG_INDEX 的值都是 5（只要大于 1）</p>\n</blockquote>\n<blockquote>\n<p>Config.Applied uint64 干嘛用的</p>\n</blockquote>\n","excerpt":"","more":"<h1 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h1><p><a href=\"https://github.com/Smith-Cruise/TinyKV-White-Paper\">Smith-Cruise&#x2F;TinyKV-White-Paper: Tutorial for TinyKV project in Talent Plan. (github.com)</a><br><a href=\"https://cn.pingcap.com/blog/the-design-and-implementation-of-multi-raft/#raftstore\">源码解析</a></p>\n<h1 id=\"Project2-RaftKV\"><a href=\"#Project2-RaftKV\" class=\"headerlink\" title=\"Project2 RaftKV\"></a>Project2 RaftKV</h1><h2 id=\"背景知识\"><a href=\"#背景知识\" class=\"headerlink\" title=\"背景知识\"></a>背景知识</h2><h3 id=\"Raft\"><a href=\"#Raft\" class=\"headerlink\" title=\"Raft\"></a>Raft</h3><p>[[Raft 协议]]</p>\n<h3 id=\"Raft-GC\"><a href=\"#Raft-GC\" class=\"headerlink\" title=\"Raft GC\"></a>Raft GC</h3><p>Raft GC 是指在 Raft 一致性算法中用于清理日志条目的过程。在 Raft 中，每个节点都会维护一个日志，用于记录系统状态的变化。当日志变得庞大时，执行一致性操作的成本也会增加。为了限制日志的大小并提高性能，Raft 使用 Raft GC 机制来清理已经提交（committed）的日志条目。</p>\n<p>Raft GC 的基本原则是，一旦某个日志条目已经被提交并应用到状态机，就可以安全地删除该条目之前的所有条目。删除旧的日志条目可以释放存储空间，并减少后续一致性操作的开销。Raft GC 通常通过一些策略（例如基于索引或时间）来判断哪些日志条目可以安全删除。</p>\n<h3 id=\"Snapshot（快照）\"><a href=\"#Snapshot（快照）\" class=\"headerlink\" title=\"Snapshot（快照）\"></a>Snapshot（快照）</h3><p>Raft 中的快照是一种机制，用于在节点的状态机状态较新的情况下压缩和清理日志。当日志变得很大时，将整个日志传输给新加入的节点可能会很耗时和耗带宽。为了解决这个问题，Raft 使用快照机制来捕获节点的状态，并将其保存为一个快照文件。</p>\n<p>快照包含了节点在某个特定时间点的状态机状态。当新节点加入集群时，它可以通过获取最新的快照来快速将自己带到当前状态，并只追加日志中从快照之后的新条目。这样可以大大减少传输和恢复的开销。</p>\n<p>快照通常是通过在节点的状态机达到某个预定阈值时触发，或者通过节点之间的协商来创建。创建快照后，旧的日志条目可以被截断和删除，只保留最新的日志条目和快照文件。</p>\n<h2 id=\"任务目标\"><a href=\"#任务目标\" class=\"headerlink\" title=\"任务目标\"></a>任务目标</h2><ol>\n<li>实现基本的 raft 算法。</li>\n<li>在 Raft 上构建容错 KV 服务器。</li>\n<li>添加 Raft GC 和 snapshot 的支持。</li>\n</ol>\n<h3 id=\"Part-A\"><a href=\"#Part-A\" class=\"headerlink\" title=\"Part A\"></a>Part A</h3><h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><ol>\n<li>代码位于 raft&#x2F;</li>\n<li>使用逻辑时钟实现，选举和超时时间</li>\n<li>粗略阅读一下 eraftpb.proto ， 消息接收和发送的定义</li>\n<li>注意，这里与标准 Raft 协议不同，将 HeartBeat 和 AppendEntries 分成不同的消息。</li>\n<li>大致步骤：<ol>\n<li>Leader election</li>\n<li>Log replication</li>\n<li>Raw node interface</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"实现-Raft-算法\"><a href=\"#实现-Raft-算法\" class=\"headerlink\" title=\"实现 Raft 算法\"></a>实现 Raft 算法</h4><ol>\n<li><code>Raft/Raft.go</code> 提供了 Raft 算法的核心，包括消息处理、驱动逻辑时钟等。</li>\n</ol>\n<h5 id=\"Leader-选举\"><a href=\"#Leader-选举\" class=\"headerlink\" title=\"Leader 选举\"></a>Leader 选举</h5><ol>\n<li><code>raft.Raft.tick()</code> 可以将内部时钟前移一个</li>\n<li>发送消息时仅将消息推入<code>raft.Raft.msgs</code>，因为测试代码会从这个里面的消息然后使用 <code>raft.Raft.Step()</code> 处理回应消息</li>\n<li>make project2aa 测试。</li>\n</ol>\n<h5 id=\"日志复制\"><a href=\"#日志复制\" class=\"headerlink\" title=\"日志复制\"></a>日志复制</h5><ol>\n<li>先在发送方和接收方实现处理 “MsgAppend” 和 “MsgAppendResponse” 。</li>\n<li><code>raft/log.go</code> 中的 <code>raft.RaftLog</code> 是关键结构。</li>\n<li>需要通过<code>raft/Storage.go</code>中定义的<code>Storage </code>接口与上层应用程序交互，以获取日志条目和快照等持久化数据。</li>\n<li>make project2ab 进行测试。</li>\n</ol>\n<h4 id=\"实现-Rawnode-接口\"><a href=\"#实现-Rawnode-接口\" class=\"headerlink\" title=\"实现 Rawnode 接口\"></a>实现 Rawnode 接口</h4><p> <code>raft/rawnode.go</code> 中的 <code>raft.RawNode</code> 是与上层应用交互的接口。</p>\n<ol>\n<li><p>包含 <code>raft.Raft</code> ，封装了时钟相关： <code>RawNode.Tick()</code>and <code>RawNode.Step()</code>，日志 ：<code>RawNode.Propose()</code></p>\n</li>\n<li><p>包含一个新的 结构 <code>Ready</code>，处理消息或推进逻辑时钟时，<code>raft.Raft</code> 可能需要与上层应用程序交互，例如：</p>\n<ul>\n<li>向其他对等方发送消息</li>\n<li>将日志项保存到稳定的存储中</li>\n<li>保存硬状态（如术语），提交索引，并投票到稳定存储</li>\n<li>将提交的日志条目应用于状态机</li>\n<li>等<br>交互不会立即发生，相反，它们被封装在 “Ready” 中，并由 “RawNode” 返回。<code>Ready（）</code>到上层应用程序。这取决于上层应用程序何时调用 <code>Ready（）</code>并进行处理。在处理完返回的 Ready 之后，上层应用程序还需要调用一些函数，如 <code>RawNode.Advance（）</code> 更新 <code>raft.Raft</code> 的内部状态，如应用索引、稳定日志索引等。</li>\n</ul>\n</li>\n<li><p>“makeproject2ac” 来测试实现</p>\n</li>\n</ol>\n<p>也可以运行 “make project2a” 来测试整个A部分。</p>\n<blockquote>\n<p>提示。</p>\n<ul>\n<li>需要时添加任何状态到 <code>raft.Raft</code>, <code>raft.RaftLog</code>, <code>raft.RawNode</code> 和消息，在<code>eraftpb.proto</code> 中</li>\n<li>测试中假设初始的 term 0</li>\n<li>测试中假设新选举的 Leader 应该在任期内添加一个 noop 条目。 </li>\n<li>测试中假设一旦领导者推进其提交索引，它将通过 “MessageType_MsgAppend” 消息广播提交索引。</li>\n<li>测试中不会为本地 Message，<code>MessageType_MsgHup</code>, <code>MessageType_MsgBeat</code> 和 <code>MessageType_MsgPropose</code> 添加 term 号, </li>\n<li>领导者和非领导者的日志条目附加有很大不同，有不同的来源，检查和处理，请小心。</li>\n<li>不要忘记，peers 之间的选举超时时间应该不同。</li>\n<li>rawnode.go 中的一些包装函数可以通过 raft.Step(local message) 来实现</li>\n<li>当启动一个新的 raft 时，从<code>Storage</code>中获取最后的稳定状态来初始化<code>raft.Raft</code>和<code>raft.Raft Log</code></li>\n</ul>\n</blockquote>\n<h3 id=\"Part-B\"><a href=\"#Part-B\" class=\"headerlink\" title=\"Part B\"></a>Part B</h3><p>使用 part A 中 实现的 Raft 模块构建一个容错键值存储服务。</p>\n<ol>\n<li>键&#x2F;值服务将是一个复制状态机，由多个使用 Raft 进行复制的键&#x2F;值服务器组成。</li>\n<li>只要大多数服务器处于活动状态并且可以通信，尽管存在其他故障或网络分区，您的键&#x2F;值服务就应该继续处理客户端请求。<blockquote>\n<p>三个术语：“Store”、“Peer” 和 “Region”（定义在 “proto&#x2F;proto&#x2F;metapb.proto” 中）</p>\n<ul>\n<li>Store 代表tinykv-server 的一个实例</li>\n<li>Peer 代表在 Store 上运行的 Raft 节点</li>\n<li>Region是 Peers 的集合，也称为 Raft group (现在不需要考虑Region的范围。 项目3中将进一步引入多个区域。)</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p>查看 <code>kv/storage/raft_storage/raft_server.go</code> 中的 <code>RaftStorage</code> ：实现了 <code>Storage</code> 接口（与 Project1 中的单机存储不同），首先将每个写入和读取请求发送到 Raft，然后在 Raft 提交请求后才对底层引擎进行实际的写入和读取。<br><code>RaftStorage</code> 创建一个 <code>Raftstore</code> 来驱动 Raft。 当调用 <code>Reader</code> 或 <code>Write</code> 函数时，它实际上通过通道（ 通道是“raftWorker”的“raftCh”），并在 Raft 提交并应用命令后返回响应。 Reader 和 Write 函数的 kvrpc.Context 参数现在很有用，它从客户端的角度携带 Region 信息，并作为 RaftCmdRequest 的 header 传递。 这些信息可能不正确或过时，因此 raftstore 需要检查它们并决定是否提出请求。<br>接下来，就到了TinyKV的核心——raftstore。 结构有点复杂，阅读 TiKV 参考资料可以更好地理解设计：</p>\n<ul>\n<li><a href=\"https://pingcap.com/blog-cn/the-design-and-implementation-of-multi-raft/#raftstore\">https://pingcap.com/blog-cn/the-design-and-implementation-of-multi-raft/#raftstore</a>（中文版）</li>\n<li><a href=\"https://pingcap.com/blog/design-and-implementation-of-multi-raft/#raftstore\">https://pingcap.com/blog/design-and-implementation-of-multi-raft/#raftstore</a>（英文版）</li>\n</ul>\n<p>raftstore 的入口是 <code>Raftstore</code>，参见<code>kv/raftstore/raftstore.go</code>。 它启动一些工作线程异步处理特定任务，其中大多数现在不使用，因此您可以忽略它们。 你需要关注的是<code>raftWorker</code>。(kv&#x2F;raftstore&#x2F;raft_worker.go)</p>\n<p>整个过程分为两部分：raftworker 轮询 “raftCh” 以获取消息，包括驱动 Raft 模块的基本 tick 和建议作为 Raft 条目的 Raft 命令； 它从 Raft 模块获取并处理就绪，包括发送 raft 消息、持久化状态、将提交的条目应用到状态机。 申请后，将响应返回给客户。</p>\n<h4 id=\"实现对等存储-peer-storage\"><a href=\"#实现对等存储-peer-storage\" class=\"headerlink\" title=\"实现对等存储 peer storage\"></a>实现对等存储 peer storage</h4><p>对等存储是您通过 A 部分中的 “Storage”  接口进行交互的内容，但除了 raft 日志之外，对等存储还管理其他持久化元数据，这对于重启后恢复一致状态机非常重要</p>\n<blockquote>\n<p><code>proto/proto/raft_serverpb.proto</code> 中定义了三个重要的状态：</p>\n</blockquote>\n<ul>\n<li>RaftLocalState：用于存储当前 Raft 的 HardState 和最后一个 Log Index。</li>\n<li>RaftApplyState：用于存储 Raft 最后应用的 Log 索引以及一些被截断的 Log 信息。</li>\n<li>RegionLocalState：用于存储 Region 信息以及该 Store 上对应的 Peer 状态。 Normal 表示该 Peer 正常，Tombstone 表示该 Peer 已从 Region 中移除，无法加入 Raft Group。<br>这些状态存储在两个 badger 实例中：raftdb 和 kvdb：</li>\n<li>raftdb 存储 raft 日志和 <code>RaftLocalState</code></li>\n<li>kvdb 将键值数据存储在不同的列族 “RegionLocalState” 和 “RaftApplyState” 中。 可以把kvdb看成Raft论文中提到的状态机<blockquote>\n<p>why?<br>实际上，可以只使用一个 badger 来存储 raft 日志和状态机数据。 分成两个实例只是为了与 TiKV 设计保持一致。</p>\n</blockquote>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Key</th>\n<th align=\"left\">KeyFormat</th>\n<th align=\"left\">Value</th>\n<th align=\"left\">DB</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">raft_log_key</td>\n<td align=\"left\">0x01 0x02 region_id 0x01 log_idx</td>\n<td align=\"left\">Entry</td>\n<td align=\"left\">raft</td>\n</tr>\n<tr>\n<td align=\"left\">raft_state_key</td>\n<td align=\"left\">0x01 0x02 region_id 0x02</td>\n<td align=\"left\">RaftLocalState</td>\n<td align=\"left\">raft</td>\n</tr>\n<tr>\n<td align=\"left\">apply_state_key</td>\n<td align=\"left\">0x01 0x02 region_id 0x03</td>\n<td align=\"left\">RaftApplyState</td>\n<td align=\"left\">kv</td>\n</tr>\n<tr>\n<td align=\"left\">region_state_key</td>\n<td align=\"left\">0x01 0x03 region_id 0x01</td>\n<td align=\"left\">RegionLocalState</td>\n<td align=\"left\">kv</td>\n</tr>\n<tr>\n<td align=\"left\">这些元数据应该在 “PeerStorage” 中创建和更新。 创建 PeerStorage 时，请参阅 “kv&#x2F;raftstore&#x2F;peer_storage.go”。 它会初始化该 Peer 的RaftLocalState、RaftApplyState，或者重启时从底层引擎获取之前的值。 注意，RAFT_INIT_LOG_TERM 和 RAFT_INIT_LOG_INDEX 的值都是 5（只要大于 1），而不是 0。之所以不设置为 0，是为了与 conf 更改后被动创建 Peer 的情况区别。 你现在可能还不太明白，所以请记住这一点，当你实现 conf 更改时，详细信息将在project3b 中描述。</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<p>这部分需要实现的代码只有一个函数：<code>PeerStorage.SaveReadyState</code>，该函数的作用是将 <code>raft.Ready</code> 中的数据保存到 badger 中，包括追加日志条目和保存 Raft 硬状态。</p>\n<blockquote>\n<p>硬状态：更新 <code>RaftLocalState.HardState</code> 并保存。</p>\n</blockquote>\n<p>要追加日志条目，只需将 “raft.Ready.Entries” 中的所有日志条目保存到 raftdb 并删除任何以前追加的永远不会提交的日志条目。 另外，更新对等存储的 “RaftLocalState”并将其保存到 raftdb。</p>\n<blockquote>\n<p>提示：</p>\n<ul>\n<li>使用 <code>WriteBatch</code> 立即保存这些状态。</li>\n<li>有关如何读取和写入这些状态的信息，请参阅 <code>peer_storage.go</code> 中的其他函数。</li>\n<li>设置环境变量 LOG_LEVEL&#x3D;debug 这可以帮助您进行调试，另请参阅所有可用的<a href=\"../log/log.go\">日志级别</a>。</li>\n</ul>\n</blockquote>\n<h3 id=\"实施-Raft-Ready-流程\"><a href=\"#实施-Raft-Ready-流程\" class=\"headerlink\" title=\"实施 Raft Ready 流程\"></a>实施 Raft Ready 流程</h3><p>在 Part A 部分，构建了一个基于 tick 的 Raft 模块。 现在您需要编写外部进程来驱动它。 大部分代码已经在 <code>kv/raftstore/peer_msg_handler.go</code> 和 <code>kv/raftstore/peer.go</code> 下实现。 所以你需要学习代码并完成 <code>proposeRaftCommand</code> 和 <code>HandleRaftReady</code> 的逻辑。 以下是对该框架的一些解释。</p>\n<p>Raft “RawNode” 已使用 “PeerStorage” 创建并存储在 “peer” 中。 在 Raft Worker 中，您可以看到它采用 “peer” 并通过 “peerMsgHandler” 包装它。  <code>peerMsgHandler</code> 主要有两个功能：一是 <code>HandleMsg</code> ，另一个是 <code>HandleRaftReady</code>。</p>\n<p><code>HandleMsg</code> 处理从 raftCh 接收到的所有消息，包括 <code>MsgTypeTick</code> 调用 <code>RawNode.Tick()</code> 来驱动 Raft，<code>MsgTypeRaftCmd</code> 包装来自客户端的请求，以及 <code>MsgTypeRaftMessage</code> 是 Raft 对等点之间传输的消息 。 所有消息类型都在 <code>kv/raftstore/message/msg.go</code> 中定义。 具体大家可以查看一下，其中一些会在后面的部分用到。</p>\n<p>消息处理完毕后，Raft 节点应该有一些状态更新。 因此 <code>HandleRaftReady</code> 应该从 Raft 模块中做好准备并执行相应的操作，例如持久化日志条目、应用提交的条目<br>并通过网络向其他对等点发送 raft 消息。</p>\n<p>在伪代码中，raftstore 使用 Raft，如下所示：</p>\n<pre><code class=\"go\">for &#123;\n  select &#123;\n  case &lt;-s.Ticker:\n    Node.Tick()\n  default:\n    if Node.HasReady() &#123;\n      rd := Node.Ready()\n      saveToStorage(rd.State, rd.Entries, rd.Snapshot)\n      send(rd.Messages)\n      for _, entry := range rd.CommittedEntries &#123;\n        process(entry)\n      &#125;\n      s.Node.Advance(rd)\n    &#125;\n&#125;\n</code></pre>\n<p>之后读取或写入的整个过程将是这样的：</p>\n<ul>\n<li>客户端调用RPC RawGet&#x2F;RawPut&#x2F;RawDelete&#x2F;RawScan</li>\n<li>RPC处理程序调用<code>RaftStorage</code>相关方法</li>\n<li><code>RaftStorage</code> 向 raftstore 发送 Raft 命令请求，并等待响应</li>\n<li><code>RaftStore</code> 将 Raft 命令请求作为 Raft 日志提出</li>\n<li>Raft模块追加日志，并通过<code>PeerStorage</code>持久化</li>\n<li>Raft模块提交日志</li>\n<li>Raft Worker在Raft准备就绪时执行Raft命令，并通过回调返回响应</li>\n<li><code>RaftStorage</code> 接收回调的响应并返回到 RPC 处理程序</li>\n<li>RPC 处理程序执行一些操作并将 RPC 响应返回给客户端。</li>\n</ul>\n<p>您应该运行“make project2b”来通过所有测试。 整个测试运行一个模拟集群，包括多个带有模拟网络的 TinyKV 实例。 它执行一些读写操作并检查返回值是否符合预期。</p>\n<p>需要注意的是，错误处理是通过测试的重要组成部分。 您可能已经注意到“proto&#x2F;proto&#x2F;errorpb.proto”中定义了一些错误，并且错误是 gRPC 响应的一个字段。 另外，实现了 error 接口的相应错误定义在 kv&#x2F;raftstore&#x2F;util&#x2F;error.go 中，因此您可以将它们用作函数的返回值。</p>\n<p>这些错误主要与Region有关。 所以它也是<code>RaftCmdResponse</code>的<code>RaftResponseHeader</code>的成员。 当提出请求或应用命令时，可能会出现一些错误。 如果是这样，您应该返回带有错误的 raft 命令响应，然后错误将进一步传递给 gRPC 响应。 当返回带有错误的响应时，您可以使用 kv&#x2F;raftstore&#x2F;cmd_resp.go 中提供的 BindRespError 将这些错误转换为 errorpb.proto 中定义的错误。</p>\n<p>在这个阶段，你可能会考虑这些错误，其他的将在 project3 中处理：</p>\n<ul>\n<li>ErrNotLeader：在跟随者上提议 raft 命令。 所以用它来让客户端尝试其他对等点。</li>\n<li>ErrStaleCommand：可能由于领导者更改，某些日志未提交并被新领导者的日志覆盖。 但客户并不知道这一点，仍在等待回复。 因此，您应该返回此信息以让客户端知道并再次重试该命令。</li>\n</ul>\n<h1 id=\"TODO\"><a href=\"#TODO\" class=\"headerlink\" title=\"TODO\"></a>TODO</h1><blockquote>\n<p>why<br>RAFT_INIT_LOG_TERM 和 RAFT_INIT_LOG_INDEX 的值都是 5（只要大于 1）</p>\n</blockquote>\n<blockquote>\n<p>Config.Applied uint64 干嘛用的</p>\n</blockquote>\n"},{"_content":"1. 假设当前文件夹为 project\n2. 初始文件\n\tserver.go\n\tmyserver.proto\n3. 在命令行中执行\n\t```bash\n\tgo mod init project\n\tgo mod tidy \n\tgo mod downloads\n\tprotoc --go_out=. --go-grpc_out=. --proto_path=. myserver.proto\n\t```\n\n4. 生成可执行文件\n5. 执行文件\n\t```bash\n\t./project\n```\n\n","source":"_posts/编程语言/GO_lang/grpc/grpc_1.md","raw":"1. 假设当前文件夹为 project\n2. 初始文件\n\tserver.go\n\tmyserver.proto\n3. 在命令行中执行\n\t```bash\n\tgo mod init project\n\tgo mod tidy \n\tgo mod downloads\n\tprotoc --go_out=. --go-grpc_out=. --proto_path=. myserver.proto\n\t```\n\n4. 生成可执行文件\n5. 执行文件\n\t```bash\n\t./project\n```\n\n","slug":"编程语言/GO_lang/grpc/grpc_1","published":1,"date":"2024-04-22T13:14:48.683Z","updated":"2024-02-07T04:47:32.910Z","title":"","comments":1,"layout":"post","photos":[],"_id":"clvbspf0r002okgg4bc1edm7t","content":"<ol>\n<li><p>假设当前文件夹为 project</p>\n</li>\n<li><p>初始文件<br> server.go<br> myserver.proto</p>\n</li>\n<li><p>在命令行中执行</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go mod init project</span><br><span class=\"line\">go mod tidy </span><br><span class=\"line\">go mod downloads</span><br><span class=\"line\">protoc --go_out=. --go-grpc_out=. --proto_path=. myserver.proto</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>生成可执行文件</p>\n</li>\n<li><p>执行文件</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./project</span><br></pre></td></tr></table></figure></li>\n</ol>\n","excerpt":"","more":"<ol>\n<li><p>假设当前文件夹为 project</p>\n</li>\n<li><p>初始文件<br> server.go<br> myserver.proto</p>\n</li>\n<li><p>在命令行中执行</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go mod init project</span><br><span class=\"line\">go mod tidy </span><br><span class=\"line\">go mod downloads</span><br><span class=\"line\">protoc --go_out=. --go-grpc_out=. --proto_path=. myserver.proto</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>生成可执行文件</p>\n</li>\n<li><p>执行文件</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./project</span><br></pre></td></tr></table></figure></li>\n</ol>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}