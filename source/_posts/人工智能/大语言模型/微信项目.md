
# 地址

https://github.com/zhayujie/chatgpt-on-wechat

[ChatGPT微信开发，轻松拿捏_keyerror: 'wxsid-CSDN博客](https://blog.csdn.net/qq_37215621/article/details/130517060)

https://space.bilibili.com/4401694/dynamic



# 运行
nohup python3 app.py & tail -f nohup.out
nohup ./clash-linux-amd64 > /dev/null 2>&1 &
nohup docker compose up > /dev/null 2>&1 &
# 问题

[WARNING][2024-02-27 04:41:40][chat_gpt_bot.py:150] - [CHATGPT] APIConnectionError: Error communicating with OpenAI: HTTPSConnectionPool(host='api.openai.com', port=443): Max retries exceeded with url: /v1/chat/completions (Caused by ProxyError('Cannot connect to proxy.', NewConnectionError('<urllib3.connection.HTTPSConnection object at 0x7f75d9c45e50>: Failed to establish a new connection: [Errno 111] Connection refused')))
[WARNING][2024-02-27 04:41:40][chat_gpt_bot.py:150] - [CHATGPT] APIConnectionError: Error communicating with OpenAI: HTTPSConnectionPool(host='api.openai.com', port=443): Max retries exceeded with url: /v1/chat/completions (Caused by ProxyError('Cannot connect to proxy.', NewConnectionError('<urllib3.connection.HTTPSConnection object at 0x7f75d9c45fa0>: Failed to establish a new connection: [Errno 111] Connection refused')))
[INFO][2024-02-27 04:41:40][wechat_channel.py:218] - [WX] sendMsg=Reply(type=ERROR, content=[ERROR]
我连接不到你的网络), receiver=@dade582ddc06e63c6ec1175c680f90ff82f77df7c20d9450bfb147cb5a925968


## 解决
[【完美解决：openai.error.APIConnectionError: Error communicating with OpenAI:】_openai.openaierror: the api_key client option must-CSDN博客](https://blog.csdn.net/T752462536/article/details/134164508)

`pip3 show openai`查看安装目录
`cd /opt/conda/envs/fyn_python3_8/lib/python3.8/site-packages/openai`


# 问题

## 1 

[INFO][2024-02-27 05:34:07][chat_gpt_bot.py:49] - [CHATGPT] query=哈哈哈
[ERROR][2024-02-27 05:34:07][chat_gpt_bot.py:155] - [CHATGPT] Exception: local variable 'proxy' referenced before assignment
Traceback (most recent call last):
  File "/root/test/GptWchat/chatgpt-on-wechat/bot/chatgpt/chat_gpt_bot.py", line 123, in reply_text
    response = openai.ChatCompletion.create(api_key=api_key, messages=session.messages, **args)
  File "/opt/conda/envs/fyn_python3_8/lib/python3.8/site-packages/openai/api_resources/chat_completion.py", line 25, in create
    return super().create(*args, **kwargs)
  File "/opt/conda/envs/fyn_python3_8/lib/python3.8/site-packages/openai/api_resources/abstract/engine_api_resource.py", line 153, in create
    response, _, api_key = requestor.request(
  File "/opt/conda/envs/fyn_python3_8/lib/python3.8/site-packages/openai/api_requestor.py", line 288, in request
    result = self.request_raw(
  File "/opt/conda/envs/fyn_python3_8/lib/python3.8/site-packages/openai/api_requestor.py", line 609, in request_raw
    proxies=proxy,
UnboundLocalError: local variable 'proxy' referenced before assignment
[INFO][2024-02-27 05:34:08][wechat_channel.py:218] - [WX] sendMsg=Reply(type=ERROR, content=[ERROR]
我现在有点累了，等会再来吧), receiver=@5dc3bf914f7a577d4798603da08adc85720678732d3a0413329ceebb3041f0b7



[bot] 这段代码是在Python中定义一个特殊的 `__setitem__` 方法，它是一个魔法方法或者叫做运算符重载。这个方法在我们试图给一个对象的实例分配值时被调用。这里看起来像是在实现一个优先级队列或者是一个以某种方式排序的字典。

下面是代码行的详细解释：

1. `def __setitem__(self, key, value):`: 定义一个名为 `__setitem__` 的方法，它接收三个参数：`self`（表示实例自身，类似于 Java 或 C++ 中的 `this`），`key`（字典中要设置的键），`value`（该键所对应的值）。

2. `if key in self:`: 如果提供的键已经在字典中存在。

3. `super().__setitem__(key, value)`: 使用超类（可能是 `dict` 或其它字典类型）的 `__setitem__` 方法来设置键值对。

4. `for i, (priority, k) in enumerate(self.heap):`: 遍历 `heap` 列表中的每一项，`i` 是索引，`priority` 和 `k` 分别是元组中的两个项目，其中 `priority` 是优先级（或排序函数的结果），`k` 是键。

5. `if k == key:`: 如果当前键等于要设置的键。

6. `self.heap[i] = (self.sort_func(key, value), key)`: 使用 `sort_func` 函数计算新的优先级，并更新 `heap` 列表中对应的项。

7. `heapq.heapify(self.heap)`: 重新调整 `heap` 列表以保持堆的特性（堆是完全二叉树，且任一节点的值都大于或等于其子节点的值）。

8. `break`: 找到了正确的键，所以退出循环。

9. `self.sorted_keys = None`: 重置 `sorted_keys`。

10. `else:`: 如果字典中不存在这个键。

11. `super().__setitem__(key, value)`: 使用超类的 `__setitem__` 方法来设置新的键值对。

12. `heapq.heappush(self.heap, (self.sort_func(key, value), key))`: 在 `heap` 列表中添加新的元素，元素是一个元组，包含 `sort_func` 函数计算出的优先级和键。

13. `self.sorted_keys = None`: 重置 `sorted_keys`。

这段代码的主要目的是实现一个可以自我排序的字典或者类似结构，键值对的排序取决于 `sort_func` 函数的返回结果。
## 2
import ntwork
import pilk

