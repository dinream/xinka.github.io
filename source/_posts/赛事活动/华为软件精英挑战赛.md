# 时间线

![[Pasted image 20240307091119.png]]


# 赛题
● 华为基于自身ICT基础设施能力，通过对港口场景的洞察和理解，以智慧、绿色、高效、安全为目标，数字化、智能化为手段，联合生态伙伴，助力世界一流港口建设。

 ● 本次赛题抽象自华为云智能港口真实业务难题，选手通过算法完成运输船只智能泊靠、运输机器人智能拣货装货等任务，以最大化提升港口物流效率。

# 初赛练习题

https://bbs.huaweicloud.com/forum/thread-0209145106256505005-1-1.htm
https://bbs.huaweicloud.com/forum/forum-0168144383617537003-1.html
## 题目概述

⚫目标  
赚取更多的资金。  
⚫ 程序操控方式  
选手作为运输公司来运输货物赚取资金，每个选手有 5 艘轮船、10 个机器人。选  
手需要使用机器人来执行移动、搬运等动作来完成物品递送任务，同时赚取利  
润。在运行结束时，选手拥有的资金数即为最终分数，所获得的资金越高越好。  
初赛时间为 15,000 帧（最多 5 分钟）。  
⚫ 程序交付方式  
选手程序通过标准输入和标准输出与判题器进行交互。判题器运行帧率为每秒 50  
帧，对于每一帧，判题器都会把场上的实时信息通过标准输入传递给选手程序，  
同时从选手程序读取机器人的操控指令作用到各个机器人上。每一帧有  
1000/50=20ms 的时间，由于判题器需保留 5ms 执行计算来模拟真实场景，故选手  
程序需要在 15ms 内做出每一帧的决策，如果超过 15ms 未做出决策，则系统将直  
接忽略这一帧的控制进入下一帧，并且在选手程序返回控制指令前，不会再发送  
状态数据给程序。  
注意，你不需要让自己的程序具备处理 50FPS 的性能，程序处理帧率低于 50FPS  
也能正常运行（例如只处理 10FPS 也可以），但是处理更高的帧率可以让你实现更  
高精度的控制。  
程序的输入和输出格式请参考 3.4 输入与输出格式。  
⚫ 判题器使用  
今年的比赛判题器与数据集完全开放给大家下载，并且做了跨平台设计  
（Windows/Linux/MacOS），大家可以根据自己习惯选择对应版本下载。但是请注  
意，比赛平台使用 Linux，因此无论你选择何种平台开发调试，都必须确保你的代  
码可以在 Linux 下编译运行。  
运行判题器中的 run_simple_demo 可快速运行一个 DEMO，运行界面如下：
## 题目分析


## 环境配置
docker run -itd -v /home/fengyuening/container_18_04/:/root/ --gpus all --name fyn_ubuntu_18_04 ubuntu:18.04

![[Y[Y%]@RY36}%AGFAHROTPCN.png]]


![[Pasted image 20240308135154.png]]

###  碰撞检测模块


# 关键点 
1. 一个机器人只能拉一个货物
2. 可以用 std::pthread
3. 机器人不能斜走，只能横竖来走
4. 考虑数据集的变化会导致算法出现的问题
5. 如何避免多个机器人同时锁定同一个资源
6. 怎么定义资源的性价比，
	1. 考虑距离港口的距离
	2. 考虑资源的价值，基本的性价比
	3. 考虑港口的负载
7. 怎么防止机器人扎堆存在，
	1. 每个机器固定一个覆盖范围：
	2. 根据
8. 怎么避免多个机器人锁定同一个货物
	1. 如果锁定了同一个货物
	2. 由于每一次到来


机器人不会与货物相撞
我想让你担任心理健康顾问。我将为您提供一个寻求指导和建议的人，以管理他们的情绪、压力、焦虑和其他心理健康问题。您应该利用您的认知行为疗法、冥想技巧、正念练习和其他治疗方法的知识来制定个人可以实施的策略，以改善他们的整体健康状况。我的第一个请求是“我需要一个可以帮助我控制抑郁症状的人。

地图上有一个指针
读到了当前机器人的位置，先简单点，后面的车躲避前面的车。l


![[Pasted image 20240309134153.png]]

类似于这样的方法，前面的小车标记的其实是下一个地点。
先清除，
先规划，

后续可以考虑通过判断移动来决定是否清除
1. 存储机器人的上一个位置
2. 在读到新的位置之后判断如果没有更改则不会清除这个位置，
那么前面的机器人也能识别到之后机器人的位置


十个码头 五艘船
1. 一开始如何评价这十个码头中最有价值的5个码头。
	1. 


这里的码头类似与这样的实现：

机器人 主动搜索可行工作台还是工作台召唤机器人-->由码头管理所有的产品信息，并且在机器人靠码头之后下发下一个产品目标

如果机器人靠码头之后这里的船没有到，




最终如果时间即将到达，应该立刻把轮船全部开走


假设当前机器人会在固定的码头上运输物品：
关于机器人获取目标物品：
1. 如果总是每次停靠码头后进行计算：会导致第一次计算时需要单独从机器人的角度出发，计算机器人到物品再到码头的时间。
2. 如果总是从机器人出发，需要每次计算机器人到每一个物品的性价比考虑最优的选择，
	1. 但是实际上只有第一次是这么算的，之后全部在码头计算的，不如直接算在码头头上。
	2. 那么就是说现在是用码头来维护性价比信息。
3. 两者统一 让机器人搜索最近最有价值的物品


可以考虑让所有的码头同时接收物品，船由码头的物品情况来选择：
1. 但是这样的话码头中的物品其实是动态增加的，船也来动态的选择一个码头。

先寻路再避让
一个问题：寻路算法

（如果C上方和下方都是障碍物的话会走入死胡同吗？不会，根据算法，这时候C会被直接放到关闭列表，没有发生任何节点的F更新和父节点更新）即不会有任何的节点以这个节点为父亲节点。
[A*寻路算法C++简单实现_c++ 实现a*算法-CSDN博客](https://blog.csdn.net/u012234115/article/details/47152137)

```
char mazeArray[200][200]; // 假设已有一个二维字符数组
std::vector<std::vector<char>> maze;

maze.reserve(200); // 预分配行向量的内存

for (int i = 0; i < 200; ++i) {
    std::vector<char> row;
    row.reserve(200); // 预分配每行的内存
    for (int j = 0; j < 200; ++j) {
        row.push_back(std::move(mazeArray[i][j])); // 使用移动语义
    }
    maze.push_back(std::move(row)); // 使用移动语义
}
```




如何给机器人目标
1. 目前 机器人可以实现对目标的锁定和移动，
2. 


如何快速

# 当前要求分析
## 总体要求：机器人 A* 的优化
## 当前效果：
输入：map start end 
输出：path：start->end
每一次计算都是重新计算，有些耗费算历

## JSP 算法
https://zhuanlan.zhihu.com/p/620172389
https://blog.csdn.net/qq_17347313/article/details/120245994

A*算法的一些概念
current： 当前节点
openset 开启节点集合，集合内节点有待进一步探索拓展
closedset 关闭节点结合，集合内节点后续不再进行拓展，已经扩展过了
neighbor 邻居，与当前节点相邻的节点
parent(x) 节点 x 的父节点，即算法寻得的路径中节点 parent(x)的下一节点为 x
G 值表示从起点到当前点路径耗费；
H 值是一个期待值，当前点到终点的理论路径耗费；、
F=G+H表示经过该节点到终点的路径耗费

PS 算法的两条定义，三个规则
定义一：强迫邻居（forced neighbour）：如果点 n 是 x 的邻居，并且点 n 的邻居有阻挡（不可行走的格子），并且从 parent(x)、x、n 的路径长度比其他任何从 parent(x)到 n 且不经过 x 的路径短，其中parent(x)为路径中 x 的前一个点，则 n 为 x 的强迫邻居，x 为 n 的跳点），例如图 2 中，寻找从 S 到 E的路径时，K 为 I 的强迫邻居（I 为 K 的跳点）。这里不认为从 H 到 K 能走，因为对角线有阻挡（这点和论文不一致，但和代码一致，因为如果 H 到 K 能直接到达，会走进 H 右边的阻挡区，大部分的 JPS 开源代码根据论文都认为 H 到 K能走，所以存在穿越阻挡的情况），如果需要 H 到 K 可走，则 K 为 H的强迫邻居（H 为 K的跳点）。

定义二：跳点（jump point）：
（1）如果点 y 是起点或目标点，则 y 是跳点，例如图 2 中，S 是起点也是跳点，E 是目标点也是跳点；（2）如果 y 有邻居且是强迫邻居则 y 是跳点， 例 如 I 是跳点，请注意此类跳点和强迫邻居是伴生系，从上文强迫邻居的定义来看 n 是强迫邻居，x 是跳点，二者的关系是伴生的，例如图 2 中 K 的邻居只有I 是跳点，M 虽然也是 K的邻居，但 M 不是跳点，因为 K 不是 M 的强迫邻居；（3）如果 parent(y)到 y 是对角线移动，并且 y 经过水平或垂直方向移动可以到达跳点，则 y 是跳点，例如图 2 中 G 是跳点，因为 parent(G)为 S，S 到 G 为对角线移动，从 G 到跳点 I 为垂直方向移动，I 是跳点，所以 G 也是跳点。

规则一：JPS 搜索跳点的过程中，如果直线方向（为了和对角线区分，直线方向代表水平方向、垂直方向，下文所说的直线均为水平方向和垂直方向）、对角线方向都可以移动，则首先在直线方向搜索跳点，再在对角线方向搜索跳点。
规则二：（1）如果从 parent(x)到 x 是直线移动，n 是 x 的邻居，若有从 parent(x)到 n 的路径不经过 x 且路径长度小于或等于从 parent(x)经过 x 到 n 的路径，则走到 x 后下一个点不会走到 n；（2）果从 parent(x)到 x 是对角线移动，n 是 x 的邻居，若有从 parent(x)到 n 的路径不经过 x 且路径长度小于从parent(x)经过 x 到 n 的路径，则走到 x 后下一个点不会走到 n（相关证明见论文）。
规则三：只有跳点才会加入 openset，因为跳点会改变行走方向，而非跳点不会改变行走方向，最后寻找出来的路径点也只会是跳点集合的子集。







