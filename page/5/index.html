<!DOCTYPE html>
<html lang="zh-CN">
    <head>
  <!-- 元数据 -->
  <meta charset="utf-8">
  
  
  <title>心咖</title>
  
  <meta name="author" content="dreamin" />
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="format-detection" content="telphone=no, email=no" />
  
    <meta name="keywords" content="" />
  
  <meta name="description" content="生于尘埃，溺于人海，死于理想的高台">
<meta property="og:type" content="website">
<meta property="og:title" content="心咖">
<meta property="og:url" content="https://xinka.vercel.app/page/5/index.html">
<meta property="og:site_name" content="心咖">
<meta property="og:description" content="生于尘埃，溺于人海，死于理想的高台">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="dreamin">
<meta name="twitter:card" content="summary">
  
  <!-- 站点验证相关 -->
  
    
    
    
  
  <!-- 样式表文件 -->
  <link rel="stylesheet" id="kratos-css" href="/css/kratosr.min.css" media="all"></script>
  
    <link rel="stylesheet" id="darkmode-css" href="/css/kr-color-dark.min.css" media="(prefers-color-scheme: dark)"></script>
    <script src="/js/kr-dark.min.js"></script>
  
  
    <link rel="stylesheet" id="highlight-css" href="/css/highlight/night-eighties.min.css" media="all"></script>
  
  <link rel="stylesheet" id="fontawe-css" href="/vendors/font-awesome@4.7.0/css/font-awesome.min.css" media="all"></script>
  <link rel="stylesheet" id="nprogress-css" href="/vendors/nprogress@0.2.0/nprogress.css" media="all"></script>
  
  
    <link rel="stylesheet" href="/vendors/aplayer@1.10.1/dist/APlayer.min.css"></script>
  
  
    <link rel="stylesheet" href="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"></script>
  
  <!-- 不得不预先加载的一些JS文件 -->
  <script src="/vendors/jquery@3.6.0/dist/jquery.min.js"></script>
  
    <script src="/vendors/qrcode_js@1.0.0/qrcode.min.js"></script>
  
  
  <style>
    
    
  </style>
  
<meta name="generator" content="Hexo 7.2.0"></head>


    <body class="custom-background">
        <div id="kratos-wrapper">
    <div id="kratos-page">
        <div id="kratos-header">
            <header id="kratos-desktop-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="nav-header">
                        <nav id="kratos-menu-wrap">
                            <ul id="kratos-primary-menu" class="sf-menu">
                                
                                    
                                    
                                
                            </ul>
                        </nav>
                    </div>
                </div>
            </header>
            <header id="kratos-mobile-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="color-logo"><a href="/">心咖</a></div>
                    <div class="nav-toggle">
                        <a class="kratos-nav-toggle js-kratos-nav-toggle">
                            <i></i>
                        </a>
                    </div>
                </div>
            </header>
        </div>
        <div class="kratos-start kratos-hero-2">
            <!-- <div class="kratos-overlay"></div> -->
            <div class="kratos-cover kratos-cover-2 text-center">
                <div class="desc desc2 animate-box">
                    <a href="/">
                        <h2>心咖</h2> <br />
                        <span>人生如此，方趁我心</span>
                    </a>
                </div>
            </div>
        </div>

        <div id="kratos-blog-post">
            <div class="container">
                <div id="main" class="row">
                    

        

            <section class="col-md-8">

        

            <!-- Breadcrumb for tag & category page -->




    
    
        <article class="kratos-hentry kratos-entry-border-new clearfix" itemscope itemtype="https://schema.org/Article">
            <div class="kratos-status">
                
                    <i class="fa fa-refresh"></i>
                
                <div class="kratos-status-inner">
                    <div class="kratos-status-content" itemprop="articleBody">
                        
                            <p><a target="_blank" rel="noopener" href="https://go.dev/play/p/yGTd4MtgD5">在线调试平台</a></p>
<table>
<thead>
<tr>
<th>项目</th>
<th>地址</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>[[grpc_1]]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>[[go 基础]]</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>[[go 高级]]</p>

                        
                    </div>
                </div>
            </div>
            
                <footer class="kratos-post-meta-new">
                    <span class="pull-left">
                        <time datetime="2024-04-23T03:05:06.593Z" itemprop="datePublished">
                            <a><i class="fa fa-calendar"></i> 2024-04-23</a>
                        </time>
                        
                        
                            <!-- 当前仅支持valine/waline自带的统计功能 -->
                            
                        
                        
                            <!-- 当前仅支持waline自带的统计功能 -->
                            
                        
                    </span>
                    
                    
                        <span class="pull-right">
                            <a class="read-more" href="/2024/04/23/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/GO_lang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" title="留言">留言<i class="fa fa-chevron-circle-right"></i></a>
                        </span>
                    

                </footer>
            
        </article>
    

    
    
        <article class="kratos-hentry kratos-entry-border-new clearfix" itemscope itemtype="https://schema.org/Article">
            <div class="kratos-status">
                
                    <i class="fa fa-refresh"></i>
                
                <div class="kratos-status-inner">
                    <div class="kratos-status-content" itemprop="articleBody">
                        
                            <h1 id="常见库"><a href="#常见库" class="headerlink" title="常见库"></a>常见库</h1><h2 id="Flag-包"><a href="#Flag-包" class="headerlink" title="Flag 包"></a>Flag 包</h2><h3 id="flag包基本使用"><a href="#flag包基本使用" class="headerlink" title="flag包基本使用"></a>flag包基本使用</h3><p><a target="_blank" rel="noopener" href="https://studygolang.com/pkgdoc">官方文档</a>]<br><a target="_blank" rel="noopener" href="https://www.liwenzhou.com/posts/Go/flag/">参考文档</a></p>
<h4 id="导入flag包"><a href="#导入flag包" class="headerlink" title="导入flag包"></a>导入flag包</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flag</span><br></pre></td></tr></table></figure>

<h4 id="flag参数类型"><a href="#flag参数类型" class="headerlink" title="flag参数类型"></a>flag参数类型</h4><p>flag包支持的命令行参数类型有<code>bool</code>、<code>int</code>、<code>int64</code>、<code>uint</code>、<code>uint64</code>、<code>float</code> <code>float64</code>、<code>string</code>、<code>duration</code>。</p>
<table>
<thead>
<tr>
<th>flag参数</th>
<th>有效值</th>
</tr>
</thead>
<tbody><tr>
<td>字符串flag</td>
<td>合法字符串</td>
</tr>
<tr>
<td>整数flag</td>
<td>1234、0664、0x1234等类型，也可以是负数。</td>
</tr>
<tr>
<td>浮点数flag</td>
<td>合法浮点数</td>
</tr>
<tr>
<td>bool类型flag</td>
<td>1, 0, t, f, T, F, true, false, TRUE, FALSE, True, False。</td>
</tr>
<tr>
<td>时间段flag</td>
<td>任何合法的时间段字符串。如”300ms”、”-1.5h”、“2h45m”。合法的单位有”ns”、“us” &#x2F;“µs”、“ms”、“s”、“m”、“h”。</td>
</tr>
</tbody></table>
<h4 id="定义命令行flag参数"><a href="#定义命令行flag参数" class="headerlink" title="定义命令行flag参数"></a>定义命令行flag参数</h4><p>有以下两种常用的定义命令行<code>flag</code>参数的方法。</p>
<h3 id="flag-Type"><a href="#flag-Type" class="headerlink" title="flag.Type()"></a>flag.Type()</h3><p>基本格式如下：</p>
<p><code>flag.Type(flag名, 默认值, 帮助信息)*Type</code> 例如我们要定义姓名、年龄、婚否三个命令行参数，我们可以按如下方式定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name := flag.String(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;姓名&quot;</span>)</span><br><span class="line">age := flag.Int(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>, <span class="string">&quot;年龄&quot;</span>)</span><br><span class="line">married := flag.Bool(<span class="string">&quot;married&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;婚否&quot;</span>)</span><br><span class="line">delay := flag.Duration(<span class="string">&quot;d&quot;</span>, <span class="number">0</span>, <span class="string">&quot;时间间隔&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>需要注意的是，此时<code>name</code>、<code>age</code>、<code>married</code>、<code>delay</code>均为对应类型的指针。</p>
<h4 id="flag-TypeVar"><a href="#flag-TypeVar" class="headerlink" title="flag.TypeVar()"></a>flag.TypeVar()</h4><p>基本格式如下： <code>flag.TypeVar(Type指针, flag名, 默认值, 帮助信息)</code> 例如我们要定义姓名、年龄、婚否三个命令行参数，我们可以按如下方式定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> age <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> married <span class="type">bool</span></span><br><span class="line"><span class="keyword">var</span> delay time.Duration</span><br><span class="line">flag.StringVar(&amp;name, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;姓名&quot;</span>)</span><br><span class="line">flag.IntVar(&amp;age, <span class="string">&quot;age&quot;</span>, <span class="number">18</span>, <span class="string">&quot;年龄&quot;</span>)</span><br><span class="line">flag.BoolVar(&amp;married, <span class="string">&quot;married&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;婚否&quot;</span>)</span><br><span class="line">flag.DurationVar(&amp;delay, <span class="string">&quot;d&quot;</span>, <span class="number">0</span>, <span class="string">&quot;时间间隔&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="flag-Parse"><a href="#flag-Parse" class="headerlink" title="flag.Parse()"></a>flag.Parse()</h4><p>通过以上两种方法定义好命令行flag参数后，需要通过调用<code>flag.Parse()</code>来对命令行参数进行解析。</p>
<p>支持的命令行参数格式有以下几种：</p>
<ul>
<li><code>-flag xxx</code> （使用空格，一个<code>-</code>符号）</li>
<li><code>--flag xxx</code> （使用空格，两个<code>-</code>符号）</li>
<li><code>-flag=xxx</code> （使用等号，一个<code>-</code>符号）</li>
<li><code>--flag=xxx</code> （使用等号，两个<code>-</code>符号）</li>
</ul>
<p>其中，布尔类型的参数必须使用等号的方式指定。</p>
<p>Flag解析在第一个非flag参数（单个”-“不是flag参数）之前停止，或者在终止符”–“之后停止。</p>
<h4 id="flag其他函数"><a href="#flag其他函数" class="headerlink" title="flag其他函数"></a>flag其他函数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flag.Args()  <span class="comment">////返回命令行参数后的其他参数，以[]string类型</span></span><br><span class="line">flag.NArg()  <span class="comment">//返回命令行参数后的其他参数个数</span></span><br><span class="line">flag.NFlag() <span class="comment">//返回使用的命令行参数个数</span></span><br></pre></td></tr></table></figure>

<h4 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//定义命令行参数方式1</span></span><br><span class="line">	<span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line">	<span class="keyword">var</span> age <span class="type">int</span></span><br><span class="line">	<span class="keyword">var</span> married <span class="type">bool</span></span><br><span class="line">	<span class="keyword">var</span> delay time.Duration</span><br><span class="line">	flag.StringVar(&amp;name, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;姓名&quot;</span>)</span><br><span class="line">	flag.IntVar(&amp;age, <span class="string">&quot;age&quot;</span>, <span class="number">18</span>, <span class="string">&quot;年龄&quot;</span>)</span><br><span class="line">	flag.BoolVar(&amp;married, <span class="string">&quot;married&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;婚否&quot;</span>)</span><br><span class="line">	flag.DurationVar(&amp;delay, <span class="string">&quot;d&quot;</span>, <span class="number">0</span>, <span class="string">&quot;延迟的时间间隔&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//解析命令行参数</span></span><br><span class="line">	flag.Parse()</span><br><span class="line">	fmt.Println(name, age, married, delay)</span><br><span class="line">	<span class="comment">//返回命令行参数后的其他参数</span></span><br><span class="line">	fmt.Println(flag.Args())</span><br><span class="line">	<span class="comment">//返回命令行参数后的其他参数个数</span></span><br><span class="line">	fmt.Println(flag.NArg())</span><br><span class="line">	<span class="comment">//返回使用的命令行参数个数</span></span><br><span class="line">	fmt.Println(flag.NFlag())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>命令行参数使用提示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ ./flag_demo -<span class="built_in">help</span></span><br><span class="line">Usage of ./flag_demo:</span><br><span class="line">  -age int</span><br><span class="line">        年龄 (default 18)</span><br><span class="line">  -d duration</span><br><span class="line">        时间间隔</span><br><span class="line">  -married</span><br><span class="line">        婚否</span><br><span class="line">  -name string</span><br><span class="line">        姓名 (default <span class="string">&quot;张三&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>正常使用命令行flag参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./flag_demo -name 沙河娜扎 --age 28 -married=<span class="literal">false</span> -d=1h30m</span><br><span class="line">沙河娜扎 28 <span class="literal">false</span> 1h30m0s</span><br><span class="line">[]</span><br><span class="line">0</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>使用非flag命令行参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./flag_demo a b c</span><br><span class="line">张三 18 <span class="literal">false</span> 0s</span><br><span class="line">[a b c]</span><br><span class="line">3</span><br><span class="line">0</span><br></pre></td></tr></table></figure>




<h2 id="Log-包"><a href="#Log-包" class="headerlink" title="Log 包"></a>Log 包</h2><p>日志相关，<a href="ttps://blog.csdn.net/cold___play/article/details/130744302">参考</a></p>
<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>常量列表：</p>
<ul>
<li>Ldate         日期 年&#x2F;月&#x2F;日</li>
<li>Ltime         时间 时:分:秒</li>
<li>Lmicroseconds 时间 .毫秒于Ltime之后</li>
<li>Llongfile     完整文件名:行号</li>
<li>Lshortfile    文件名，此标志位优先于 Llongfile</li>
<li>LstdFlags     &#x3D; Ldate 并且 Ltime</li>
</ul>
<p>功能说明：标志位常量控制日志格式。</p>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	log.SetFlags(log.Lshortfile | log.LstdFlags)</span><br><span class="line">	log.Println(<span class="string">&quot;log:&quot;</span>) <span class="comment">//2023/05/18 12:09:57 constantsDemo.go:15: log:</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数列表:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fatal</span><span class="params">(v ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fatalf</span><span class="params">(format <span class="type">string</span>, v ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fatalln</span><span class="params">(v ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Flags</span><span class="params">()</span></span> <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Panic</span><span class="params">(v ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Panicf</span><span class="params">(format <span class="type">string</span>, v ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Panicln</span><span class="params">(v ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Prefix</span><span class="params">()</span></span> <span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">(v ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Printf</span><span class="params">(format <span class="type">string</span>, v ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Println</span><span class="params">(v ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetFlags</span><span class="params">(flag <span class="type">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetOutput</span><span class="params">(w io.Writer)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetPrefix</span><span class="params">(prefix <span class="type">string</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(out io.Writer, prefix <span class="type">string</span>, flag <span class="type">int</span>)</span></span> *Logger</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span></span> Fatal(v ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span></span> Fatalf(format <span class="type">string</span>, v ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span></span> Fatalln(v ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span></span> Flags() <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span></span> Output(calldepth <span class="type">int</span>, s <span class="type">string</span>) <span class="type">error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span></span> Panic(v ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span></span> Panicf(format <span class="type">string</span>, v ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span></span> Panicln(v ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span></span> Prefix() <span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span></span> Print(v ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span></span> Printf(format <span class="type">string</span>, v ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span></span> Println(v ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span></span> SetFlags(flag <span class="type">int</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span></span> SetPrefix(prefix <span class="type">string</span>)</span><br></pre></td></tr></table></figure>
<h3 id="自定义-logger"><a href="#自定义-logger" class="headerlink" title="自定义 logger:"></a>自定义 logger:</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(out io.Writer, prefix <span class="type">string</span>, flag <span class="type">int</span>)</span></span> *Logger</span><br></pre></td></tr></table></figure>
<p>参数列表：<br>    out 输出目标<br>    prefix 输出前缀<br>    flag 格式配置标识值<br>返回值：<br>    自定义的logger<br>功能说明：<br>    这个方法用来自定义logger，指定输出目标、格式等<br>示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	l := log.New(os.Stderr, <span class="string">&quot;logger&quot;</span>, log.Ldate)</span><br><span class="line">	l.Println(<span class="string">&quot;log to stderr sample&quot;</span>)<span class="comment">//logger2023/05/18 log to stderr sample</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Fatal系列函数"><a href="#Fatal系列函数" class="headerlink" title="Fatal系列函数"></a>Fatal系列函数</h3><h4 id="1-1-func-Fatal-v-…interface"><a href="#1-1-func-Fatal-v-…interface" class="headerlink" title="1.1 func Fatal(v …interface{})"></a>1.1 func Fatal(v …interface{})</h4><p>参数列表：<br>    v 待输出参数列表<br>返回值：<br>    无<br>功能说明：<br>    打印日志并退出。相当于调用Print()并os.Exit(1)</p>
<h4 id="1-2-func-Fatalf-format-string-v-…interface"><a href="#1-2-func-Fatalf-format-string-v-…interface" class="headerlink" title="1.2 func Fatalf(format string, v …interface{})"></a>1.2 func Fatalf(format string, v …interface{})</h4><p>参数列表：<br>    format 输出格式<br>    v 带输出参数列表<br>返回值：<br>    无<br>功能说明：<br>    按格式输出日志，并退出。相当于调用Printf()并调用os.Exit(1)</p>
<h4 id="1-3-func-Fatalln-v-…interface"><a href="#1-3-func-Fatalln-v-…interface" class="headerlink" title="1.3 func Fatalln(v …interface{})"></a>1.3 func Fatalln(v …interface{})</h4><p>参数列表：<br>    v<br>返回值：<br>    无<br>功能说明：<br>    打印一行日志并退出。相当于调用Println()并os.Exit(1)</p>
<h4 id="1-4-func-l-Logger-Fatal-v-…interface"><a href="#1-4-func-l-Logger-Fatal-v-…interface" class="headerlink" title="1.4 func (l *Logger) Fatal(v …interface{})"></a>1.4 func (l *Logger) Fatal(v …interface{})</h4><p>参数列表：<br>    v 待输出参数列表<br>返回值：<br>    无<br>功能说明：<br>    打印日志并退出。相当于调用l.Print()并os.Exit(1)</p>
<h4 id="1-5-func-Fatalf-format-string-v-…interface"><a href="#1-5-func-Fatalf-format-string-v-…interface" class="headerlink" title="1.5 func Fatalf(format string, v …interface{})"></a>1.5 func Fatalf(format string, v …interface{})</h4><p>参数列表：<br>    format 输出格式<br>    v 带输出参数列表<br>返回值：<br>    无<br>功能说明：<br>    按格式输出日志，并退出。相当于调用l.Printf()并调用os.Exit(1)</p>
<h4 id="1-6-func-l-Logger-Fatalln-v-…interface"><a href="#1-6-func-l-Logger-Fatalln-v-…interface" class="headerlink" title="1.6 func (l *Logger) Fatalln(v …interface{})"></a>1.6 func (l *Logger) Fatalln(v …interface{})</h4><p>参数列表：<br>    v<br>返回值：<br>    无<br>功能说明：<br>    打印一行日志并退出。相当于调用l.Println()并os.Exit(1)</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	age := <span class="number">25</span></span><br><span class="line">	log.Fatal(<span class="string">&quot;Hi &amp; Bye ! Age = &quot;</span>, age) <span class="comment">// this will print &quot;Hi &amp; Bye ! Age = 25&quot;</span></span><br><span class="line">	log.Println(<span class="string">&quot;This will not be called.&quot;</span>)</span><br><span class="line"></span><br><span class="line">	name := <span class="string">&quot;golang&quot;</span></span><br><span class="line">	log.Fatalf(<span class="string">&quot;%8d,%8s&quot;</span>, <span class="number">23</span>, name) <span class="comment">//2013/03/10 16:08:49       23,  golang</span></span><br><span class="line"></span><br><span class="line">	log.Fatalln(<span class="string">&quot;bye!&quot;</span>) <span class="comment">//2013/03/10 16:14:54 bye!\n</span></span><br><span class="line"></span><br><span class="line">	l := log.New(os.Stdout, <span class="string">&quot;&quot;</span>, log.LstdFlags)</span><br><span class="line">	age = <span class="number">25</span></span><br><span class="line">	l.Fatal(<span class="string">&quot;Hi &amp; Bye ! Age = &quot;</span>, age) <span class="comment">// this will print &quot;Hi &amp; Bye ! Age = 25&quot;</span></span><br><span class="line">	l.Println(<span class="string">&quot;This will not be called.&quot;</span>)</span><br><span class="line"></span><br><span class="line">	l = log.New(os.Stdout, <span class="string">&quot;&quot;</span>, log.LstdFlags)</span><br><span class="line">	<span class="comment">//l.Fatalf(&quot;%s&quot;, &quot;hello&quot;)</span></span><br><span class="line">	name = <span class="string">&quot;golang&quot;</span></span><br><span class="line">	l.Fatalf(<span class="string">&quot;%8d,%8s&quot;</span>, <span class="number">23</span>, name) <span class="comment">//2013/03/10 16:08:49       23,  golang</span></span><br><span class="line"></span><br><span class="line">	l = log.New(os.Stdout, <span class="string">&quot;&quot;</span>, log.LstdFlags)</span><br><span class="line">	l.Fatalln(<span class="string">&quot;bye!&quot;</span>) <span class="comment">//2013/03/10 16:14:54 bye!\n</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Flags系列函数"><a href="#Flags系列函数" class="headerlink" title="Flags系列函数"></a>Flags系列函数</h3><h4 id="2-1-func-Flags-int"><a href="#2-1-func-Flags-int" class="headerlink" title="2.1 func Flags() int"></a>2.1 func Flags() int</h4><p>参数列表：<br>    无<br>返回值：<br>    默认logger的配置值<br>功能说明：<br>    返回默认logger配置值。</p>
<h4 id="2-2-func-l-Logger-Flags-int"><a href="#2-2-func-l-Logger-Flags-int" class="headerlink" title="2.2 func (l *Logger) Flags() int"></a>2.2 func (l *Logger) Flags() int</h4><p>参数列表：<br>    无<br>返回值：<br>    当前logger的配置值<br>功能说明：<br>    返回当前logger配置值。</p>
<h4 id="2-3-func-SetFlags-flag-int"><a href="#2-3-func-SetFlags-flag-int" class="headerlink" title="2.3 func SetFlags(flag int)"></a>2.3 func SetFlags(flag int)</h4><p>参数列表：<br>    flag logger配置值<br>返回值：<br>    无<br>功能说明：<br>    这个方法用来设置标准logger的配置，默认为3（logger.LstdFlags）</p>
<h4 id="2-4-func-l-Logger-SetFlags-flag-int"><a href="#2-4-func-l-Logger-SetFlags-flag-int" class="headerlink" title="2.4 func (l *Logger) SetFlags(flag int)"></a>2.4 func (l *Logger) SetFlags(flag int)</h4><p>参数列表：<br>    flag logger配置值<br>返回值：<br>    无<br>功能说明：<br>    这个方法用来设置标准logger的配置，默认为3（logger.LstdFlags）</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;standard flags :&quot;</span>, log.Flags()) <span class="comment">//standard flags : 3</span></span><br><span class="line">	<span class="comment">//the flags constants</span></span><br><span class="line">	fmt.Println(log.Ldate)         <span class="comment">//1</span></span><br><span class="line">	fmt.Println(log.Ltime)         <span class="comment">//2</span></span><br><span class="line">	fmt.Println(log.Lmicroseconds) <span class="comment">//4</span></span><br><span class="line">	fmt.Println(log.Llongfile)     <span class="comment">//8</span></span><br><span class="line">	fmt.Println(log.Lshortfile)    <span class="comment">//16</span></span><br><span class="line">	fmt.Println(log.LstdFlags)     <span class="comment">//LstdFlags     = Ldate | Ltime   3</span></span><br><span class="line"></span><br><span class="line">	l := log.New(os.Stdout, <span class="string">&quot;&quot;</span>, log.LstdFlags)</span><br><span class="line">	fmt.Println(<span class="string">&quot;logger l&#x27;s flags :&quot;</span>, l.Flags()) <span class="comment">//logger l&#x27;s flags : 3</span></span><br><span class="line"></span><br><span class="line">	log.Println(log.Flags()) <span class="comment">//2013/03/10 17:46:53 3</span></span><br><span class="line">	log.SetFlags(log.Ldate)</span><br><span class="line">	log.Println(log.Flags()) <span class="comment">//2013/03/10 1</span></span><br><span class="line">	log.SetFlags(log.LstdFlags | log.Lshortfile)</span><br><span class="line">	log.Println(log.Flags()) <span class="comment">//2013/03/10 17:46:53 setflags.go:17: 19</span></span><br><span class="line"></span><br><span class="line">	l = log.New(os.Stdout, <span class="string">&quot;&quot;</span>, log.LstdFlags)</span><br><span class="line">	l.Println(l.Flags()) <span class="comment">//2013/03/10 17:46:53 3</span></span><br><span class="line">	l.SetFlags(log.Ldate)</span><br><span class="line">	l.Println(l.Flags()) <span class="comment">//2013/03/10 1</span></span><br><span class="line">	l.SetFlags(log.LstdFlags | log.Lshortfile)</span><br><span class="line">	l.Println(l.Flags()) <span class="comment">//2013/03/10 17:46:53 setflags.go:17: 19</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Panic系列函数"><a href="#Panic系列函数" class="headerlink" title="Panic系列函数"></a>Panic系列函数</h3><h4 id="3-1-func-l-Logger-Panic-v-…interface"><a href="#3-1-func-l-Logger-Panic-v-…interface" class="headerlink" title="3.1 func (l *Logger) Panic(v …interface{})"></a>3.1 func (l *Logger) Panic(v …interface{})</h4><p>参数列表：<br>    v 待输出参数列表<br>返回值：<br>    无<br>功能说明：<br>    这个方法相当于调用l.Print()及panic()</p>
<h4 id="3-2-func-l-Logger-Panicf-format-string-v-…interface"><a href="#3-2-func-l-Logger-Panicf-format-string-v-…interface" class="headerlink" title="3.2 func (l *Logger) Panicf(format string, v …interface{})"></a>3.2 func (l *Logger) Panicf(format string, v …interface{})</h4><p>参数列表：<br>    format 输出格式<br>    v 待输出参数列表<br>返回值：<br>    无<br>功能说明：<br>    相当于调用l.Printf()，之后调用panic()</p>
<h4 id="3-3-func-l-Logger-Panicln-v-…interface"><a href="#3-3-func-l-Logger-Panicln-v-…interface" class="headerlink" title="3.3 func (l *Logger) Panicln(v …interface{})"></a>3.3 func (l *Logger) Panicln(v …interface{})</h4><p>参数列表：<br>    v 待输出参数列表<br>返回值：<br>    无<br>功能说明：<br>    相当于调用l.Println()并调用panic()</p>
<h4 id="3-4-func-Panic-v-…interface"><a href="#3-4-func-Panic-v-…interface" class="headerlink" title="3.4 func Panic(v …interface{})"></a>3.4 func Panic(v …interface{})</h4><p>参数列表：<br>    v 待输出参数列表<br>返回值：<br>    无<br>功能说明：<br>    这个方法相当于调用Print()及panic()</p>
<h4 id="3-5-func-Panicf-format-string-v-…interface"><a href="#3-5-func-Panicf-format-string-v-…interface" class="headerlink" title="3.5 func Panicf(format string, v …interface{})"></a>3.5 func Panicf(format string, v …interface{})</h4><p>参数列表：<br>    format 输出格式<br>    v 待输出参数列表<br>返回值：<br>    - 无<br>功能说明：<br>    相当于调用Printf()，之后调用panic()</p>
<h4 id="3-6-func-Panicln-v-…interface"><a href="#3-6-func-Panicln-v-…interface" class="headerlink" title="3.6 func Panicln(v …interface{})"></a>3.6 func Panicln(v …interface{})</h4><p>参数列表：<br>    v 待输出参数列表<br>返回值：<br>    无<br>功能说明：<br>    相当于调用Println()并调用panic()</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	l := log.New(os.Stdout, <span class="string">&quot;&quot;</span>, log.LstdFlags)</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err) <span class="comment">//output : &quot;call panic and stop&quot;</span></span><br><span class="line">			handleException()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	l.Panic(<span class="string">&quot;call panic and stop&quot;</span>)</span><br><span class="line">	log.Println(<span class="string">&quot;this will not be called.&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err == <span class="string">&quot;3q&quot;</span> &#123;</span><br><span class="line">				log.Println(<span class="string">&quot;you are welcome&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	l = log.New(os.Stdout, <span class="string">&quot;&quot;</span>, log.LstdFlags)</span><br><span class="line">	l.Panicf(<span class="string">&quot;%d%s&quot;</span>, <span class="number">3</span>, <span class="string">&quot;q&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err == <span class="string">&quot;3q\n&quot;</span> &#123;</span><br><span class="line">				log.Println(<span class="string">&quot;you are welcome&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	l = log.New(os.Stdout, <span class="string">&quot;&quot;</span>, log.LstdFlags)</span><br><span class="line">	l.Panicln(<span class="string">&quot;3q&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleException</span><span class="params">()</span></span> &#123;</span><br><span class="line">	log.Println(<span class="string">&quot;recovering...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Print系列函数"><a href="#Print系列函数" class="headerlink" title="Print系列函数"></a>Print系列函数</h3><h4 id="4-1-func-l-Logger-Print-v-…interface"><a href="#4-1-func-l-Logger-Print-v-…interface" class="headerlink" title="4.1 func (l *Logger) Print(v …interface{})"></a>4.1 func (l *Logger) Print(v …interface{})</h4><p>参数列表：<br>    v 待输出参数列表<br>返回值：<br>    无<br>功能说明：<br>    输出日志到logger。参数处理方式同fmt.Print</p>
<h4 id="4-2-func-l-Logger-Printf-format-string-v-…interface"><a href="#4-2-func-l-Logger-Printf-format-string-v-…interface" class="headerlink" title="4.2 func (l *Logger) Printf(format string, v …interface{})"></a>4.2 func (l *Logger) Printf(format string, v …interface{})</h4><p>参数列表：<br>    format 输出格式<br>    v 待输出参数列表<br>返回值：<br>    无<br>功能说明：<br>    调用l.Output输出日志到logger l。参数处理方式同fmt.Printf</p>
<h4 id="4-3-func-l-Logger-Println-v-…interface"><a href="#4-3-func-l-Logger-Println-v-…interface" class="headerlink" title="4.3 func (l *Logger) Println(v …interface{})"></a>4.3 func (l *Logger) Println(v …interface{})</h4><p>参数列表：<br>    v 待输出参数列表<br>返回值：<br>    无<br>功能说明：<br>    调用Output打印日志到当前logger，参数处理方式同fmt.Println</p>
<h4 id="4-4-func-Print-v-…interface"><a href="#4-4-func-Print-v-…interface" class="headerlink" title="4.4 func Print(v …interface{})"></a>4.4 func Print(v …interface{})</h4><p>参数列表：<br>    v 待输出参数列表<br>返回值：<br>    无<br>功能说明：<br>    输出日志到标准logger。参数处理方式同fmt.Print</p>
<h4 id="4-5-func-Printf-format-string-v-…interface"><a href="#4-5-func-Printf-format-string-v-…interface" class="headerlink" title="4.5 func Printf(format string, v …interface{})"></a>4.5 func Printf(format string, v …interface{})</h4><p>参数列表：<br>    format 输出格式<br>    v 待输出参数列表<br>返回值：<br>    无<br>功能说明：<br>    调用Output输出日志到标准logger。参数处理方式同fmt.Printf</p>
<h4 id="4-6-func-Println-v-…interface"><a href="#4-6-func-Println-v-…interface" class="headerlink" title="4.6 func Println(v …interface{})"></a>4.6 func Println(v …interface{})</h4><p>参数列表：<br>    v<br>返回值：<br>    无<br>功能说明：<br>    调用Output打印日志到标准logger，参数处理方式同fmt.Println</p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	l := log.New(os.Stdout, <span class="string">&quot;&quot;</span>, log.LstdFlags)</span><br><span class="line">	l.Print(<span class="string">&quot;string&quot;</span>, <span class="number">1</span>, <span class="number">2.3</span>) <span class="comment">//2013/03/10 17:26:06 string1 2.3</span></span><br><span class="line"></span><br><span class="line">	l = log.New(os.Stdout, <span class="string">&quot;&quot;</span>, log.LstdFlags)</span><br><span class="line">	l.Printf(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;hello&quot;</span>) <span class="comment">//hello</span></span><br><span class="line">	name := <span class="string">&quot;golang&quot;</span></span><br><span class="line">	l.Printf(<span class="string">&quot;%8d,%8s&quot;</span>, <span class="number">23</span>, name) <span class="comment">//2013/03/10 16:08:49       23,  golang</span></span><br><span class="line"></span><br><span class="line">	l = log.New(os.Stdout, <span class="string">&quot;&quot;</span>, log.LstdFlags)</span><br><span class="line">	l.Println(<span class="string">&quot;hello&quot;</span>) <span class="comment">//2013/03/10 17:35:28 hello\n</span></span><br><span class="line"></span><br><span class="line">	log.Print(<span class="string">&quot;string&quot;</span>, <span class="number">1</span>, <span class="number">2.3</span>) <span class="comment">//2013/03/10 17:26:06 string1 2.3</span></span><br><span class="line"></span><br><span class="line">	log.Printf(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;hello&quot;</span>) <span class="comment">//hello</span></span><br><span class="line">	name = <span class="string">&quot;golang&quot;</span></span><br><span class="line">	log.Printf(<span class="string">&quot;%8d,%8s&quot;</span>, <span class="number">23</span>, name) <span class="comment">//2013/03/10 16:08:49       23,  golang</span></span><br><span class="line"></span><br><span class="line">	log.Println(<span class="string">&quot;hello&quot;</span>) <span class="comment">//2013/03/10 17:35:28 hello\n</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其它函数"><a href="#其它函数" class="headerlink" title="其它函数"></a>其它函数</h3><h4 id="5-1-func-l-Logger-Prefix-string"><a href="#5-1-func-l-Logger-Prefix-string" class="headerlink" title="5.1 func (l *Logger) Prefix() string"></a>5.1 func (l *Logger) Prefix() string</h4><p>参数列表：<br>    无<br>返回值：<br>    logger前缀，字符串类型<br>功能说明：<br>    返回当前logger的输出前缀</p>
<h4 id="5-2-func-Prefix-string"><a href="#5-2-func-Prefix-string" class="headerlink" title="5.2 func Prefix() string"></a>5.2 func Prefix() string</h4><p>参数列表：<br>    无<br>返回值：<br>    标准logger前缀，字符串类型<br>功能说明：<br>    返回标准logger的输出前缀</p>
<h4 id="5-3-func-SetPrefix-prefix-string"><a href="#5-3-func-SetPrefix-prefix-string" class="headerlink" title="5.3 func SetPrefix(prefix string)"></a>5.3 func SetPrefix(prefix string)</h4><p>参数列表：<br>    prefix 前缀<br>返回值：<br>    无<br>功能说明：<br>    设置logger的输出前缀</p>
<h4 id="5-4-func-SetPrefix-prefix-string"><a href="#5-4-func-SetPrefix-prefix-string" class="headerlink" title="5.4 func SetPrefix(prefix string)"></a>5.4 func SetPrefix(prefix string)</h4><p>参数列表：<br>    prefix 前缀<br>返回值：<br>    无<br>功能说明：<br>    设置logger的输出前缀</p>
<h4 id="5-5-func-l-Logger-Output-calldepth-int-s-string-error"><a href="#5-5-func-l-Logger-Output-calldepth-int-s-string-error" class="headerlink" title="5.5 func (l *Logger) Output(calldepth int, s string) error"></a>5.5 func (l *Logger) Output(calldepth int, s string) error</h4><p>参数列表：<br>    calldepth 深度<br>    s 字符串<br>返回值：<br>    error 错误<br>功能说明：<br>    输出日志事件。字符串s包含待打印内容，跟在预定义的prefix后面，并且根据flags设置会有区分。如果s末尾没有换行符，这个方法会默认加上一个。calldepth目前预定义均为2,以后会用来支持通用场景，支持其他值配置。（本人注：日志输出不建议直接使用该方法）</p>
<h4 id="5-6-func-SetOutput-w-io-Writer"><a href="#5-6-func-SetOutput-w-io-Writer" class="headerlink" title="5.6 func SetOutput(w io.Writer)"></a>5.6 func SetOutput(w io.Writer)</h4><p>参数列表：<br>    w 目标流，io.Writer类型<br>返回值：<br>    无<br>功能说明：<br>    设置标准logger的输出目标</p>
<h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	l := log.New(os.Stdout, <span class="string">&quot;&quot;</span>, log.LstdFlags)</span><br><span class="line">	fmt.Print(l.Prefix()) <span class="comment">//this will print nothing</span></span><br><span class="line">	l.Println(<span class="number">1</span>)          <span class="comment">//2013/03/10 17:02:05 1</span></span><br><span class="line">	l.SetPrefix(<span class="string">&quot;log:&quot;</span>)</span><br><span class="line">	fmt.Println(l.Prefix()) <span class="comment">//log:</span></span><br><span class="line">	l.Println(<span class="number">2</span>)            <span class="comment">//log:2013/03/10 17:02:05 2</span></span><br><span class="line"></span><br><span class="line">	fmt.Print(log.Prefix()) <span class="comment">//this will print nothing</span></span><br><span class="line">	log.Println(<span class="number">1</span>)          <span class="comment">//2013/03/10 17:02:05 1</span></span><br><span class="line">	log.SetPrefix(<span class="string">&quot;log:&quot;</span>)</span><br><span class="line">	fmt.Println(log.Prefix()) <span class="comment">//log:</span></span><br><span class="line">	log.Println(<span class="number">2</span>)            <span class="comment">//log:2013/03/10 17:02:05 2</span></span><br><span class="line"></span><br><span class="line">	l = log.New(os.Stdout, <span class="string">&quot;&quot;</span>, log.LstdFlags)</span><br><span class="line">	fmt.Print(l.Prefix()) <span class="comment">//this will print nothing</span></span><br><span class="line">	l.Println(<span class="number">1</span>)          <span class="comment">//2013/03/10 17:02:05 1</span></span><br><span class="line">	l.SetPrefix(<span class="string">&quot;log:&quot;</span>)</span><br><span class="line">	fmt.Println(l.Prefix()) <span class="comment">//log:</span></span><br><span class="line"></span><br><span class="line">	l.Println(<span class="number">2</span>) <span class="comment">//log:2013/03/10 17:02:05 2</span></span><br><span class="line"></span><br><span class="line">	fmt.Print(log.Prefix()) <span class="comment">//this will print nothing</span></span><br><span class="line">	log.Println(<span class="number">1</span>)          <span class="comment">//2013/03/10 17:02:05 1</span></span><br><span class="line">	log.SetPrefix(<span class="string">&quot;log:&quot;</span>)</span><br><span class="line">	fmt.Println(log.Prefix()) <span class="comment">//log:</span></span><br><span class="line">	log.Println(<span class="number">2</span>)            <span class="comment">//log:2013/03/10 17:02:05 2</span></span><br><span class="line"></span><br><span class="line">	l = log.New(os.Stdout, <span class="string">&quot;log-&gt;&quot;</span>, log.Ldate)</span><br><span class="line">	l.Output(<span class="number">2</span>, <span class="string">&quot;log output&quot;</span>)</span><br><span class="line"></span><br><span class="line">	file, err := os.OpenFile(<span class="string">&quot;sample.txt&quot;</span>, os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	log.SetOutput(file)</span><br><span class="line">	log.Println(<span class="string">&quot;log to file&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Badger-包"><a href="#Badger-包" class="headerlink" title="Badger 包"></a>Badger 包</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903814571491335">参考</a><br><a target="_blank" rel="noopener" href="https://pkg.go.dev/github.com/dgraph-io/badger#Txn">官方文档</a><br>badger是一个纯Go实现的快速的嵌入式K&#x2F;V数据库，针对LSM tree做了优化。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><code>$ go get github.com/dgraph-io/badger/...</code></p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>打开一个数据库</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">opts := badger.DefaultOptions</span><br><span class="line">opts.Dir = <span class="string">&quot;/tmp/badger&quot;</span> </span><br><span class="line">opts.ValueDir = <span class="string">&quot;/tmp/badger&quot;</span> </span><br><span class="line">db, err := badger.Open(opts) </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatal(err) </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">defer</span> db.Close()</span><br></pre></td></tr></table></figure>
<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><h4 id="存储kv"><a href="#存储kv" class="headerlink" title="存储kv"></a>存储kv</h4><p>使用 Txn.Set()方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err := db.Update(<span class="function"><span class="keyword">func</span><span class="params">(txn *badger.Txn)</span></span> <span class="type">error</span> &#123;   </span><br><span class="line">	err := txn.Set([]<span class="type">byte</span>(<span class="string">&quot;answer&quot;</span>), []<span class="type">byte</span>(<span class="string">&quot;42&quot;</span>))   </span><br><span class="line">	<span class="keyword">return</span> err </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="批量设置"><a href="#批量设置" class="headerlink" title="批量设置"></a>批量设置</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wb := db.NewWriteBatch() </span><br><span class="line"><span class="keyword">defer</span> wb.Cancel() </span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; N; i++ &#123;</span><br><span class="line">	err := wb.Set(key(i), value(i), <span class="number">0</span>) <span class="comment">// Will create txns as needed. </span></span><br><span class="line">	handle(err) </span><br><span class="line">&#125; </span><br><span class="line">handle(wb.Flush()) <span class="comment">// Wait for all txns to finish.</span></span><br></pre></td></tr></table></figure>
<p>WriteBatch不允许任何读取。对于读-修改-写，应该使用事务API。</p>
<h5 id="设置生存时间-TTL"><a href="#设置生存时间-TTL" class="headerlink" title="设置生存时间 TTL"></a>设置生存时间 TTL</h5><p>Badger 允许在键上设置一个可选的生存时间 (TTL) 值。一旦 TTL 结束，KEY 将不再是可检索的，并且将进行垃圾收集。TTL 可以使用 Txn.SetWithTTL() 设置为一个<code>time.Duration</code>的值</p>
<h5 id="设置元数据"><a href="#设置元数据" class="headerlink" title="设置元数据"></a>设置元数据</h5><p><code>Txn.SetWithMeta()</code> 设置用户元数据</p>
<p>使用 <code>Txn.SetEntry()</code> 可以一次性设置 key, value, user metatadata 和 TTL</p>
<h5 id="遍历-keys"><a href="#遍历-keys" class="headerlink" title="遍历 keys"></a>遍历 keys</h5><p>要遍历键，我们可以使用迭代器，可以使用 <code>Txn.NewIterator()</code>方法获得迭代器。迭代按字节字典排序顺序进行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">err := db.View(<span class="function"><span class="keyword">func</span><span class="params">(txn *badger.Txn)</span></span> <span class="type">error</span> &#123; <span class="comment">// badger 的 view 方法创建一个只读事务</span></span><br><span class="line">	opts := badger.DefaultIteratorOptions   </span><br><span class="line">	opts.PrefetchSize = <span class="number">10</span>   </span><br><span class="line">	it := txn.NewIterator(opts)   </span><br><span class="line">	<span class="keyword">defer</span> it.Close()   </span><br><span class="line">	<span class="keyword">for</span> it.Rewind(); it.Valid(); it.Next() &#123;</span><br><span class="line">	    item := it.Item() </span><br><span class="line">	    k := item.Key()     </span><br><span class="line">	    err := item.Value(<span class="function"><span class="keyword">func</span><span class="params">(v []<span class="type">byte</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	        fmt.Printf(<span class="string">&quot;key=%s, value=%s\n&quot;</span>, k, v)       </span><br><span class="line">	        <span class="keyword">return</span> <span class="literal">nil</span>     </span><br><span class="line">	        &#125;)     </span><br><span class="line">	    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;       </span><br><span class="line">		    <span class="keyword">return</span> err</span><br><span class="line">		&#125;   </span><br><span class="line">	&#125;   </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span> </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h6 id="前缀扫描"><a href="#前缀扫描" class="headerlink" title="前缀扫描"></a>前缀扫描</h6><p>要遍历键前缀，可以将 Seek() 和 ValidForPrefix() 组合使用：（这里的前缀是键值的）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">db.View(<span class="function"><span class="keyword">func</span><span class="params">(txn *badger.Txn)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	it := txn.NewIterator(badger.DefaultIteratorOptions)</span><br><span class="line">	<span class="keyword">defer</span> it.Close()   </span><br><span class="line">	prefix := []<span class="type">byte</span>(<span class="string">&quot;1234&quot;</span>)   </span><br><span class="line">	<span class="keyword">for</span> it.Seek(prefix); it.ValidForPrefix(prefix); it.Next() &#123;</span><br><span class="line">		item := it.Item()    </span><br><span class="line">		k := item.Key()     </span><br><span class="line">		err := item.Value(<span class="function"><span class="keyword">func</span><span class="params">(v []<span class="type">byte</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;key=%s, value=%s\n&quot;</span>, k, v)       </span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>     </span><br><span class="line">		&#125;)     </span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;       </span><br><span class="line">			<span class="keyword">return</span> err     </span><br><span class="line">		&#125;   </span><br><span class="line">	&#125;   </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span> </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h6 id="键的遍历"><a href="#键的遍历" class="headerlink" title="键的遍历"></a>键的遍历</h6><p>Badger支持一种独特的迭代模式，称为只有键的迭代。它比常规迭代快几个数量级，因为它只涉及对 lsm 树的访问，而 lsm 树通常完全驻留在 RAM 中。要启用只有键的迭代，您需要设置 IteratorOptions 。PrefetchValues 字段为 false 。这还可以用于在迭代期间对选定的键执行稀疏读取，只在需要时调用 item.Value() 。(获取键，而不获取对应的值)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">err := db.View(<span class="function"><span class="keyword">func</span><span class="params">(txn *badger.Txn)</span></span> <span class="type">error</span> &#123;   </span><br><span class="line">	opts := badger.DefaultIteratorOptions   </span><br><span class="line">	opts.PrefetchValues = <span class="literal">false</span>   </span><br><span class="line">	it := txn.NewIterator(opts)   </span><br><span class="line">	<span class="keyword">defer</span> it.Close()   </span><br><span class="line">	<span class="keyword">for</span> it.Rewind(); it.Valid(); it.Next() &#123;</span><br><span class="line">		item := it.Item()     </span><br><span class="line">		k := item.Key()     </span><br><span class="line">		fmt.Printf(<span class="string">&quot;key=%s\n&quot;</span>, k)   </span><br><span class="line">	&#125;   </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span> </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p>Badger 提供了一个流框架，它可以并发地遍历数据库的全部或部分，将数据转换为自定义键值，并连续地将数据流输出，以便通过网络发送、写入磁盘，甚至写入 Badger。这是比使用单个迭代器更快的遍历 Badger 的方法。Stream 在管理模式和正常模式下都支持Badger 。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">stream := db.NewStream() </span><br><span class="line"><span class="comment">// db.NewStreamAt(readTs) for managed mode. </span></span><br><span class="line"><span class="comment">// -- Optional settings </span></span><br><span class="line">stream.NumGo = <span class="number">16</span>          <span class="comment">// Set number of goroutines to use for iteration.</span></span><br><span class="line">stream.Prefix = []<span class="type">byte</span>(<span class="string">&quot;some-prefix&quot;</span>) <span class="comment">// Leave nil for iteration over the whole DB. </span></span><br><span class="line">stream.LogPrefix = <span class="string">&quot;Badger.Streaming&quot;</span> <span class="comment">// For identifying stream logs. Outputs to Logger. </span></span><br><span class="line"><span class="comment">// ChooseKey is called concurrently for every key. If left nil, assumes true by default. </span></span><br><span class="line">stream.ChooseKey = <span class="function"><span class="keyword">func</span><span class="params">(item *badger.Item)</span></span> <span class="type">bool</span> &#123;   </span><br><span class="line">	<span class="keyword">return</span> bytes.HasSuffix(item.Key(), []<span class="type">byte</span>(<span class="string">&quot;er&quot;</span>)) </span><br><span class="line">	<span class="comment">// 这个例子中判断后缀 “er” </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// KeyToList is called concurrently for chosen keys. This can be used to convert </span></span><br><span class="line"><span class="comment">// Badger data into custom key-values. If nil, uses stream.ToList, a default </span></span><br><span class="line"><span class="comment">// implementation, which picks all valid key-values. </span></span><br><span class="line">stream.KeyToList = <span class="literal">nil</span> </span><br><span class="line"><span class="comment">// -- End of optional settings. </span></span><br><span class="line"><span class="comment">// Send is called serially, while Stream.Orchestrate is running. 用于序列化并处理流操作的结果</span></span><br><span class="line">stream.Send = <span class="function"><span class="keyword">func</span><span class="params">(list *pb.KVList)</span></span> <span class="type">error</span> &#123;   </span><br><span class="line">	<span class="keyword">return</span> proto.MarshalText(w, list) <span class="comment">// Write to w. </span></span><br><span class="line">	&#125; </span><br><span class="line"><span class="comment">// Run the stream </span></span><br><span class="line"><span class="keyword">if</span> err := stream.Orchestrate(context.Background()); err != <span class="literal">nil</span> &#123;   </span><br><span class="line">	<span class="keyword">return</span> err </span><br><span class="line">&#125; <span class="comment">// Done.</span></span><br></pre></td></tr></table></figure>


<h3 id="删除一个key"><a href="#删除一个key" class="headerlink" title="删除一个key"></a>删除一个key</h3><p>使用<code>Txn.Delete()</code> 方法删除一个key</p>
<h3 id="获取-key-value"><a href="#获取-key-value" class="headerlink" title="获取 key value"></a>获取 key value</h3><p>通过 txn.Get 获取 value</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">err := db.View(<span class="function"><span class="keyword">func</span><span class="params">(txn *badger.Txn)</span></span> <span class="type">error</span> &#123;   </span><br><span class="line">	item, err := txn.Get([]<span class="type">byte</span>(<span class="string">&quot;answer&quot;</span>))   </span><br><span class="line">	handle(err)   </span><br><span class="line">	<span class="keyword">var</span> valNot, valCopy []<span class="type">byte</span>   </span><br><span class="line">	err := item.Value(<span class="function"><span class="keyword">func</span><span class="params">(val []<span class="type">byte</span>)</span></span> <span class="type">error</span> &#123;     </span><br><span class="line">	<span class="comment">// This func with val would only be called if item.Value encounters no error.     </span></span><br><span class="line">	<span class="comment">// Accessing val here is valid.     </span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;The answer is: %s\n&quot;</span>, val)     </span><br><span class="line">	<span class="comment">// Copying or parsing val is valid.     </span></span><br><span class="line">	valCopy = <span class="built_in">append</span>([]<span class="type">byte</span>&#123;&#125;, val...)     <span class="comment">// 三个点（`...`）的语法，表示将切片 `val` 展开，将其中的元素逐个添加到新的切片 `valCopy` 中。</span></span><br><span class="line">	<span class="comment">// Assigning val slice to another variable is NOT OK.     </span></span><br><span class="line">	valNot = val <span class="comment">// Do not do this.     </span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>   </span><br><span class="line">&#125;)   </span><br><span class="line">handle(err)   <span class="comment">// DO NOT access val here. It is the most common cause of bugs.</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;NEVER do this. %s\n&quot;</span>, valNot)   </span><br><span class="line"><span class="comment">// You must copy it to use it outside item.Value(...).   </span></span><br><span class="line">fmt.Printf(<span class="string">&quot;The answer is: %s\n&quot;</span>, valCopy)   </span><br><span class="line"><span class="comment">// Alternatively, you could also use item.ValueCopy().   </span></span><br><span class="line">valCopy, err = item.ValueCopy(<span class="literal">nil</span>)   </span><br><span class="line">handle(err)   </span><br><span class="line">fmt.Printf(<span class="string">&quot;The answer is: %s\n&quot;</span>, valCopy)   </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span> </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如果不存在 <code>Txn.Get()</code> 将会返回一个 <code>ErrKeyNotFound</code> 错误</p>
<p>请注意，Get()返回的值只在事务打开时有效。如果需要在事务外部使用值，则必须使用copy() 将其复制到另一个字节片。</p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h5 id="只读事务"><a href="#只读事务" class="headerlink" title="只读事务"></a>只读事务</h5><p>只读事务使用 DB.View()方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err := db.View(<span class="function"><span class="keyword">func</span><span class="params">(txn *badger.Txn)</span></span> <span class="type">error</span> &#123;  </span><br><span class="line">	<span class="comment">// Your code here…   </span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span> </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="读写事务锁"><a href="#读写事务锁" class="headerlink" title="读写事务锁"></a>读写事务锁</h5><p>读写事务可以使用 DB.Update()方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err := db.Update(<span class="function"><span class="keyword">func</span><span class="params">(txn *badger.Txn)</span></span> <span class="type">error</span> &#123;   </span><br><span class="line">	<span class="comment">// Your code here…   </span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span> </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="手动管理事务"><a href="#手动管理事务" class="headerlink" title="手动管理事务"></a>手动管理事务</h5><p>直接使用<code>DB.NewTransaction()</code>函数，手动创建和提交事务。它接受一个布尔参数来指定是否需要读写事务。对于读写事务，需要调用<code>Txn.Commit()</code>来确保事务已提交。对于只读事务，调用 <code>txn.reject()</code>就可以了。<code>commit()</code>也在内部调用 <code>txn .reject()</code>来清除事务，因此只需调用Txn.Commit()就足以执行读写事务。</p>
<p>但是，如果您的代码由于某种原因(出错)没有调用<code>Txn.Commit()</code>。就需要在defer中调用 <code>txn . reject()</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start a writable transaction. </span></span><br><span class="line">txn := db.NewTransaction(<span class="literal">true</span>) </span><br><span class="line"><span class="keyword">defer</span> txn.Discard() </span><br><span class="line"><span class="comment">// Use the transaction... </span></span><br><span class="line">err := txn.Set([]<span class="type">byte</span>(<span class="string">&quot;answer&quot;</span>), []<span class="type">byte</span>(<span class="string">&quot;42&quot;</span>)) </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;     <span class="keyword">return</span> err &#125; </span><br><span class="line"><span class="comment">// Commit the transaction and check for error. </span></span><br><span class="line"><span class="keyword">if</span> err := txn.Commit(); err != <span class="literal">nil</span> &#123;     </span><br><span class="line">	<span class="keyword">return</span> err </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Error-包"><a href="#Error-包" class="headerlink" title="Error 包"></a>Error 包</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个新 的 error 类型 数据</span></span><br><span class="line">errors.New(<span class="string">&quot;dest id is not cur id&quot;</span>) </span><br></pre></td></tr></table></figure>

<h2 id="Server-常用"><a href="#Server-常用" class="headerlink" title="Server 常用"></a>Server 常用</h2><ol>
<li><p>获取 URL 的路径参数</p>
<p>   比如： 前端访问：<a target="_blank" rel="noopener" href="http://127.0.0.1:8080/haha">http://127.0.0.1:8080/haha</a> ， 如何获取 haha 这个字符串？ 看代码：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">        <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func handler(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">        // 从请求URL中获取路径参数</span><br><span class="line">        param := r.URL.Path[len(<span class="string">&quot;/&quot;</span>):]</span><br><span class="line"></span><br><span class="line">        // 输出获取到的字符串</span><br><span class="line">        fmt.Println(param)</span><br><span class="line"></span><br><span class="line">        // 在响应中返回获取到的字符串</span><br><span class="line">        fmt.Fprintf(w, <span class="string">&quot;Received: %s&quot;</span>, param)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">        http.HandleFunc(<span class="string">&quot;/&quot;</span>, handler)</span><br><span class="line">        http.ListenAndServe(<span class="string">&quot;:80&quot;</span>, nil)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>http 状态码返回</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">        <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line">func handleRequest(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">        // 模拟根据请求处理的逻辑</span><br><span class="line">        <span class="keyword">if</span> r.URL.Path == <span class="string">&quot;/&quot;</span> &#123;</span><br><span class="line">                // 处理成功，返回HTTP 200</span><br><span class="line">                w.WriteHeader(http.StatusOK)</span><br><span class="line">                fmt.Fprintf(w, <span class="string">&quot;Success&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                // 处理失败，返回HTTP 404</span><br><span class="line">                w.WriteHeader(http.StatusNotFound)</span><br><span class="line">                fmt.Fprintf(w, <span class="string">&quot;Not Found&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">        http.HandleFunc(<span class="string">&quot;/&quot;</span>, handleRequest)</span><br><span class="line">        http.ListenAndServe(<span class="string">&quot;:80&quot;</span>, nil)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>闭包</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">在Go语言中，http.HandleFunc()函数的第二个参数是一个函数类型，它必须是满足http.HandlerFunc函数签名的函数。该函数接收两个参数：http.ResponseWriter和*http.Request。</span><br><span class="line">如果你想在handleRequest函数中传入其他参数，可以使用闭包（Closure）的方式。</span><br><span class="line">以下是一个示例代码，展示如何在handleRequest函数中传入其他参数：</span><br><span class="line">go</span><br><span class="line">复制</span><br><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">        <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func handleRequest(customParam string) http.HandlerFunc &#123;</span><br><span class="line">        <span class="built_in">return</span> func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">                // 在这里可以使用 customParam 和 w、r 来处理请求</span><br><span class="line">                fmt.Println(<span class="string">&quot;Custom parameter:&quot;</span>, customParam)</span><br><span class="line">                fmt.Fprintf(w, <span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">        param := <span class="string">&quot;custom value&quot;</span></span><br><span class="line">        http.HandleFunc(<span class="string">&quot;/&quot;</span>, handleRequest(param))</span><br><span class="line">        http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, nil)</span><br><span class="line">&#125;</span><br><span class="line">在上述代码中，我们定义了一个handleRequest函数，它接收一个类型为string的参数customParam。handleRequest函数返回一个函数，该函数满足http.HandlerFunc函数签名。</span><br><span class="line">在返回的函数中，我们可以使用闭包的方式访问customParam以及http.ResponseWriter和*http.Request参数，并进行相应的处理。</span><br><span class="line">在main函数中，我们定义了一个param变量作为自定义参数的值。然后，我们通过handleRequest(param)将param传递给handleRequest函数，并返回一个满足http.HandlerFunc函数签名的函数。</span><br><span class="line">最后，我们使用http.HandleFunc()来将路径<span class="string">&quot;/&quot;</span>与返回的处理函数进行绑定，并通过http.ListenAndServe()监听HTTP请求</span><br></pre></td></tr></table></figure>
</li>
<li><p>net 和 http同时使用</p>
<p>   Go 语言中，可以同时使用 <code>net</code> 和 <code>http</code> 包来监听同一个接口，但是需要小心处理并避免冲突。</p>
<p>   <code>net</code> 包提供了底层的网络功能，可以通过 <code>net.Listen</code> 函数来监听指定的网络地址和端口。而 <code>http</code> 包是建立在 <code>net</code> 包之上的，提供了更高级的 HTTP 服务器和客户端功能。</p>
<p>   以下是一个示例代码，同时使用 <code>net</code> 和 <code>http</code> 监听同一个接口：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">        &quot;fmt&quot;</span><br><span class="line">        &quot;net&quot;</span><br><span class="line">        &quot;net/http&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">        // 使用 net 包监听指定的网络地址和端口</span><br><span class="line">        listener, err := net.Listen(&quot;tcp&quot;, &quot;localhost:8080&quot;)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">                fmt.Println(&quot;Error listening:&quot;, err)</span><br><span class="line">                return</span><br><span class="line">        &#125;</span><br><span class="line">        defer listener.Close()</span><br><span class="line">        // 启动 HTTP 服务器</span><br><span class="line">        go func() &#123;</span><br><span class="line">                http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">                        fmt.Fprintf(w, &quot;Hello, HTTP!&quot;)</span><br><span class="line">                &#125;)</span><br><span class="line">                err := http.Serve(listener, nil)</span><br><span class="line">                if err != nil &#123;</span><br><span class="line">                        fmt.Println(&quot;Error serving HTTP:&quot;, err)</span><br><span class="line">                        return</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        // 其他的网络处理逻辑...</span><br><span class="line">        // ...</span><br><span class="line">        // 等待程序退出</span><br><span class="line">        select &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   在上述示例中，我们使用 <code>net.Listen</code> 函数监听 <code>localhost:8080</code>，然后使用 <code>http</code> 包启动了一个 HTTP 服务器。通过 <code>http.HandleFunc</code> 函数，我们定义了一个简单的处理函数来响应 HTTP 请求。最后，通过 <code>http.Serve</code> 函数将监听器与 HTTP 服务器关联起来。</p>
<p>   你可以在 <code>// 其他的网络处理逻辑...</code> 的部分添加其他网络处理逻辑，如基于 <code>net</code> 包的 TCP 或 UDP 服务器。只需确保网络处理逻辑不会与 HTTP 服务器冲突，比如使用不同的端口或处理不同的网络协议。</p>
<p>   需要注意的是，当使用 <code>http.Serve</code> 函数时，它将阻塞当前的 goroutine，因此我们在示例中使用了 <code>select &#123;&#125;</code> 来阻止 <code>main</code> 函数退出。这样可以保持服务器的运行，直到显式地退出程序。</p>
</li>
<li><p>mymux</p>
<p>   <code>myMux := http.NewServeMux()</code> 这条语句用于创建一个新的 <code>ServeMux</code> 对象。</p>
<p>   在 Go 的 <code>http</code> 包中，<code>ServeMux</code> 是一个 HTTP 请求多路复用器（multiplexer），用于将收到的 HTTP 请求分发到相应的处理器。<code>ServeMux</code> 类型实现了 <code>http.Handler</code> 接口，因此它本身可以作为一个处理器来处理请求。</p>
<p>   通过调用 <code>http.NewServeMux()</code> 函数，我们可以创建一个新的 <code>ServeMux</code> 对象，它将用于注册和管理不同路径的处理器。</p>
<p>   例如，下面是一个简单示例，使用 <code>ServeMux</code> 对象来管理不同路径的处理器：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">        &quot;fmt&quot;</span><br><span class="line">        &quot;net/http&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">        myMux := http.NewServeMux()</span><br><span class="line"></span><br><span class="line">        myMux.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">                fmt.Fprintf(w, &quot;Hello, World!&quot;)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        myMux.HandleFunc(&quot;/about&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">                fmt.Fprintf(w, &quot;About page&quot;)</span><br><span class="line">        &#125;)</span><br><span class="line">        server := &amp;http.Server&#123;</span><br><span class="line">                Addr:    &quot;:8080&quot;,</span><br><span class="line">                Handler: myMux,</span><br><span class="line">        &#125;</span><br><span class="line">        server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   在上述示例中，我们首先使用 <code>http.NewServeMux()</code> 创建了一个新的 <code>ServeMux</code> 对象 <code>myMux</code>。然后，我们使用 <code>myMux.HandleFunc</code> 方法来注册处理器函数，每个函数对应一个特定的路径。</p>
<p>   最后，我们创建了一个 <code>http.Server</code> 对象，并将 <code>myMux</code> 对象作为处理器指定给该服务器。这样，当服务器收到请求时，就会使用 <code>myMux</code> 对象来根据请求的路径选择相应的处理器函数进行处理。</p>
<p>   总结起来，<code>myMux := http.NewServeMux()</code> 用于创建一个 <code>ServeMux</code> 对象，以便注册和管理不同路径的处理器，并根据路径选择相应的处理函数来处理请求。</p>
</li>
<li><p>go routine 实现并发执行</p>
<p>   Go 的 goroutine 来实现并发执行。以下是一个示例代码，演示了如何同时运行 HTTP 服务、gRPC 服务和连接其他 gRPC 服务器：</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;log&quot;</span></span><br><span class="line">        <span class="string">&quot;net&quot;</span></span><br><span class="line">        <span class="string">&quot;net/http&quot;</span></span><br><span class="line">        <span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">        <span class="string">&quot;google.golang.org/grpc/credentials&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 创建监听器</span></span><br><span class="line">        lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Fatalf(<span class="string">&quot;Failed to listen: %v&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动 HTTP 服务器</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                http.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">                        w.Write([]<span class="type">byte</span>(<span class="string">&quot;Hello, HTTP!&quot;</span>))</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="keyword">if</span> err := http.Serve(lis, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                        log.Fatalf(<span class="string">&quot;HTTP failed to serve: %v&quot;</span>, err)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动 gRPC 服务器</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                s := grpc.NewServer()</span><br><span class="line">                <span class="comment">// 注册 gRPC 服务</span></span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="keyword">if</span> err := s.Serve(lis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                        log.Fatalf(<span class="string">&quot;gRPC failed to serve: %v&quot;</span>, err)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接其他 gRPC 服务器</span></span><br><span class="line">        conn, err := grpc.Dial(<span class="string">&quot;other_server_address&quot;</span>, grpc.WithTransportCredentials(credentials.NewInsecure()))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Fatalf(<span class="string">&quot;Failed to connect to other server: %v&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> conn.Close()</span><br><span class="line">        <span class="comment">// 进行其他操作，使用 conn 进行 gRPC 通信</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 等待程序退出</span></span><br><span class="line">        <span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   在这个示例中，我们使用 goroutine 启动了 HTTP 服务器和 gRPC 服务器，并在主函数中创建了一个与其他 gRPC 服务器的连接。</p>
<p>   注意在连接其他 gRPC 服务器时，我们使用了 <code>grpc.Dial</code> 函数，并传递了 <code>grpc.WithTransportCredentials(credentials.NewInsecure())</code> 选项来创建一个不安全的连接。你应该根据实际情况选择正确的连接配置，例如使用安全的连接和认证。</p>
<p>   最后，使用 <code>select &#123;&#125;</code> 阻塞主函数，使程序保持运行状态，直到显式退出。</p>
<p>   请根据你的实际需求，将代码中的注释部分替换为适当的 gRPC 服务注册和其他操作代码。</p>
</li>
<li><p>连接阻塞</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主要就是 grpc.WithBlock()</span></span><br><span class="line"></span><br><span class="line">conn2, err2 := grpc.Dial(*addr2, grpc.WithTransportCredentials(insecure.NewCredentials()),grpc.WithBlock())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>循环变量副本</p>
<p>   for i :&#x3D; 1; i &lt;&#x3D; *rpc_num; i++ {</p>
<p>   if i &#x3D;&#x3D; *rpc_id {</p>
<p>   continue &#x2F;&#x2F; 跳过与 当前相同的 端口号 ，不能和自己连接</p>
<p>   }</p>
<p>   go func(){</p>
<p>   conn[i], err &#x3D; grpc.Dial(rpc_addr[i], grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithBlock())</p>
<p>   if err !&#x3D; nil {</p>
<p>   log.Fatalf(“Failed to connect to server %s: %v”, rpc_addr[i], err)</p>
<p>   return</p>
<p>   }</p>
<p>   log.Printf(“Connect to %s OK”, rpc_addr[i])</p>
<p>   }()</p>
<p>   }</p>
<p>   这里有个提示信息但是没有报错，提示为：loop variable i captured by func litera</p>
<p>    “loop variable i captured by func literal” 意味着在你的代码中，匿名函数字面量（func literal）捕获了循环变量 i。</p>
<p>   在 Go 语言中，当你在循环体内使用匿名函数时，该匿名函数会形成一个闭包，它可以访问和引用外部作用域中的变量。在这种情况下，匿名函数引用了循环变量 i。然而，循环变量在每次迭代中的值会发生变化，这可能会导致一些意外的行为。</p>
<p>   为了避免这种问题，Go 语言引入了循环变量副本的概念。在每次迭代中，会为循环体内的匿名函数创建一个新的副本变量，以确保在闭包内部引用的是正确的值。这样可以避免循环变量值的竞争条件。</p>
<p>   解决这个问题的常见方法是在循环体内部创建一个局部变量，将循环变量的值复制给局部变量，然后在匿名函数中使用局部变量。例如：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">for i := 1; i &lt;= *rpc_num; i++ &#123;</span><br><span class="line">    if i == *rpc_id &#123;</span><br><span class="line">        continue</span><br><span class="line">    &#125;</span><br><span class="line">    // 创建局部变量 iCopy 并将循环变量的值赋给它</span><br><span class="line">    iCopy := i</span><br><span class="line">    go func() &#123;</span><br><span class="line">        conn[iCopy], err = grpc.Dial(rpc_addr[iCopy], grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithBlock())</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">            log.Fatalf(&quot;Failed to connect to server %s: %v&quot;, rpc_addr[iCopy], err)</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        log.Printf(&quot;Connect to %s OK&quot;, rpc_addr[iCopy])</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   通过创建局部变量 iCopy 并使用它，你可以确保每个匿名函数引用的是该迭代的正确值，而不会受到循环变量的更改影响。</p>
</li>
</ol>
<h1 id="Atomic-包"><a href="#Atomic-包" class="headerlink" title="Atomic 包"></a>Atomic 包</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">    <span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count <span class="type">int32</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    currentCount := atomic.LoadInt32(&amp;count)</span><br><span class="line">    atomic.AddInt32(&amp;count, <span class="number">1</span>)</span><br><span class="line">    log.Println(<span class="string">&quot;count:&quot;</span>, currentCount)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(runtime.NumCPU() - <span class="number">1</span>)</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/&quot;</span>, test)</span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Done-Wait-同步"><a href="#Done-Wait-同步" class="headerlink" title="Done Wait 同步"></a>Done Wait 同步</h1><p> Go 内存模型中的术语。它说明了在调用 <code>Done</code> 方法之前，它会与任何由它解除阻塞的 <code>Wait</code> 调用之后的返回之前进行”同步在”（synchronizes before）的关系。</p>
<p>具体解释如下：</p>
<ol>
<li><code>Done</code> 方法是用于通知等待组（WaitGroup）中某个操作的完成。</li>
<li><code>Wait</code> 方法是等待等待组中所有操作完成的调用。</li>
<li>“同步在”（synchronizes before）是 Go 内存模型中的同步关系，指示在同一个 goroutine 中，一个操作的执行在另一个操作之前进行了同步。</li>
</ol>
<p>根据这句话的解释，当一个 goroutine 调用 <code>Done</code> 方法时，它会在解除等待组中的某个操作的阻塞之前与该操作的返回之前进行同步。</p>
<p>具体来说，如果一个 goroutine 在调用 <code>Wait</code> 方法等待等待组中的操作时被阻塞，那么当另一个 goroutine 调用 <code>Done</code> 方法通知该操作的完成时，调用 <code>Done</code> 的 goroutine 会在被阻塞的 goroutine 返回之前进行同步。这确保了在 <code>Done</code> 方法解除阻塞之后，等待的 goroutine 可以安全地继续执行。</p>
<p>总之，这句话的含义是在 Go 内存模型中，<code>Done</code> 方法的调用会在解除阻塞的 <code>Wait</code> 调用的返回之前进行同步。这个同步关系确保了等待组的协同操作的正确性和可靠性。</p>

                        
                    </div>
                </div>
            </div>
            
                <footer class="kratos-post-meta-new">
                    <span class="pull-left">
                        <time datetime="2024-04-23T03:05:06.593Z" itemprop="datePublished">
                            <a><i class="fa fa-calendar"></i> 2024-04-23</a>
                        </time>
                        
                        
                            <!-- 当前仅支持valine/waline自带的统计功能 -->
                            
                        
                        
                            <!-- 当前仅支持waline自带的统计功能 -->
                            
                        
                    </span>
                    
                    
                        <span class="pull-right">
                            <a class="read-more" href="/2024/04/23/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/GO_lang/go%20%E9%AB%98%E7%BA%A7/" title="留言">留言<i class="fa fa-chevron-circle-right"></i></a>
                        </span>
                    

                </footer>
            
        </article>
    

    
    
        <article class="kratos-hentry kratos-entry-border-new clearfix" itemscope itemtype="https://schema.org/Article">
            <div class="kratos-status">
                
                    <i class="fa fa-refresh"></i>
                
                <div class="kratos-status-inner">
                    <div class="kratos-status-content" itemprop="articleBody">
                        
                            <p>go个人笔记</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weiguang102/article/details/128501539">https://blog.csdn.net/weiguang102/article/details/128501539</a></p>
<p>go 基础</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/go/go-tutorial.html">https://www.runoob.com/go/go-tutorial.html</a></p>
<p>go 环境安装</p>
<p><a target="_blank" rel="noopener" href="https://blog.51cto.com/fish/5734211">https://blog.51cto.com/fish/5734211</a></p>
<h2 id="零、配置"><a href="#零、配置" class="headerlink" title="零、配置"></a>零、配置</h2><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>1.临时添加环境变量 PATH</p>
<p>export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;go&#x2F;bin</p>
<p>2.所有用户永久添加环境变量</p>
<p>vim &#x2F;etc&#x2F;profile</p>
<p>末尾添加：export PATH:$PATH:&#x2F;usr&#x2F;local&#x2F;go&#x2F;bin</p>
<p>刷新：sourse &#x2F;etc&#x2F;profile</p>
<p>3.golang 工作目录</p>
<p>GOPATH 是一个环境变量，用于指定Go项目的工作目录，默认情况下，GOPATH是 $HOME是当前用户的主目录。(&#x2F;root 或者 &#x2F;home&#x2F;user1)</p>
<p>获取：</p>
<p>go env GOPATH</p>
<p>更改：</p>
<p>编辑 .bashrc 或者 .zshrc</p>
<p>找到 GOPATH 这行，将其修改为 &#x2F;path&#x2F;to&#x2F;your&#x2F;gopath</p>
<p>4.go.sum 与 go.mod</p>
<p><code>go.sum</code> 和 <code>go.mod</code> 是 Go 语言中用于管理模块依赖的文件。</p>
<ul>
<li><p><code>go.mod</code> 文件：<code>go.mod</code> 文件用于定义和管理项目的模块依赖关系。它位于项目的根目录下。当你使用 <code>go get</code> 命令来安装或更新依赖包时，<code>go.mod</code> 文件会被更新。它记录了项目所依赖的模块及其版本。你可以手动编辑 <code>go.mod</code> 文件来添加、移除或升级依赖包。在构建项目时，Go 会根据 <code>go.mod</code> 文件获取所需的依赖包。</p>
</li>
<li><p><code>go.sum</code> 文件：<code>go.sum</code> 文件用于记录项目所使用模块的校验和信息。每个模块都有一个唯一的校验和，用于确保下载的模块的完整性和安全性。<code>go.sum</code> 文件会自动生成并更新，其中包含了所有依赖模块的校验和。当你构建项目时，Go 会根据 <code>go.sum</code> 文件验证模块的完整性，以确保下载的模块与之前的校验和匹配。</p>
</li>
</ul>
<p>使用 <code>go.mod</code> 和 <code>go.sum</code> 文件的基本操作如下：</p>
<ol>
<li><p>初始化模块：在项目的根目录下执行 <code>go mod init</code> 命令，它会根据项目的路径和名称创建一个新的 <code>go.mod</code> 文件。</p>
</li>
<li><p>添加依赖包：执行 <code>go get</code> 命令来添加所需的依赖包。例如，<code>go get</code> <code>github.com/example/package</code>。这会自动更新 <code>go.mod</code> 文件并下载依赖包。</p>
</li>
<li><p>移除依赖包：执行 <code>go mod tidy</code> 命令来移除不再使用的依赖包。它会自动更新 <code>go.mod</code> 文件并删除不需要的依赖。</p>
</li>
<li><p>升级依赖包：执行 <code>go get -u</code> 命令来升级依赖包到最新版本。这会自动更新 <code>go.mod</code> 文件。</p>
</li>
<li><p>构建项目：使用 <code>go build</code> 或 <code>go run</code> 命令来构建或运行项目。Go 会根据 <code>go.mod</code> 文件下载依赖包并构建项目。</p>
</li>
</ol>
<p>需要注意的是，<code>go.mod</code> 和 <code>go.sum</code> 文件对于保证项目的可复现性和依赖包的一致性非常重要。当你与他人共享项目时，确保将 <code>go.mod</code> 和 <code>go.sum</code> 文件一同共享，以便其他人可以获取相同的依赖包版本。</p>
<p>管理和安装 <code>go.mod</code> 和 <code>go.sum</code> 中列出的依赖项：</p>
<ol>
<li><strong>下载依赖项</strong></li>
</ol>
<p>当你首次克隆一个 Go 项目或者在已有项目中更新了依赖项时，可以使用以下命令来下载 <code>go.mod</code> 文件中指定的所有依赖项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod download</span><br></pre></td></tr></table></figure>

<p>这个命令会将依赖项下载到本地的 Go 模块缓存中，但不会在项目目录中创建任何文件。</p>
<ol start="2">
<li><strong>同步依赖项</strong></li>
</ol>
<p>如果你想确保项目目录下的依赖项与 <code>go.mod</code> 文件中定义的依赖项完全同步（即添加缺失的模块，删除不需要的模块，并更新 <code>go.sum</code>），可以使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod tidy</span><br></pre></td></tr></table></figure>

<p><code>go mod tidy</code> 命令会添加缺少的模块，移除未使用的模块，并生成一个新的 <code>go.sum</code> 文件。这是确保 <code>go.mod</code> 和 <code>go.sum</code> 文件准确反映项目依赖项的好方法。</p>
<ol start="3">
<li><strong>查看依赖项</strong></li>
</ol>
<p>如果你想查看当前项目的依赖树，可以使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod graph</span><br></pre></td></tr></table></figure>

<p>这个命令会打印项目的所有依赖项及其版本，帮助你理解项目依赖的结构。</p>
<ol start="4">
<li><strong>更新依赖项</strong></li>
</ol>
<p>要更新项目中的某个依赖项到最新版本，可以使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u package@version</span><br></pre></td></tr></table></figure>

<p>其中 <code>package</code> 是依赖项的路径，<code>version</code> 是你想要更新到的版本。如果你想更新所有依赖项到最新版本，可以使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u</span><br></pre></td></tr></table></figure>

<p>但请注意，这可能会引入重大更改，因此建议仔细测试更新后的依赖项。</p>
<p>修改 proto 文件并运行 <code>make proto</code> 来更新 <code>proto/pkg/xxx/xxx.pb.go</code> 中相关生成的 go 代码</p>
<h2 id="一、变量"><a href="#一、变量" class="headerlink" title="一、变量"></a>一、变量</h2><h3 id="一般变量"><a href="#一般变量" class="headerlink" title="一般变量"></a>一般变量</h3><ol>
<li><p>变量声明</p>
<ol>
<li>标准格式</li>
</ol>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var name type <span class="comment">// 注意：声明变量时将变量的类型放在变量的名称之后</span></span><br><span class="line">var a,b *<span class="type">int</span> <span class="comment">// 将 a b 同时声明为指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">var hp <span class="type">int</span> = <span class="number">100</span> <span class="comment">// 指定类型</span></span><br><span class="line">var hp = <span class="number">100</span> <span class="comment">// 省略类型，编译器会尝试为变量推到类型</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>简短格式</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 名字 := 表达式</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 定义变量，同时显式初始化。</span></span><br><span class="line"><span class="comment">2. 不能提供数据类型</span></span><br><span class="line"><span class="comment">3. 只能用在函数内部。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时声明+初始化</span></span><br><span class="line">i, j := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">func <span class="built_in">main</span>() &#123;</span><br><span class="line">   x:=<span class="number">100</span></span><br><span class="line">   a,s:=<span class="number">1</span>, <span class="string">&quot;abc&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意  :=  左面必须是新变量</span></span><br><span class="line">var hp <span class="type">int</span> <span class="comment">// 声明 hp 变量</span></span><br><span class="line">hp := <span class="number">10</span>  <span class="comment">// 再次声明并赋值  报错！ 左面没有新变量出现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误！！！！其实 只要有新变量就行！</span></span><br><span class="line">var conn net.Conn</span><br><span class="line">var err error</span><br><span class="line">conn, err = net.<span class="built_in">Dial</span>(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:8080&quot;</span>)  <span class="comment">// 不会报错</span></span><br></pre></td></tr></table></figure>

<p>注意：变量的命名规则遵循骆驼命名法，即首个单词小写，每个新单词的首字母大写，例如：numShips 和 startDate 。</p>
<ol start="2">
<li><p>变量类型</p>
<ol>
<li><p>bool</p>
</li>
<li><p>string</p>
<ol>
<li><p>反引号可以实现多行</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> str = `第一行</span><br><span class="line">第二行</span><br><span class="line">第三行</span><br><span class="line">` </span><br><span class="line">fmt.<span class="built_in">Println</span>(str);  <span class="comment">// 输出上面的内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意 ！！！！！！</span></span><br><span class="line"><span class="comment">// 此时所有的 转义都会失效，即 `` 内部的全部都视为 字符串一部分</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串长度</p>
<ol>
<li><p>len(), 判断的是 ASCII 长度 或者是 字节长度</p>
<ol>
<li><p>在 go 语言中， 所有字符串都是以 utf-8 的格式保存，因此 汉字 3 字节，字符 1 字节</p>
</li>
<li><p>若要将汉字作为一个整体统计， 可以使用下面的函数</p>
</li>
</ol>
</li>
<li><p>RuneCountInString() , 判断的是字符的个数，或者说是 Unicode 字符串长度</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">package main</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">import</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;fmt&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;strings&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 遍历字符串</span></span></span><br><span class="line"><span class="function"><span class="comment">// 按ASCII 字符</span></span></span><br><span class="line"><span class="function">theme :=</span> <span class="string">&quot;狙击 start&quot;</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(theme); i++ &#123;<span class="comment">//使用 for 的数值循环进行遍历--</span></span><br><span class="line">    fmt.<span class="built_in">Printf</span>(<span class="string">&quot;ascii: %c  %d\n&quot;</span>, theme[i], theme[i])</span><br><span class="line">&#125;<span class="comment">// 这里 汉字为乱码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按 Unicode  字符</span></span><br><span class="line">theme := <span class="string">&quot;狙击 start&quot;</span></span><br><span class="line"><span class="keyword">for</span> _, s := range theme &#123;</span><br><span class="line">    fmt.<span class="built_in">Printf</span>(<span class="string">&quot;Unicode: %c  %d\n&quot;</span>, s, s)</span><br><span class="line">&#125;<span class="comment">// 这里汉字正常显示</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串截取</span></span><br><span class="line">newtr := theme[i:]  <span class="comment">// 截取部分包括 i</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串搜索</span></span><br><span class="line">strings.<span class="built_in">Index</span>(strings ,substring); <span class="comment">// 返回 下标</span></span><br><span class="line">strings.<span class="built_in">LastIndex</span>(strings, substrings); <span class="comment">// 反向搜索</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串修改</span></span><br><span class="line">        s1 := <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="comment">//     注意：字符串无法修改，只能在复制的基础上进行修改</span></span><br><span class="line"><span class="comment">//  方法一  转为 []byte()</span></span><br><span class="line">        s2 := []<span class="built_in">byte</span>(s1)</span><br><span class="line">        s2[<span class="number">1</span>] = <span class="string">&#x27;B&#x27;</span></span><br><span class="line">        fmt.<span class="built_in">Println</span>(<span class="built_in">string</span>(s2)) <span class="comment">//aBc</span></span><br><span class="line"><span class="comment">// 方法二  转为 []runej() </span></span><br><span class="line">        s3 := []<span class="built_in">rune</span>(s1)</span><br><span class="line">        s3[<span class="number">1</span>] = <span class="string">&#x27;B&#x27;</span></span><br><span class="line">        fmt.<span class="built_in">Println</span>(<span class="built_in">string</span>(s3)) <span class="comment">//aBc</span></span><br><span class="line"> <span class="comment">// 方法三 字符串替换</span></span><br><span class="line">        new_str := <span class="string">&quot;ABC&quot;</span></span><br><span class="line">        old_str := <span class="string">&quot;abc&quot;</span></span><br><span class="line">        s4 := strings.<span class="built_in">Replace</span>(s1, old_str , new_str , <span class="number">2</span>)</span><br><span class="line">        fmt.<span class="built_in">Println</span>(s4) <span class="comment">//ABC</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串拼接</span></span><br><span class="line">    str1 := <span class="string">&quot;hello&quot;</span></span><br><span class="line">    str2 := <span class="string">&quot;world&quot;</span></span><br><span class="line"> <span class="comment">// 方法一 使用 + 直接拼接</span></span><br><span class="line">     str3 := str1 + str2</span><br><span class="line"> <span class="comment">// 方法二 使用 bytes.Buffer</span></span><br><span class="line">     var stringBuilder bytes.Buffer</span><br><span class="line">     stringBuilder.<span class="built_in">WriteString</span>(str1)</span><br><span class="line">     stringBuilder.<span class="built_in">WriteString</span>(str2)</span><br><span class="line">     str4 := stringBuilder.<span class="built_in">String</span>()</span><br><span class="line">     </span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><p>int、int8、int16、int32、int64</p>
</li>
<li><p>uint、uint8、uint16、uint32、uint64、uintptr</p>
</li>
<li><p>byte &#x2F;&#x2F; uint8 的别名</p>
</li>
<li><p>rune &#x2F;&#x2F; int32 的别名 代表一个 Unicode 码 不对 是 UTF-8</p>
</li>
<li><p>float32、float64</p>
</li>
<li><p>complex64、complex128 内建函数</p>
</li>
<li><p>interface 接口类型<br> <a target="_blank" rel="noopener" href="https://learnku.com/go/t/38843">https://learnku.com/go/t/38843</a></p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Animal <span class="keyword">interface</span> &#123;</span><br><span class="line">    Speak() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>map[string] *sync.WaitGroup  键值对类型</p>
</li>
</ol>
</li>
<li><p>变量赋值</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b, a = a, b  <span class="comment">// 这里 可以实现交换操作</span></span><br><span class="line">a, _ := a, _ := <span class="built_in">GetData</span>()  <span class="comment">// 这里 匿名变量</span></span><br></pre></td></tr></table></figure>
<p>   注意：<strong>当一个变量被声明之后，系统自动赋予它该类型的零值：</strong><strong><code>int 为 0，float 为 0.0，bool 为 false，string 为空字符串，指针为 nil 等</code></strong></p>
<p>   所有的内存在 Go 中都是经过初始化的。</p>
</li>
<li><p>匿名变量不占用内存空间，不分配内存</p>
</li>
<li><p>作用域</p>
<ol>
<li>全局变量声明必须以 <code>var</code> 关键字开头，如果想要在外部包中使用全局变量的首字母必须大写。</li>
<li>特殊变量定义位置 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> firstIdx, err := Func(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	        log.Fatal(err)</span><br><span class="line">	        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="comment">// 这里的 firstIdx 只能在 if 里面的大括号用，一旦出去就使用不了</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>比较</p>
<p>   只有同类型的变量才能进行比较</p>
<p>   包括 0 1 到 true false 的转换</p>
</li>
<li><p>类型转换</p>
<ol>
<li><p>bool 不能强转为 int</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var n <span class="type">bool</span></span><br><span class="line">n := (<span class="type">int</span>)n</span><br><span class="line"><span class="comment">//会报错</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不能获取数组某个位置的的地址</p>
</li>
</ol>
</li>
</ol>
<h3 id="结构体变量"><a href="#结构体变量" class="headerlink" title="结构体变量"></a>结构体变量</h3><ol>
<li>结构体声明 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构体成员变量</span></span><br><span class="line"><span class="keyword">type</span> MyStruct <span class="keyword">struct</span>&#123;</span><br><span class="line">	age <span class="type">int</span>     <span class="comment">// 注意没有 逗号</span></span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结构体函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ms *MyStruct)</span></span> grow(<span class="type">int</span> a) <span class="type">bool</span>&#123;</span><br><span class="line">	ms.age += a</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体的指针继承</span></span><br><span class="line"><span class="keyword">type</span> MyStruct2 <span class="keyword">struct</span>&#123;</span><br><span class="line">	*MyStruct  <span class="comment">// 通过指针的方式，父亲结构体作为一个无名成员变量，</span></span><br><span class="line">			   <span class="comment">// 赋值时使用 父亲对象 赋值； </span></span><br><span class="line">			   <span class="comment">// 使用时使用 孩子对象 直接使用（不需要先点出来父亲）</span></span><br><span class="line">	age <span class="type">int</span>     <span class="comment">// 注意没有 逗号</span></span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>结构体实例化 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一：var 声明</span></span><br><span class="line"><span class="keyword">var</span> fan MyStruct   <span class="comment">// 为 fan 分配内存并且零化值</span></span><br><span class="line">fan.age = <span class="number">26</span></span><br><span class="line">fan.name = <span class="string">&quot;fan&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：new 关键字</span></span><br><span class="line"><span class="comment">// 11</span></span><br><span class="line">fan := &amp;MyStruct&#123;   <span class="comment">// 返回一个结构体指针，带有初始值</span></span><br><span class="line">	<span class="number">26</span>,</span><br><span class="line">	<span class="string">&quot;fan&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 22 </span></span><br><span class="line">fan := <span class="built_in">new</span>(MyStruct) <span class="comment">// 返回一个结构体指针，零值</span></span><br><span class="line">fan.name = <span class="string">&quot;fan&quot;</span></span><br><span class="line">fan.age = <span class="number">26</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法三：赋值初始化</span></span><br><span class="line"><span class="comment">// 11</span></span><br><span class="line">fan := MyStruct&#123;</span><br><span class="line">	name: <span class="string">&quot;fan&quot;</span>,</span><br><span class="line">	age: <span class="number">26</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 22：必须要对应结构体定义顺序，并且每一个都必须进行初始化。</span></span><br><span class="line">fan := MyStruct&#123;</span><br><span class="line">	<span class="number">26</span>,</span><br><span class="line">	<span class="string">&quot;fan&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>匿名结构体 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">profile := &amp;<span class="keyword">struct</span> &#123;</span><br><span class="line">           name <span class="type">string</span></span><br><span class="line">           age   <span class="type">int</span></span><br><span class="line">   &#125;&#123;</span><br><span class="line">           name: <span class="string">&quot;rat&quot;</span>,</span><br><span class="line">           age:   <span class="number">150</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 打印值</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;使用&#x27;%%+v&#x27; %+v\n&quot;</span>, profile)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;使用&#x27;%%#v&#x27; %#v\n&quot;</span>, profile)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;使用&#x27;%%T&#x27; %T\n&quot;</span>, profile)</span><br></pre></td></tr></table></figure></li>
<li>结构体返回值 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newStruct</span><span class="params">()</span></span> * MyStruct&#123;</span><br><span class="line">	<span class="comment">// 此处替换为三种不同方式</span></span><br><span class="line">    <span class="keyword">var</span> fan MyStruct   <span class="comment">// 为 fan 分配内存并且零化值</span></span><br><span class="line">	fan.age = <span class="number">26</span></span><br><span class="line">	fan.name = <span class="string">&quot;fan&quot;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;函数内变量 fan 的地址为：%p\n&quot;</span>, &amp;fan)</span><br><span class="line">	<span class="keyword">return</span> &amp;fan</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fan := newStruct()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;函数外变量 fan 的地址为：%p\n&quot;</span>, fan)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;fan使用&#x27;%%+v&#x27; %+v\n&quot;</span>, fan)</span><br><span class="line">	fan.age = <span class="number">18</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;fan使用&#x27;%%+v&#x27; %+v\n&quot;</span>, fan)</span><br><span class="line">	<span class="comment">// 方法一：地址相同，可更改 </span></span><br><span class="line">	<span class="comment">// 方法二11：地址相同，可更改</span></span><br><span class="line">	<span class="comment">// 方法二22：地址相同，可更改</span></span><br><span class="line">	<span class="comment">// 方法三11：地址相同，可更改</span></span><br><span class="line">	<span class="comment">// 方法三22：地址相同，可更改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="键值对类型"><a href="#键值对类型" class="headerlink" title="键值对类型"></a>键值对类型</h3><p>map[string] *sync.WaitGroup  键值对类型</p>
<ol>
<li>键值对变量<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">    a, b <span class="type">uint64</span></span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// !! 定义与使用 </span></span><br><span class="line">    <span class="comment">//  初始 正常运行</span></span><br><span class="line">    stru := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">uint64</span>]*MyStruct)</span><br><span class="line">    stru[<span class="number">2</span>] = &amp;MyStruct&#123;</span><br><span class="line">        <span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    stru[<span class="number">2</span>].a = <span class="number">1</span></span><br><span class="line">    stru[<span class="number">2</span>].b  = <span class="number">1</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;值为：%+v&quot;</span>,stru[<span class="number">2</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  这样也可以</span></span><br><span class="line">    <span class="keyword">var</span> stru <span class="keyword">map</span>[<span class="type">uint64</span>]*MyStruct </span><br><span class="line">    stru = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">uint64</span>]*MyStruct) <span class="comment">// 没有这行运行不通</span></span><br><span class="line">    stru[<span class="number">2</span>] = &amp;MyStruct&#123;   <span class="comment">// 去掉这行也不行</span></span><br><span class="line">        <span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line">    &#125;  </span><br><span class="line">    stru[<span class="number">2</span>].a = <span class="number">1</span></span><br><span class="line">    stru[<span class="number">2</span>].b  = <span class="number">1</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;值为：%+v&quot;</span>,stru[<span class="number">2</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 结论： map 必须通过 make 且 键值对必须 初始化。才能修改</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 判断键值是否存在</span></span><br><span class="line">	<span class="keyword">if</span> _, ok := stru[<span class="number">2</span>]; !ok &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure></li>
<li>键值对作为结构体成员变量<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">    a, b <span class="type">uint64</span></span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">type</span> MS <span class="keyword">struct</span>&#123;</span><br><span class="line">    stu  <span class="keyword">map</span>[<span class="type">uint64</span>]*MyStruct</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stru MS</span><br><span class="line">    stru.stu = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">uint64</span>]*MyStruct) <span class="comment">// 1 </span></span><br><span class="line">       stru.stu[<span class="number">2</span>]  = &amp; MyStruct&#123; <span class="comment">// 2 , 1 2 这两步都是必须的，且可以多次执行不会冲突</span></span><br><span class="line">           <span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line">       &#125;</span><br><span class="line">    stru.stu[<span class="number">2</span>].a =<span class="number">1</span></span><br><span class="line">    stru.stu[<span class="number">2</span>].b =<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;值为：%+v&quot;</span>,stru.stu[<span class="number">2</span>])</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ol>
<li>定义  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造特定大小的数组，初始会有 size 的大小，每一个元素会有一个初始值，默认0</span></span><br><span class="line">ids := <span class="built_in">make</span>([]<span class="type">uint64</span>, size)</span><br><span class="line"><span class="comment">// 构造大小为 0 的数组</span></span><br><span class="line"><span class="keyword">var</span>   ids  []<span class="type">uint64</span></span><br><span class="line"><span class="comment">//! 注意两种 定义方式 都可以用下面的方法增加元素 </span></span><br><span class="line"><span class="comment">// 增加元素</span></span><br><span class="line">ids = <span class="built_in">append</span>(ids,<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="二、输入、输出"><a href="#二、输入、输出" class="headerlink" title="二、输入、输出"></a>二、输入、输出</h2><ol>
<li><p>fmt.Sprintf(格式化样式 ， 参数列表)</p>
<ol>
<li>和 C 语言类似 printf</li>
</ol>
</li>
<li><p>fmt.Println(str)</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">package main</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">import</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;fmt&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">func <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        var progress = <span class="number">2</span></span><br><span class="line">        var target = <span class="number">8</span></span><br><span class="line">        <span class="comment">// 两参数格式化</span></span><br><span class="line">        title := fmt.<span class="built_in">Sprintf</span>(<span class="string">&quot;已采集%d个药草, 还需要%d个完成任务&quot;</span>, progress, target)</span><br><span class="line">        fmt.<span class="built_in">Println</span>(title)</span><br><span class="line">        pi := <span class="number">3.14159</span></span><br><span class="line">        <span class="comment">// 按数值本身的格式输出</span></span><br><span class="line">        variant := fmt.<span class="built_in">Sprintf</span>(<span class="string">&quot;%v %v %v&quot;</span>, <span class="string">&quot;月球基地&quot;</span>, pi, <span class="literal">true</span>) <span class="comment">//月球基地 3.14159 true</span></span><br><span class="line">        fmt.<span class="built_in">Println</span>(variant)</span><br><span class="line">        <span class="comment">// 匿名结构体声明, 并赋予初值</span></span><br><span class="line">        profile := &amp;<span class="keyword">struct</span> &#123;</span><br><span class="line">                Name string</span><br><span class="line">                HP   <span class="type">int</span></span><br><span class="line">        &#125;&#123;</span><br><span class="line">                Name: <span class="string">&quot;rat&quot;</span>,</span><br><span class="line">                HP:   <span class="number">150</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 双百分号表示转义</span></span><br><span class="line">        fmt.<span class="built_in">Printf</span>(<span class="string">&quot;使用&#x27;%%+v&#x27; %+v\n&quot;</span>, profile)  <span class="comment">// 使用&#x27;%+v&#x27; &amp;&#123;Name:rat HP:150&#125;</span></span><br><span class="line">        fmt.<span class="built_in">Printf</span>(<span class="string">&quot;使用&#x27;%%#v&#x27; %#v\n&quot;</span>, profile)  <span class="comment">// 使用&#x27;%#v&#x27; &amp;struct &#123; Name string; HP int &#125;&#123;Name:&quot;rat&quot;, HP:150&#125;</span></span><br><span class="line">        fmt.<span class="built_in">Printf</span>(<span class="string">&quot;使用&#x27;%%T&#x27; %T\n&quot;</span>, profile)  <span class="comment">// 使用&#x27;%T&#x27; *struct &#123; Name string; HP int &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>动 词 功 能</p>
<p>   %v 按值的本来值输出</p>
<p>   %+v 在 %v 基础上，对结构体字段名和值进行展开</p>
<p>   %#v 输出 Go 语言语法格式的值</p>
<p>   %T 输出 Go 语言语法格式的类型和值</p>
<p>   %% 输出 % 本体</p>
<p>   %b 整型以二进制方式显示</p>
<p>   %o 整型以八进制方式显示</p>
<p>   %d 整型以十进制方式显示</p>
<p>   %x 整型以十六进制方式显示</p>
<p>   %X 整型以十六进制、字母大写方式显示</p>
<p>   %U Unicode 字符</p>
<p>   %f 浮点数</p>
<p>   %p 指针，十六进制方式显示</p>
</li>
</ol>
<h2 id="四、-库"><a href="#四、-库" class="headerlink" title="四、 库"></a>四、 库</h2><h4 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h4><p>功能：Go 语言标准库中的一个包，用于解析命令行参数</p>
<p>关键函数：</p>
<p>flag.type(arg_name,arg_default_value,arg_discription) -&gt; value</p>
<p>flag.Parse() ：解析命令获得各个参数的值</p>
<p>实例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">        // 定义命令行参数</span><br><span class="line">        num1 := flag.Int(<span class="string">&quot;num1&quot;</span>, 0, <span class="string">&quot;第一个整数&quot;</span>)</span><br><span class="line">        num2 := flag.Int(<span class="string">&quot;num2&quot;</span>, 0, <span class="string">&quot;第二个整数&quot;</span>)</span><br><span class="line"></span><br><span class="line">        // 解析命令行参数</span><br><span class="line">        flag.Parse()</span><br><span class="line">        </span><br><span class="line">        // 计算和</span><br><span class="line">        <span class="built_in">sum</span> := *num1 + *num2</span><br><span class="line"></span><br><span class="line">        // 输出结果</span><br><span class="line">        fmt.Println(<span class="string">&quot;和:&quot;</span>, <span class="built_in">sum</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、常见技巧"><a href="#三、常见技巧" class="headerlink" title="三、常见技巧"></a>三、常见技巧</h2><h3 id="常见调用"><a href="#常见调用" class="headerlink" title="常见调用"></a>常见调用</h3><ol>
<li>获取变量类型<br> varb.(type)</li>
<li>获取数组长度<br> len(arr)</li>
</ol>
<h3 id="键值对KV"><a href="#键值对KV" class="headerlink" title="键值对KV"></a>键值对KV</h3><p>go语言中可以使用<code>map[string]interface&#123;&#125;</code>类型来实现，键的索引和值的多种类型</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">        // 定义</span><br><span class="line">        data := map[string]interface&#123;&#125;&#123;</span><br><span class="line">                <span class="string">&quot;myname&quot;</span>: <span class="string">&quot;电子科技大学@2023&quot;</span>,</span><br><span class="line">                <span class="string">&quot;tasks&quot;</span>:  []string&#123;<span class="string">&quot;task 1&quot;</span>, <span class="string">&quot;task 2&quot;</span>, <span class="string">&quot;task 3&quot;</span>&#125;,</span><br><span class="line">                <span class="string">&quot;age&quot;</span>:    25,</span><br><span class="line">                <span class="string">&quot;isStudent&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        // 增加</span><br><span class="line">        data[<span class="string">&quot;newKey&quot;</span>] = <span class="string">&quot;New Value&quot;</span></span><br><span class="line">        </span><br><span class="line">        // 删除</span><br><span class="line">        delete(data, <span class="string">&quot;age&quot;</span>) // 删除 data 中键为 “age” 的键值对</span><br><span class="line">        // 查找</span><br><span class="line">        key := <span class="string">&quot;tasks&quot;</span></span><br><span class="line">        value, found := data[key]</span><br><span class="line">        <span class="keyword">if</span> found &#123;</span><br><span class="line">                fmt.Printf(<span class="string">&quot;Value of key &#x27;%s&#x27;: %v\n&quot;</span>, key, value)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fmt.Printf(<span class="string">&quot;Key &#x27;%s&#x27; not found\n&quot;</span>, key)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // json 解析为键值对 KV 形式</span><br><span class="line">        str := `&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;@2023&quot;</span>&#125;`</span><br><span class="line">        var data map[string]interface&#123;&#125;</span><br><span class="line">        errr := json.Unmarshal([]byte(str), &amp;data)</span><br><span class="line">        <span class="keyword">if</span> errr != nil &#123;</span><br><span class="line">            // 处理解析错误</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(data[<span class="string">&quot;name&quot;</span>])</span><br><span class="line">        </span><br><span class="line">        // 多个键值对支持</span><br><span class="line">            // 局部</span><br><span class="line">            data := make(map[string]interface&#123;&#125;)</span><br><span class="line">            // 全局</span><br><span class="line">            var data map[string]interface&#123;&#125; = make(map[string]interface&#123;&#125;)</span><br><span class="line">            </span><br><span class="line">        // 获取键值对的 K V</span><br><span class="line">        <span class="keyword">for</span> k, v := range data &#123;</span><br><span class="line">             existingData[k] = v</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 将 KV对 处理为 json格式</span><br><span class="line">        jsonData, err := json.Marshal(data)</span><br><span class="line">        <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">                // 处理编码错误</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 将 K V 处理为 json格式</span><br><span class="line">            // 方法 一：</span><br><span class="line">            // fmt.Fprintf(w, <span class="string">&quot;&#123;&#x27;%s&#x27;:&#x27;%v&#x27;&#125;&quot;</span>, param, value)</span><br><span class="line">            </span><br><span class="line">            // 方法 二：</span><br><span class="line">            jsonData, err := json.Marshal(map[string]interface&#123;&#125;&#123;</span><br><span class="line">                param: value,</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">                // 处理编码错误</span><br><span class="line">            &#125;</span><br><span class="line">       </span><br><span class="line">        </span><br><span class="line">        //</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据排序"><a href="#数据排序" class="headerlink" title="数据排序"></a>数据排序</h3><p>对数据集合（包括自定义数据类型的集合）排序需要实现 sort.Interface 接口的三个方法，以下为该接口的定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">        <span class="comment">// 获取数据集合元素个数</span></span><br><span class="line">        Len() <span class="type">int</span></span><br><span class="line">        <span class="comment">// 如果 i 索引的数据小于 j 索引的数据，返回 true 且不会调用下面的 Swap()，即数据升序排序。</span></span><br><span class="line">        Less(i, j <span class="type">int</span>) <span class="type">bool</span></span><br><span class="line">        <span class="comment">// 交换 i 和 j 索引的两个元素的位置</span></span><br><span class="line">        Swap(i, j <span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据集合实现了这三个方法后，即可调用该包的 Sort() 方法进行排序。 Sort() 方法定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sort</span><span class="params">(data Interface)</span></span></span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">type</span> messageSlice []pb.Message</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s messageSlice)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(s) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s messageSlice)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> fmt.Sprint(s[i]) &lt; fmt.Sprint(s[j]) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s messageSlice)</span></span> Swap(i, j <span class="type">int</span>)      &#123; s[i], s[j] = s[j], s[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">sort.Sort(messageSlice(msgs)) <span class="comment">// msgs 为 []pb.Message 类型， 先强转再使用</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="数据比较"><a href="#数据比较" class="headerlink" title="数据比较"></a>数据比较</h3><p>reflect包中的DeepEqual函数完美的解决了比较问题。</p>
<p>函数签名：</p>
<p>func DeepEqual(a1, a2 interface{}) bool</p>
<p>文档中对该函数的说明：<br>DeepEqual函数用来判断两个值是否深度一致：除了类型相同；在可以时（主要是基本类型）会使用&#x3D;&#x3D;；但还会比较array、slice的成员，map的键值对，结构体字段进行深入比对。map的键值对，对键只使用&#x3D;&#x3D;，但值会继续往深层比对。DeepEqual 函数可以正确处理循环的类型。函数类型只有都会nil时才相等；空切片不等于nil切片；还会考虑array、slice的长度、map键值对数。<br>示例：</p>
<p>func main() {<br>    m1 :&#x3D; map[int]interface{}{1: []int{1, 2, 3}, 2: 3, 3: “a”}<br>    m2 :&#x3D; map[int]interface{}{1: []int{1, 2, 3}, 2: 3, 3: “a”}<br>    if reflect.DeepEqual(m1, m2) {<br>        fmt.Println(“相等”)<br>    }<br>}</p>
<p>uestc.leemen.org</p>

                        
                    </div>
                </div>
            </div>
            
                <footer class="kratos-post-meta-new">
                    <span class="pull-left">
                        <time datetime="2024-04-23T03:05:06.592Z" itemprop="datePublished">
                            <a><i class="fa fa-calendar"></i> 2024-04-23</a>
                        </time>
                        
                        
                            <!-- 当前仅支持valine/waline自带的统计功能 -->
                            
                        
                        
                            <!-- 当前仅支持waline自带的统计功能 -->
                            
                        
                    </span>
                    
                    
                        <span class="pull-right">
                            <a class="read-more" href="/2024/04/23/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/GO_lang/go%20%E5%9F%BA%E7%A1%80/" title="留言">留言<i class="fa fa-chevron-circle-right"></i></a>
                        </span>
                    

                </footer>
            
        </article>
    

    
    
        <article class="kratos-hentry kratos-entry-border-new clearfix" itemscope itemtype="https://schema.org/Article">
            <div class="kratos-status">
                
                    <i class="fa fa-refresh"></i>
                
                <div class="kratos-status-inner">
                    <div class="kratos-status-content" itemprop="articleBody">
                        
                            <h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><h3 id="关键"><a href="#关键" class="headerlink" title="关键"></a>关键</h3><p>两两匹配，且只匹配一次，</p>
<h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>两次for循环，计算每两个之间的和</p>
<h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>1</p>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>$n^2$</p>
<h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>先排序，再遍历</p>
<h4 id="没有意义"><a href="#没有意义" class="headerlink" title="没有意义"></a>没有意义</h4><h3 id="方法3"><a href="#方法3" class="headerlink" title="方法3"></a>方法3</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>用哈希，只遍历一次。</p>
<h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>n</p>
<h4 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>n</p>

                        
                    </div>
                </div>
            </div>
            
                <footer class="kratos-post-meta-new">
                    <span class="pull-left">
                        <time datetime="2024-04-23T03:05:06.587Z" itemprop="datePublished">
                            <a><i class="fa fa-calendar"></i> 2024-04-23</a>
                        </time>
                        
                        
                            <!-- 当前仅支持valine/waline自带的统计功能 -->
                            
                        
                        
                            <!-- 当前仅支持waline自带的统计功能 -->
                            
                        
                    </span>
                    
                    
                        <span class="pull-right">
                            <a class="read-more" href="/2024/04/23/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/" title="留言">留言<i class="fa fa-chevron-circle-right"></i></a>
                        </span>
                    

                </footer>
            
        </article>
    

    
    
        <article class="kratos-hentry kratos-entry-border-new clearfix" itemscope itemtype="https://schema.org/Article">
            <div class="kratos-status">
                
                    <i class="fa fa-refresh"></i>
                
                <div class="kratos-status-inner">
                    <div class="kratos-status-content" itemprop="articleBody">
                        
                            <h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>map是STL的一个关联容器，它提供一对一的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=hash&spm=1001.2101.3001.7020">hash</a>。</p>
<p>第一个可以称为关键字(key)，每个关键字只能在map中出现一次；<br>第二个可能称为该关键字的值(value)；</p>
<p>map以模板(泛型)方式实现，可以存储任意类型的数据，包括使用者自定义的数据类型。Map主要用于资料一对一映射(one-to-one)的情況，map內部的实现自建一颗<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%BA%A2%E9%BB%91%E6%A0%91&spm=1001.2101.3001.7020">红黑树</a>，这颗树具有对数据自动排序的功能。在map内部所有的数据都是有序的，后边我们会见识到有序的好处。比如一个班级中，每个学生的学号跟他的姓名就存在著一对一映射的关系。</p>
<h2 id="map的功能"><a href="#map的功能" class="headerlink" title="map的功能"></a>map的功能</h2><p>自动建立key － value的对应。key 和 value可以是任意你需要的类型。</p>
<h2 id="使用-map"><a href="#使用-map" class="headerlink" title="使用 map"></a>使用 map</h2><p>使用map得包含map类所在的头文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;map&gt;  //注意，STL头文件没有扩展名.h</span><br></pre></td></tr></table></figure>

<p>map对象是模板类，需要关键字和存储对象两个模板参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std:map&lt;int, string&gt; personnel;</span><br></pre></td></tr></table></figure>

<p>这样就定义了一个用int作为索引,并拥有相关联的指向string的指针.</p>
<p>为了使用方便，可以对模板类进行一下类型定义，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef map&lt;int,CString&gt; UDT_MAP_INT_CSTRING;</span><br><span class="line"></span><br><span class="line">UDT_MAP_INT_CSTRING enumMap;</span><br></pre></td></tr></table></figure>

<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>map共提供了6个构造函数，这块涉及到内存分配器这些东西，略过不表，在下面我们将接触到一些map的构造方法，这里要说下的就是，我们通常用如下方法构造一个map：</p>
<pre><code>map&lt;int, string&gt; mapStudent;
</code></pre>
<h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个map对象</span></span><br><span class="line">map&lt;<span class="type">int</span>, string&gt; mapStudent;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 第一种 用insert函數插入pair</span></span><br><span class="line">mapStudent.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">000</span>, <span class="string">&quot;student_zero&quot;</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 第二种 用insert函数插入value_type数据</span></span><br><span class="line">mapStudent.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, string&gt;::<span class="built_in">value_type</span>(<span class="number">001</span>, <span class="string">&quot;student_one&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种 用&quot;array&quot;方式插入</span></span><br><span class="line">mapStudent[<span class="number">123</span>] = <span class="string">&quot;student_first&quot;</span>;</span><br><span class="line">mapStudent[<span class="number">456</span>] = <span class="string">&quot;student_second&quot;</span>;</span><br></pre></td></tr></table></figure>
<p> 第一种和第二种在效果上是完成一样的，用insert函数插入数据，在数据的 插入上涉及到集合的唯一性这个概念，即当map中有这个关键字时，insert操作是不能在插入数据的，但是用数组方式就不同了，它可以覆盖以前该关键字对 应的值，用程序说明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mapStudent.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, string&gt;::<span class="built_in">value_type</span> (<span class="number">001</span>, <span class="string">&quot;student_one&quot;</span>));</span><br><span class="line"> </span><br><span class="line">mapStudent.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, string&gt;::<span class="built_in">value_type</span> (<span class="number">001</span>, <span class="string">&quot;student_two&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>上面这两条语句执行后，map中001这个关键字对应的值是“student_one”，第二条语句并没有生效。<br> 那么这就涉及到我们怎么知道insert语句是否插入成功的问题了，可以用pair来获得是否插入成功，程序如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造定义，返回一个pair对象</span></span><br><span class="line"><span class="function">pair&lt;iterator,<span class="type">bool</span>&gt; <span class="title">insert</span> <span class="params">(<span class="type">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"> </span><br><span class="line">pair&lt;map&lt;<span class="type">int</span>, string&gt;::iterator, <span class="type">bool</span>&gt; Insert_Pair;</span><br><span class="line"> </span><br><span class="line">Insert_Pair = mapStudent.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, string&gt;::<span class="built_in">value_type</span> (<span class="number">001</span>, <span class="string">&quot;student_one&quot;</span>));</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(!Insert_Pair.second)</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&quot;</span>Error insert <span class="keyword">new</span> element<span class="string">&quot; &lt;&lt; endl;</span></span><br></pre></td></tr></table></figure>
<p>我们通过pair的第二个变量来知道是否插入成功，它的第一个变量返回的是一个map的迭代器，如果插入成功的话Insert_Pair.second应该是true的，否则为false。</p>
<h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><p>当所查找的关键key出现时，它返回数据所在对象的位置，如果沒有，返回iter与end函数的值相同。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// find 返回迭代器指向当前查找元素的位置否则返回map::end()位置</span></span><br><span class="line">iter = mapStudent.<span class="built_in">find</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(iter != mapStudent.<span class="built_in">end</span>())</span><br><span class="line">       cout&lt;&lt;<span class="string">&quot;Find, the value is&quot;</span>&lt;&lt;iter-&gt;second&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   cout&lt;&lt;<span class="string">&quot;Do not Find&quot;</span>&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<h3 id="刪除与清空元素"><a href="#刪除与清空元素" class="headerlink" title="刪除与清空元素"></a>刪除与清空元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代器刪除</span></span><br><span class="line">iter = mapStudent.<span class="built_in">find</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">mapStudent.<span class="built_in">erase</span>(iter);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//用关键字刪除</span></span><br><span class="line"><span class="type">int</span> n = mapStudent.<span class="built_in">erase</span>(<span class="string">&quot;123&quot;</span>); <span class="comment">//如果刪除了會返回1，否則返回0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//用迭代器范围刪除 : 把整个map清空</span></span><br><span class="line">mapStudent.<span class="built_in">erase</span>(mapStudent.<span class="built_in">begin</span>(), mapStudent.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">//等同于mapStudent.clear()</span></span><br></pre></td></tr></table></figure>
<h3 id="的大小"><a href="#的大小" class="headerlink" title="的大小"></a>的大小</h3><p>在往map里面插入了数据，我们怎么知道当前已经插入了多少数据呢，可以用size函数，用法如下：</p>
<pre><code>int nSize = mapStudent.size();
</code></pre>
<h3 id="map的基本操作函数："><a href="#map的基本操作函数：" class="headerlink" title="map的基本操作函数："></a>map的基本操作函数：</h3><pre><code>C++ maps是一种关联式容器，包含“关键字/值”对
</code></pre>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">begin</span>()         返回指向map头部的迭代器</span><br><span class="line"></span><br><span class="line"><span class="built_in">clear</span>(）        删除所有元素</span><br><span class="line"></span><br><span class="line"><span class="built_in">count</span>()         返回指定元素出现的次数</span><br><span class="line"></span><br><span class="line"><span class="built_in">empty</span>()         如果map为空则返回<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">end</span>()           返回指向map末尾的迭代器</span><br><span class="line"></span><br><span class="line"><span class="built_in">equal_range</span>()   返回特殊条目的迭代器对</span><br><span class="line"></span><br><span class="line"><span class="built_in">erase</span>()         删除一个元素</span><br><span class="line"></span><br><span class="line"><span class="built_in">find</span>()          查找一个元素</span><br><span class="line"></span><br><span class="line"><span class="built_in">get_allocator</span>() 返回map的配置器</span><br><span class="line"></span><br><span class="line"><span class="built_in">insert</span>()        插入元素</span><br><span class="line"></span><br><span class="line"><span class="built_in">key_comp</span>()      返回比较元素key的函数</span><br><span class="line"></span><br><span class="line"><span class="built_in">lower_bound</span>()   返回键值&gt;=给定元素的第一个位置</span><br><span class="line"></span><br><span class="line"><span class="built_in">max_size</span>()      返回可以容纳的最大元素个数</span><br><span class="line"></span><br><span class="line"><span class="built_in">rbegin</span>()        返回一个指向map尾部的逆向迭代器</span><br><span class="line"></span><br><span class="line"><span class="built_in">rend</span>()          返回一个指向map头部的逆向迭代器</span><br><span class="line"></span><br><span class="line"><span class="built_in">size</span>()          返回map中元素的个数</span><br><span class="line"></span><br><span class="line"><span class="built_in">swap</span>()           交换两个map</span><br><span class="line"></span><br><span class="line"><span class="built_in">upper_bound</span>()    返回键值&gt;给定元素的第一个位置</span><br><span class="line"></span><br><span class="line"><span class="built_in">value_comp</span>()     返回比较元素value的函数</span><br></pre></td></tr></table></figure>

<h1 id="hash-map"><a href="#hash-map" class="headerlink" title="hash_map"></a>hash_map</h1><p>hash_map基于hash table（哈希表）。 哈希表最大的优点，就是把数据的存储和查找消耗的时间大大降低，几乎可以看成是常数时间；而代价仅仅是消耗比较多的内存。然而在当前可利用内存越来越多的情况下，用空间换时间的做法是值得的。另外，编码比较容易也是它的特点之一。</p>
<p><code>hash_map</code>是一个哈希表容器，通常指的是<code>std::unordered_map</code>。在C++11标准之后，<code>std::unordered_map</code>已经取代了旧的<code>std::hash_map</code>。在<code>std::unordered_map</code>中，元素的存储位置是由哈希函数计算得出的。</p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>使用一个下标范围比较大的数组来存储元素。可以设计一个函数（哈希函数，也叫做散列函数），使得每个元素的关键字都与一个函数值（即数组下标，hash值）相对应，于是用这个数组单元来存储这个元素；也可以简单的理解为，按照关键字为每一个元素“分类”，然后将这个元素存储在相应“类”所对应的地方，称为桶。</p>
<p>但是，不能够保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了“冲突”，换句话说，就是把不同的元素分在了相同的“类”之中。 总的来说，“直接定址”与“解决冲突”是哈希表的两大特点。</p>
<p>hash_map，首先分配一大片内存，形成许多桶。是利用hash函数，对key进行映射到不同区域（桶）进行保存。其插入过程是：</p>
<p>得到key<br>通过hash函数得到hash值<br>得到桶号(一般都为hash值对桶数求模)<br>存放key和value在桶内。<br>其取值过程是:</p>
<p>得到key<br>通过hash函数得到hash值<br>得到桶号(一般都为hash值对桶数求模)<br>比较桶的内部元素是否与key相等，若都不相等，则没有找到。<br>取出相等的记录的value。<br>hash_map中直接地址用hash函数生成，解决冲突，用比较函数解决。这里可以看出，如果每个桶内部只有一个元素，那么查找的时候只有一次比较。当许多桶内没有值时，许多查询就会更快了(指查不到的时候).</p>
<p>由此可见，要实现哈希表, 和用户相关的是：<strong>hash函数</strong>和<strong>比较函数</strong>。这两个参数刚好是我们在使用hash_map时需要指定的参数。</p>
<p>例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;hash_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        hash_map&lt;<span class="type">int</span>, string&gt; mymap;</span><br><span class="line">        mymap[<span class="number">9527</span>]=<span class="string">&quot;唐伯虎点秋香&quot;</span>;</span><br><span class="line">        mymap[<span class="number">1000000</span>]=<span class="string">&quot;百万富翁的生活&quot;</span>;</span><br><span class="line">        mymap[<span class="number">10000</span>]=<span class="string">&quot;白领的工资底线&quot;</span>;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span>(mymap.<span class="built_in">find</span>(<span class="number">10000</span>) != mymap.<span class="built_in">end</span>())&#123;</span><br><span class="line">                ...</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>你没有指定hash函数和比较函数的时候，你会有一个缺省的函数，看看hash_map的声明，你会更加明白。下面是SGI STL的声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Key</span>, <span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_HashFcn</span> = hash&lt;_Key&gt;,</span><br><span class="line"><span class="keyword">class</span> _EqualKey = equal_to&lt;_Key&gt;,</span><br><span class="line"><span class="keyword">class</span> _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) &gt;</span><br><span class="line"><span class="keyword">class</span> hash_map</span><br><span class="line">&#123;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，在上例中，有以下等同关系：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hash_map&lt;<span class="type">int</span>, string&gt; mymap;</span><br><span class="line"><span class="comment">//等同于:</span></span><br><span class="line">hash_map&lt;<span class="type">int</span>, string, hash&lt;<span class="type">int</span>&gt;, equal_to&lt;<span class="type">int</span>&gt; &gt; mymap;</span><br></pre></td></tr></table></figure>
<h2 id="hash-map-的hash函数"><a href="#hash-map-的hash函数" class="headerlink" title="hash_map 的hash函数"></a>hash_map 的hash函数</h2><p>hash&lt; int&gt;到底是什么样子？看看源码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line">        <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> __x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> __x; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>原来是个函数对象。在SGI STL中，提供了以下hash函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">char</span>*&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">char</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">signed</span> <span class="type">char</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">short</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">unsigned</span> <span class="type">short</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">int</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">long</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span>&lt;<span class="type">unsigned</span> <span class="type">long</span>&gt;</span><br></pre></td></tr></table></figure>
<p>也就是说，如果你的key使用的是以上类型中的一种，你都可以使用缺省的hash函数。当然你自己也可以定义自己的hash函数。对于自定义变量，你只能如此，例如对于string，就必须自定义hash函数。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">str_hash</span>&#123;</span><br><span class="line">        <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string&amp; str)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">long</span> __h = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span> ; i &lt; str.<span class="built_in">size</span>() ; i ++)</span><br><span class="line">                __h = <span class="number">5</span>*__h + str[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">size_t</span>(__h);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果你希望利用系统定义的字符串hash函数，你可以这样写：</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str_hash</span>&#123;</span><br><span class="line">        <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string&amp; str)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> __stl_hash_string(str.<span class="built_in">c_str</span>());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在声明自己的哈希函数时要注意以下几点：</p>
<p>1、使用struct，然后重载operator().<br>2、返回是size_t<br>3、参数是你要hash的key的类型。<br>4、函数是const类型的。</p>
<p>现在可以对开头的string 进行哈希化了 . 直接替换成下面的声明即可：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, string&gt; namemap; </span><br><span class="line"><span class="comment">//改为：</span></span><br><span class="line">hash_map&lt;string, string, str_hash&gt; namemap;</span><br></pre></td></tr></table></figure>
                        
                    </div>
                </div>
            </div>
            
                <footer class="kratos-post-meta-new">
                    <span class="pull-left">
                        <time datetime="2024-04-23T03:05:06.586Z" itemprop="datePublished">
                            <a><i class="fa fa-calendar"></i> 2024-04-23</a>
                        </time>
                        
                        
                            <!-- 当前仅支持valine/waline自带的统计功能 -->
                            
                        
                        
                            <!-- 当前仅支持waline自带的统计功能 -->
                            
                        
                    </span>
                    
                    
                        <span class="pull-right">
                            <a class="read-more" href="/2024/04/23/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/STL/" title="留言">留言<i class="fa fa-chevron-circle-right"></i></a>
                        </span>
                    

                </footer>
            
        </article>
    

    
    
        <article class="kratos-hentry kratos-entry-border-new clearfix" itemscope itemtype="https://schema.org/Article">
            <div class="kratos-status">
                
                    <i class="fa fa-refresh"></i>
                
                <div class="kratos-status-inner">
                    <div class="kratos-status-content" itemprop="articleBody">
                        
                            <p>[[方向调研]]</p>
<p>[[检索工具]]</p>
<p>[[会议调研]]</p>
<ul>
<li><code>@article</code>: 用于引用发表在学术期刊中的文章，包括期刊论文、期刊文章等。</li>
<li><code>@book</code>: 用于引用书籍、专著等完整的出版物。</li>
<li><code>@inproceedings</code>: 用于引用会议论文或会议文章。</li>
<li><code>@thesis</code>: 用于引用学位论文、硕士论文、博士论文等。</li>
<li><code>@techreport</code>: 用于引用技术报告、研究报告等非正式出版物。</li>
<li><code>@website</code>: 用于引用网页、网站或在线资源。</li>
</ul>

                        
                    </div>
                </div>
            </div>
            
                <footer class="kratos-post-meta-new">
                    <span class="pull-left">
                        <time datetime="2024-04-23T03:05:06.580Z" itemprop="datePublished">
                            <a><i class="fa fa-calendar"></i> 2024-04-23</a>
                        </time>
                        
                        
                            <!-- 当前仅支持valine/waline自带的统计功能 -->
                            
                        
                        
                            <!-- 当前仅支持waline自带的统计功能 -->
                            
                        
                    </span>
                    
                    
                        <span class="pull-right">
                            <a class="read-more" href="/2024/04/23/%E7%A0%94%E7%A9%B6%E6%96%B9%E5%90%91/%E7%A0%94%E7%A9%B6/" title="留言">留言<i class="fa fa-chevron-circle-right"></i></a>
                        </span>
                    

                </footer>
            
        </article>
    

    
    
        <article class="kratos-hentry kratos-entry-border-new clearfix" itemscope itemtype="https://schema.org/Article">
            <div class="kratos-status">
                
                    <i class="fa fa-refresh"></i>
                
                <div class="kratos-status-inner">
                    <div class="kratos-status-content" itemprop="articleBody">
                        
                            <h1 id="检索数据库"><a href="#检索数据库" class="headerlink" title="检索数据库"></a>检索数据库</h1><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>链接</th>
</tr>
</thead>
<tbody><tr>
<td>Engineering Village</td>
<td>平台上的10多个数据库涵盖了工程、应用科学相关的最为广泛的领域，内容来源包括学术文献、商业出版物、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8F%91%E6%98%8E%E4%B8%93%E5%88%A9/1140123?fromModule=lemma_inlink">发明专利</a>、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%BC%9A%E8%AE%AE%E8%AE%BA%E6%96%87/4482302?fromModule=lemma_inlink">会议论文</a>和<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/8206960?fromModule=lemma_inlink">技术报告</a>等等;其中的Compendex 就是美国工程索引Engineering Index数据库</td>
<td><a target="_blank" rel="noopener" href="https://www.engineeringvillage.com/">https://www.engineeringvillage.com/</a><br>（用 Edge 打开）</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>

                        
                    </div>
                </div>
            </div>
            
                <footer class="kratos-post-meta-new">
                    <span class="pull-left">
                        <time datetime="2024-04-23T03:05:06.580Z" itemprop="datePublished">
                            <a><i class="fa fa-calendar"></i> 2024-04-23</a>
                        </time>
                        
                        
                            <!-- 当前仅支持valine/waline自带的统计功能 -->
                            
                        
                        
                            <!-- 当前仅支持waline自带的统计功能 -->
                            
                        
                    </span>
                    
                    
                        <span class="pull-right">
                            <a class="read-more" href="/2024/04/23/%E7%A0%94%E7%A9%B6%E6%96%B9%E5%90%91/%E6%A3%80%E7%B4%A2%E5%B7%A5%E5%85%B7/" title="留言">留言<i class="fa fa-chevron-circle-right"></i></a>
                        </span>
                    

                </footer>
            
        </article>
    

    
    
        <article class="kratos-hentry kratos-entry-border-new clearfix" itemscope itemtype="https://schema.org/Article">
            <div class="kratos-status">
                
                    <i class="fa fa-refresh"></i>
                
                <div class="kratos-status-inner">
                    <div class="kratos-status-content" itemprop="articleBody">
                        
                            <p>论文调研旨在找到一个喜欢的方向并且实现小论文撰写，</p>
<h1 id="ICDE-2023"><a href="#ICDE-2023" class="headerlink" title="ICDE 2023"></a>ICDE 2023</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>ICDE-2023共接收论文228篇，录用率在25%左右，研究方向统计如下：</p>
<table>
<thead>
<tr>
<th>方向</th>
<th>子方向</th>
<th>论文数量</th>
</tr>
</thead>
<tbody><tr>
<td>图与网络</td>
<td>图算法、图处理框架、图数据库、图神经网络、图分析、知识图谱</td>
<td>69</td>
</tr>
<tr>
<td>时空、轨迹数据分析</td>
<td></td>
<td>34</td>
</tr>
<tr>
<td>AI4DB</td>
<td>基数估计、查询优化、学习索引、NL2SQL、表格推理、工作负载预测、性能调优、数据库嵌入</td>
<td>13</td>
</tr>
<tr>
<td>数据库管理</td>
<td>物化视图管理、工作负载分析、事务、死锁检测、数据库安全</td>
<td>8</td>
</tr>
<tr>
<td>存储</td>
<td></td>
<td>4</td>
</tr>
<tr>
<td>查询、索引优化</td>
<td></td>
<td>18</td>
</tr>
<tr>
<td>人工智能</td>
<td>机器学习、深度学习、聚类、强化学习、在线学习</td>
<td>25</td>
</tr>
<tr>
<td>流处理</td>
<td>-</td>
<td>9</td>
</tr>
<tr>
<td>数据挖掘与分析</td>
<td>数据挖掘、数据压缩、推荐</td>
<td>25</td>
</tr>
<tr>
<td>边缘计算、区块链、物联网</td>
<td>-</td>
<td>11</td>
</tr>
<tr>
<td>视频处理</td>
<td>-</td>
<td>2</td>
</tr>
<tr>
<td>隐私保护、数据安全</td>
<td>-</td>
<td>4</td>
</tr>
<tr>
<td>众包</td>
<td>-</td>
<td>6</td>
</tr>
</tbody></table>
<h2 id="详情"><a href="#详情" class="headerlink" title="详情"></a>详情</h2><h3 id="图与网络"><a href="#图与网络" class="headerlink" title="图与网络"></a>图与网络</h3><table>
<thead>
<tr>
<th>论文</th>
<th>子方向</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>COCLEP: Contrastive Learning-based Semi-Supervised Community Search</td>
<td>图算法</td>
<td></td>
</tr>
<tr>
<td>FASI: FPGA-friendly Subgraph Isomorphism on Massive Graphs</td>
<td>图算法</td>
<td></td>
</tr>
<tr>
<td>HGMatch: A Match-by-Hyperedge Framework for Efficient and Parallel Subhypergraph Matching</td>
<td>图算法</td>
<td></td>
</tr>
<tr>
<td>Layph: Making Change Propagation Constraint in Incremental Graph Processing by Layering Graph</td>
<td>图算法</td>
<td></td>
</tr>
<tr>
<td>LightTraffic: On Optimizing CPU-GPU Data Traffic for Efficient Large-scale Random Walks</td>
<td>图算法</td>
<td></td>
</tr>
<tr>
<td>Lumos: Heterogeneity-aware Federated Graph Learning over Decentralized Devices</td>
<td>图算法</td>
<td></td>
</tr>
<tr>
<td>PSPC: Efficient Parallel Shortest Path Counting on Large-Scale Graphs</td>
<td>图算法</td>
<td></td>
</tr>
<tr>
<td>TDB: Breaking All Hop-Constrained Cycles in Billion-Scale Directed Graphs</td>
<td>图算法</td>
<td></td>
</tr>
<tr>
<td>Finer-Grained Engagement in Hypergraphs</td>
<td>图算法</td>
<td></td>
</tr>
<tr>
<td>Distributed (α, β)-Core Decomposition over Bipartite Graphs</td>
<td>图算法</td>
<td></td>
</tr>
<tr>
<td>Fairness-aware Maximal Biclique Enumeration on Bipartite Graphs</td>
<td>图算法</td>
<td></td>
</tr>
<tr>
<td>Index-Based Biclique Percolation Communities Search on Bipartite graphs</td>
<td>图算法</td>
<td></td>
</tr>
<tr>
<td>Efficiently Answering Quality Constrained Shortest Distance Queries in Large Graphs</td>
<td>图算法</td>
<td></td>
</tr>
<tr>
<td>Verification-Free Approaches to Efficient Locally Densest Subgraph Discovery</td>
<td>图算法</td>
<td></td>
</tr>
<tr>
<td>Efficient Maximum Signed Biclique Identification</td>
<td>图算法</td>
<td></td>
</tr>
<tr>
<td>Explainable Hyperlink Prediction: A Hypergraph Edit Distance-Based Approach</td>
<td>图算法</td>
<td></td>
</tr>
<tr>
<td>Reinforcement Learning Enhanced Weighted Sampling for Accurate Subgraph Counting on Fully Dynamic Graph Streams</td>
<td>图算法</td>
<td></td>
</tr>
<tr>
<td>Towards Efficient Shortest Path Counting on Billion-Scale Graphs</td>
<td>图算法</td>
<td></td>
</tr>
<tr>
<td>Fair Group Summarization with Graph Patterns</td>
<td>图算法</td>
<td></td>
</tr>
<tr>
<td>Top-r keyword-based community search in attributed graphs</td>
<td>图算法</td>
<td></td>
</tr>
<tr>
<td>Accelerating k-Core Decomposition by a GPU</td>
<td>图算法</td>
<td></td>
</tr>
<tr>
<td>Minimizing the Influence of Misinformation via Vertex Blocking</td>
<td>图算法</td>
<td></td>
</tr>
<tr>
<td>Efficiently Sampling and Estimating Hypergraphs By Hybrid Random Walk</td>
<td>图算法</td>
<td></td>
</tr>
<tr>
<td>Efficient Multi-GPU Graph Processing with Remote Work Stealing</td>
<td>图算法</td>
<td></td>
</tr>
<tr>
<td>Neighborhood Skyline on Graphs: Concepts, Algorithms and Applications</td>
<td>图算法</td>
<td></td>
</tr>
<tr>
<td>Finding Top-k Important Edges on Bipartite Graphs: Ego-betweenness Centrality-based Approaches</td>
<td>图算法</td>
<td></td>
</tr>
<tr>
<td>VC-dimension and Rademacher Averages of Subgraphs, with Applications to Graph Mining</td>
<td>图算法</td>
<td></td>
</tr>
<tr>
<td>Most Probable Densest Subgraphs</td>
<td>图算法</td>
<td></td>
</tr>
<tr>
<td>Scalable Algorithms for Densest Subgraph Discovery</td>
<td>图算法</td>
<td></td>
</tr>
<tr>
<td>Distributed Near-Maximum Independent Set Maintenance over Large-scale Dynamic Graphs</td>
<td>图算法</td>
<td></td>
</tr>
<tr>
<td>Fast Unsupervised Graph Embedding via Graph Zoom Learning</td>
<td>图算法</td>
<td></td>
</tr>
<tr>
<td>Wind-Bell Index: Towards Ultra-Fast Relational Query for Graph Databases</td>
<td>图数据库</td>
<td>查询</td>
</tr>
<tr>
<td>Hop-Constrained s-t Simple Path Enumeration on Large Dynamic Graphs</td>
<td>图数据库</td>
<td>查询</td>
</tr>
<tr>
<td>A Reachability Index for Recursive Label-Concatenated Graph Queries</td>
<td>图数据库</td>
<td>索引</td>
</tr>
<tr>
<td>VEND: Vertex Encoding for Edge Nonexistence Determination</td>
<td>图数据库</td>
<td></td>
</tr>
<tr>
<td>Extracting Graphs Properties with Semantic Joins</td>
<td>图数据库</td>
<td></td>
</tr>
<tr>
<td>Integrating Connection Search in Graph Queries</td>
<td>图数据库</td>
<td>查询</td>
</tr>
<tr>
<td>AFaVS: Accurate Yet Fast Version Switching for Graph Processing Systems</td>
<td>图处理系统</td>
<td></td>
</tr>
<tr>
<td>FLASH: A Framework for Programming Distributed Graph Processing Algorithms</td>
<td>图处理系统</td>
<td></td>
</tr>
<tr>
<td>Partitioner Selection with EASE to Optimize Distributed Graph Processing</td>
<td>图处理系统</td>
<td></td>
</tr>
<tr>
<td>Optimizing Graph Partition by Optimal Vertex-Cut: A Holistic Approach</td>
<td>图处理系统</td>
<td>图划分</td>
</tr>
<tr>
<td>HyTGraph: GPU-Accelerated Graph Processing with Hybrid Transfer Management</td>
<td>图处理系统</td>
<td></td>
</tr>
<tr>
<td>GAMMA: A Graph Pattern Mining Framework for Large Graphs on GPU</td>
<td>图处理系统</td>
<td>图模式挖掘</td>
</tr>
<tr>
<td>HyGNN: Drug-Drug Interaction Prediction via Hypergraph Neural Network</td>
<td>图神经网络</td>
<td></td>
</tr>
<tr>
<td>Demystifying Bitcoin Address Behavior via Graph Neural Networks</td>
<td>图神经网络</td>
<td></td>
</tr>
<tr>
<td>Jointly Attacking Graph Neural Network and its Explanations</td>
<td>图神经网络</td>
<td></td>
</tr>
<tr>
<td>Relational Temporal Graph Convolutional Networks for Ranking-Based Stock Prediction</td>
<td>图神经网络</td>
<td></td>
</tr>
<tr>
<td>A Bayesian Graph Neural Network for EEG Classification — A Win-Win on Performance and Interpretability</td>
<td>图神经网络</td>
<td></td>
</tr>
<tr>
<td>Layer-refined Graph Convolutional Networks for Recommendation</td>
<td>图神经网络</td>
<td></td>
</tr>
<tr>
<td>AutoAC: Towards Automated Attribute Completion for Heterogeneous Graph Neural Network</td>
<td>图神经网络</td>
<td></td>
</tr>
<tr>
<td>SEIGN: A Simple and Efficient Graph Neural Network for Large Dynamic Graphs</td>
<td>图神经网络</td>
<td></td>
</tr>
<tr>
<td>Revisiting Citation Prediction with Cluster-Aware Text-Enhanced Heterogeneous Graph Neural Networks</td>
<td>图神经网络</td>
<td></td>
</tr>
<tr>
<td>Towards Higher-order Topological Consistency for Unsupervised Network Alignment</td>
<td>图神经网络</td>
<td></td>
</tr>
<tr>
<td>CLDG: Contrastive Learning on Dynamic Graphs</td>
<td>图分析</td>
<td></td>
</tr>
<tr>
<td>GALE: Active Adversarial Learning for Erroneous Node Detection in Graphs</td>
<td>图分析</td>
<td></td>
</tr>
<tr>
<td>IFCA: Index-Free Community-Aware Reachability Processing Over Large Dynamic Graphs</td>
<td>图分析</td>
<td></td>
</tr>
<tr>
<td>Unsupervised Graph Outlier Detection: Problem Revisit, New Insight, and Superior Method</td>
<td>图分析</td>
<td></td>
</tr>
<tr>
<td>Efficient and Compact Spreadsheet Formula Graphs</td>
<td>图分析</td>
<td></td>
</tr>
<tr>
<td>Inconsistency Detection with Temporal Graph Functional Dependencies</td>
<td>图分析</td>
<td></td>
</tr>
<tr>
<td>Keyword-based Socially Tenuous Group Queries</td>
<td>图分析</td>
<td></td>
</tr>
<tr>
<td>Community Search: A Meta-Learning Approach</td>
<td>图分析</td>
<td></td>
</tr>
<tr>
<td>Dynamic Activation of Clients and Parameters for Federated Learning over Heterogeneous Graphs</td>
<td>图分析</td>
<td></td>
</tr>
<tr>
<td>RETIA: Relation-Entity Twin-Interact Aggregation for Temporal Knowledge Graph Extrapolation</td>
<td>知识图谱</td>
<td></td>
</tr>
<tr>
<td>Disconnected Emerging Knowledge Graph Oriented Inductive Link Prediction</td>
<td>知识图谱</td>
<td></td>
</tr>
<tr>
<td>Relational Message Passing for Fully Inductive Knowledge Graph Completion</td>
<td>知识图谱</td>
<td></td>
</tr>
<tr>
<td>MMKGR: Multi-hop Multi-modal Knowledge Graph Reasoning</td>
<td>知识图谱</td>
<td></td>
</tr>
<tr>
<td>Robust Attributed Graph Alignment via Joint Structure Learning and Optimal Transpor</td>
<td>知识图谱</td>
<td></td>
</tr>
<tr>
<td>Multimodal Biological Knowledge Graph Completion via Triple Co-attention Mechanism</td>
<td>知识图谱</td>
<td></td>
</tr>
<tr>
<td>A Holistic Approach for Answering Logical Queries on Knowledge Graphs</td>
<td>知识图谱</td>
<td></td>
</tr>
</tbody></table>
<h3 id="时空、轨迹数据分析"><a href="#时空、轨迹数据分析" class="headerlink" title="时空、轨迹数据分析"></a>时空、轨迹数据分析</h3><table>
<thead>
<tr>
<th>论文</th>
<th>子方向</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>TSC-AutoML: Meta-learning for automatic Time Series Classification Algorithm Selection</td>
<td>时空数据分析</td>
<td></td>
</tr>
<tr>
<td>TSEXPLAIN: Explaining Aggregated Time Series by Surfacing Evolving Contributors</td>
<td>时空数据分析</td>
<td></td>
</tr>
<tr>
<td>Towards Long-Term Time-Series Forecasting: Feature, Pattern, and Distribution</td>
<td>时空数据分析</td>
<td></td>
</tr>
<tr>
<td>PriSTI: A Conditional Diffusion Framework for Spatiotemporal Imputation</td>
<td>时空数据分析</td>
<td></td>
</tr>
<tr>
<td>REncoder: A Space-Time Efficient Range Filter with Local Encoder</td>
<td>时空数据分析</td>
<td></td>
</tr>
<tr>
<td>ROI-demand Traffic Prediction: A Pre-train, Query and Fine-tune Framework</td>
<td>时空数据分析</td>
<td></td>
</tr>
<tr>
<td>When Spatio-Temporal Meet Wavelets: Disentangled Traffic Forecasting via Efficient Spectral Graph Attention Networks</td>
<td>时空数据分析</td>
<td></td>
</tr>
<tr>
<td>Discovering Frequency Bursting Patterns in Temporal Graphs</td>
<td>时空数据分析</td>
<td></td>
</tr>
<tr>
<td>Matrix Factorization with Landmarks for Spatial Data</td>
<td>时空数据分析</td>
<td></td>
</tr>
<tr>
<td>Uncertainty Quantification for Traffic Forecasting: A Unified Approach</td>
<td>时空数据分析</td>
<td></td>
</tr>
<tr>
<td>Extreme-Aware Local-Global Attention for Spatio-Temporal Urban Mobility Learning</td>
<td>时空数据分析</td>
<td></td>
</tr>
<tr>
<td>Mining Seasonal Temporal Patterns in Time Series</td>
<td>时空数据分析</td>
<td></td>
</tr>
<tr>
<td>A Stitch in Time Saves Nine: Enabling Early Anomaly Detection with Correlation Analysis</td>
<td>时空数据分析</td>
<td></td>
</tr>
<tr>
<td>Self-Supervised Spatial-Temporal Bottleneck Attentive Network for Efﬁcient Long-term Trafﬁc Forecasting</td>
<td>时空数据分析</td>
<td></td>
</tr>
<tr>
<td>namic Hypergraph Structure Learning for Traffic Flow Forecasting</td>
<td>时空数据分析</td>
<td></td>
</tr>
<tr>
<td>Forecasting COVID-19 Dynamics: Clustering, Generalized Spatiotemporal Attention, and Impacts of Mobility and Geographic Proximity</td>
<td>时空数据分析</td>
<td></td>
</tr>
<tr>
<td>Double Hierarchical Labeling Shortest Distance Querying in Time-dependent Road Networks</td>
<td>时空数据分析</td>
<td></td>
</tr>
<tr>
<td>BERT-Trip: Effective and Scalable Trip Representation using Attentive Contrast Learning</td>
<td>轨迹数据分析</td>
<td></td>
</tr>
<tr>
<td>LHMM: A Learning Enhanced HMM Model for Cellular Trajectory Map-matching</td>
<td>轨迹数据分析</td>
<td></td>
</tr>
<tr>
<td>Contrastive Trajectory Similarity Learning with Dual-Feature Attention</td>
<td>轨迹数据分析</td>
<td></td>
</tr>
<tr>
<td>Online Anomalous Subtrajectory Detection on Road Networks with Deep Reinforcement Learning</td>
<td>轨迹数据分析</td>
<td></td>
</tr>
<tr>
<td>Towards Efficient MIT query in Trajectory Data</td>
<td>轨迹数据分析</td>
<td></td>
</tr>
<tr>
<td>A Lightweight Framework for Fast Trajectory Simplification</td>
<td>轨迹数据分析</td>
<td></td>
</tr>
<tr>
<td>Self-supervised Trajectory Representation Learning with Temporal Regularities and Travel Semantics</td>
<td>轨迹数据分析</td>
<td></td>
</tr>
<tr>
<td>RNTrajRec: Road Network Enhanced Trajectory Recovery with Spatial-Temporal Transformer</td>
<td>轨迹数据分析</td>
<td></td>
</tr>
<tr>
<td>Collision-Aware Route Planning in Warehouses Made Efficient: A Strip-based Framework</td>
<td>轨迹数据分析</td>
<td></td>
</tr>
<tr>
<td>Efficient Public Transport Planning on Roads</td>
<td>轨迹数据分析</td>
<td></td>
</tr>
<tr>
<td>Reinforcement Learning based Tree Decomposition for Distance Querying in Road Networks</td>
<td>路网分析</td>
<td></td>
</tr>
<tr>
<td>Global Routing Optimization In Road Networks</td>
<td>路网分析</td>
<td></td>
</tr>
<tr>
<td>Experimental Evaluation of Indexing Techniques for Shortest Distance Queries on Road Networks</td>
<td>路网分析</td>
<td></td>
</tr>
<tr>
<td>Finding Top-k Optimal Routes with Collective Spatial Keywords on Road Networks</td>
<td>路网分析</td>
<td></td>
</tr>
<tr>
<td>Data Imputation for Sparse Radio Maps in Indoor Positioning</td>
<td>地理信息分析</td>
<td></td>
</tr>
<tr>
<td>Semi-supervised Learning with Network Embedding on Ambient RF Signals for Geofencing Services</td>
<td>地理信息分析</td>
<td></td>
</tr>
<tr>
<td>A Contextual Master-Slave Framework on Urban Region Graph for Urban Village Detection</td>
<td>地理信息分析</td>
<td></td>
</tr>
</tbody></table>
<h3 id="Ai4DB"><a href="#Ai4DB" class="headerlink" title="Ai4DB"></a>Ai4DB</h3><table>
<thead>
<tr>
<th>论文</th>
<th>子方向</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>AutoCE: An Accurate and Efficient Model Advisor for Learned Cardinality Estimation</td>
<td>基数估计</td>
<td></td>
</tr>
<tr>
<td>Couper: Memory-Efficient Cardinality Estimation under Unbalanced Distribution</td>
<td>基数估计</td>
<td></td>
</tr>
<tr>
<td>Dynamic Materialized View Management using Graph Neural Network</td>
<td>查询优化</td>
<td>物化视图、图神经网络</td>
</tr>
<tr>
<td>Efficient Deep Ensemble Inference via Query Difficulty-dependent Task Scheduling</td>
<td>查询优化</td>
<td></td>
</tr>
<tr>
<td>GAR: A Generate-and-Rank Approach for Natural Language to SQL Translation</td>
<td>NL2SQL</td>
<td></td>
</tr>
<tr>
<td>Efficiently Learning Spatial Indices</td>
<td>学习索引</td>
<td></td>
</tr>
<tr>
<td>Towards Optimizing Storage Costs on the Cloud</td>
<td>存储</td>
<td></td>
</tr>
<tr>
<td>Data Ambiguity Profiling for the Generation of Training Examples</td>
<td>NL2SQL</td>
<td></td>
</tr>
<tr>
<td>Towards Explainable Table Interpretation Using Multi-view Explanations</td>
<td>表解释</td>
<td></td>
</tr>
<tr>
<td>Toward a Unified Framework for Unsupervised Complex Tabular Reasoning</td>
<td>表格推理</td>
<td></td>
</tr>
<tr>
<td>DBAugur: An Adversarial-based Trend Forecasting System for Diversified Workloads</td>
<td>工作负载预测</td>
<td></td>
</tr>
<tr>
<td>Active Sampling for Sparse Table by Bayesian Optimization with Adaptive Resolution</td>
<td>性能调优</td>
<td></td>
</tr>
<tr>
<td>Stable Tuple Embeddings for Dynamic Databases</td>
<td>数据库嵌入</td>
<td></td>
</tr>
</tbody></table>
<h3 id="数据库管理"><a href="#数据库管理" class="headerlink" title="数据库管理"></a>数据库管理</h3><table>
<thead>
<tr>
<th>论文</th>
<th>子方向</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>S&#x2F;C: Speeding up Data Materialization with Bounded Memory</td>
<td>物化视图</td>
<td></td>
</tr>
<tr>
<td>Co-Utilizing SIMD and Scalar to Accelerate the Data Analytics Workloads</td>
<td>工作负载分析</td>
<td></td>
</tr>
<tr>
<td>Leopard: A Black-Box Approach for Efficiently Verifying Various Isolation Levels</td>
<td>事务</td>
<td></td>
</tr>
<tr>
<td>Knock Out 2PC with Practicality Intact: a High-performance and General Distributed Transaction Protocol</td>
<td>事务</td>
<td></td>
</tr>
<tr>
<td>Database Deadlock Diagnosis for Large-scale ORM-based Web Applications</td>
<td>死锁检测</td>
<td></td>
</tr>
<tr>
<td>LCL: A Lock Chain Length-based Distributed Algorithm for Deadlock Detection and Resolution</td>
<td>死锁检测</td>
<td></td>
</tr>
<tr>
<td>Sequence-Oriented DBMS Fuzzing</td>
<td>数据库安全</td>
<td></td>
</tr>
<tr>
<td>DBCatcher: A Cloud Database Online Anomaly Detection System based on Indicator Correlatio</td>
<td>数据库安全</td>
<td></td>
</tr>
</tbody></table>
<h3 id="存储、LSM-Tree"><a href="#存储、LSM-Tree" class="headerlink" title="存储、LSM Tree"></a>存储、LSM Tree</h3><table>
<thead>
<tr>
<th>论文</th>
<th>子方向</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>ACEing the Bufferpool Management Paradigm for Modern Storage Devices</td>
<td>存储</td>
<td></td>
</tr>
<tr>
<td>Redesigning High-Performance LSM-based Key-Value Stores with Persistent CPU Caches</td>
<td>存储</td>
<td></td>
</tr>
<tr>
<td>Workload-Aware Log-Structured Merge Key-Value Store for NVM-SSD Hybrid Storage</td>
<td>存储</td>
<td></td>
</tr>
<tr>
<td>Real-Time LSM-Trees for HTAP Workloads</td>
<td>LSM Tree</td>
<td>适用于 HTAP 工作负载的实时 LSM 树</td>
</tr>
</tbody></table>
<h3 id="查询、索引优化"><a href="#查询、索引优化" class="headerlink" title="查询、索引优化"></a>查询、索引优化</h3><table>
<thead>
<tr>
<th>论文</th>
<th>子方向</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>ADAMANT: A Query Executor with Plug-In Interfaces for Easy Co-processor Integration</td>
<td>查询</td>
<td></td>
</tr>
<tr>
<td>Skyline Micro-Cluster Query: A Novel and Practical Spatial Query</td>
<td>查询</td>
<td></td>
</tr>
<tr>
<td>Ver: View Discovery in the Wild</td>
<td>查询</td>
<td></td>
</tr>
<tr>
<td>EulerFD: An Efficient Double-Cycle Approximation of Functional Dependencies</td>
<td>查询</td>
<td></td>
</tr>
<tr>
<td>Finding Best Tuple via Error-prone User Interaction</td>
<td>查询</td>
<td></td>
</tr>
<tr>
<td>KOIOS: Top-k Semantic Overlap Set Search</td>
<td>查询</td>
<td></td>
</tr>
<tr>
<td>Complete Join Reordering for Null-Intolerant Joins</td>
<td>查询</td>
<td></td>
</tr>
<tr>
<td>Efficiently Answering Top-k Window Aggregate Queries: Calculating Coverage Number Sequences over Hierarchical Structures</td>
<td>查询</td>
<td></td>
</tr>
<tr>
<td>On Explaining Confounding Bias</td>
<td>查询</td>
<td></td>
</tr>
<tr>
<td>MetricJoin: Leveraging Metric Properties for Robust Exact Set Similarity Joins</td>
<td>查询</td>
<td></td>
</tr>
<tr>
<td>Selecting Sub-tables for Data Exploration</td>
<td>查询</td>
<td></td>
</tr>
<tr>
<td>In-Situ Cross-Database Query Processing</td>
<td>查询</td>
<td></td>
</tr>
<tr>
<td>These Rows Are Made for Sorting and That’s Just What We’ll Do</td>
<td>查询</td>
<td></td>
</tr>
<tr>
<td>JanusAQP: Efficient Partition Tree Maintenance for Dynamic Approximate Query Processing</td>
<td>查询</td>
<td></td>
</tr>
<tr>
<td>dLSM: An LSM-Based Index for Memory Disaggregation</td>
<td>索引</td>
<td></td>
</tr>
<tr>
<td>Cutting Learned Index into Pieces: An In-depth Inquiry into Updatable Learned Indexes</td>
<td>索引</td>
<td></td>
</tr>
<tr>
<td>Indexing for Near-Sorted Data</td>
<td>索引</td>
<td></td>
</tr>
<tr>
<td>EEPH: An Efficient Extendible Perfect Hashing for Hybrid PMem-DRAM</td>
<td>索引</td>
<td></td>
</tr>
</tbody></table>
<h3 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h3><table>
<thead>
<tr>
<th>论文</th>
<th>子方向</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>Fed-SC: One-Shot Federated Subspace Clustering over High-Dimensional Data</td>
<td>聚类</td>
<td></td>
</tr>
<tr>
<td>Parallel Filtered Graphs for Hierarchical Clustering</td>
<td>聚类</td>
<td></td>
</tr>
<tr>
<td>Efficient Augmentation for Imbalanced Deep Learning</td>
<td>深度学习</td>
<td></td>
</tr>
<tr>
<td>Pricing Prediction Services for Profit Maximization with Incomplete Information</td>
<td>深度学习</td>
<td></td>
</tr>
<tr>
<td>Detection of Groups With Biased Representation in Ranking</td>
<td>深度学习</td>
<td></td>
</tr>
<tr>
<td>The Art of Losing to Win: Using Lossy Image Compression to Improve Data Loading in Deep Learning Pipelines</td>
<td>深度学习</td>
<td></td>
</tr>
<tr>
<td>Opponent-aware Order Pricing towards Hub-oriented Mobility Services</td>
<td>深度学习</td>
<td></td>
</tr>
<tr>
<td>Rotary: A Resource Arbitration Framework for Progressive Iterative Analytics</td>
<td>深度学习</td>
<td></td>
</tr>
<tr>
<td>Sudowoodo: Contrastive Self-supervised Learning for Multi-purpose Data Integration and Preparation</td>
<td>深度学习</td>
<td></td>
</tr>
<tr>
<td>ENLD: Efficient Noisy Label Detection for Incremental Datasets in Data Lake ENLD：数据湖中增量数据集的高效噪声标签检测</td>
<td>深度学习</td>
<td></td>
</tr>
<tr>
<td>Improving Progressive Retrieval for HPC Scientific Data using Deep Neural Network</td>
<td>深度学习</td>
<td></td>
</tr>
<tr>
<td>Lightweight-Yet-Efficient: Revitalizing Ball-Tree for Point-to-Hyperplane Nearest Neighbor Search</td>
<td>机器学习</td>
<td></td>
</tr>
<tr>
<td>Automatic Feasibility Study via Data Quality Analysis for ML: A Case-Study on Label Noise</td>
<td>机器学习</td>
<td></td>
</tr>
<tr>
<td>A Hierarchical Approach to Anomalous Subgroup Discovery</td>
<td>机器学习</td>
<td></td>
</tr>
<tr>
<td>Metam: Goal-Oriented Data Discovery</td>
<td>机器学习</td>
<td></td>
</tr>
<tr>
<td>Dynamic Shapley Value Computation</td>
<td>机器学习</td>
<td></td>
</tr>
<tr>
<td>SK-Gradient: Efficient Communication for Distributed Machine Learning with Data Sketch</td>
<td>机器学习</td>
<td>分布式机器学习</td>
</tr>
<tr>
<td>Distribution-Regularized Federated Learning on Non-IID Data</td>
<td>机器学习</td>
<td>分布式机器学习</td>
</tr>
<tr>
<td>Orchestrating Large-Scale SpGEMMs using Dynamic Block Distribution and Data Transfer Minimization on Heterogeneous Systems</td>
<td>机器学习</td>
<td>分布式机器学习</td>
</tr>
<tr>
<td>Enhancing Decentralized Federated Learning for Non-IID Data on Heterogenous Devices</td>
<td>机器学习</td>
<td>分布式机器学习</td>
</tr>
<tr>
<td>Toward Efficient Automated Feature Engineering</td>
<td>特征工程</td>
<td></td>
</tr>
<tr>
<td>PA-FEAT: Fast Feature Selection for Structured Data via Progress-Aware Multi-Task Deep Reinforcement Learning</td>
<td>强化学习</td>
<td></td>
</tr>
<tr>
<td>Discovering Editing Rules by Deep Reinforcement Learning</td>
<td>强化学习</td>
<td></td>
</tr>
<tr>
<td>Schema Matching using Pre-Trained Language Models</td>
<td>NLP</td>
<td></td>
</tr>
<tr>
<td>Online Pricing Strategy Achieving Vanishing Regret for Shipping Container Pricing with Limited Inventory</td>
<td>在线学习</td>
<td></td>
</tr>
</tbody></table>
<h3 id="流处理"><a href="#流处理" class="headerlink" title="流处理"></a>流处理</h3><table>
<thead>
<tr>
<th>论文</th>
<th>子方向</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>CompressStreamDB: Fine-Grained Adaptive Stream Processing without Decompression</td>
<td>流处理</td>
<td></td>
</tr>
<tr>
<td>HistSketch: A Compact Data Structure for Accurate Per-Key Distribution Monitoring</td>
<td>流处理</td>
<td></td>
</tr>
<tr>
<td>HyperCalm Sketch: One-Pass Mining Periodic Batches in Data Streams</td>
<td>流处理</td>
<td></td>
</tr>
<tr>
<td>RADAR: Reactive Concept Drift Management with Robust Variational Inference for Evolving IoT Data Streams</td>
<td>流处理</td>
<td></td>
</tr>
<tr>
<td>SASPAR: Shared Adaptive Stream Partitioning</td>
<td>流处理</td>
<td></td>
</tr>
<tr>
<td>SketchConf: A Framework for Automatic Sketch Configuration</td>
<td>流处理</td>
<td></td>
</tr>
<tr>
<td>Parallelizing Stream Compression for IoT Applications on Asymmetric Multicores</td>
<td>流处理</td>
<td></td>
</tr>
<tr>
<td>Globally Aware Contextual Embeddings for Named Entity Recognition in Social Media Streams</td>
<td>流处理</td>
<td></td>
</tr>
<tr>
<td>Finding Simplex Items in Data Streams</td>
<td>流处理</td>
<td></td>
</tr>
</tbody></table>
<h3 id="数据分析与挖掘"><a href="#数据分析与挖掘" class="headerlink" title="数据分析与挖掘"></a>数据分析与挖掘</h3><table>
<thead>
<tr>
<th>论文</th>
<th>子方向</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>IndiBits: Incremental Discovery of Relaxed Functional Dependencies using Bitwise Similarity</td>
<td>数据挖掘</td>
<td></td>
</tr>
<tr>
<td>UADB: Unsupervised Anomaly Detection Booster</td>
<td>数据挖掘</td>
<td></td>
</tr>
<tr>
<td>Learn to Explore: on Bootstrapping Interactive Data Exploration with Meta-learning</td>
<td>数据挖掘</td>
<td></td>
</tr>
<tr>
<td>Efficient Parallel Mining of High-utility Itemsets on Multicore Processors</td>
<td>数据挖掘</td>
<td></td>
</tr>
<tr>
<td>Benchmarking Filtering Techniques for Entity Resolution</td>
<td>数据挖掘</td>
<td></td>
</tr>
<tr>
<td>Voting-based Opinion Maximization</td>
<td>数据挖掘</td>
<td></td>
</tr>
<tr>
<td>Interactive Search with Mixed Attributes</td>
<td>数据挖掘</td>
<td></td>
</tr>
<tr>
<td>Planning Data Poisoning Attacks on Heterogeneous Recommender Systems in a Multiplayer Setting</td>
<td>数据挖掘</td>
<td></td>
</tr>
<tr>
<td>A Feature-Driven Fixed-Ratio Lossy Compression Framework for Real-World Scientific Datasets</td>
<td>数据压缩</td>
<td></td>
</tr>
<tr>
<td>Neural Node Matching for Multi-Target Cross Domain Recommendation</td>
<td>推荐</td>
<td></td>
</tr>
<tr>
<td>Incremental Learning for Multi-Interest Sequential Recommendation</td>
<td>推荐</td>
<td></td>
</tr>
<tr>
<td>Disentangled Graph Social Recommendation</td>
<td>推荐</td>
<td></td>
</tr>
<tr>
<td>Group Buying Recommendation Model Based on Multi-task Learning</td>
<td>推荐</td>
<td>多任务学习</td>
</tr>
<tr>
<td>Probabilistic Majority Rule-Based Group Recommendation</td>
<td>推荐</td>
<td></td>
</tr>
<tr>
<td>Sequential Recommendation with User Causal Behavior Discovery</td>
<td>推荐</td>
<td></td>
</tr>
<tr>
<td>Towards Capacity-Aware Broker Matching: From Recommendation to Assignment</td>
<td>推荐</td>
<td></td>
</tr>
<tr>
<td>Visualization Recommendation Through Visual Relation Learning and Visual Preference Learning</td>
<td>推荐</td>
<td></td>
</tr>
<tr>
<td>Personalized Diversification for Neural Re-ranking in Recommendation</td>
<td>推荐</td>
<td></td>
</tr>
<tr>
<td>A Competition-Aware Approach to Accurate TV Show Recommendation</td>
<td>推荐</td>
<td></td>
</tr>
<tr>
<td>Intent-aware Multi-source Contrastive Alignment for Tag-enhanced Recommendation</td>
<td>推荐</td>
<td></td>
</tr>
<tr>
<td>Instant Representation Learning for Recommendation over Large Dynamic Graphs</td>
<td>推荐</td>
<td></td>
</tr>
<tr>
<td>A Generic Reinforced Explainable Framework with Knowledge Graph for Session-based Recommendation</td>
<td>推荐</td>
<td></td>
</tr>
<tr>
<td>Contrastive Enhanced Slide Filter Mixer for Sequential Recommendation</td>
<td>推荐</td>
<td></td>
</tr>
<tr>
<td>Bayesian Negative Sampling for Recommendation</td>
<td>推荐</td>
<td></td>
</tr>
<tr>
<td>Influential Recommender System</td>
<td>推荐</td>
<td></td>
</tr>
</tbody></table>
<h3 id="边缘计算、区块链、物联网"><a href="#边缘计算、区块链、物联网" class="headerlink" title="边缘计算、区块链、物联网"></a>边缘计算、区块链、物联网</h3><table>
<thead>
<tr>
<th>论文</th>
<th>子方向</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>EdgeNN: Efficient Neural Network Inference for CPU-GPU Integrated Edge Devices</td>
<td>边缘计算</td>
<td></td>
</tr>
<tr>
<td>FedKNOW: Federated Continual Learning with Signature Task Knowledge Integration at Edge</td>
<td>边缘计算</td>
<td></td>
</tr>
<tr>
<td>Reliable Transactions in Serverless-Edge Architecture</td>
<td>边缘计算</td>
<td></td>
</tr>
<tr>
<td>Ziziphus: Scalable Data Management Across Byzantine Edge Servers</td>
<td>边缘计算</td>
<td></td>
</tr>
<tr>
<td>Saguaro: An Edge Computing-Enabled Hierarchical Permissioned Blockchain</td>
<td>边缘计算 、区块链</td>
<td></td>
</tr>
<tr>
<td>SChain: Scalable Concurrency over Flexible Permissioned Blockchain</td>
<td>区块链</td>
<td></td>
</tr>
<tr>
<td>TxAllo: Dynamic Transaction Allocation in Sharded Blockchain Systems</td>
<td>区块链</td>
<td></td>
</tr>
<tr>
<td>On Sharding Across Heterogeneous Blockchains</td>
<td>区块链</td>
<td></td>
</tr>
<tr>
<td>Scaling Blockchain Consensus via a Robust Shared Mempool</td>
<td>区块链</td>
<td></td>
</tr>
<tr>
<td>Non-Blocking Raft for High Throughput IoT Data</td>
<td>物联网</td>
<td></td>
</tr>
<tr>
<td>Federated IoT Interaction Vulnerability Analysis</td>
<td>物联网</td>
<td>漏洞分析</td>
</tr>
</tbody></table>
<h3 id="视频处理"><a href="#视频处理" class="headerlink" title="视频处理"></a>视频处理</h3><table>
<thead>
<tr>
<th>论文</th>
<th>子方向</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>Marshalling Model Inference In Video Streams</td>
<td>视频处理</td>
<td></td>
</tr>
<tr>
<td>Track Merging for Effective Video Query Processing</td>
<td>视频处理</td>
<td></td>
</tr>
</tbody></table>
<h3 id="隐私保护"><a href="#隐私保护" class="headerlink" title="隐私保护"></a>隐私保护</h3><table>
<thead>
<tr>
<th>论文</th>
<th>子方向</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>Dynamic Private Task Assignment under Differential Privacy</td>
<td>隐私保护</td>
<td></td>
</tr>
<tr>
<td>Differential Aggregation against General Colluding Attackers</td>
<td>隐私保护</td>
<td></td>
</tr>
<tr>
<td>KVSAgg: Secure Aggregation of Distributed Key-Value Sets</td>
<td>隐私保护</td>
<td></td>
</tr>
<tr>
<td>PrivNUD: Effective Range Query Processing under Local Differential Privacy</td>
<td>隐私保护</td>
<td></td>
</tr>
</tbody></table>
<h3 id="众包"><a href="#众包" class="headerlink" title="众包"></a>众包</h3><table>
<thead>
<tr>
<th>论文</th>
<th>子方向</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>Air-Ground Spatial Crowdsourcing with UAV Carriers by Geometric Graph Convolutional Multi-Agent Deep Reinforcement Learning</td>
<td>众包</td>
<td></td>
</tr>
<tr>
<td>Efficient Cross Dynamic Task Assignment in Spatial Crowdsourcing</td>
<td>众包</td>
<td></td>
</tr>
<tr>
<td>Batch-Based Cooperative Task Assignment in Spatial Crowdsourcing</td>
<td>众包</td>
<td></td>
</tr>
<tr>
<td>Exploring both Individuality and Cooperation for Air-Ground Spatial Crowdsourcing by Multi-Agent Deep Reinforcement Learning</td>
<td>众包</td>
<td></td>
</tr>
<tr>
<td>Hierarchical Crowdsourcing for Data Labeling with Heterogeneous Crowd</td>
<td>众包</td>
<td></td>
</tr>
<tr>
<td>Learning from Noisy Crowd Labels with Logics 从喧闹的人群标签中学习逻辑</td>
<td>众包</td>
<td></td>
</tr>
</tbody></table>
<h1 id="密码生成"><a href="#密码生成" class="headerlink" title="密码生成"></a>密码生成</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>关于口令生成的方向调研</p>
<h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h2><p>[[方向：密码生成]]</p>
<h2 id="安全一流会议"><a href="#安全一流会议" class="headerlink" title="安全一流会议"></a>安全一流会议</h2><p>S&amp;P、CCS、NDSS、USENIX Conference、IEEE tDSC</p>
<h2 id="详情-1"><a href="#详情-1" class="headerlink" title="详情"></a>详情</h2><table>
<thead>
<tr>
<th>论文</th>
<th>时间</th>
<th>级别</th>
<th>笔记</th>
</tr>
</thead>
<tbody><tr>
<td>GENPass: A General Deep Learning Model for Password Guessing with PCFG Rules and Adversarial Generation</td>
<td>2018</td>
<td></td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://link.springer.com/chapter/10.1007/978-3-030-21568-2_11">PassGAN: A Deep Learning Approach to Password Guessing</a><br><a target="_blank" rel="noopener" href="https://github.com/brannondorsey/PassGAN">代码</a><br><a target="_blank" rel="noopener" href="https://github.com/ponedo/rnnPassGAN-password-cracking">改进代码</a></td>
<td>2019</td>
<td></td>
<td>[[PassGAN]]</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.mdpi.com/1424-8220/20/11/3106">Recurrent gans password cracker for iot password security enhancement</a></td>
<td>2019</td>
<td></td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://iopscience.iop.org/article/10.1088/1742-6596/1631/1/012161/pdf">Research on Password Cracking Technology Based on Improved Transformer</a></td>
<td>2020</td>
<td></td>
<td>[[Pass improved Transformer]]</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.mdpi.com/2076-3417/10/20/7306">Generating optimized guessing candidates toward better password cracking from multi-dictionaries using relativistic GAN</a></td>
<td>2020</td>
<td>三区</td>
<td>[[REDPACK]]</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://link.springer.com/chapter/10.1007/978-3-030-93206-0_18">Densegan: A password <strong>guessing model based</strong> on <strong>densenet</strong> and <strong>passgan</strong></a></td>
<td>2021</td>
<td></td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.mdpi.com/2076-3417/11/10/4607">Dynamic Markov Model: Password Guessing Using Probability Adjustment</a></td>
<td>2021</td>
<td>C</td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://dl.acm.org/doi/abs/10.1145/3448608">A large-scale analysis of the semantic password model and linguistic patterns in passwords</a>综述</td>
<td>2021</td>
<td>B</td>
<td>[[语义密码模型和密码语言模式分析]]</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.mdpi.com/1424-8220/22/12/4604">LPG–PCFG: an improved probabilistic context-free grammar to hit low-probability passwords</a></td>
<td>2022</td>
<td>C</td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2208.10413">On deep learning in password guessing, a survey</a></td>
<td>2022</td>
<td>C</td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/abstract/document/9799343/">GNPassGAN: improved generative adversarial networks for trawling offline password guessing</a></td>
<td>2022</td>
<td>A</td>
<td>[[GNPassGAN]]</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://link.springer.com/chapter/10.1007/978-981-99-9239-3_3">PassDiff: A New Approach for Password Guessing Using Diffusion Model</a><a target="_blank" rel="noopener" href="https://books.google.co.jp/books?hl=zh-CN&lr&id=NjvsEAAAQBAJ&oi=fnd&pg=PA29&ots=MFKPmtXK-9&sig=Ea5MEWjfUDxwHsZPvrnk1jdnHo0&redir_esc=y&pli=1#v=onepage&q&f=false">阅读</a><br><a target="_blank" rel="noopener" href="https://github.com/madaan/minimal-text-diffusion">代码</a><br></td>
<td>2023</td>
<td></td>
<td>[[PassDiff]]</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://dl.acm.org/doi/abs/10.5555/3636988.3637019">OneRuleToFindThem: Efficient Automated Generation of Password Cracking</a><br>自动生成密码规则</td>
<td>2023</td>
<td></td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.mdpi.com/1099-4300/25/9/1303">A Systematic Review on Password Guessing Tasks</a><br>密码生成的系统综述</td>
<td>2023</td>
<td></td>
<td>[[AReview]]</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://link.springer.com/article/10.1007/s12243-023-00969-4">Adaptive password guessing: learning language, nationality and dataset</a><br>自适应密码猜测</td>
<td>2023</td>
<td>4区</td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2306.06824">SE# PCFG: Semantically Enhanced PCFG for Password Analysis and Cracking</a><br>密码分析和破解语义的增强</td>
<td>2023</td>
<td></td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2306.01545">PassGPT: Password Modeling and (Guided) Generation with Large Language</a></td>
<td>2023</td>
<td></td>
<td>[[PassGPT]]</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/abstract/document/10152712/">A New Targeted Online Password Guessing Algorithm Based on Old Password</a></td>
<td>2023</td>
<td>B</td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.usenix.org/conference/usenixsecurity23/presentation/xu-ming">Improving real-world password guessing attacks via bi-directional transformers</a></td>
<td>2023</td>
<td>A</td>
<td>[[PassBERT]]</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://link.springer.com/article/10.1007/s10796-022-10325-x">Password and passphrase guessing with recurrent neural networks</a></td>
<td>2023</td>
<td>(JCR:Q2)</td>
<td>[[Pass_RNN]]</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.usenix.org/system/files/sec23fall-prepub-183-wang-ding.pdf">Password guessing using random forest</a><br>随机森林<br><a target="_blank" rel="noopener" href="https://github.com/PadishahIII/RFGuess">代码</a></td>
<td>2023</td>
<td>A</td>
<td>[[PASS_RF]]</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.sciencedirect.com/science/article/pii/S1084804523000115">PGTCN: A novel password-guessing model based on temporal convolution</a></td>
<td>2023</td>
<td>C</td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2403.09954">Search-based Ordered Password Generation of Autoregressive Neural Networks</a></td>
<td>2024</td>
<td>C</td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/abstract/document/10466588/"><em>GuessFuse</em>: Hybrid Password Guessing with Multi-View</a></td>
<td>2024</td>
<td>A</td>
<td>[[GuessFuse]]</td>
</tr>
</tbody></table>
<h2 id="A-Two-Decade-Retrospective-Analysis-of-a-University’s-Vulnerability-to-Attacks-Exploiting-Reused-Passwords"><a href="#A-Two-Decade-Retrospective-Analysis-of-a-University’s-Vulnerability-to-Attacks-Exploiting-Reused-Passwords" class="headerlink" title="A Two-Decade Retrospective Analysis of a University’s Vulnerability to Attacks Exploiting Reused Passwords"></a>A Two-Decade Retrospective Analysis of a University’s Vulnerability to Attacks Exploiting Reused Passwords</h2><p>凭据猜测攻击通常会利用在用户在线帐户中重复使用的密码。为了了解组织如何更好地保护用户，我们回顾性分析了我们大学二十年来遭受凭据猜测攻击的脆弱性。给定一份大学用户名列表，我们从数百个网站和十几个大型泄露事件汇编中搜索了两个数据泄露事件中的匹配项。在破解哈希密码并调整猜测后，我们成功猜测了 32.0% 与数据泄露中的大学电子邮件地址匹配的帐户的密码，以及 6.5% 与用户名（但不一定是域名）匹配的帐户的密码。这些帐户中的许多帐户在被泄露的数据泄露后多年仍然容易受到攻击，并且在泄露中逐字发现的密码被利用的可能性（即观察到可疑的帐户活动）几乎是经过调整的猜测的四倍。超过 70 种不同的数据泄露和各种用户名匹配策略引导了正确的猜测。在对我们猜测密码的 40 名用户进行的调查中，许多用户没有意识到他们的大学帐户存在风险，或者他们的凭据已被泄露。对我们大学密码重用的分析为组织保护帐户提供了务实的建议。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://medium.com/@gsurma/password-cracker-generating-passwords-with-recurrent-neural-networks-lstms-9583714a3310">使用 RNN(LSTMs) 生成密码</a>：<a target="_blank" rel="noopener" href="https://github.com/gsurma/password_cracker">代码不全</a></p>
<p>（1）<br>（2）Generative Adversarial Networks can crack your password!<br>（3）Password Cracker - Generating Passwords</p>

                        
                    </div>
                </div>
            </div>
            
                <footer class="kratos-post-meta-new">
                    <span class="pull-left">
                        <time datetime="2024-04-23T03:05:06.579Z" itemprop="datePublished">
                            <a><i class="fa fa-calendar"></i> 2024-04-23</a>
                        </time>
                        
                        
                            <!-- 当前仅支持valine/waline自带的统计功能 -->
                            
                        
                        
                            <!-- 当前仅支持waline自带的统计功能 -->
                            
                        
                    </span>
                    
                    
                        <span class="pull-right">
                            <a class="read-more" href="/2024/04/23/%E7%A0%94%E7%A9%B6%E6%96%B9%E5%90%91/%E6%96%B9%E5%90%91%E8%B0%83%E7%A0%94/" title="留言">留言<i class="fa fa-chevron-circle-right"></i></a>
                        </span>
                    

                </footer>
            
        </article>
    

    
    
        <article class="kratos-hentry kratos-entry-border-new clearfix" itemscope itemtype="https://schema.org/Article">
            <div class="kratos-status">
                
                    <i class="fa fa-refresh"></i>
                
                <div class="kratos-status-inner">
                    <div class="kratos-status-content" itemprop="articleBody">
                        
                            <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>互联网和安全不断发展，互联网的开放性也带来了许多内在的安全隐患。</p>
<p>为了保护用户信息，当前已经产生了多种认证方式：<br>身份认证的分类：</p>
<ol>
<li>用户知道的：密码，个人识别码</li>
<li>用户拥有的：U盾，加密卡</li>
<li>用户本身的：<ol>
<li>生理特征：指纹，虹膜</li>
<li>行为特征：手写</li>
</ol>
</li>
</ol>
<p>对于上面这些认证方式，其中密码（即口令）破解是最常见的认证方式，原因主要有：</p>
<ol>
<li>互联网应用不断发展，人们不得不设置许多满足不同密码策略的密码来保护相应的软件应用程序。</li>
<li>人的记忆能力有限。研究表明，人类只能记住五到七个密码，因此在设置密码时普遍会使用一些低信息熵的密码，比如：<ol>
<li>在多个系统中使用相同密码</li>
<li>在密码中使用个人相关信息</li>
</ol>
</li>
<li>大量知名网站的密码文件被泄露：比如著名的 rockyou数据集就是2018年受黑客攻击而泄漏的。</li>
</ol>
<p>且人工智能以及到现在 大模型的产生和发展更进一步增强了破解口令认证系统的能力，因此对于这方面的研究也显得更加迫切和重要。<br>（对口令认证系统攻击最严重的是口令猜测攻击）</p>
<h1 id="口令猜测分类"><a href="#口令猜测分类" class="headerlink" title="口令猜测分类"></a>口令猜测分类</h1><p>（<br>密码猜测的角度|方法：</p>
<ol>
<li>启发式搜索</li>
<li>概率模型</li>
<li>深度学习<br>）</li>
</ol>
<p>根据是否在线（也就是是否与服务器进行交互）：</p>
<ol>
<li>离线密码猜测</li>
<li>在线密码猜测</li>
</ol>
<p>（前一种攻击要求身份验证服务器存储用户帐户密码文件，然后攻击者在本地主机上猜测密码。在这种情况下，可以尝试的猜测次数仅受攻击者的计算资源的限制。后者不需要密码文件，攻击者只需要连接到网络即可。然而，可以尝试的猜测次数往往受到服务器安全策略的限制，例如美国国家身份标准NIST-800-63-3，其中规定政府网站系统一个月允许的最大登录失败次数为100次，如果超过100次，帐户将被锁定。）</p>
<p>根据是否利用用户的个人信息：</p>
<ol>
<li>拖网猜测。</li>
<li>定向猜测，利用用户个人信息。<br>（拖网猜测主要利用用户选择流行密码的倾向，而定向猜测不仅利用普通用户使用流行密码的漏洞，还利用用户重复使用密码和使用个人信息构建密码的漏洞。在个人身份信息和历史密码等信息的帮助下，定向密码猜测的成功率明显高于相同猜测次数的拖网猜测）</li>
</ol>
<p>是否使用人工智能：</p>
<ol>
<li>传统攻击</li>
<li>神经攻击<br>（前者将密码猜测作为一项文本生成任务，依靠人工智能相关技术在大规模密码训练语料库上生成文本密码。后者封装了其他方法，不包括深度神经网络猜测方法。）</li>
</ol>
<p>（几乎所有现有的工作都是离线猜测，而在线猜测太难在100个猜测内猜出一个密码。所以当前的分类方式主要为：传统的。。基于神经网络的。。）</p>
<p>（说一下如何比较生成密码的质量：<br>    1. 生成的唯一密码个数和比例；<br>    2. 生成密码的速度；<br>    3. 生成的密码和训练数据集之外其他数据集的匹配个数<br>   ）</p>
<h3 id="拖网猜测"><a href="#拖网猜测" class="headerlink" title="拖网猜测"></a>拖网猜测</h3><h4 id="传统拖网猜测"><a href="#传统拖网猜测" class="headerlink" title="传统拖网猜测"></a>传统拖网猜测</h4><ol>
<li>启发式算法<blockquote>
<p>这些算法没有严格的理论体系，严重依赖于零散的奇思妙想，例如，基于开源软件使用精心设计的猜测序列构建独特的猜测词典。这些启发式方法很难重现，也很难相互公平地比较。因此，在这里，我们只介绍一些常用的启发式密码猜测工具。</p>
</blockquote>
<ol>
<li>Jtr是一个密码猜测工具，专注于破解UNIX&#x2F;Linux系统的弱密码。在JTR中有四种模式–简单破解模式、单词表模式、增量模式和外部模式。</li>
<li>Hashcat是世界上速度最快、最先进的密码恢复实用程序，支持针对300多种高度优化的哈希算法的五种独特攻击模式。Hashcat目前支持Linux、Windows和MacOS上的CPU、GPU和其他硬件加速器，并具有帮助启用分布式密码破解的设施。<blockquote>
<p>彩虹攻击：<br>一种基于预先计算和空间-时间折中的攻击方法。通过事先计算大量的密码和散列值之间的对应关系（彩虹表），以便在攻击时快速查找并破解散列值。彩虹表是一个预先计算的表格，其中包含了大量的密码和对应的散列值。通过在彩虹表中进行查找，攻击者可以找到与目标散列值匹配的原始密码。</p>
</blockquote>
</li>
</ol>
</li>
<li>概率上下文无关语法<br> 该算法的核心假设是密码的字母段L、数字段D和特殊字符段S相互独立。该算法包括训练和猜测两个阶段。<ol>
<li>在训练阶段，最关键的是根据泄露的密码数据集计算密码模式(结构)和字符成分(语义)的频率。</li>
<li>在猜测阶段，根据训练阶段得到的模式频率表和语义频率表生成具有频率猜测的集合，以模拟真实密码的概率分布。<br> 粒度太细，无法获得字符之间的语义关系，改进：</li>
<li>基于词的内聚力和自由度提取密码中的语义片段，并对基于语义片段的PCFG算法进行改进</li>
<li>密码视为由几个块组成，其中块是频繁出现在一起以模拟密码的相关字符的序列。</li>
<li>扩展字节对编码(BPE)算法，它使用块词汇表平均长度的可配置参数来替换合并操作的数量。</li>
<li>为了解决长密码猜测的困难，提出了一种改进的基于PCFG的LONG</li>
</ol>
</li>
<li>马尔可夫序列决策<br> 该算法的核心假设是用户从前到后依次构造口令。它不像PCFG那样分割密码，而是训练整个密码，并通过从左到右链接字符来计算密码的概率。<ol>
<li>传统的马尔可夫模型因其结构简单、推理速度快而被广泛应用于口令猜测工作中。但是，它也有一定的缺陷，如过度拟合、重复率高、基于随机抽样生成的密码覆盖率低等。</li>
<li>过拟合：将拉普拉斯平滑和结束符号正则化技术应用于马尔可夫模型。平滑策略消除了数据集中的过拟合问题，正则化技术使攻击算法产生的猜测概率总是和为1。</li>
<li>重复率：设计了一种基于随机抽样的动态分配机制。该机制允许动态调整密码的概率分布，并在猜测过程中严格收敛到均匀分布。基于上述动态分布机制，提出了一种动态马尔可夫模型。</li>
<li>对口令中的语义段进行建模：提出了一个名为Word马尔可夫的模型，通过语义分段从密码中提取单词的凝聚力和自由度。</li>
</ol>
</li>
</ol>
<h4 id="神经拖网猜测算法"><a href="#神经拖网猜测算法" class="headerlink" title="神经拖网猜测算法"></a>神经拖网猜测算法</h4><p>密码猜测任务视为文本生成问题，核心就是把密码数据集给神经网络进行训练，并利用训练好的模型生成候选密码。</p>
<ol>
<li>递归神经网络(RNN)：递归神经网络以序列数据为输入，在序列进化方向上递归，所有节点以链的形式连接。 RNN 有许多变体：如： LSTM，GRU，BiLSTM 等。<ol>
<li>步骤：基于RNN的密码猜测方法通常有以下两个步骤：<ol>
<li>·将训练集中的密码序列输入到RNN模型中，以进行顺序文本生成的训练。</li>
<li>训练好的 RNN 猜测模型旨在根据已有的密码字符生成下一个密码字符，直到输出终止字符位置。</li>
</ol>
</li>
<li>在整个密码生成过程中，RNN计算任何字符作为下一个密码令牌的概率。对于给定的阈值，概率高于阈值的密码将被放入密码猜测集中作为有效密码。</li>
<li>一些变体：<ol>
<li>对密码单词进行切分，在词段的基础上使用BiLSTM生成密码。</li>
<li>层次语义模型HSM，该模型将LSTM和语义分析相结合，用于挖掘用于密码猜测的词之间潜在的概率关系。</li>
<li>基于汉字音节的密码猜测方法。该方法将汉语音节作为整体元素对密码进行解析和处理。然后，在LSTM神经网络中对处理后的密码进行训练以生成密码。</li>
<li>特别是具有注意力机制的RNN来组合和内插同一组用户的信息，以定义比他们的密码分布更稳健和准确的优先级。推理时使用辅助数据来适应目标密码的分布。通过这种方式，开发了一种利用辅助信息并实例化上下文感知口令计量和猜测攻击的全自动方法，而不需要来自目标口令分布的任何明文样本。</li>
</ol>
</li>
</ol>
</li>
<li>生成式对抗网络（GAN）：<ol>
<li>基于GAN的密码猜测模型由密码生成器和鉴别器组成。这两个网络相互对抗，不断地调整参数。最终目的是使鉴别器网络无法判断生成网络的输出是否真实，从而达到口令生成的效果。</li>
<li>问题：离散密码数据的不可微性可能导致梯度反向传播失败，基于GAN的密码猜测模型训练难以收敛，由GAN模型生成的密码重复率较高。</li>
<li>离散数据不可微问题解决：<ol>
<li>使用Gumbel-Softmax松弛技术来训练基于GAN的密码猜测模型。</li>
<li>使用通过附加的自动编码器获得的真实口令的平滑表示。</li>
<li>种基于SeqGAN的密码猜测方法RLPassGAN，该方法使用策略梯度来确保模型参数的持续优化。</li>
</ol>
</li>
<li>收敛困难的问题解决：基于双向生成对抗网络的猜测算法，提高了算法的收敛速度。与传统的GaN相比，它可以在更短的时间内产生相同数量的样本</li>
<li>重复率高问题解决：<ol>
<li>使用蒙特卡罗搜索来评估中间层输出处的不完整密码序列，减少冗余的合成密码。（此外，通过蒙特卡罗搜索来评估输出的不完整密码序列。蒙特卡罗是一种使用大量随机样本来了解特定系统的计算方法。）</li>
<li>使用鉴别器和控制器构建额外的控制器网络，以分别学习生成的密码分布与真实密码分布和均匀分布之间的度量。然后利用这两个度量对生成器进行训练，从而降低了口令生成的重复率。</li>
<li>RLPass：还创新性地将表征学习用于密码猜测。具体地，将密码投影到隐藏空间，并且使用隐藏空间中的密码表示之间的距离来定义密码的相似性。基于口令的强局部性和弱局部性现象，提出了一种动态口令猜测和条件口令算法。</li>
</ol>
</li>
<li>GAN的模型生成的长密码质量较低的问题解决：设计了一种基于DenseNet的GAN密码猜测结构DenseGAN，并提出了两种新的密码猜测DenseGAN模型，这两种模型都能生成高质量的密码猜测。</li>
</ol>
</li>
<li>自动编码器（AE）：它基于反向传播算法和优化方法，使用输入数据本身作为监督来指导神经网络学习映射关系，以获得重建的输出。AE 包括编码器和解码器两部分。根据学习范式，AE 可分为欠完备自动编码器、正则化自动编码器和变分自动编码器，其中前两种是判别性模型，后者是生成性模型。<ol>
<li>在拖网密码猜测的研究中，通常使用<strong>变分自动编码器</strong>来生成密码猜测。将密码样本输入到VAE的编码器以获得表示，然后使用解码器基于该表示重建样本。基于输入和输出之间的重构损失来训练密码生成器。除了使用最经典的VAE框架来猜测密码，也提出来了许多优化。<ol>
<li>优化 GAN：将VAE技术与GaN技术相结合，用VAE代替GaN生成器，旨在解决离散口令数据的反向传播问题。</li>
<li>轻量级问题：用门控卷积神经网络(GCNN)代替了复杂的RNN生成单元，降低了模型的复杂性。</li>
</ol>
</li>
</ol>
</li>
<li>Transformer.<br> ![[Pasted image 20240305201324.png]]<br> Transformer 模型采用编解码器体系结构，并使用注意力机制替换 Seq2Seq 模型中的递归结构，以实现序列建模的并行化。这种并行化结构给自然语言处理 (NLP) 领域带来了巨大的冲击。随着研究的深入，相关技术逐渐从自然语言处理向计算机视觉 (CV)、语音、生物、化学等领域发展。同样，在拖网密码猜测的研究中也出现了一些基于Transformer的方法：<ol>
<li>基于改进 Transformer 的口令猜测模型：将消息（个人信息和密码的相关性）权重引入到数据预处理中，并在模型中使用改进的波束搜索算法来快速搜索排名靠前的密码猜测。</li>
<li>PassBERT：基于双向 Transformer 的猜测框架，首次将预训练&#x2F;微调的范式应用于密码破解。具体地说，<ol>
<li>首先，作者设计了包含一般密码分布知识的通用密码预训练模型。</li>
<li>然后，提出了三种特定于攻击的微调方法来定制预先训练的口令模型以适应以下真实攻击场景：条件口令猜测、目标口令猜测和基于自适应规则的口令猜测。最后，他们进一步提出了一种混合密码强度计来降低这三种攻击的风险。</li>
</ol>
</li>
</ol>
</li>
<li>Reinforcement Learning (RL) 强化学习<ol>
<li>RL是机器学习的范例和方法之一，用于描述和解决智能代理在与环境交互过程中最大化回报或实现特定目标的学习策略问题。密码生成器是代理，每个生成的密码序列代表一个完整的轨迹，生成过程中的每个字符都被视为一个操作。例如，由时间戳t生成的字符是action at。根据由所生成的不完整序列确定的关于当前状态ST的随机策略来生成每个动作At。生成器根据一组随机策略从任意字符生成密码，直到满足预定长度。</li>
<li>RLPassGAN：遵循SeqGAN，将密码猜测视为一个连续决策，并使用策略梯度 来确保参数可以连续优化。</li>
</ol>
</li>
<li>Flow： （一个强大的密度估计统计工具）流动模型的一个非常独特的特征是，它的转变通常是可逆的。流模型不仅找到了从分布Z转移到分布X的网络路径，而且该路径还允许X改变为Z。简而言之，流模型找到了分布Z和X之间的双向路径（Z和X的数据维度必须相同）。<ol>
<li>PassFlow：基于产生流模型的口令猜测方法。基于流的口令猜测模型使用精确的对数似然计算和优化，使潜在变量的推断更加准确。此外，还给出了潜在空间的一种有意义的表示，这使得探索潜在空间的特定子空间和内插等操作成为可能。（密码猜测方面优于现有的基于GAN的方法）</li>
</ol>
</li>
</ol>
<h4 id="另一种分类"><a href="#另一种分类" class="headerlink" title="另一种分类"></a>另一种分类</h4><p>根据泄露的数据集和目标密码是否来自同一数据源，拖网场景可以进一步分为站内场景和跨站场景。 虽然跨站密码猜测场景较为真实，但攻击者一般以掌握目标数据的部分分布信息为前提来猜测密码。</p>
<h3 id="定向密码猜测"><a href="#定向密码猜测" class="headerlink" title="定向密码猜测"></a>定向密码猜测</h3><p>定向整体来说其实是对传统的优化，比如不改变核心思想的前提下修改嵌入，数据预处理等方面。</p>
<h4 id="神经定向密码猜测"><a href="#神经定向密码猜测" class="headerlink" title="神经定向密码猜测"></a>神经定向密码猜测</h4><p>随着自然语言处理技术的发展，一些复杂的神经网络被应用到目标密码猜测领域。</p>
<ol>
<li>PG-PASS：由指针生成网络组成的有针对性的口令猜测模型。该工作创新性地将目标口令猜测作为一项摘要任务，并将智能摘要领域中常用的指针网络技术应用于该任务。需要注意的是，除了用户的人口统计相关信息(姓名、生日等)外，攻击者还可以利用用户在其他网站上泄露的密码进行有针对性的攻击。可以预期，这种利用用户密码重复使用这一易受攻击行为的定向攻击可能比基于人口统计相关信息的攻击更具危害性。</li>
<li>重用模型：重用或微调旧密码来生成新密码的事实，引入深度学习技术来表征用户的密码重复使用行为。更具体地说，他们训练了序列到序列(Seq2seq)模型，以预测将现有密码转换为其姊妹密码所需的修改，并在大规模数据集(即4iQ数据集)上进行了验证。</li>
<li>PASS2EDIT：有针对性的密码猜测算法，用于模拟日益严重的凭据篡改攻击，在该攻击中，攻击者利用受害者泄露的密码来提高在其他站点猜测受害者密码的成功率。特别是，他们提出了一种多步决策训练机制，并建立了一个分类神经网络来学习一步编辑操作对现有密码的反应。由于每项工作使用的数据集不同，因此很难进行横断面比较。</li>
</ol>
<h4 id="传统定向密码猜测"><a href="#传统定向密码猜测" class="headerlink" title="传统定向密码猜测"></a>传统定向密码猜测</h4><p>攻击者使用与目标人员相关的个人信息来增强猜测。</p>
<p>基于拖网马尔可夫攻击模型的定向攻击猜测方法：</p>
<ol>
<li>基本思想是，关于使用某些个人信息的人口的百分比，攻击目标也将具有相同的使用该个人信息的可能性百分比。<ol>
<li>首先将PII划分为几种类型，如用户名-A、电子邮件前缀-E和名称-N，并根据所需的粒度进一步细分每种广泛的类型。然后，将训练集的每个密码中的所有PII替换为对应的PII类型。</li>
<li>训练阶段的其余步骤与行走马尔可夫模型的步骤相同。</li>
<li>猜测集生成阶段分为两个步骤。<ol>
<li>在第一步中，运行马尔可夫模型以生成中间猜测集合，该中间猜测集合包含直接可用的猜测，</li>
<li>第二步用相应的PII信息替换中间猜测中的基本PII类型字符。</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>基于PCFG的定向攻击猜测方法：</p>
<ol>
<li><p>–Personal-PCFG。。其基本思想与PCFG攻击模型相同：根据字符类型和长度对密码进行切片。为了实现这一思想，将六种PI字符类型 (即用户名-A、电子邮件前缀-E、姓名-N、生日-B、电话号码-P和ID-G)等同于拖网PCFG模型中的L、D和S，从而在个人PCFG中有九种类型的字符。然后，在训练过程中，与拖网PCFG攻击模型中一样，训练集中的每个密码根据相应的字符类型及其长度进行分段。</p>
</li>
<li><p>TarGuess Wang等人。提出了一个框架，它用四个数学概率模型系统地刻画了典型的定向猜测场景。</p>
<ol>
<li>第一个场景TarGuess-I旨在利用用户的PII创建在线目标密码猜测。为了在密码中表示PII令牌，除了PCFG模型中的L、D和S标签外，作者还定义了基于个人信息类型的28个PII标签(例如，N1−N7和B1−B10)。对于每个PII标签，其下标编号表示该类型的PII使用的细分，而不是指示相应长度的下标编号，例如L、D和S标签。例如，N表示名称信息，而N1表示全名，而n2表示全名的缩写</li>
<li>第二个是Targuess-II，目的是根据用户在其他网站(例如Dodonew)中泄露的密码来猜测目标网站(例如CSDN)中的用户密码。具体地，作者提出了6种结构级和2种字符级助记转换来描述密码重用，并基于上述重用规则使用马尔可夫模型来刻画上下文无关的转换文法。</li>
<li>第三个是TarGuessIII，目的是使用姐妹密码和一些PII信息来猜测用户的密码。TarGuess-III将PII信息引入到TarGuess-II模型中，允许在结构级密码重用中嵌入PII信息。</li>
<li>与TarGuess-III相比，TarGuess-IV场景中的攻击者知道难以量化的额外PII(例如，性别、教育)。为了解决某些PII难以直接体现在口令中的问题，在这种难以量化的PII的基础上，巧妙地引入贝叶斯理论来计算口令的重用概率。</li>
</ol>
</li>
<li><p>RFGuess-PII.在RFGuess的基础上，Wang et al.提出了一种新的目标口令猜测模型RFGuess-PII。密码训练和生成过程类似于拖网猜测场景。不同的是，通过新的PII匹配，密码中的PII字符串被替换为相应的数字标签。这种新的PII匹配旨在最小化信息熵，并试图准确地提取整个用户组的PII使用行为。PII匹配算法的第一步是细分PII的各种可能的变换，并使用数字标签来表示它们。第二步是为训练集中的每个密码列出具有PII标签的所有可能的表示。然后，按频率从高到低对表征进行排序。</p>
</li>
<li><p>RFGuess-重复使用。除了基于PII的针对性密码破解研究外，作者还专注于对用户的密码重复使用行为进行建模。他们还考虑了结构级和段级转换，如TarGuess-II。具体地，它们通过计算训练集中每个密码对的编辑矩阵来计算结构级转换，并训练基于随机森林的段级转换(即，相同类型的字符串内的转换，例如字母段中的密码→密码)模型。</p>
</li>
<li><p>TG-SPSR图谱。马尔可夫模型和PCFG模型转化为目标攻击，提出了一种基于结构划分和字符串重组的系统目标攻击模型，称为TG-SPSR。在结构划分阶段，除了将密码划分为类似于PCFG的基本结构外，还在基本语法模式中定义了基于轨迹的键盘，并引入了索引位来准确描述特殊字符的位置。此外，基于定义的9条修改规则，构造了一个BiLSTM分类器来重用和修改密码的行为。</p>
</li>
</ol>
<h1 id="可能的方向"><a href="#可能的方向" class="headerlink" title="可能的方向"></a>可能的方向</h1><p>总体来说还是做的工作挺多的，16-23年提出来了三十多种方法，2016年至2018年零星出版数量较少，2021年增至9种。。但是当前比较热门的还是基于深度学习的密码猜测方法。</p>
<ol>
<li>修改模型结构提高模型训练时的速度：在低资源的情况下快速执行密码猜测也是具有挑战性的。</li>
<li>尝试大模型：预训练的语言模型近年来在自然语言处理领域应用很成熟。可以尝试关于密码猜测的预训练&#x2F;精调范式，将预先训练的语言模型强大的通用语言建模功能与现有的密码猜测工作结合起来</li>
<li>尝试更多模型：目前的神经密码猜测方法都有一个前提，即密码字符串是一个字符序列，使用序列编码对密码进行处理。比如根据密码的语义依赖将密码组织成图，并使用最新的图神经网络(GNN)相关技术进行采样和生成。</li>
<li>传统猜测方法与深度学习方法相结合。比如用深度学习生成规则等。</li>
</ol>
<h1 id="之后的想法"><a href="#之后的想法" class="headerlink" title="之后的想法"></a>之后的想法</h1><ol>
<li>这两周涉及到了解一些背景所以读的也比较仔细，后面计划读快一些，重点关注方法和创新性。</li>
<li>选择较新，效果较好，的论文尝试复现，分析数据，寻找优化的点。</li>
</ol>

                        
                    </div>
                </div>
            </div>
            
                <footer class="kratos-post-meta-new">
                    <span class="pull-left">
                        <time datetime="2024-04-23T03:05:06.579Z" itemprop="datePublished">
                            <a><i class="fa fa-calendar"></i> 2024-04-23</a>
                        </time>
                        
                        
                            <!-- 当前仅支持valine/waline自带的统计功能 -->
                            
                        
                        
                            <!-- 当前仅支持waline自带的统计功能 -->
                            
                        
                    </span>
                    
                    
                        <span class="pull-right">
                            <a class="read-more" href="/2024/04/23/%E7%A0%94%E7%A9%B6%E6%96%B9%E5%90%91/%E6%96%B9%E5%90%91%EF%BC%9A%E5%AF%86%E7%A0%81%E7%94%9F%E6%88%90/" title="留言">留言<i class="fa fa-chevron-circle-right"></i></a>
                        </span>
                    

                </footer>
            
        </article>
    

    
    
        <article class="kratos-hentry kratos-entry-border-new clearfix" itemscope itemtype="https://schema.org/Article">
            <div class="kratos-status">
                
                    <i class="fa fa-refresh"></i>
                
                <div class="kratos-status-inner">
                    <div class="kratos-status-content" itemprop="articleBody">
                        
                            <p>[[中国计算机学会推荐国际学术会议和期刊目录-2019.pdf]]</p>
<h1 id="会议级别"><a href="#会议级别" class="headerlink" title="会议级别"></a>会议级别</h1><p>ei 会议 &lt; ei 期刊 &lt;  sci | ssci</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzkwMTM0NzU1MQ==&mid=2247505285&idx=1&sn=8f2fbac906e7bba64545fe9a30b8435e&chksm=c0b4b435f7c33d234329c1bdfa5e39fa1191cbb409b75b5dd7b412e54d12c7838211e74f0d97&scene=27">会议信息 | 2023年12月截稿的密码学与信息安全会议整理 (qq.com)</a></p>
<h1 id="主要依据"><a href="#主要依据" class="headerlink" title="主要依据"></a>主要依据</h1><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>期刊CCF等级</td>
<td>未收录</td>
</tr>
<tr>
<td>JCR分区</td>
<td>Q2</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>JCR分区是通过将一个学科内收录的期刊总数分为四等份来进行的，其中影响因子排名前25%的期刊为一区（Q1），26-50%为二区（Q2），51-75%为三区（Q3），76-100%为四区（Q4）</p>
<p>CCF分类则是中国计算机学会（CCF）对计算机科学领域的期刊和会议进行的评级，基于期刊和会议的国际影响力、学术水平等因素，通过将它们划分为不同的等级（A、B、C），</p>
<p>中科院期刊分区根据13个大类学科，分别将各大类的SCI期刊由3年平均影响因子划分为 1 区（最高区）、2区、3区和4区四个等级。这种分区标准也被更多的机构采纳以作为科研评价的指标。</p>

                        
                    </div>
                </div>
            </div>
            
                <footer class="kratos-post-meta-new">
                    <span class="pull-left">
                        <time datetime="2024-04-23T03:05:06.578Z" itemprop="datePublished">
                            <a><i class="fa fa-calendar"></i> 2024-04-23</a>
                        </time>
                        
                        
                            <!-- 当前仅支持valine/waline自带的统计功能 -->
                            
                        
                        
                            <!-- 当前仅支持waline自带的统计功能 -->
                            
                        
                    </span>
                    
                    
                        <span class="pull-right">
                            <a class="read-more" href="/2024/04/23/%E7%A0%94%E7%A9%B6%E6%96%B9%E5%90%91/%E4%BC%9A%E8%AE%AE%E8%B0%83%E7%A0%94/" title="留言">留言<i class="fa fa-chevron-circle-right"></i></a>
                        </span>
                    

                </footer>
            
        </article>
    



    <div class='text-center pagination'>
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
    </div>



    <div class="hidden">
        <!-- 加载文章阅读对应的统计功能，评论自带的那种 -->
        
    </div>



        

            </section>

        

                
            

<section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm">
    <!-- 文章和页面根据splitter来分割，没有的话就从头开始设置为sticky -->
    
        <div class="sticky-area">
    
    
                <aside id="krw-about" class="widget widget-kratos-about clearfix">
    <div class="photo-background"></div>
    <div class="photo-wrapper clearfix">
        <div class="photo-wrapper-tip text-center">
            <img class="about-photo" src="/images/avatar.webp" loading="lazy" decoding="auto" />
        </div>
    </div>
    <div class="textwidget">
        <p class="text-center">生于尘埃，溺于人海，死于理想的高台</p>
    </div>
    <div class="site-meta">
        <a class="meta-item" href="/archives/">
            <span class="title">
                文章
            </span>
            <span class="count">
                98
            </span>
        </a>
        <a class="meta-item" href="/categories/">
            <span class="title">
                分类
            </span>
            <span class="count">
                0
            </span>
        </a>
        <a class="meta-item" href="/tags/">
            <span class="title">
                标签
            </span>
            <span class="count">
                1
            </span>
        </a>
    </div>
</aside>
            
                

            
                
  <aside id="krw-tags" class="widget widget-kratos-tags clearfix">
    <h4 class="widget-title"><i class="fa fa-tags"></i>标签聚合</h4>
      <div class="tag-clouds">
        <a href="/tags/excalidraw/" style="font-size: 0.6em;">excalidraw</a>
      </div>
  </aside>

            
                
  <aside id="krw-posts" class="widget widget-kratos-posts">
  <h4 class="widget-title"><i class="fa fa-file"></i>最新文章</h4>
  <div class="tab-content">
      <ul class="list-group">
        
        
          
          
            <a class="list-group-item" href="/2024/04/23/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D/"><i class="fa  fa-book"></i> Englislearning</a>
            
          
        
          
          
            <a class="list-group-item" href="/2024/04/23/hello-world/"><i class="fa  fa-book"></i> Hello Worldaaaaaaa</a>
            
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
      </ul>
  </div>
  </aside>

            
    </div>
</section>
        
        </div>
    </div>
</div>
<footer>
    <div id="footer"  class="ap-lrc"  >
        <div class="container">
            <div class="row">
                <div class="col-md-6 col-md-offset-3 footer-list text-center">
                    <ul class="kratos-social-icons">
                        <!-- Keep for compatibility -->
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        <!-- New links -->
                        
                    </ul>
                    <ul class="kratos-copyright">
                        <div>
                            <li>&copy; 2024 心咖 版权所有.</li>
                            <li>本站已运行<span id="span_dt">Loading...</span></li>
                        </div>
                        <div>
                            <li>Theme <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a></li>
                            <li>Site built with&nbsp;<i class="fa fa-heart throb" style="color:#d43f57"></i>&nbsp;by dreamin.</li>
                        </div>
                        <div>
                            <li>Powered by <a href="https://hexo.io" target="_blank" rel="nofollow">Hexo</a></li>
                            <li>Hosted on <a href="https://github.io" target="_blank">Github Pages</a></li>
                        </div>
                        <div>
                            
                            
                        </div>
                    </ul>
                </div>
            </div>
        </div>
        <div class="kr-tool text-center">
            <div class="tool">
                
                    <div class="box search-box">
                        <a href="/search/">
                            <span class="fa fa-search"></span>
                        </a>
                    </div>
                
                
                    <div class="box theme-box" id="darkmode-switch">
                        <span class="fa fa-adjust"></span>
                    </div>
                
                
                
            </div>
            <div class="box gotop-box">
                <span class="fa fa-chevron-up"></span>
            </div>
        </div>
    </div>
</footer>
</div>
</div>

        <script defer src="/vendors/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>
<script defer src="/vendors/nprogress@0.2.0/nprogress.js"></script>
<script>
    if (!window.kr) {
        window.kr = {};
    }
    window.kr.notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));
    window.kr.siteRoot = "/";
</script>


    <script async src="/js/candy.min.js"></script>



    <script defer src="/vendors/aplayer@1.10.1/dist/APlayer.min.js"></script>
    
    <script defer src="/vendors/meting@2.0.1/dist/Meting.min.js"></script>
    <meting-js
        server="netease"
        type="playlist"
        id="3204190542"
        order="random"
        fixed="true"
    >
    </meting-js>



    <script defer src="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script defer src="/js/kratosr.min.js"></script>
<script defer src="/js/pjax.min.js"></script>



<!-- Extra support for third-party plguins  -->


    </body>
</html>